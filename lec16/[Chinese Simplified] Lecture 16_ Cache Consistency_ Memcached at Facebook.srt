1
00:00:01,520 --> 00:00:07,980
好的，大家好，我今天

2
00:00:07,980 --> 00:00:10,920
要讨论的是这篇关于

3
00:00:10,920 --> 00:00:15,299
Facebook 如何使用内存缓存的论文我是为了

4
00:00:15,299 --> 00:00:19,109
处理巨大的负载我们

5
00:00:19,109 --> 00:00:21,000
阅读这篇论文的原因是它是一篇

6
00:00:21,000 --> 00:00:23,750
经验论文，实际上并没有任何

7
00:00:23,750 --> 00:00:26,670
新的概念或想法 或者这里的技术，

8
00:00:26,670 --> 00:00:32,510
但这是一家真实的

9
00:00:32,840 --> 00:00:36,270
公司在

10
00:00:36,270 --> 00:00:38,460
尝试构建非常高容量的

11
00:00:38,460 --> 00:00:40,860
基础设施时遇到的问题，有几种方法

12
00:00:40,860 --> 00:00:44,160
可以阅读它，其中一种是

13
00:00:44,160 --> 00:00:47,550
关于如果你不采取会出现什么问题的警示故事

14
00:00:47,550 --> 00:00:49,800
 

15
00:00:49,800 --> 00:00:53,219
从一开始就认真地保持一致性 另一种阅读方式是

16
00:00:53,219 --> 00:00:55,199
，这是一个令人印象深刻的故事，讲述了

17
00:00:55,199 --> 00:00:58,140
如何通过

18
00:00:58,140 --> 00:01:02,300
使用大多数现成的软件获得极高的容量

19
00:01:03,019 --> 00:01:05,580
另一种阅读方式是，它是

20
00:01:05,580 --> 00:01:08,250
一种说明或基本

21
00:01:08,250 --> 00:01:11,490
斗争 许多设置面临

22
00:01:11,490 --> 00:01:13,470
着试图通过复制等方法获得非常高的

23
00:01:13,470 --> 00:01:16,259
性能，

24
00:01:16,259 --> 00:01:18,299
以及如何为复制等技术提供一致性

25
00:01:18,299 --> 00:01:20,640
，这才

26
00:01:20,640 --> 00:01:24,180
是真正的敌人，所以你知道 我们

27
00:01:24,180 --> 00:01:26,970
可以争论我们是否喜欢他们的

28
00:01:26,970 --> 00:01:28,770
设计，或者我们认为它是优雅的还是一个

29
00:01:28,770 --> 00:01:31,860
好的解决方案，但我们不能真正

30
00:01:31,860 --> 00:01:35,850
争论他们的成功程度，所以我们

31
00:01:35,850 --> 00:01:37,829
确实需要认真对待它们，

32
00:01:37,829 --> 00:01:40,020
实际上对我来说，这是我第一次

33
00:01:40,020 --> 00:01:43,590
阅读的这篇论文 几年前，我一直在

34
00:01:43,590 --> 00:01:45,659
思考它，它

35
00:01:45,659 --> 00:01:51,479
是一种想法和

36
00:01:51,479 --> 00:01:55,170
对许多问题的理解的来源，

37
00:01:55,170 --> 00:01:57,380
 

38
00:01:57,890 --> 00:02:01,290
所以在谈论

39
00:02:01,290 --> 00:02:03,240
Facebook 之前，你知道它们

40
00:02:03,240 --> 00:02:06,240
是一种模式的例子， 你经常看到

41
00:02:06,240 --> 00:02:07,619
或者很多人

42
00:02:07,619 --> 00:02:09,149
经历过他们试图

43
00:02:09,149 --> 00:02:11,068
建立一个网站来做某事并且你

44
00:02:11,068 --> 00:02:13,020
知道通常建立网站的人

45
00:02:13,020 --> 00:02:15,000
对构建高性能不感兴趣

46
00:02:15,000 --> 00:02:20,190
你知道

47
00:02:20,190 --> 00:02:22,200
他们有兴趣构建高性能存储基础架构

48
00:02:22,200 --> 00:02:24,750
 

49
00:02:24,750 --> 00:02:26,940
可以让他们的用户满意或销售

50
00:02:26,940 --> 00:02:29,220
更多广告或您知道的东西的功能，

51
00:02:29,220 --> 00:02:31,290
这样他们就不会从

52
00:02:31,290 --> 00:02:33,450
花费一年的主要精力

53
00:02:33,450 --> 00:02:35,400
或大量时间开始构建 g 很酷的

54
00:02:35,400 --> 00:02:36,450
基础设施他们将从

55
00:02:36,450 --> 00:02:38,340
构建功能开始，因为他们只会

56
00:02:38,340 --> 00:02:41,850
 

57
00:02:41,850 --> 00:02:42,989
在他们真正需要的范围内使基础设施变得更好，

58
00:02:42,989 --> 00:02:44,070
因为你知道这是对他们时间的最佳利用，

59
00:02:44,070 --> 00:02:47,910
所以这是一个典型的开始

60
00:02:47,910 --> 00:02:51,840
场景 某个网站

61
00:02:51,840 --> 00:02:54,180
非常小，你知道

62
00:02:54,180 --> 00:02:55,800
从

63
00:02:55,800 --> 00:02:57,569
一台机器开始没有任何意义吗？你

64
00:02:57,569 --> 00:02:59,160
知道，也许你开始了，你只有

65
00:02:59,160 --> 00:03:01,980
几个用户坐在他们的

66
00:03:01,980 --> 00:03:05,220
浏览器前，你知道他们在

67
00:03:05,220 --> 00:03:07,260
这里通过互联网交谈 你的单机

68
00:03:07,260 --> 00:03:09,540
你的单机现在可能会

69
00:03:09,540 --> 00:03:16,170
运行 Apache Web 服务器也许你

70
00:03:16,170 --> 00:03:20,450
 

71
00:03:20,450 --> 00:03:23,970
使用 PHP 或 Python 或其他

72
00:03:23,970 --> 00:03:27,000
一些方便的易于编程的

73
00:03:27,000 --> 00:03:29,340
脚本风格语言编写生成网页的脚本，而 Facebook

74
00:03:29,340 --> 00:03:33,060
使用 PHP 你需要存储数据

75
00:03:33,060 --> 00:03:36,000
在某个地方，或者您可以下载

76
00:03:36,000 --> 00:03:41,190
某种标准数据库，而 Facebook

77
00:03:41,190 --> 00:03:42,630
恰好使用我的续集我的学校是一个不错的

78
00:03:42,630 --> 00:03:45,630
选择，因为它实现了续集

79
00:03:45,630 --> 00:03:49,079
查询局域网 guage 非常强大，并且 acid

80
00:03:49,079 --> 00:03:51,510
事务提供了持久的存储，所以

81
00:03:51,510 --> 00:03:54,930
这就像一个非常好的设置，

82
00:03:54,930 --> 00:03:58,320
我实际上会带你走很长一段路，但是

83
00:03:58,320 --> 00:04:00,450
假设你成功了，

84
00:04:00,450 --> 00:04:02,670
你会得到越来越多的用户，你知道

85
00:04:02,670 --> 00:04:04,350
你会得到更多 更多的负载

86
00:04:04,350 --> 00:04:07,049
越来越多的人会查看你的

87
00:04:07,049 --> 00:04:09,900
网站并运行

88
00:04:09,900 --> 00:04:10,590
你

89
00:04:10,590 --> 00:04:14,970
网站提供的任何 PHP 东西，所以在某些时候

90
00:04:14,970 --> 00:04:17,190
几乎可以肯定的第一件事

91
00:04:17,190 --> 00:04:19,290
会出错的是 PHP

92
00:04:19,290 --> 00:04:21,839
脚本会占用太多的 CPU

93
00:04:21,839 --> 00:04:25,650
时间

94
00:04:25,650 --> 00:04:26,880
如果他们从单个服务器开始，这通常是人们遇到的第一个瓶颈，

95
00:04:26,880 --> 00:04:29,850
所以你需要一些

96
00:04:29,850 --> 00:04:31,919
方法来为你的 PHP 脚本获得更多的马力

97
00:04:31,919 --> 00:04:33,840
，这样我们就可

98
00:04:33,840 --> 00:04:38,430
 

99
00:04:38,430 --> 00:04:40,470
以为你知道你有很多和 很多

100
00:04:40,470 --> 00:04:44,450
用户正确或比以前更多的用户

101
00:04:44,450 --> 00:04:47,400
你需要更多的 CPU 能力来运行你的 PHP

102
00:04:47,400 --> 00:04:50,040
脚本，所以你运行一堆前端

103
00:04:50,040 --> 00:04:53,520
服务器，它们唯一的工作就是运行

104
00:04:53,520 --> 00:04:57,139
用户浏览器通信的 Web 服务器 到

105
00:04:57,139 --> 00:05:00,479
这些被称为前端服务器，因此

106
00:05:00,479 --> 00:05:03,860
它们将运行一个补丁或者

107
00:05:04,650 --> 00:05:09,240
网络服务器和 PHP 脚本现在你

108
00:05:09,240 --> 00:05:10,560
知道你的用户将

109
00:05:10,560 --> 00:05:11,880
在不同的时间与不同的服务器交谈

110
00:05:11,880 --> 00:05:14,610
也许你的用户 Quadra 彼此他们

111
00:05:14,610 --> 00:05:16,259
互相发送消息他们需要 查看

112
00:05:16,259 --> 00:05:17,460
彼此的帖子或其他内容，

113
00:05:17,460 --> 00:05:19,080
因此所有这些前端服务器

114
00:05:19,080 --> 00:05:22,699
都需要查看相同的后端数据

115
00:05:23,210 --> 00:05:27,120
，为了做到这一点，您可能

116
00:05:27,120 --> 00:05:28,889
至少不能坚持一段时间，

117
00:05:28,889 --> 00:05:30,300
您可以坚持使用一个数据库

118
00:05:30,300 --> 00:05:31,500
服务器，所以你将拥有一台

119
00:05:31,500 --> 00:05:35,310
机器已经是我的续集，它处理

120
00:05:35,310 --> 00:05:37,770
所有数据库所有查询和

121
00:05:37,770 --> 00:05:40,530
更新来自

122
00:05:40,530 --> 00:05:43,199
前端服务器的读取和写入，如果可能的话，

123
00:05:43,199 --> 00:05:45,060
在这里使用一台服务器是明智的，因为

124
00:05:45,060 --> 00:05:46,560
只要你有两个 服务器，

125
00:05:46,560 --> 00:05:49,050
不知何故，您在多个数据库

126
00:05:49,050 --> 00:05:51,620
服务器上的数据变得更加复杂

127
00:05:51,620 --> 00:05:54,060
，您需要担心诸如

128
00:05:54,060 --> 00:05:56,550
您是否需要分布式事务或

129
00:05:56,550 --> 00:05:58,830
它如何让 PHP 脚本决定哪个

130
00:05:58,830 --> 00:06:01,590
数据库 可以与之交谈，因此

131
00:06:01,590 --> 00:06:03,389
您可以通过第二种架构获得很长的

132
00:06:03,389 --> 00:06:05,699
 

133
00:06:05,699 --> 00:06:07,889
 

134
00:06:07,889 --> 00:06:11,880
 

135
00:06:11,880 --> 00:06:13,590
 

136
00:06:13,590 --> 00:06:16,020
路要走 许多前端，

137
00:06:16,020 --> 00:06:18,000
但您知道也许您非常

138
00:06:18,000 --> 00:06:22,610
成功，您获得了更多用户，

139
00:06:22,610 --> 00:06:24,840
所以问题是接下来会出现

140
00:06:24,840 --> 00:06:27,599
什么问题，通常接下来会出现问题

141
00:06:27,599 --> 00:06:30,090
是数据库服务器，因为您

142
00:06:30,090 --> 00:06:33,169
总是可以添加更多 CPU 更多 Web

143
00:06:33,169 --> 00:06:35,430
服务器 知道不可避免的问题是

144
00:06:35,430 --> 00:06:37,620
，一段时间后数据库服务器会

145
00:06:37,620 --> 00:06:43,380
耗尽动力，那么

146
00:06:43,380 --> 00:06:49,380
下一个架构是什么，这是 Web

147
00:06:49,380 --> 00:06:51,690
架构 3 和

148
00:06:51,690 --> 00:06:55,080
大型网站的标准演变，

149
00:06:55,080 --> 00:06:57,930
如果你现在知道

150
00:06:57,930 --> 00:07:01,500
成千上万 用户有很多很多的

151
00:07:01,500 --> 00:07:04,740
前端，现在我们基本上知道

152
00:07:04,740 --> 00:07:07,909
我们将不得不拥有多个

153
00:07:07,909 --> 00:07:10,590
数据库服务器，所以现在在前端后面

154
00:07:10,590 --> 00:07:14,159
我们有一个完整的数据库服务器机架，

155
00:07:14,159 --> 00:07:16,860
每个服务器 r 再次取消我的

156
00:07:16,860 --> 00:07:18,280
续集，

157
00:07:18,280 --> 00:07:21,220
但我们将

158
00:07:21,220 --> 00:07:22,960
分片我们现在驱动的数据

159
00:07:22,960 --> 00:07:25,390
，以便在数据库服务器上分片数据，所以你知道

160
00:07:25,390 --> 00:07:27,130
也许第一个持有你知道

161
00:07:27,130 --> 00:07:32,080
的密钥 a 到 G & G 到第二个持有

162
00:07:32,080 --> 00:07:34,660
密钥 G 到 Q 你知道

163
00:07:34,660 --> 00:07:37,360
图表是什么，现在

164
00:07:37,360 --> 00:07:38,680
你知道前端你必须在

165
00:07:38,680 --> 00:07:40,960
这里教你的 PHP 脚本来查看

166
00:07:40,960 --> 00:07:42,250
他们需要的数据并尝试找出

167
00:07:42,250 --> 00:07:43,510
他们将要与哪个数据库服务器

168
00:07:43,510 --> 00:07:45,100
对话你知道 在不同的时间

169
00:07:45,100 --> 00:07:46,360
处理不同的数据，他们将

170
00:07:46,360 --> 00:07:50,250
与不同的服务器通信，所以这就是分片

171
00:07:51,030 --> 00:07:53,230
，当然，这给

172
00:07:53,230 --> 00:07:57,460
你带来动力的原因是，现在所有

173
00:07:57,460 --> 00:07:58,720
的读写工作已经分开了，

174
00:07:58,720 --> 00:08:01,360
希望能

175
00:08:01,360 --> 00:08:04,090
在 这些服务器，因为它们保存

176
00:08:04,090 --> 00:08:05,830
不同的数据，现在复制

177
00:08:05,830 --> 00:08:08,170
了对数据进行评分的文字图表，它们可以

178
00:08:08,170 --> 00:08:09,960
并行执行，并且具有很大的并行

179
00:08:09,960 --> 00:08:14,980
容量来读取和写入数据，如果您需要

180
00:08:14,980 --> 00:08:17,110
，PHP 代码必须

181
00:08:17,110 --> 00:08:19,180
了解分片，这有点痛苦 更改

182
00:08:19,180 --> 00:08:21,460
数据库服务器的设置

183
00:08:21,460 --> 00:08:23,440
添加新的数据库服务器，或者

184
00:08:23,440 --> 00:08:25,330
您意识到需要以不同的方式拆分密钥

185
00:08:25,330 --> 00:08:27,430
您现在知道需要一个

186
00:08:27,430 --> 00:08:29,320
您将不得不修改

187
00:08:29,320 --> 00:08:31,360
在前端运行的软件或其他

188
00:08:31,360 --> 00:08:33,370
东西以便 他们了解

189
00:08:33,370 --> 00:08:35,620
如何切换到新的分片，所以

190
00:08:35,620 --> 00:08:37,750
有些人在这里有些痛苦，

191
00:08:37,750 --> 00:08:40,030
如果你需要交易

192
00:08:40,030 --> 00:08:42,760
，你知道如果你需要交易，很多人会使用它们，

193
00:08:42,760 --> 00:08:45,130
但是

194
00:08:45,130 --> 00:08:47,140
单个交易中涉及的数据在

195
00:08:47,140 --> 00:08:49,870
多个数据库上 服务器，您

196
00:08:49,870 --> 00:08:51,730
可能需要两阶段提交或

197
00:08:51,730 --> 00:08:53,610
其他一些分布式事务方案，

198
00:08:53,610 --> 00:08:59,040
这也是一种痛苦和缓慢，好吧，

199
00:08:59,040 --> 00:09:03,490
您可以通过这种安排走得很远，

200
00:09:03,490 --> 00:09:07,089
但是它非常昂贵，

201
00:09:07,089 --> 00:09:10,750
我的续集或您知道的全

202
00:09:10,750 --> 00:09:12,520
功能 像人们

203
00:09:12,520 --> 00:09:14,680
喜欢使用的数据库服务器它不是特别快

204
00:09:14,680 --> 00:09:18,130
它可能每秒可以

205
00:09:18,130 --> 00:09:20,380
执行几十万次读取

206
00:09:20,380 --> 00:09:24,340
并且权限要少得多而且你

207
00:09:24,340 --> 00:09:29,790
知道网站倾向于 阅读量很大，

208
00:09:29,790 --> 00:09:32,200
因此您可能会

209
00:09:32,200 --> 00:09:36,300
在写入之前耗尽读取的动力

210
00:09:36,300 --> 00:09:38,410
，我们在 Web 服务器上加载的流量

211
00:09:38,410 --> 00:09:40,150
将由读取主导，

212
00:09:40,150 --> 00:09:43,660
因此一段时间后您知道您可以

213
00:09:43,660 --> 00:09:45,790
对数据进行更多切片，并且 在越来越多的服务器上变得越来越薄，

214
00:09:45,790 --> 00:09:49,210
但有两件事出了

215
00:09:49,210 --> 00:09:51,910
问题，一个是有时

216
00:09:51,910 --> 00:09:54,430
你有一些很热的特定密钥，这些密钥

217
00:09:54,430 --> 00:09:57,340
被大量使用，并且没有多少

218
00:09:57,340 --> 00:09:59,080
切片真的有帮助，因为每个

219
00:09:59,080 --> 00:10:02,110
密钥都只在一个 单个服务器因此

220
00:10:02,110 --> 00:10:03,550
非常流行，

221
00:10:03,550 --> 00:10:04,990
无论您

222
00:10:04,990 --> 00:10:09,160
对

223
00:10:09,160 --> 00:10:10,980
数据进行多少

224
00:10:10,980 --> 00:10:13,060
分区或分

225
00:10:13,060 --> 00:10:17,010
片，服务器

226
00:10:17,010 --> 00:10:20,080
都可能过载

227
00:10:20,080 --> 00:10:21,640
事实证明，过了一段时间，

228
00:10:21,640 --> 00:10:23,440
你会开始好好思考，

229
00:10:23,440 --> 00:10:25,060
而不是花很多钱来

230
00:10:25,060 --> 00:10:27,760
添加另一个运行我的续集的数据库服务器，

231
00:10:27,760 --> 00:10:30,880
我可以让同一台服务器运行

232
00:10:30,880 --> 00:10:32,920
得更快 呃，就像

233
00:10:32,920 --> 00:10:35,470
发生在 memcache D

234
00:10:35,470 --> 00:10:37,420
上一样，使用缓存从同一硬件中每秒获得的读取次数

235
00:10:37,420 --> 00:10:40,090
比使用数据库多得多，

236
00:10:40,090 --> 00:10:45,640
因此下一个架构

237
00:10:45,640 --> 00:10:48,280
，现在开始类似于

238
00:10:48,280 --> 00:10:51,940
Facebook 正在使用的架构，下一个架构

239
00:10:51,940 --> 00:10:56,680
仍然需要用户，我们仍然 有

240
00:10:56,680 --> 00:10:59,950
一堆前端服务器

241
00:10:59,950 --> 00:11:03,460
在 PHP 中运行 Web 服务器，现在可能有大量

242
00:11:03,460 --> 00:11:05,110
前端服务器，我们仍然拥有我们的

243
00:11:05,110 --> 00:11:06,640
数据库服务器，因为您知道

244
00:11:06,640 --> 00:11:11,020
我们需要一个系统来

245
00:11:11,020 --> 00:11:13,540
为我们将数据安全地存储在磁盘上，我们将

246
00:11:13,540 --> 00:11:17,860
为我们提供事务之类的东西，所以

247
00:11:17,860 --> 00:11:19,300
你知道可能需要一个数据库

248
00:11:19,300 --> 00:11:21,940
，但在这之间我们会有一个

249
00:11:21,940 --> 00:11:23,710
缓存层，这就是

250
00:11:23,710 --> 00:11:26,160
memcache D 的用武之地

251
00:11:26,160 --> 00:11:27,959
，当然还有其他东西你

252
00:11:27,959 --> 00:11:29,940
可以使用 memcache 但 memcache

253
00:11:29,940 --> 00:11:31,649
D 碰巧是一个非常流行的

254
00:11:31,649 --> 00:11:34,230
缓存方案，现在的想法是你有

255
00:11:34,230 --> 00:11:36,959
一大堆这样的 memcache 服务器

256
00:11:36,959 --> 00:11:41,759
，当前端需要读取一些

257
00:11:41,759 --> 00:11:45,990
数据时，它做的第一件事就是询问

258
00:11:45,990 --> 00:11:47,850
一个 memca  che 服务器看看你有没有

259
00:11:47,850 --> 00:11:48,839
我需要的数据，

260
00:11:48,839 --> 00:11:50,819
所以它会向其中一个 memcache 服务器发送一个带有一些密钥的 get 请求

261
00:11:50,819 --> 00:11:54,810
 

262
00:11:54,810 --> 00:11:56,279
，memcache 服务器会检查它

263
00:11:56,279 --> 00:11:58,139
在内存中只有一个表它实际上

264
00:11:58,139 --> 00:12:00,689
memcache 非常简单它很

265
00:12:00,689 --> 00:12:04,889
远 比您的实验室 3 更简单，例如

266
00:12:04,889 --> 00:12:07,529
它只是在内存中拥有一个大哈希表，

267
00:12:07,529 --> 00:12:09,000
它会使用哈希表中的键检查

268
00:12:09,000 --> 00:12:11,040
它是否发送回

269
00:12:11,040 --> 00:12:12,509
数据说哦，是的，这是

270
00:12:12,509 --> 00:12:15,180
我为此兑现的价值，如果我们 如果

271
00:12:15,180 --> 00:12:16,470
前端在这个 memcache 服务器中命中

272
00:12:16,470 --> 00:12:19,319
很好，我可以生成

273
00:12:19,319 --> 00:12:21,389
包含该数据的网页，如果它在

274
00:12:21,389 --> 00:12:23,839
网络服务器中丢失，尽管前端

275
00:12:23,839 --> 00:12:27,569
必须后部无关的数据库

276
00:12:27,569 --> 00:12:30,689
服务器，并且数据库服务器会说

277
00:12:30,689 --> 00:12:33,029
哦，你知道这里是 这是

278
00:12:33,029 --> 00:12:36,779
您需要的数据，然后为了将其

279
00:12:36,779 --> 00:12:39,000
兑现以用于下一个

280
00:12:39,000 --> 00:12:42,540
需要它的前端前端我们将发送一个put

281
00:12:42,540 --> 00:12:44,670
，其中包含它塑造数据库的数据

282
00:12:44,670 --> 00:12:48,300
到该memcache服务器并且因为

283
00:12:48,300 --> 00:12:50,850
memcache运行在 至少 10，也许

284
00:12:50,850 --> 00:12:52,740
m

285
00:12:52,740 --> 00:12:55,800
对于给定数量的硬件，杂草的速度可能比数据库快 10 倍以上

286
00:12:55,800 --> 00:12:58,079
 

287
00:12:58,079 --> 00:12:59,819
，为 memcache 和数据库服务器使用相当数量的硬件确实是值得的，

288
00:12:59,819 --> 00:13:02,189
 

289
00:13:02,189 --> 00:13:05,040
所以人们经常使用这种

290
00:13:05,040 --> 00:13:06,420
安排，它只是 为他们

291
00:13:06,420 --> 00:13:09,209
省钱，因为 memcache

292
00:13:09,209 --> 00:13:12,029
对于杂草来说比数据库服务器仍然

293
00:13:12,029 --> 00:13:13,410
需要向数据库发送写入要快得多，

294
00:13:13,410 --> 00:13:15,990
因为您希望有权将更新

295
00:13:15,990 --> 00:13:20,639
持久地存储在数据库中，因为

296
00:13:20,639 --> 00:13:22,379
如果发生崩溃或其他情况，它仍然可以存在，

297
00:13:22,379 --> 00:13:26,309
但是 你可以

298
00:13:26,309 --> 00:13:28,019
更快地将 Reese 发送到缓存，

299
00:13:28,019 --> 00:13:30,600
所以我们有一个问题，

300
00:13:30,600 --> 00:13:32,639
问题是为什么 memcache

301
00:13:32,639 --> 00:13:34,589
服务器实际上不会代表前端命中 put

302
00:13:34,589 --> 00:13:36,329
并

303
00:13:36,329 --> 00:13:37,949
在响应前端之前缓存响应所以

304
00:13:37,949 --> 00:13:39,209
这是一个很好的问题，

305
00:13:39,209 --> 00:13:41,100
你可以想象一个缓存层，

306
00:13:41,100 --> 00:13:43,439
你会向它发送一个 get，

307
00:13:43,439 --> 00:13:45,449
如果它错过了 memcache 层，它

308
00:13:45,449 --> 00:13:48,569
会将请求转发到

309
00:13:48,569 --> 00:13:50,670
数据库，婴儿响应 memcache

310
00:13:50,670 --> 00:13:52,699
mem 缓存会将数据添加到其

311
00:13:52,699 --> 00:13:55,680
表中，然后做出响应，

312
00:13:55,680 --> 00:13:59,339
原因是 memcache 就像一个

313
00:13:59,339 --> 00:14:00,720
完全独立的软件

314
00:14:00,720 --> 00:14:02,880
，它对

315
00:14:02,880 --> 00:14:04,589
数据库一无所知，实际上它甚至

316
00:14:04,589 --> 00:14:06,509
不一定与数据库一起使用和组合

317
00:14:06,509 --> 00:14:08,819
 

318
00:14:08,819 --> 00:14:12,240
虽然通常是这样，但我们无法

319
00:14:12,240 --> 00:14:14,720
将数据库的知识融入 memcache

320
00:14:14,720 --> 00:14:18,480
中，更深层次的原因是

321
00:14:18,480 --> 00:14:22,380
前端通常并没有真正

322
00:14:22,380 --> 00:14:25,160
在 memcache 中存储一对一的数据库记录，但

323
00:14:25,160 --> 00:14:28,980
几乎总是或非常频繁地发生了

324
00:14:28,980 --> 00:14:30,899
什么是 前端

325
00:14:30,899 --> 00:14:32,790
将向数据库发出一些请求，

326
00:14:32,790 --> 00:14:35,189
然后在某种程度上处理结果，您

327
00:14:35,189 --> 00:14:37,500
知道可能需要一些步骤将

328
00:14:37,500 --> 00:14:42,949
其转换为 HTML 或收集在一起

329
00:14:42,949 --> 00:14:46,529
您知道

330
00:14:46,529 --> 00:14:47,910
数据库中多行上多个职业的结果并

331
00:14:47,910 --> 00:14:49,860
缓存部分处理的信息

332
00:14:49,860 --> 00:14:51,120
在 memcache 中

333
00:14:51,120 --> 00:14:53,730
只是为了让下一个读者

334
00:14:53,730 --> 00:14:56,279
不必进行相同的处理，

335
00:14:56,279 --> 00:14:59,819
因此 memcache 它并不是真的

336
00:14:59,819 --> 00:15:01,410
不明白 d

337
00:15:01,410 --> 00:15:03,630
朋友们希望看到的

338
00:15:03,630 --> 00:15:06,089
缓存内容与您如何

339
00:15:06,089 --> 00:15:07,350
从数据库中获取数据之间的关系，即知识

340
00:15:07,350 --> 00:15:09,480
实际上只存在于前端的 PHP 代码中，

341
00:15:09,480 --> 00:15:12,449
因此即使我们可以

342
00:15:12,449 --> 00:15:14,850
构建一个好主意，我们也可以” 这里没有

343
00:15:14,850 --> 00:15:17,929
这种集成，

344
00:15:17,929 --> 00:15:20,279
 

345
00:15:20,279 --> 00:15:22,829
虽然它可能使缓存一致性故事更加简单，但这里没有这种集成，但它可能会使

346
00:15:22,829 --> 00:15:25,380
缓存一致性故事更加

347
00:15:25,380 --> 00:15:27,870
简单，是

348
00:15:27,870 --> 00:15:31,440
的，就是这样，并回答下一个

349
00:15:31,440 --> 00:15:33,630
问题，即

350
00:15:33,630 --> 00:15:37,100
后备现金和通过现金查看之间

351
00:15:37,100 --> 00:15:40,020
的区别 事实上，后备业务

352
00:15:40,020 --> 00:15:42,150
是前端

353
00:15:42,150 --> 00:15:44,280
对现金进行旁观以查看数据是否存在，

354
00:15:44,280 --> 00:15:45,930
如果不存在，它会自行

355
00:15:45,930 --> 00:15:48,090
安排使契约

356
00:15:48,090 --> 00:15:51,000
出错，您知道通过现金查看我

357
00:15:51,000 --> 00:15:53,160
对数据库的转发请求 并

358
00:15:53,160 --> 00:15:57,270
直接处理响应现在

359
00:15:57,270 --> 00:15:59,700
在 memcache 中受欢迎的部分原因

360
00:15:59,700 --> 00:16:01,770
是它是一种备用

361
00:16:01,770 --> 00:16:04,890
现金，对于是否存在完全中立的

362
00:16:04,890 --> 00:16:07,170
是一个数据库，或者数据库中有什么，

363
00:16:07,170 --> 00:16:09,140
或者

364
00:16:09,140 --> 00:16:11,520
memcache

365
00:16:11,520 --> 00:16:17,160
中的内容与数据库中的最终项目之间的关系，所以这

366
00:16:17,160 --> 00:16:18,840
是非常流行的安排，非常广泛

367
00:16:18,840 --> 00:16:21,540
使用它具有成本效益，因为

368
00:16:21,540 --> 00:16:23,310
memcache 在数据库中的速度要快得多，

369
00:16:23,310 --> 00:16:27,180
它有点 复杂的每一个

370
00:16:27,180 --> 00:16:29,370
让你认真的网站，所以这

371
00:16:29,370 --> 00:16:33,150
面临一个问题，如果你不

372
00:16:33,150 --> 00:16:35,190
做某事，存储在

373
00:16:35,190 --> 00:16:37,530
缓存中的

374
00:16:37,530 --> 00:16:40,050
数据将与数据库中的数据不同步，所以每个人

375
00:16:40,050 --> 00:16:42,600
都必须有一个关于如何制作的故事

376
00:16:42,600 --> 00:16:43,800
确保当您修改数据库中的某些内容时，

377
00:16:43,800 --> 00:16:48,710
您会对 memcache

378
00:16:48,710 --> 00:16:50,640
 

379
00:16:50,640 --> 00:16:52,560
 

380
00:16:52,560 --> 00:16:54,750
 

381
00:16:54,750 --> 00:16:56,790
 

382
00:16:56,790 --> 00:16:58,620
进行一些操作 尽管其他人

383
00:16:58,620 --> 00:17:05,030
有其他计划，但这种安排也

384
00:17:05,030 --> 00:17:08,040
可能有点脆弱，它允许

385
00:17:08,040 --> 00:17:11,970
您扩展到更多用户，然后您

386
00:17:11,970 --> 00:17:13,440
可以单独使用数据库，

387
00:17:13,440 --> 00:17:15,660
因为 memcache 是如此 ast 但这

388
00:17:15,660 --> 00:17:17,700
意味着您最终将

389
00:17:17,700 --> 00:17:20,180
得到一个系统，该系统承受的

390
00:17:20,180 --> 00:17:24,060
负载远远高于您

391
00:17:24,060 --> 00:17:25,829
知道的数量级，比数据库

392
00:17:25,829 --> 00:17:29,340
可以处理的负载高得多，因此如果出现任何

393
00:17:29,340 --> 00:17:30,990
问题，例如，如果您的一个

394
00:17:30,990 --> 00:17:34,250
memcache 服务器 将失败，

395
00:17:34,250 --> 00:17:36,210
这意味着前端现在

396
00:17:36,210 --> 00:17:37,710
必须联系数据库，因为

397
00:17:37,710 --> 00:17:40,080
他们没有命中他们无法使用它

398
00:17:40,080 --> 00:17:41,220
来存储数据

399
00:17:41,220 --> 00:17:42,630
你将大大增加数据库中的负载，

400
00:17:42,630 --> 00:17:45,450
因为

401
00:17:45,450 --> 00:17:47,120
你知道 memcache 假设 它有

402
00:17:47,120 --> 00:17:50,309
99% 的命中率，或者你知道

403
00:17:50,309 --> 00:17:53,220
 

404
00:17:53,220 --> 00:17:55,049
memcache 会吸收几乎

405
00:17:55,049 --> 00:17:58,470
所有的读取，数据库后端

406
00:17:58,470 --> 00:18:00,450
只会看到总读取的百分之几，

407
00:18:00,450 --> 00:18:04,530
所以这里的任何故障都会

408
00:18:04,530 --> 00:18:06,179
增加 百分之几的读取

409
00:18:06,179 --> 00:18:07,950
，也许你知道我不知道 50

410
00:18:07,950 --> 00:18:09,840
% 的读取或

411
00:18:09,840 --> 00:18:11,669
任何一个巨大的数量级

412
00:18:11,669 --> 00:18:16,320
增加的东西，就像 Facebook 所做的那样，一旦你

413
00:18:16,320 --> 00:18:18,659
必须依赖这个缓存 la 是的，您

414
00:18:18,659 --> 00:18:24,299
需要设置非常严格的

415
00:18:24,299 --> 00:18:26,429
措施，以确保您永远不会

416
00:18:26,429 --> 00:18:30,440
将数据库层暴露在

417
00:18:30,440 --> 00:18:35,039
任何

418
00:18:35,039 --> 00:18:37,289
 

419
00:18:37,289 --> 00:18:40,080
 

420
00:18:40,080 --> 00:18:43,350
东西上 确保

421
00:18:43,350 --> 00:18:44,850
数据库永远不会看到

422
00:18:44,850 --> 00:18:48,860
像满载这样的东西 好吧

423
00:18:48,860 --> 00:18:54,059
到目前为止这是通用的 现在我想

424
00:18:54,059 --> 00:18:58,230
切换到

425
00:18:58,230 --> 00:19:00,600
Facebook 在论文中描述

426
00:19:00,600 --> 00:19:04,020
的整体架构的大图 当然

427
00:19:04,020 --> 00:19:05,970
他们每个都有很多用户 用户作为

428
00:19:05,970 --> 00:19:08,640
无朋友和状态以及帖子、

429
00:19:08,640 --> 00:19:13,830
喜欢和照片，但 Facebook 非常

430
00:19:13,830 --> 00:19:16,650
容易或乐于向用户显示数据

431
00:19:16,650 --> 00:19:21,390
，其中一个超级重要的方面

432
00:19:21,390 --> 00:19:24,740
是，在您知道的情况下，新数据并不是

433
00:19:24,740 --> 00:19:26,909
绝对必要的，假设

434
00:19:26,909 --> 00:19:31,260
 

435
00:19:31,260 --> 00:19:34,169
您知道读取 由于缓存应该

436
00:19:34,169 --> 00:19:36,120
读取的数据已经过时了几秒钟

437
00:19:36,120 --> 00:19:38,429
，因此您向用户显示的

438
00:19:38,429 --> 00:19:40,110
数据不是最新的数据，而是

439
00:19:40,110 --> 00:19:41,880
几秒钟前的数据，您

440
00:19:41,880 --> 00:19:45,000
知道用户是什么 s 是极不可能

441
00:19:45,000 --> 00:19:48,570
注意到的，除非在特殊情况下，如果

442
00:19:48,570 --> 00:19:50,159
我正在查看今天的新闻提要，

443
00:19:50,159 --> 00:19:53,309
你知道今天的新闻你知道我是否看到

444
00:19:53,309 --> 00:19:54,419
了

445
00:19:54,419 --> 00:19:57,629
几次前的新闻与现在的新闻

446
00:19:57,629 --> 00:20:00,210
大事没有人会注意到没有人的

447
00:20:00,210 --> 00:20:01,710
会抱怨你知道这并不

448
00:20:01,710 --> 00:20:03,809
总是适用于所有数据，但对于

449
00:20:03,809 --> 00:20:05,429
很多数据来说，他们必须

450
00:20:05,429 --> 00:20:07,590
处理某种超级最新的

451
00:20:07,590 --> 00:20:08,970
一致性，比如

452
00:20:08,970 --> 00:20:11,549
线性化能力

453
00:20:11,549 --> 00:20:14,190
实际上并不重要，重要的是 你

454
00:20:14,190 --> 00:20:17,850
不会无限期地缓存陈旧的数据你

455
00:20:17,850 --> 00:20:20,159
知道他们不能做的是错误地

456
00:20:20,159 --> 00:20:22,200
拥有一些他们向

457
00:20:22,200 --> 00:20:25,259
用户展示的昨天或上周

458
00:20:25,259 --> 00:20:28,590
甚至一个小时前的数据，这些用户真的

459
00:20:28,590 --> 00:20:32,220
会开始注意到，所以他们 不

460
00:20:32,220 --> 00:20:34,889
关心

461
00:20:34,889 --> 00:20:36,720
一秒一秒的一致性，但他们非常

462
00:20:36,720 --> 00:20:41,789
关心不要不参与 不能

463
00:20:41,789 --> 00:20:44,159
从很久以前咀嚼过时的数据

464
00:20:44,159 --> 00:20:47,669
 

465
00:20:47,669 --> 00:20:48,600
他们需要提供

466
00:20:48,600 --> 00:20:51,149
一致性的另一种情况是，如果用户 更新 他们

467
00:20:51,149 --> 00:20:54,720
自己的数据，或者如果用户更新了几乎任何

468
00:20:54,720 --> 00:20:56,970
数据，然后读取

469
00:20:56,970 --> 00:20:59,249
了人类知道他们刚刚更新的

470
00:20:59,249 --> 00:21:02,489
 

471
00:21:02,489 --> 00:21:04,499
相同数据，如果用户知道他们刚刚

472
00:21:04,499 --> 00:21:07,619
更改过旧数据，那么在这种特定情况

473
00:21:07,619 --> 00:21:11,669
下，Facebook 会非常困惑。 设计还小心

474
00:21:11,669 --> 00:21:14,549
确保如果用户更改数据

475
00:21:14,549 --> 00:21:18,529
，该用户将看到更改数据

476
00:21:19,220 --> 00:21:23,519
正常，因此 Facebook 有多个数据中心

477
00:21:23,519 --> 00:21:27,899
，他们称之为区域，我认为

478
00:21:27,899 --> 00:21:30,389
在撰写本文时，他们有

479
00:21:30,389 --> 00:21:33,859
两个区域作为他们的主要区域

480
00:21:33,859 --> 00:21:36,690
区域在加利福尼亚西海岸，

481
00:21:36,690 --> 00:21:40,109
他们的次要区域

482
00:21:40,109 --> 00:21:43,769
在东海岸，两个数据中心

483
00:21:43,769 --> 00:21:51,480
看起来非常相似，你的一

484
00:21:51,480 --> 00:21:52,890
组数据库服务器运行我的

485
00:21:52,890 --> 00:21:56,520
续集在这些我的续集数据库服务器上共享日期，

486
00:21:56,520 --> 00:21:59,570
 

487
00:21:59,820 --> 00:22:03,900
他们有一堆内存缓存 D

488
00:22:03,900 --> 00:22:05,710
我们将看到它们实际上

489
00:22:05,710 --> 00:22:07,480
被安排在独立的集群中的服务器，

490
00:22:07,480 --> 00:22:09,630
然后他们有一堆前端

491
00:22:09,630 --> 00:22:15,160
再次在每个数据中心中进行单独的安排，

492
00:22:15,160 --> 00:22:20,230
并且那里' 这样做的几个

493
00:22:20,230 --> 00:22:22,570
原因是他们的

494
00:22:22,570 --> 00:22:24,370
客户分散在

495
00:22:24,370 --> 00:22:27,250
全国各地，

496
00:22:27,250 --> 00:22:28,300
东

497
00:22:28,300 --> 00:22:29,920
海岸的人们可以与附近的数据中心通信，

498
00:22:29,920 --> 00:22:31,750
而西海岸的人们也

499
00:22:31,750 --> 00:22:33,460
可以与附近的赤字通信，这很好。 只是减少了

500
00:22:33,460 --> 00:22:42,310
互联网延迟现在数据

501
00:22:42,310 --> 00:22:44,500
中心不是对称的，他们每个人都

502
00:22:44,500 --> 00:22:46,000
拥有所有数据的完整副本，

503
00:22:46,000 --> 00:22:47,920
他们没有

504
00:22:47,920 --> 00:22:50,590
在数据中心之间对数据进行分片，所以

505
00:22:50,590 --> 00:22:54,040
我认为西海岸是主要的，有点像

506
00:22:54,040 --> 00:22:55,930
拥有数据的真实副本，而

507
00:22:55,930 --> 00:23:00,370
东海岸是次要的，这

508
00:23:00,370 --> 00:23:01,930
真正意味着所有权利都

509
00:23:01,930 --> 00:23:05,920
必须发送到相关数据库并且

510
00:23:05,920 --> 00:23:08,200
第一天成为中心所以你知道任何

511
00:23:08,200 --> 00:23:12,940
权利都会被发送你知道这里和他们

512
00:23:12,940 --> 00:23:15,340
使用我的续集的一个特性，他们提供

513
00:23:15,340 --> 00:23:17,260
异步日志复制方案，

514
00:23:17,260 --> 00:23:21,360
让主区域中的每个数据库

515
00:23:21,360 --> 00:23:24,280
将每个更新发送到

516
00:23:24,280 --> 00:23:26,380
辅助区域中的相应数据库，这样

517
00:23:26,380 --> 00:23:29,640
可能会有几秒钟的

518
00:23:29,640 --> 00:23:31,720
延迟 数据库服务器将具有

519
00:23:31,720 --> 00:23:33,820
相同的内容，辅助数据库

520
00:23:33,820 --> 00:23:35,710
服务器将具有与主数据库相同的内容，

521
00:23:35,710 --> 00:23:38,140
尽管我们是本地的，

522
00:23:38,140 --> 00:23:39,430
所以当这些前端需要

523
00:23:39,430 --> 00:23:41,890
查找一些数据时，我通常会与

524
00:23:41,890 --> 00:23:44,590
该数据中心的 memcache memcache

525
00:23:44,590 --> 00:23:46,600
和 如果他们错过了内存缓存

526
00:23:46,600 --> 00:23:48,640
，他们会与他们交谈，他们会再次从

527
00:23:48,640 --> 00:23:52,080
同一个数据数据中心的数据库中读取，

528
00:23:52,080 --> 00:23:56,880
尽管数据库是

529
00:23:56,880 --> 00:23:59,830
完整的副本，所有数据都

530
00:23:59,830 --> 00:24:03,540
在这两个区域

531
00:24:04,180 --> 00:24:10,670
中，这就是接下来的整体情况

532
00:24:10,670 --> 00:24:11,990
我想

533
00:24:11,990 --> 00:24:18,110
谈谈他们如何使用的一些细节，你

534
00:24:18,110 --> 00:24:21,020
知道这个白细胞缓存

535
00:24:21,020 --> 00:24:25,040
实际上看起来像这样，所以确实

536
00:24:25,040 --> 00:24:28,550
有读取和写入，这

537
00:24:28,550 --> 00:24:31,910
正是图 2 中显示的在前面执行的

538
00:24:31,910 --> 00:24:33,640
读取 -

539
00:24:33,640 --> 00:24:37,360
 

540
00:24:37,360 --> 00:24:39,340
如果您读取任何

541
00:24:39,340 --> 00:24:40,870
可能被缓存的数据，则结束第一件事 前端代码所做的第一件事就是

542
00:24:40,870 --> 00:24:43,420
 

543
00:24:43,420 --> 00:24:46,060
使用他们想要的数据的键进行此 get 库调用

544
00:24:46,060 --> 00:24:48,370
并获取 ju  st 生成一个

545
00:24:48,370 --> 00:24:51,790
RPC 到相关的 memcache 服务器，所以

546
00:24:51,790 --> 00:24:56,050
他们散列这个库例程

547
00:24:56,050 --> 00:24:57,970
在客户端上散列散列选择

548
00:24:57,970 --> 00:25:01,420
memcache 服务器的密钥并将 RPC 发送到那个

549
00:25:01,420 --> 00:25:04,150
mcat 服务器他们随便回答是，

550
00:25:04,150 --> 00:25:06,670
这是你的数据，或者它可能指向

551
00:25:06,670 --> 00:25:10,090
nil 说我没有那些数据它

552
00:25:10,090 --> 00:25:18,910
没有被缓存所以如果 V 是 nil 那么

553
00:25:18,910 --> 00:25:22,600
前端将发出任何后续

554
00:25:22,600 --> 00:25:27,510
查询所需的从数据库中获取数据

555
00:25:27,510 --> 00:25:32,680
然后进行另一个 RPC

556
00:25:32,680 --> 00:25:34,920
调用

557
00:25:36,980 --> 00:25:39,810
- memk2 相关的 memcache 服务器要

558
00:25:39,810 --> 00:25:41,760
安装 在 memcache 服务器中获取数据，

559
00:25:41,760 --> 00:25:44,070
所以这只是我

560
00:25:44,070 --> 00:25:45,680
在

561
00:25:45,680 --> 00:25:48,660
它是后备缓存所做的事情之前讨论过的例程

562
00:25:48,660 --> 00:25:51,710
，

563
00:25:55,540 --> 00:25:59,890
你知道 V 是我们有一个键

564
00:25:59,890 --> 00:26:01,930
和一个值没有 Rana 正确的写作，所以

565
00:26:01,930 --> 00:26:05,050
每个库例程 前端我们

566
00:26:05,050 --> 00:26:11,110
将把新数据发送到数据库

567
00:26:11,110 --> 00:26:15,010
，你知道我在 Keene 之前提到过

568
00:26:15,010 --> 00:26:16,240
，值可能有点

569
00:26:16,240 --> 00:26:17,680
不同，你知道

570
00:26:17,680 --> 00:26:19,570
数据库中存储的内容通常

571
00:26:19,570 --> 00:26:21,300
与 存储在

572
00:26:21,300 --> 00:26:23,680
memcache 中的内容见，但我们现在可以想象一下

573
00:26:23,680 --> 00:26:26,350
，一旦数据库有了

574
00:26:26,350 --> 00:26:29,230
新数据，那么正确的库例程

575
00:26:29,230 --> 00:26:34,480
就会向 memcache 发送一个 RPC，详细说明它

576
00:26:34,480 --> 00:26:38,230
看起来你必须删除这个键，所以我

577
00:26:38,230 --> 00:26:41,860
想写 writer is invalidating

578
00:26:41,860 --> 00:26:43,780
memcache 中的键你知道

579
00:26:43,780 --> 00:26:47,380
这意味着什么，下一个

580
00:26:47,380 --> 00:26:49,000
尝试从 memcache D 中读取该键的前端

581
00:26:49,000 --> 00:26:52,180
将返回 nil，因为

582
00:26:52,180 --> 00:26:54,130
它不再被缓存，并且

583
00:26:54,130 --> 00:26:56,500
将从数据库中获取更新的值并将其

584
00:26:56,500 --> 00:27:01,570
安装到 memcache 中 好吧，所以

585
00:27:01,570 --> 00:27:04,210
这是一个无效，特别是

586
00:27:04,210 --> 00:27:06,490
它不是你可以想象的一个方案，

587
00:27:06,490 --> 00:27:08,620
在这一点上将新数据发送到内存缓存 T

588
00:27:08,620 --> 00:27:10,000
但它实际上并没有这样做

589
00:27:10,000 --> 00:27:13,180
，而不是 gliese 它实际上

590
00:27:13,180 --> 00:27:17,830
在 facebook 方案的上下文中是

591
00:27:17,830 --> 00:27:21,640
真实的 之所以需要这个删除，是

592
00:27:21,640 --> 00:27:24,330
为了让

593
00:27:24,330 --> 00:27:26,940
我们看到他们自己的权利，因为

594
00:27:26,940 --> 00:27:29,940
事实上在他们的计划中，mem cat 我的

595
00:27:29,940 --> 00:27:32,490
续集服务器数据库服务器也

596
00:27:32,490 --> 00:27:35,460
发送删除了你们中的一个，

597
00:27:35,460 --> 00:27:37,500
前端写了一些东西 g 在数据库中

598
00:27:37,500 --> 00:27:39,809
 

599
00:27:39,809 --> 00:27:42,029
论文中提到的具有混合尖叫机制的数据库将

600
00:27:42,029 --> 00:27:44,730
相关的删除发送

601
00:27:44,730 --> 00:27:47,159
到可能持有此密钥的 memcache 服务器，因此

602
00:27:47,159 --> 00:27:49,350
数据库服务器实际上

603
00:27:49,350 --> 00:27:51,510
将使 memcache 中的内容失效的数据

604
00:27:51,510 --> 00:27:54,539
可能会导致它们 虽然嗯，但是因为

605
00:27:54,539 --> 00:27:57,179
这可能需要一段时间，前端

606
00:27:57,179 --> 00:27:58,980
也删除了密钥说

607
00:27:58,980 --> 00:28:04,649
前端不会看到它刚刚更新的数据的陈旧值，

608
00:28:04,649 --> 00:28:14,659
好吧，这

609
00:28:16,590 --> 00:28:21,390
一切的背景

610
00:28:21,390 --> 00:28:23,520
几乎就是每个人都如何使用 memcache

611
00:28:23,520 --> 00:28:24,990
G 现在这里还没有什么

612
00:28:24,990 --> 00:28:28,980
特别特别的地方，最终你知道

613
00:28:28,980 --> 00:28:31,350
这篇论文表面上都是

614
00:28:31,350 --> 00:28:34,020
关于解决一致性问题的，

615
00:28:34,020 --> 00:28:36,929
这些确实很重要，但是

616
00:28:36,929 --> 00:28:39,059
他们遇到

617
00:28:39,059 --> 00:28:41,700
这些一致性问题的原因很大程度上

618
00:28:41,700 --> 00:28:46,380
是因为他们知道 修改

619
00:28:46,380 --> 00:28:47,970
设计或设置具有极高性能的设计，

620
00:28:47,970 --> 00:28:49,289
因为它们

621
00:28:49,289 --> 00:28:51,330
具有极高的负载，并表示

622
00:28:51,330 --> 00:28:54,029
他们迫切希望获得性能和

623
00:28:54,029 --> 00:28:56,909
某种结构

624
00:28:56,909 --> 00:28:59,840
为了

625
00:28:59,840 --> 00:29:02,100
保持合理的一致性水平，我们一直在支持性能改进

626
00:29:02,100 --> 00:29:04,110
，因为性能

627
00:29:04,110 --> 00:29:05,610
对他们来说是第

628
00:29:05,610 --> 00:29:07,590
 

629
00:29:07,590 --> 00:29:10,529
 

630
00:29:10,529 --> 00:29:14,210
 

631
00:29:14,210 --> 00:29:18,600
一位的

632
00:29:18,600 --> 00:29:21,330
在这里我还没有

633
00:29:21,330 --> 00:29:28,559
看到的问题让我看一下好吧，所以一个

634
00:29:28,559 --> 00:29:30,029
问题这意味着

635
00:29:30,029 --> 00:29:32,490
从主

636
00:29:32,490 --> 00:29:34,500
数据库到辅助数据库的复制更新也必须

637
00:29:34,500 --> 00:29:39,210
发出删除 - 是的，所以我认为这

638
00:29:39,210 --> 00:29:40,860
是对前一个或

639
00:29:40,860 --> 00:29:43,230
架构幻灯片观察结果

640
00:29:43,230 --> 00:29:47,100
是，确实，当前端

641
00:29:47,100 --> 00:29:49,500
向数据库服务器发送写入时，每个

642
00:29:49,500 --> 00:29:53,039
服务器都会更新其磁盘上的数据，并且它将

643
00:29:53,039 --> 00:29:56,070
 

644
00:29:56,070 --> 00:29:58,260
 

645
00:29:58,260 --> 00:30:00,690
向本地数据中心本地区域中的任何 memcache 服务器发送无效删除

646
00:30:00,690 --> 00:30:02,460
可能具有刚刚

647
00:30:02,460 --> 00:30:05,070
更新的密钥的数据库服务器还将更新的

648
00:30:05,070 --> 00:30:07,950
一种表示形式发送

649
00:30:07,950 --> 00:30:09,899
到相应的数据库 服务于

650
00:30:09,899 --> 00:30:11,940
另一个区域，它处理

651
00:30:11,940 --> 00:30:15,090
它对磁盘上的磁盘数据的权利，它

652
00:30:15,090 --> 00:30:18,779
也使用它们，借口排序的日志

653
00:30:18,779 --> 00:30:22,169
读取设备找出哪个

654
00:30:22,169 --> 00:30:25,169
内存缓存服务器可能持有

655
00:30:25,169 --> 00:30:27,299
刚刚更新的密钥并将其删除

656
00:30:27,299 --> 00:30:32,340
也发送到该内存缓存服务器，所以

657
00:30:32,340 --> 00:30:34,740
如果它的关键是缓存

658
00:30:34,740 --> 00:30:40,049
在两个数据中心中都无效，那么另一个

659
00:30:40,049 --> 00:30:41,399
问题是如果我们

660
00:30:41,399 --> 00:30:45,210
首先在右侧删除然后发送到

661
00:30:45,210 --> 00:30:47,630
数据库

662
00:30:48,260 --> 00:30:50,960
会发生什么，或者参考这个

663
00:30:50,960 --> 00:30:53,190
东西如果我们这样做会发生什么

664
00:30:53,190 --> 00:30:58,830
脚首先你知道如果你

665
00:30:58,830 --> 00:31:01,289
先删除然后你增加了

666
00:31:01,289 --> 00:31:03,659
一些其他客户的机会，所以假设你

667
00:31:03,659 --> 00:31:11,100
删除然后发送

668
00:31:11,100 --> 00:31:13,020
到这里的数据库如果另一个客户读取

669
00:31:13,020 --> 00:31:14,880
他们此时会错过的相同密钥

670
00:31:14,880 --> 00:31:18,480
他们' 重新从数据库中获取旧数据

671
00:31:18,480 --> 00:31:20,460
，然后他们

672
00:31:20,460 --> 00:31:21,240
会将其插入

673
00:31:21,240 --> 00:31:22,980
现金，然后您将对其进行更新

674
00:31:22,980 --> 00:31:25,490
，至少保留 memcache 一段时间，

675
00:31:25,490 --> 00:31:28,740
然后使用陈旧数据，然后如果这是

676
00:31:28,740 --> 00:31:30,120
写入客户端 再次读取它可能会

677
00:31:30,120 --> 00:31:31,440
看到陈旧的数据，即使它刚刚

678
00:31:31,440 --> 00:31:34,820
更新它执行删除第二次，

679
00:31:34,820 --> 00:31:37,290
你知道这些可能

680
00:31:37,290 --> 00:31:40,410
有人会在这段时间内阅读

681
00:31:40,410 --> 00:31:43,350
并看到窃取数据，但他们

682
00:31:43,350 --> 00:31:44,550
一般并不担心陈旧的数据

683
00:31:44,550 --> 00:31:47,130
在这种

684
00:31:47,130 --> 00:31:50,400
情况下，他们真的最担心客户端读取自己的

685
00:31:50,400 --> 00:31:52,950
权限，因此即使

686
00:31:52,950 --> 00:31:56,220
存在一致性问题，我

687
00:31:56,220 --> 00:32:00,240
执行删除第二次的方式也确保

688
00:32:00,240 --> 00:32:02,850
客户端在任何一种情况下都将拥有自己的权限，

689
00:32:02,850 --> 00:32:06,450
最终数据库

690
00:32:06,450 --> 00:32:09,720
服务器为 我刚刚提到

691
00:32:09,720 --> 00:32:13,190
将为书面密钥发送删除

692
00:32:19,510 --> 00:32:21,560
另一个问题我对

693
00:32:21,560 --> 00:32:24,670
编写新值如何显示陈旧数据感到困惑，

694
00:32:24,670 --> 00:32:40,940
但删除并没有让我看到我不确定

695
00:32:40,940 --> 00:32:42,500
 

696
00:32:42,500 --> 00:32:47,770
问题是什么 参考这段代码，

697
00:32:47,770 --> 00:32:53,090
一旦写好就可以了，也许

698
00:32:53,090 --> 00:32:54,560
问题是我们真的没有做

699
00:32:54,560 --> 00:32:59,060
删除，所以当客户的

700
00:32:59,060 --> 00:33:02,180
前端网络结束或想要

701
00:33:02,180 --> 00:33:03,350
更新他时，大卫只会告诉

702
00:33:03,350 --> 00:33:07,550
数据 abase 但没有显式地

703
00:33:07,550 --> 00:33:10,420
从 memcache 中删除数据 问题

704
00:33:10,420 --> 00:33:17,210
在于，如果客户端将此写入发送

705
00:33:17,210 --> 00:33:19,430
到数据库，然后立即

706
00:33:19,430 --> 00:33:22,040
读取相同的数据，则读取将从

707
00:33:22,040 --> 00:33:24,830
memcache 中出来，并且因为 memcache

708
00:33:24,830 --> 00:33:26,240
仍然具有

709
00:33:26,240 --> 00:33:27,590
您知道 memcache 的旧数据 还没有看到这个

710
00:33:27,590 --> 00:33:30,800
正确的客户端更新了一些数据

711
00:33:30,800 --> 00:33:32,900
然后读取它你知道在

712
00:33:32,900 --> 00:33:34,370
数据库中更新它但是如果来自memcache的过时数据它会读取数据

713
00:33:34,370 --> 00:33:36,320
然后

714
00:33:36,320 --> 00:33:38,450
客户端可能会更新一些数据但仍然

715
00:33:38,450 --> 00:33:41,570
看到旧数据和 如果您

716
00:33:41,570 --> 00:33:44,330
从 memcache 中删除它，那么如果您

717
00:33:44,330 --> 00:33:46,640
这样做的客户端删除，而不是写入

718
00:33:46,640 --> 00:33:49,760
一些数据并从 memcache 中删除它

719
00:33:49,760 --> 00:33:51,800
然后再次读取它的客户端，

720
00:33:51,800 --> 00:33:54,110
由于删除，它会在 memcache 中丢失，他们

721
00:33:54,110 --> 00:33:55,100
不必 转到数据库并

722
00:33:55,100 --> 00:33:56,780
读取数据，数据库会给

723
00:33:56,780 --> 00:34:03,560
它新的数据，好吧，所以问题是

724
00:34:03,560 --> 00:34:06,740
为什么我们在这里删除

725
00:34:06,740 --> 00:34:10,730
天哪，为什么我们不直接而不是这个

726
00:34:10,730 --> 00:34:13,880
删除让客户端直接

727
00:34:13,880 --> 00:34:18,260
因为它知道新的 d  ata 只是发送一个

728
00:34:18,260 --> 00:34:24,080
集合 RPC - memcache T 这

729
00:34:24,080 --> 00:34:24,949
是一个很好的问题

730
00:34:24,949 --> 00:34:26,960
，所以我们在这里做我有一个

731
00:34:26,960 --> 00:34:29,090
无效方案，这通常被

732
00:34:29,090 --> 00:34:34,760
称为更新方案，让我

733
00:34:34,760 --> 00:34:37,370
试着做一个例子来说明

734
00:34:37,370 --> 00:34:39,110
虽然这可能会使

735
00:34:39,110 --> 00:34:44,980
这个更新方案工作

736
00:34:45,130 --> 00:34:47,330
它不起作用它不能开箱即用，

737
00:34:47,330 --> 00:34:48,800
你不需要做一些仔细的

738
00:34:48,800 --> 00:34:50,570
设计来让它工作，所以

739
00:34:50,570 --> 00:34:51,889
这不是客户想要的 现在摆姿势，我们

740
00:34:51,889 --> 00:34:54,819
有两个客户端

741
00:34:57,220 --> 00:34:59,130
读取和写入交错的相同密钥，

742
00:34:59,130 --> 00:35:05,760
所以假设客户端一个

743
00:35:05,760 --> 00:35:11,710
告诉数据库您知道将 X plus

744
00:35:11,710 --> 00:35:15,130
plus 发送到数据库，只是

745
00:35:15,130 --> 00:35:19,630
增加 X，然后当然或者让

746
00:35:19,630 --> 00:35:22,990
我说它将从零增加 X

747
00:35:22,990 --> 00:35:25,980
设置为一，因此将 X 设置为一，然后

748
00:35:25,980 --> 00:35:30,490
在该客户端将调用

749
00:35:30,490 --> 00:35:36,400
我们的键集 X 和值

750
00:35:36,400 --> 00:35:40,050
一并将其写入内存缓存 D

751
00:35:40,050 --> 00:35:43,240
假设同时客户端二也

752
00:35:43,240 --> 00:35:46,150
想要增加 X 所以它会

753
00:35:46,150 --> 00:35:48,010
读取这个 数据库中的最新值

754
00:35:48,010 --> 00:35:50,700
和几乎证书 因为这些实际上是

755
00:35:50,700 --> 00:35:54,070
事务所以如果我们做

756
00:35:54,070 --> 00:35:55,450
增量什么客户端不会

757
00:35:55,450 --> 00:35:57,640
发送将是

758
00:35:57,640 --> 00:35:58,810
数据库上的某种增量事务以确保

759
00:35:58,810 --> 00:36:00,400
正确性因为数据库确实

760
00:36:00,400 --> 00:36:02,710
支持事务所以我们将

761
00:36:02,710 --> 00:36:04,270
想象客户端 to 增加

762
00:36:04,270 --> 00:36:07,839
x 的值 to to 将该增量发送

763
00:36:07,839 --> 00:36:09,550
到数据库，客户端 2 也

764
00:36:09,550 --> 00:36:12,070
将执行此设置，因此它将

765
00:36:12,070 --> 00:36:15,970
设置 X 为 2，但现在我们剩下

766
00:36:15,970 --> 00:36:19,690
的是 memcache D 中的值 1

767
00:36:19,690 --> 00:36:21,700
尽管设置了正确的值和

768
00:36:21,700 --> 00:36:25,540
数据库，也就是说如果我们进行

769
00:36:25,540 --> 00:36:28,060
此更新，即使它确实为

770
00:36:28,060 --> 00:36:29,560
我们节省了一些时间，因为现在我们正在

771
00:36:29,560 --> 00:36:31,720
为将来的某个人节省一个失误，

772
00:36:31,720 --> 00:36:33,099
因为我们直接说而不是

773
00:36:33,099 --> 00:36:36,130
删除我们也运行 如果

774
00:36:36,130 --> 00:36:39,040
它是在数据库中留下陈旧数据的流行数据

775
00:36:39,040 --> 00:36:41,770
的风险，并不是说您

776
00:36:41,770 --> 00:36:45,849
无法以某种方式使其工作，

777
00:36:45,849 --> 00:36:49,599
而是需要仔细考虑才能解决

778
00:36:49,599 --> 00:36:55,599
此问题，这就是为什么

779
00:36:55,599 --> 00:36:58,450
他们使用无效而不是

780
00:36:58,450 --> 00:37:03,109
更新好，所以我要

781
00:37:03,109 --> 00:37:07,460
讨论性能，

782
00:37:07,460 --> 00:37:09,789
他们如何获得性能的这种途径是

783
00:37:09,789 --> 00:37:12,859
通过并行并行化

784
00:37:12,859 --> 00:37:16,279
并行执行，对于

785
00:37:16,279 --> 00:37:18,650
一个高水平的存储系统，

786
00:37:18,650 --> 00:37:21,499
实际上有两种方法可以获得良好的

787
00:37:21,499 --> 00:37:22,249
性能，

788
00:37:22,249 --> 00:37:27,400
一种是通过分区 这是分片

789
00:37:27,400 --> 00:37:30,049
，即您获取数据并将

790
00:37:30,049 --> 00:37:32,450
其拆分为十个

791
00:37:32,450 --> 00:37:34,069
服务器上的十个部分，这十个服务器可以

792
00:37:34,069 --> 00:37:37,190
独立运行，

793
00:37:37,190 --> 00:37:39,619
希望您可以使用额外的硬件来获得

794
00:37:39,619 --> 00:37:42,579
更高的性能，尽管

795
00:37:42,579 --> 00:37:48,140
复制有超过 一份

796
00:37:48,140 --> 00:37:51,109
数据副本，对于给定数量

797
00:37:51,109 --> 00:37:53,259
的硬件，您可以选择

798
00:37:53,259 --> 00:37:55,670
是否对数据进行分区或

799
00:37:55,670 --> 00:37:56,930
复制以使用该

800
00:37:56,930 --> 00:38:04,519
硬件，并且您从

801
00:38:04,519 --> 00:38:05,509
memcache 中知道，看看我们在这里谈论的

802
00:38:05,509 --> 00:38:09,529
是

803
00:38:09,529 --> 00:38:11,599
通过对密钥进行散列处理将数据拆分到可用的内存缓存服务器上，

804
00:38:11,599 --> 00:38:14,509
以便每个密钥类型都存在

805
00:38:14,509 --> 00:38:16,279
于一个内存缓存服务器上，并来自

806
00:38:16,279 --> 00:38:18,789
我们将要谈论的内存缓存 这里是

807
00:38:18,789 --> 00:38:21,769
让每个前端只与

808
00:38:21,769 --> 00:38:23,839
单个 memcache 服务器通信并将其所有请求发送到

809
00:38:23,839 --> 00:38:25,819
那里，以便每个 memcache

810
00:38:25,819 --> 00:38:29,029
服务器仅服务于前端的一个子集

811
00:38:29,029 --> 00:38:31,690
并满足他们的所有需求，

812
00:38:31,690 --> 00:38:35,599
而 Facebook 实际上使用

813
00:38:35,599 --> 00:38:39,019
了两个分区的组合 和用于

814
00:38:39,019 --> 00:38:41,390
分区的复制 对它

815
00:38:41,390 --> 00:38:44,349
有利的事情是它的内存效率很高，

816
00:38:44,349 --> 00:38:48,220
因为您只存储每个项目的单个副本

817
00:38:48,220 --> 00:38:50,720
Abita 在复制中

818
00:38:50,720 --> 00:38:52,519
您将存储每条数据

819
00:38:52,519 --> 00:39:00,440
可能在分区类型的每台服务器

820
00:39:00,440 --> 00:39:03,290
上 只要您的

821
00:39:03,290 --> 00:39:05,329
密钥大致同样

822
00:39:05,329 --> 00:39:07,970
受欢迎，就可以很好地工作，但是如果

823
00:39:07,970 --> 00:39:10,040
有一些热键

824
00:39:10,040 --> 00:39:12,140
，那么一旦您

825
00:39:12,140 --> 00:39:13,609
获得足够多的分区以使这些

826
00:39:13,609 --> 00:39:17,690
热键位于您知道的不同服务器上，分区并不能真正帮助您

827
00:39:17,690 --> 00:39:19,160
例如，如果只有一个

828
00:39:19,160 --> 00:39:20,690
热键，则没有多少

829
00:39:20,690 --> 00:39:22,910
分区可以帮助您，因为

830
00:39:22,910 --> 00:39:25,220
无论您分区多少，该热键

831
00:39:25,220 --> 00:39:30,550
仍然只位于一台

832
00:39:34,100 --> 00:39:38,640
服务器上 问题分区是，

833
00:39:38,640 --> 00:39:40,890
如果前端

834
00:39:40,890 --> 00:39:42,930
需要使用大量数据，很多不同的

835
00:39:42,930 --> 00:39:44,970
键，这并不意味着前端，这意味着最终每个

836
00:39:44,970 --> 00:39:47,580
前端可能会与很多

837
00:39:47,580 --> 00:39:51,060
分区进行通信，至少如果您使用

838
00:39:51,060 --> 00:39:53,270
协议 就像 TCP 保持

839
00:39:53,270 --> 00:39:58,530
状态一样，当您

840
00:39:58,530 --> 00:40:00,090
 

841
00:40:00,090 --> 00:40:09,480
为复制添加越来越多的 N 平方通信时，

842
00:40:09,480 --> 00:40:12,830
如果您的问题是

843
00:40:12,830 --> 00:40:17,160
一些键很受欢迎，那就太好了，因为现在您

844
00:40:17,160 --> 00:40:18,390
知道您正在制作

845
00:40:18,390 --> 00:40:20,369
这些热键的副本并且 您可以

846
00:40:20,369 --> 00:40:24,210
并行地为每个副本提供相同的密钥，这

847
00:40:24,210 --> 00:40:26,490
很好，因为这样更少，

848
00:40:26,490 --> 00:40:28,980
没有 n 平方通信每个

849
00:40:28,980 --> 00:40:30,270
前端可能只与一个

850
00:40:30,270 --> 00:40:38,270
memcache 服务器通信，但坏处

851
00:40:38,270 --> 00:40:40,220
是每台服务器中都有一个数据副本，

852
00:40:40,220 --> 00:40:43,580
您可以缓存很远 复制的不同数据项比分区少

853
00:40:43,580 --> 00:40:47,600
，

854
00:40:47,600 --> 00:40:53,270
因此可以存储的总数据更少，

855
00:40:53,270 --> 00:40:57,140
因此这些只是通用的

856
00:40:57,140 --> 00:41:00,890
，这两种主要方法的优缺点是

857
00:41:00,890 --> 00:41:02,990
使用额外的硬件来获得更高的性能

858
00:41:02,990 --> 00:41:07,670
性能还可以，所以我想

859
00:41:07,670 --> 00:41:11,150
谈谈当

860
00:41:11,150 --> 00:41:12,710
他们使用分区和

861
00:41:12,710 --> 00:41:15,620
复制的一种上下文处于不同区域的级别时，

862
00:41:15,620 --> 00:41:21,820
我只想谈谈

863
00:41:21,820 --> 00:41:26,110
为什么他们决定有

864
00:41:26,110 --> 00:41:28,910
单独的区域和类型 独立的

865
00:41:28,910 --> 00:41:30,560
完整数据中心，

866
00:41:30,560 --> 00:41:33,950
每个区域的所有数据，所以在我这样做

867
00:41:33,950 --> 00:41:35,990
之前有一个问题，为什么我们不能通过

868
00:41:35,990 --> 00:41:38,330
 

869
00:41:38,330 --> 00:41:42,170
复制缓存相同数量的数据，所以假设你有 10

870
00:41:42,170 --> 00:41:46,070
台机器，每台机器都有 1 GB 的 RAM，而

871
00:41:46,070 --> 00:41:48,380
你

872
00:41:48,380 --> 00:41:50,240
 

873
00:41:50,240 --> 00:41:53,960
如果您使用

874
00:41:53,960 --> 00:41:56,290
分区方案，其中每台服务器

875
00:41:56,290 --> 00:41:58,310
存储与其他服务器不同的数据

876
00:41:58,310 --> 00:42:01,160
，您可以在您的服务器上存储总共 10

877
00:42:01,160 --> 00:42:04,250
GB 的不同数据

878
00:42:04,250 --> 00:42:07,070
对象 10 台服务器，每台都有 1 GB 的

879
00:42:07,070 --> 00:42:09,680
RAM，因此通过分区，您知道每个

880
00:42:09,680 --> 00:42:11,270
ram 字节用于不同的数据，因此您

881
00:42:11,270 --> 00:42:12,470
可以查看您拥有的 RAM 总量，

882
00:42:12,470 --> 00:42:15,470
这就是您有多少不同的数据

883
00:42:15,470 --> 00:42:16,940
知道您可以通过复制存储的不同数据项

884
00:42:16,940 --> 00:42:20,510
您知道假设您的

885
00:42:20,510 --> 00:42:22,400
用户或多或少地查看

886
00:42:22,400 --> 00:42:29,690
相同的内容每个副本每个缓存

887
00:42:29,690 --> 00:42:32,240
副本最终将存储

888
00:42:32,240 --> 00:42:36,440
与所有其他缓存大致相同的内容，因此

889
00:42:36,440 --> 00:42:38,060
您的 10 个您有 10 GB  RAM

890
00:42:38,060 --> 00:42:41,270
仍然是它们和你的 10 台机器，但

891
00:42:41,270 --> 00:42:42,920
每台机器都存储大致

892
00:42:42,920 --> 00:42:44,420
相同的数据，所以你最终会得到这

893
00:42:44,420 --> 00:42:48,460
10 个相同千兆字节项目的副本吗？

894
00:42:48,460 --> 00:42:51,110
所以在这个特定的例子中，如果

895
00:42:51,110 --> 00:42:52,090
你使用复制，你

896
00:42:52,090 --> 00:42:54,100
会尝试尽可能多的不同数据

897
00:42:54,100 --> 00:42:57,010
你知道这实际上可能是

898
00:42:57,010 --> 00:43:01,450
一个好主意，这取决于你知道

899
00:43:01,450 --> 00:43:04,480
你的数据是什么样的，但这确实

900
00:43:04,480 --> 00:43:07,090
意味着复制给你

901
00:43:07,090 --> 00:43:09,490
的缓存总数据更少，你知道

902
00:43:09,490 --> 00:43:11,140
你可以看到他们提到的纸质单词中有一些点

903
00:43:11,140 --> 00:43:14,530
这种紧张在

904
00:43:14,530 --> 00:43:18,040
名义上他们不会在另一边下降，

905
00:43:18,040 --> 00:43:19,150
因为他们同时使用

906
00:43:19,150 --> 00:43:27,610
复制和图表，好吧好吧，

907
00:43:27,610 --> 00:43:30,100
所以他们

908
00:43:30,100 --> 00:43:33,450
玩这个游戏的最高水平是 区域之间，

909
00:43:33,450 --> 00:43:36,730
因此在这个高级别上，每个区域都拥有

910
00:43:36,730 --> 00:43:38,880
所有数据的完整副本，

911
00:43:38,880 --> 00:43:41,200
他们拥有每个区域作为一组完整

912
00:43:41,200 --> 00:43:42,850
的数据库服务器每个数据库

913
00:43:42,850 --> 00:43:45,340
数据库对应的数据库服务器

914
00:43:45,340 --> 00:43:47,890
用于相同的数据并假设用户

915
00:43:47,890 --> 00:43:49,150
正在查看更多或 更少相同的东西

916
00:43:49,150 --> 00:43:52,630
，这意味着

917
00:43:52,630 --> 00:43:55,030
不同区域的 memcache 服务器也

918
00:43:55,030 --> 00:43:57,580
或多或少地存储基本上

919
00:43:57,580 --> 00:43:59,350
复制我们在

920
00:43:59,350 --> 00:44:00,760
数据库服务器和 memcache

921
00:44:00,760 --> 00:44:04,330
服务器中复制的地方，而重点

922
00:44:04,330 --> 00:44:09,400
是你想要一个完整的副本

923
00:44:09,400 --> 00:44:11,590
靠近互联网上西海岸用户的网站

924
00:44:11,590 --> 00:44:13,960
在互联网早期加载，而

925
00:44:13,960 --> 00:44:16,030
另一个

926
00:44:16,030 --> 00:44:18,460
靠近东海岸用户的完整网站的副本

927
00:44:18,460 --> 00:44:22,240
再次关闭互联网，

928
00:44:22,240 --> 00:44:23,860
互联网速度非常快，但从海岸到

929
00:44:23,860 --> 00:44:27,460
海岸你知道 50 毫秒或

930
00:44:27,460 --> 00:44:30,070
如果用户

931
00:44:30,070 --> 00:44:31,770
必须等待太多 50 毫秒的

932
00:44:31,770 --> 00:44:33,820
时间间隔，他们会开始注意到该

933
00:44:33,820 --> 00:44:36,880
时间量的另一个原因是 t

934
00:44:36,880 --> 00:44:42,800
你想要

935
00:44:42,800 --> 00:44:44,930
在两个区域之间应用数据的理由

936
00:44:44,930 --> 00:44:48,200
是，这些前端甚至

937
00:44:48,200 --> 00:44:50,740
可以为用户请求创建一个网页，

938
00:44:50,740 --> 00:44:53,840
通常来自缓存或数据库的数十或数百个

939
00:44:53,840 --> 00:44:55,880
不同的数据项

940
00:44:55,880 --> 00:44:58,940
，因此

941
00:44:58,940 --> 00:45:00,920
延迟的速度 前端

942
00:45:00,920 --> 00:45:03,770
可以从 memcache 键的外观中获取这数百个项目

943
00:45:03,770 --> 00:45:05,420
 

944
00:45:05,420 --> 00:45:07,880
的延迟非常重要，因此

945
00:45:07,880 --> 00:45:10,610
拥有前端并且只

946
00:45:10,610 --> 00:45:15,080
与只读本地 memcache 服务器

947
00:45:15,080 --> 00:45:17,960
和本地数据库对话非常重要，这样您就可以

948
00:45:17,960 --> 00:45:19,160
 

949
00:45:19,160 --> 00:45:21,350
非常快速地为一个网页执行数百个查询，所以如果

950
00:45:21,350 --> 00:45:23,090
我们在两个区域之间划分了数据，

951
00:45:23,090 --> 00:45:27,110
那么如果

952
00:45:27,110 --> 00:45:28,880
我在看我的朋友并且我的一些

953
00:45:28,880 --> 00:45:29,990
朋友在东方，你就会知道前端 海岸和西海岸的一些

954
00:45:29,990 --> 00:45:31,880
，这意味着如果我们进行

955
00:45:31,880 --> 00:45:33,860
分区，可能需要

956
00:45:33,860 --> 00:45:37,120
前端实际向其他数据中心发出许多

957
00:45:37,120 --> 00:45:39,820
请求，每个请求需要 50 毫秒

958
00:45:39,820 --> 00:45:45,280
，

959
00:45:45,280 --> 00:45:49,280
用户会看到这个 ki  nd 的延迟

960
00:45:49,280 --> 00:45:52,130
并且非常沮丧，所以

961
00:45:52,130 --> 00:45:53,720
另一个复制的原因是

962
00:45:53,720 --> 00:45:56,300
保持前端始终靠近数据

963
00:45:56,300 --> 00:46:00,140
到他们需要的所有数据当然这

964
00:46:00,140 --> 00:46:01,460
使得写入更加昂贵，因为现在

965
00:46:01,460 --> 00:46:03,500
如果前端和辅助 区域

966
00:46:03,500 --> 00:46:05,360
需要在 estes 中写入 将数据

967
00:46:05,360 --> 00:46:07,940
一直通过互联网发送

968
00:46:07,940 --> 00:46:10,370
读取频率远远高于

969
00:46:10,370 --> 00:46:13,850
正确的频率，因此这是一个很好的权衡，

970
00:46:13,850 --> 00:46:15,350
尽管论文没有提到这

971
00:46:15,350 --> 00:46:18,200
可能是

972
00:46:18,200 --> 00:46:20,180
两者之间完全复制的另一个原因

973
00:46:20,180 --> 00:46:23,720
网站是

974
00:46:23,720 --> 00:46:26,030
 

975
00:46:26,030 --> 00:46:27,560
 

976
00:46:27,560 --> 00:46:29,360
 

977
00:46:29,360 --> 00:46:31,570
 

978
00:46:34,890 --> 00:46:38,650
 

979
00:46:38,650 --> 00:46:40,359
 

980
00:46:40,359 --> 00:46:45,359
这样的 数据

981
00:46:48,150 --> 00:46:51,239
中心现在都在一个区域内的数据中心

982
00:46:51,239 --> 00:47:00,269
内，因此在每个区域中

983
00:47:00,269 --> 00:47:06,239
都有一组数据库服务器，

984
00:47:07,620 --> 00:47:11,900
因此在数据库级别，数据是

985
00:47:11,900 --> 00:47:14,910
图表化的，而不是在每个区域内复制，

986
00:47:14,910 --> 00:47:19,440
但是 在内存缓存级别，

987
00:47:19,440 --> 00:47:21,060
他们实际上使用复制和

988
00:47:21,060 --> 00:47:22,590
图表，所以他们有这个

989
00:47:22,590 --> 00:47:26,190
集群的概念，所以给定的区域实际上

990
00:47:26,190 --> 00:47:29,820
支持多个前端

991
00:47:29,820 --> 00:47:31,680
和数据库服务器集群，所以这里我将

992
00:47:31,680 --> 00:47:34,020
在这个区域中有两个集群，这个

993
00:47:34,020 --> 00:47:35,670
集群有 你知道一堆

994
00:47:35,670 --> 00:47:40,940
前端和一堆 memcache 服务器，

995
00:47:40,940 --> 00:47:45,690
它们是完全独立的，几乎

996
00:47:45,690 --> 00:47:46,950
完全独立，因此

997
00:47:46,950 --> 00:47:49,440
前端和集群一个将其所有

998
00:47:49,440 --> 00:47:51,990
读取发送到本地 memcache 服务器并

999
00:47:51,990 --> 00:47:54,300
错过它需要转到一个而不是

1000
00:47:54,300 --> 00:47:57,480
数据库服务器的数量，同样

1001
00:47:57,480 --> 00:48:01,340
，这个集群中的每个

1002
00:48:02,680 --> 00:48:06,080
前端只与同一个集群中的 memcache 服务器通信，

1003
00:48:06,080 --> 00:48:11,480
那么为什么他们有这么

1004
00:48:11,480 --> 00:48:15,380
多个集群，为什么不让你

1005
00:48:15,380 --> 00:48:16,580
基本上知道一个集群，

1006
00:48:16,580 --> 00:48:18,530
一组前端服务器和

1007
00:48:18,530 --> 00:48:20,690
一组 Memcache 服务器

1008
00:48:20,690 --> 00:48:24,140
由所有这些前端共享一个是，如果

1009
00:48:24,140 --> 00:48:26,180
你这样做了，这意味着你

1010
00:48:26,180 --> 00:48:27,830
知道是否需要扩大容量，

1011
00:48:27,830 --> 00:48:29,360
你会增加更多和

1012
00:48:29,360 --> 00:48:31,820
在同一个集群的前端有更多的 memcache 服务器，

1013
00:48:31,820 --> 00:48:36,230
你不会获得任何胜利，

1014
00:48:36,230 --> 00:48:38,990
因此在

1015
00:48:38,990 --> 00:48:43,100
你知道的流行键的性能上，所以

1016
00:48:43,100 --> 00:48:44,570
这个 memcache 服务的数据类型是一种

1017
00:48:44,570 --> 00:48:46,400
你知道的混合，其中大部分可能只

1018
00:48:46,400 --> 00:48:48,140
由一个 少数用户，但

1019
00:48:48,140 --> 00:48:49,790
那里有很多

1020
00:48:49,790 --> 00:48:52,070
用户需要查看的一些东西，通过使用

1021
00:48:52,070 --> 00:48:55,370
复制和分片，他们可以让

1022
00:48:55,370 --> 00:48:57,920
你知道非常

1023
00:48:57,920 --> 00:49:00,800
流行的密钥的多个副本，因此他们可以

1024
00:49:00,800 --> 00:49:02,770
在这些密钥之间并行服务

1025
00:49:02,770 --> 00:49:07,880
不同的集群

1026
00:49:07,880 --> 00:49:11,360
不想过多增加集群大小的另一个原因

1027
00:49:11,360 --> 00:49:13,340
 

1028
00:49:13,340 --> 00:49:16,430
是，集群中的所有数据

1029
00:49:16,430 --> 00:49:19,550
都分布在

1030
00:49:19,550 --> 00:49:21,800
所有 memcache 服务器上，并且任何一个

1031
00:49:21,800 --> 00:49:23,780
前端通常实际上都

1032
00:49:23,780 --> 00:49:26,420
需要来自可能的数据

1033
00:49:26,420 --> 00:49:30,650
最终每台 memcache 服务器，因此这

1034
00:49:30,650 --> 00:49:31,640
意味着您在前端和 memcache 服务器之间有一种 n 平方

1035
00:49:31,640 --> 00:49:33,380
通信模式，

1036
00:49:33,380 --> 00:49:38,060
并且在

1037
00:49:38,060 --> 00:49:39,590
某种程度上 他们正在使用 TCP 进行

1038
00:49:39,590 --> 00:49:41,360
通信，这涉及大量

1039
00:49:41,360 --> 00:49:44,180
开销

1040
00:49:44,180 --> 00:49:46,340
对于所有不同的 TCP 有很多连接状态，所以他们

1041
00:49:46,340 --> 00:49:50,120
想要限制，所以你知道这是 N

1042
00:49:50,120 --> 00:49:55,400
平方 CCP，他们想要限制

1043
00:49:55,400 --> 00:49:57,440
这个和方式的增长 这样做是

1044
00:49:57,440 --> 00:49:58,970
为了确保没有一个集群

1045
00:49:58,970 --> 00:50:01,640
变得太大，因此这个 N 平方不会变得

1046
00:50:01,640 --> 00:50:03,970
太大

1047
00:50:09,010 --> 00:50:13,060
并且与之密切相关的是，在

1048
00:50:13,060 --> 00:50:14,740
种姓拥塞业务中，他们正在

1049
00:50:14,740 --> 00:50:17,290
谈论如果主唱需要

1050
00:50:17,290 --> 00:50:20,530
大量数据 在内存缓存服务器中，

1051
00:50:20,530 --> 00:50:21,670
它实际上会

1052
00:50:21,670 --> 00:50:23,290
或多或少同时发出请求

1053
00:50:23,290 --> 00:50:25,270
，这意味着这个前端

1054
00:50:25,270 --> 00:50:26,860
将从所有

1055
00:50:26,860 --> 00:50:28,480
内存缓存服务器获得响应，以或多或少同时查询它

1056
00:50:28,480 --> 00:50:30,520
，这可能

1057
00:50:30,520 --> 00:50:32,170
意味着 数十或数百个数据包

1058
00:50:32,170 --> 00:50:34,630
同时到达这里，

1059
00:50:34,630 --> 00:50:36,700
如果您不小心，我们会

1060
00:50:36,700 --> 00:50:41,890
导致种姓拥塞的数据包丢失，并且

1061
00:50:41,890 --> 00:50:43,510
为了限制您

1062
00:50:43,510 --> 00:50:44,740
拥有他们谈论的一堆技术

1063
00:50:44,740 --> 00:50:47,110
但其中一个的糟糕程度 其中 并没有使

1064
00:50:47,110 --> 00:50:49,150
集群太大，因此

1065
00:50:49,150 --> 00:50:51,520
memcache的数量给前端往往会

1066
00:50:51,520 --> 00:50:53,650
说话，它们可能

1067
00:50:53,650 --> 00:50:55,990
对同一个种姓有贡献永远不会

1068
00:50:55,990 --> 00:50:59,650
太大，论文提到的最后一个原因

1069
00:50:59,650 --> 00:51:02,200
是它或在这个后面 is

1070
00:51:02,200 --> 00:51:04,990
是数据中心中的一个大型

1071
00:51:04,990 --> 00:51:08,620
网络，很难构建

1072
00:51:08,620 --> 00:51:11,860
既快如每秒许多比特的网络，又

1073
00:51:11,860 --> 00:51:13,870
可以与大量不同的

1074
00:51:13,870 --> 00:51:16,480
计算机通信，并将数据

1075
00:51:16,480 --> 00:51:19,210
中心分成这些集群并进行

1076
00:51:19,210 --> 00:51:20,800
大部分通信 只

1077
00:51:20,800 --> 00:51:22,720
在每个集群内继续，这意味着他们需要

1078
00:51:22,720 --> 00:51:25,210
一个较小的他们需要你知道

1079
00:51:25,210 --> 00:51:27,370
这个集群的适度大小的快速网络和一个

1080
00:51:27,370 --> 00:51:29,050
适度的规模你知道

1081
00:51:29,050 --> 00:51:30,400
这个集群的合理快速的网络，但他们

1082
00:51:30,400 --> 00:51:32,050
不必构建一个可以排序的单个网络

1083
00:51:32,050 --> 00:51:34,290
处理巨型集群的

1084
00:51:34,290 --> 00:51:37,090
所有计算机之间的所有流量，

1085
00:51:37,090 --> 00:51:41,220
因此它限制了

1086
00:51:41,220 --> 00:51:44,620
底层网络的昂贵程度，另一方面

1087
00:51:44,620 --> 00:51:46,150
，它们当然是在复制数据

1088
00:51:46,150 --> 00:51:50,020
和两个集群和 f 或者

1089
00:51:50,020 --> 00:51:51,430
不是很受欢迎并且不会真正

1090
00:51:51,430 --> 00:51:53,500
从

1091
00:51:53,500 --> 00:51:58,120
拥有多个副本的性能优势中受益的项目

1092
00:51:58,120 --> 00:52:00,370
，坐在所有这些 RAM 上是浪费的，你

1093
00:52:00,370 --> 00:52:01,450
知道我们正在谈论

1094
00:52:01,450 --> 00:52:03,700
成百上千的服务器，所以数量

1095
00:52:03,700 --> 00:52:05,110
他们为内存缓存服务花在 RAM 上的钱

1096
00:52:05,110 --> 00:52:10,540
不是开玩笑，所以除了

1097
00:52:10,540 --> 00:52:13,990
每个集群内的内存缓存服务器池之外，

1098
00:52:13,990 --> 00:52:17,220
还有一个区域

1099
00:52:17,220 --> 00:52:20,680
内存缓存服务器池，

1100
00:52:20,680 --> 00:52:23,109
由一个区域中的所有集群共享，

1101
00:52:23,109 --> 00:52:28,329
然后他们修改到这个区域池中

1102
00:52:28,329 --> 00:52:30,609
前端

1103
00:52:30,609 --> 00:52:32,079
的软件，这样前端的软件就知道

1104
00:52:32,079 --> 00:52:32,890
啊哈

1105
00:52:32,890 --> 00:52:35,980
这个密钥这个滑雪板的数据实际上

1106
00:52:35,980 --> 00:52:38,290
并不经常使用，而不是将它存储

1107
00:52:38,290 --> 00:52:41,410
在我自己的集群的内存缓存服务器上我

1108
00:52:41,410 --> 00:52:43,300
将把这个不太流行的密钥存储

1109
00:52:43,300 --> 00:52:47,740
在 区域池的适当内存缓存服务器，

1110
00:52:47,740 --> 00:52:53,339
所以这

1111
00:52:55,480 --> 00:53:00,369
是区域池，这只是

1112
00:53:00,369 --> 00:53:02,339
承认某些数据

1113
00:53:02,339 --> 00:53:04,420
不够流行，不想拥有大量

1114
00:53:04,420 --> 00:53:06,670
副本，它们可以节省资金 y 通过

1115
00:53:06,670 --> 00:53:14,170
只兑现一个副本，

1116
00:53:14,170 --> 00:53:15,520
这就是他们获得这种

1117
00:53:15,520 --> 00:53:18,900
Carol 复制与分区

1118
00:53:18,900 --> 00:53:22,599
策略的方式，他们在每个区域内的每个区域内使用

1119
00:53:22,599 --> 00:53:26,170
 

1120
00:53:26,170 --> 00:53:28,770
他们讨论的一个困难是，当他们想要

1121
00:53:28,770 --> 00:53:32,079
在数据中创建一个新集群时 中心

1122
00:53:32,079 --> 00:53:34,510
他们实际上有一种临时的

1123
00:53:34,510 --> 00:53:36,700
性能问题，因为他们正在让

1124
00:53:36,700 --> 00:53:38,920
那个集群运行所以你知道假设

1125
00:53:38,920 --> 00:53:41,230
他们决定安装你知道

1126
00:53:41,230 --> 00:53:42,970
几百台机器是一个新的集群

1127
00:53:42,970 --> 00:53:44,799
，前端有新的前端新的

1128
00:53:44,799 --> 00:53:47,829
memcache 错误，然后他们触发 启动它

1129
00:53:47,829 --> 00:53:50,170
，你知道可能会导致一半的

1130
00:53:50,170 --> 00:53:52,630
用户开始使用新集群 我将

1131
00:53:52,630 --> 00:53:55,030
不得不在开始时很好地使用旧集群

1132
00:53:55,030 --> 00:53:56,710
这些

1133
00:53:56,710 --> 00:53:59,020
内存缓存服务器中什么都没有，所有前端

1134
00:53:59,020 --> 00:54:00,220
服务器都会错过内存缓存

1135
00:54:00,220 --> 00:54:04,390
服务器和 必须去数据库

1136
00:54:04,390 --> 00:54:06,730
，至少在开始时，直到

1137
00:54:06,730 --> 00:54:08,410
这些 memcache 服务填充

1138
00:54:08,410 --> 00:54:10,660
了所有类型的大量使用的数据，

1139
00:54:10,660 --> 00:54:12,940
这会增加负载

1140
00:54:12,940 --> 00:54:15,010
n 数据库服务器绝对是巨大的

1141
00:54:15,010 --> 00:54:18,099
飞跃，因为在我们添加新

1142
00:54:18,099 --> 00:54:19,869
集群之前，数据库服务器可能只

1143
00:54:19,869 --> 00:54:22,599
看到了 1% 的读取，因为

1144
00:54:22,599 --> 00:54:24,280
这些 memcache 服务器的读取命中

1145
00:54:24,280 --> 00:54:27,069
率可能是 99%，

1146
00:54:27,069 --> 00:54:28,420
这意味着只有 1% 的读取

1147
00:54:28,420 --> 00:54:30,760
在我们添加新集群之前的数据库服务器

1148
00:54:30,760 --> 00:54:33,520
如果

1149
00:54:33,520 --> 00:54:35,530
我们在内存缓存服务器中添加一个没有任何内容的新集群

1150
00:54:35,530 --> 00:54:37,510
并向它发送一半的流量，它最初会获得

1151
00:54:37,510 --> 00:54:39,839
100% 的未命中率

1152
00:54:39,839 --> 00:54:44,500
，所以这意味着你知道我们

1153
00:54:44,500 --> 00:54:46,780
已经离开了 所以现在总的未写写

1154
00:54:46,780 --> 00:54:48,490
将是 50% 所以我们已经

1155
00:54:48,490 --> 00:54:51,609
从这些数据库服务器提供了 1

1156
00:54:51,609 --> 00:54:54,460
% 的读取服务到它们提供了 50

1157
00:54:54,460 --> 00:54:56,410
% 的读取所以至少在这个

1158
00:54:56,410 --> 00:54:58,530
虚构的例子中我们已经

1159
00:54:58,530 --> 00:55:00,609
启动了这个新集群 我们可能会将

1160
00:55:00,609 --> 00:55:02,559
数据库的负载

1161
00:55:02,559 --> 00:55:05,079
增加 50 倍，并且

1162
00:55:05,079 --> 00:55:07,329
数据库服务器可能正在运行，您

1163
00:55:07,329 --> 00:55:09,130
合理地知道 Coast 的容量，

1164
00:55:09,130 --> 00:55:12,009
当然不是容量不足的 50/50 倍

1165
00:55:12,009 --> 00:55:14,980
因此

1166
00:55:14,980 --> 00:55:17,710
，如果他们只是

1167
00:55:17,710 --> 00:55:20,589
像那样启动

1168
00:55:20,589 --> 00:55:26,650
 

1169
00:55:26,650 --> 00:55:29,950
一个新集群，这将是

1170
00:55:29,950 --> 00:55:33,690
 

1171
00:55:33,690 --> 00:55:38,190
世界末日 在这种情况

1172
00:55:38,190 --> 00:55:40,599
下，当前端和新集群

1173
00:55:40,599 --> 00:55:45,099
错过实际上首先它有

1174
00:55:45,099 --> 00:55:48,369
自己的本地内存缓存，如果说不，我

1175
00:55:48,369 --> 00:55:49,990
没有数据，那么前端

1176
00:55:49,990 --> 00:55:51,910
我们会在另一个集群中询问相应的内存缓存

1177
00:55:51,910 --> 00:55:54,579
温暖的

1178
00:55:54,579 --> 00:55:56,410
集群已经拥有数据的数据，

1179
00:55:56,410 --> 00:55:58,299
如果它是流行的数据，它可能会

1180
00:55:58,299 --> 00:56:01,569
被我的朋友缓存并获取它的

1181
00:56:01,569 --> 00:56:05,529
数据，然后它将它安装在

1182
00:56:05,529 --> 00:56:08,680
本地内存缓存中，并且只有

1183
00:56:08,680 --> 00:56:10,839
本地内存缓存和暖内存缓存都没有

1184
00:56:10,839 --> 00:56:13,180
没有数据表明这是

1185
00:56:13,180 --> 00:56:15,220
前端，新集群

1186
00:56:15,220 --> 00:56:20,680
将从数据库服务器读取，所以就是这样

1187
00:56:20,680 --> 00:56:22,000
，所以它们在这种冷

1188
00:56:22,000 --> 00:56:24,490
模式下运行了一段时间，我

1189
00:56:24,490 --> 00:56:25,990
认为论文提到了几个小时，直到

1190
00:56:25,990 --> 00:56:28,180
内存缓存 服务器 ource 和新

1191
00:56:28,180 --> 00:56:30,400
集群开始拥有所有流行的

1192
00:56:30,400 --> 00:56:32,650
数据，然后他们可以关闭这个

1193
00:56:32,650 --> 00:56:35,740
冷功能，只使用本地

1194
00:56:35,740 --> 00:56:42,660
集群 memcache 没关系，

1195
00:56:42,660 --> 00:56:47,410
所以另一个负载

1196
00:56:47,410 --> 00:56:49,630
问题，如果他们遇到，

1197
00:56:49,630 --> 00:56:52,539
这是一个负载 再次

1198
00:56:52,539 --> 00:56:55,980
从这种旁观缓存

1199
00:56:55,980 --> 00:56:59,849
策略衍生的问题被称为雷鸣群

1200
00:56:59,849 --> 00:57:06,490
，场景

1201
00:57:06,490 --> 00:57:09,280
是假设我们有一些

1202
00:57:09,280 --> 00:57:12,310
数据，有很多 memcache 服务器，但是

1203
00:57:12,310 --> 00:57:13,930
有一些数据存储在

1204
00:57:13,930 --> 00:57:16,600
这个 memcache 服务器上，有

1205
00:57:16,600 --> 00:57:20,310
一大堆前面 通常

1206
00:57:20,310 --> 00:57:23,560
读取一条非常流行的

1207
00:57:23,560 --> 00:57:25,900
数据的终端，因此它们都在不断

1208
00:57:25,900 --> 00:57:27,369
发送针对该数据的 get 请求，

1209
00:57:27,369 --> 00:57:29,470
memcache 服务器将其保存在缓存中，它会

1210
00:57:29,470 --> 00:57:31,450
回答它们，并且您知道他们的 memcache

1211
00:57:31,450 --> 00:57:33,820
服务器节省了数百万到数

1212
00:57:33,820 --> 00:57:36,100
百万个请求 其次，所以我们

1213
00:57:36,100 --> 00:57:39,250
做得很好，当然还有

1214
00:57:39,250 --> 00:57:40,540
一些数据库服务器坐在这里

1215
00:57:40,540 --> 00:57:42,220
，它拥有该数据的真实副本，但

1216
00:57:42,220 --> 00:57:43,420
我们没有 不用打扰它，因为它被

1217
00:57:43,420 --> 00:57:46,090
很好地缓存了假设一些前端出现

1218
00:57:46,090 --> 00:57:49,570
并修改了这个非常流行的

1219
00:57:49,570 --> 00:57:51,010
数据，因此它将

1220
00:57:51,010 --> 00:57:53,080
使用新数据向数据库发送写入，然后

1221
00:57:53,080 --> 00:57:57,400
它将向内存缓存服务器发送删除，

1222
00:57:57,400 --> 00:57:58,570
因为这就是方式 权利

1223
00:57:58,570 --> 00:58:00,580
工作，所以现在我们刚刚删除了这个

1224
00:58:00,580 --> 00:58:02,800
非常受欢迎的数据我们有所有这些

1225
00:58:02,800 --> 00:58:04,600
前端不断发送获取

1226
00:58:04,600 --> 00:58:08,320
的数据他们都会同时错过

1227
00:58:08,320 --> 00:58:13,660
他们现在都会

1228
00:58:13,660 --> 00:58:17,410
错过发送读取请求到

1229
00:58:17,410 --> 00:58:19,750
前端数据库同时进行

1230
00:58:19,750 --> 00:58:22,090
，所以现在这个前端数据库

1231
00:58:22,090 --> 00:58:23,830
可能同时面临数十或数百个

1232
00:58:23,830 --> 00:58:25,660
对这些数据的请求，所以

1233
00:58:25,660 --> 00:58:27,160
这里的 Loews 会非常高

1234
00:58:27,160 --> 00:58:30,580
，而且特别令人失望，

1235
00:58:30,580 --> 00:58:33,609
因为我们知道所有这些请求

1236
00:58:33,609 --> 00:58:35,380
都是 对于相同的密钥，因此数据库

1237
00:58:35,380 --> 00:58:36,790
将一遍又一遍地执行相同的工作

1238
00:58:36,790 --> 00:58:39,190
以响应该密钥的最新书面

1239
00:58:39,190 --> 00:58:46,180
副本，直到最终

1240
00:58:46,180 --> 00:58:48,460
前端开始在 m 中安装新

1241
00:58:48,460 --> 00:58:50,619
密钥 emcache 然后人们又开始

1242
00:58:50,619 --> 00:58:53,109
打，所以这就是

1243
00:58:53,109 --> 00:58:55,119
雷霆伤害 我们真正想要的是

1244
00:58:55,119 --> 00:58:58,810
一个单曲 你知道如果有失误，如果有

1245
00:58:58,810 --> 00:59:01,270
正确的，并且在 memcache 中发生了线索和失误

1246
00:59:01,270 --> 00:59:03,550
，我们想要我们想要的

1247
00:59:03,550 --> 00:59:05,590
是第一个

1248
00:59:05,590 --> 00:59:07,390
错过获取数据并安装它

1249
00:59:07,390 --> 00:59:09,400
的前端，对于其他前端，就像

1250
00:59:09,400 --> 00:59:11,710
深呼吸一样，然后等到新数据

1251
00:59:11,710 --> 00:59:15,380
被缓存，

1252
00:59:15,380 --> 00:59:17,029
如果你看一下，这就是他们的设计所做的

1253
00:59:17,029 --> 00:59:21,109
一个叫做 Elise

1254
00:59:21,109 --> 00:59:26,119
的东西与以前使用的不同

1255
00:59:26,119 --> 00:59:30,049
，但它们叫 Elise，我们

1256
00:59:30,049 --> 00:59:33,339
再次在场景中从头开始让我们

1257
00:59:33,339 --> 00:59:35,539
看看现在假设我们有一个流行

1258
00:59:35,539 --> 00:59:40,640
的数据片段，第一个前端

1259
00:59:40,640 --> 00:59:44,779
请求缺少 memcache 的数据 Devo

1260
00:59:44,779 --> 00:59:46,039
会发回一个错误，说哦，不

1261
00:59:46,039 --> 00:59:47,660
，我的缓存中没有数据，但它

1262
00:59:47,660 --> 00:59:51,529
会安装 Elise，这是一个唯一的

1263
00:59:51,529 --> 00:59:55,069
数字，它会选择一个最小的数字，将

1264
00:59:55,069 --> 00:59:57,470
它安装在一个表中，然后将此租赁

1265
00:59:57,470 --> 01:00:01,250
令牌发送回 前端，然后是

1266
01:00:01,250 --> 01:00:03,079
其他前端 t 帽子进来并

1267
01:00:03,079 --> 01:00:05,890
要求相同的基思，他们

1268
01:00:05,890 --> 01:00:10,849
只会被要求等待你知道

1269
01:00:10,849 --> 01:00:12,259
四分之一秒或任何合理

1270
01:00:12,259 --> 01:00:13,789
的时间由内存缓存 D

1271
01:00:13,789 --> 01:00:15,230
因为内存缓存键会看到哈哈我

1272
01:00:15,230 --> 01:00:16,880
已经 发布了该密钥的租约，

1273
01:00:16,880 --> 01:00:18,920
现在至少有一个 V

1274
01:00:18,920 --> 01:00:21,529
Sparky 服务器会注意到它

1275
01:00:21,529 --> 01:00:22,940
已经发布，至少可以告诉

1276
01:00:22,940 --> 01:00:26,259
这些人等待，所以只有

1277
01:00:26,259 --> 01:00:28,789
服务器的一个猜测 Elise 这个服务器然后

1278
01:00:28,789 --> 01:00:33,230
在何时从数据库中请求数据

1279
01:00:33,230 --> 01:00:35,180
反对回复妈妈，

1280
01:00:35,180 --> 01:00:39,730
然后它

1281
01:00:40,210 --> 01:00:43,359
使用密钥和上帝的价值发送新

1282
01:00:43,359 --> 01:00:45,039
 

1283
01:00:45,039 --> 01:00:46,779
数据

1284
01:00:46,779 --> 01:00:48,190
的

1285
01:00:48,190 --> 01:00:51,640
put 被授予租约的人

1286
01:00:51,640 --> 01:00:52,960
实际上

1287
01:00:52,960 --> 01:00:55,690
将由这些其他朋友进行安装

1288
01:00:55,690 --> 01:00:57,250
 

1289
01:00:57,250 --> 01:01:00,220
 

1290
01:01:00,220 --> 01:01:03,430
 

1291
01:01:03,430 --> 01:01:05,289
的

1292
01:01:05,289 --> 01:01:08,740
几十个或几百个，我认为

1293
01:01:08,740 --> 01:01:10,089
租约的意义是

1294
01:01:10,089 --> 01:01:14,260
前端在一个尴尬的时刻失败并且

1295
01:01:14,260 --> 01:01:16,000
实际上没有从数据库请求数据

1296
01:01:16,000 --> 01:01:17,650
或者没有绕过它

1297
01:01:17,650 --> 01:01:19,569
安装它 memcache D 最终

1298
01:01:19,569 --> 01:01:21,700
memcache D 将删除租约，因为

1299
01:01:21,700 --> 01:01:23,680
它超时，下一个要询问的前端

1300
01:01:23,680 --> 01:01:26,770
将获得新租约，并希望

1301
01:01:26,770 --> 01:01:28,299
它将与数据库对话并安装

1302
01:01:28,299 --> 01:01:32,319
新数据，所以是的，他们

1303
01:01:32,319 --> 01:01:35,710
回答租约超时的问题，以防万一

1304
01:01:35,710 --> 01:01:41,140
第一个前端失败 是 是 好的 所以

1305
01:01:41,140 --> 01:01:43,029
这些租约是他们

1306
01:01:43,029 --> 01:01:48,130
解决 Thundering Herd 问题的解决方案 嗯，

1307
01:01:48,130 --> 01:01:49,930
他们遇到的另一个问题是，如果其中

1308
01:01:49,930 --> 01:01:54,430
一个内存缓存服务器发生故障，最

1309
01:01:54,430 --> 01:01:56,349
自然的你知道的，如果他们不做

1310
01:01:56,349 --> 01:01:58,059
任何特别的事情 memcache 服务器出现

1311
01:01:58,059 --> 01:02:00,309
故障，前端将发送一个请求，

1312
01:02:00,309 --> 01:02:02,470
他们将返回超时，网络

1313
01:02:02,470 --> 01:02:04,150
会说天哪，你知道我无法

1314
01:02:04,150 --> 01:02:05,819
联系该主机从未得到响应

1315
01:02:05,819 --> 01:02:09,039
，而真正的 I BRE

1316
01:02:09,039 --> 01:02:10,869
软件所做的是然后感知它

1317
01:02:10,869 --> 01:02:13,690
要求 数据库，所以如果一个 memcache

1318
01:02:13,690 --> 01:02:14,980
服务器出现故障并且我们没有做任何

1319
01:02:14,980 --> 01:02:17,260
特别的事情，那么数据库现在将

1320
01:02:17,260 --> 01:02:19,720
直接暴露给所有

1321
01:02:19,720 --> 01:02:21,010
这些礁石的读取，我正在捕获服务器 West

1322
01:02:21,010 --> 01:02:22,779
服务，这是 memcache 服务器很

1323
01:02:22,779 --> 01:02:23,859
可能一直在为你服务 知道

1324
01:02:23,859 --> 01:02:26,770
每秒一百万次读取，这可能

1325
01:02:26,770 --> 01:02:29,020
意味着数据库服务器将

1326
01:02:29,020 --> 01:02:30,339
受到每秒百万次读取的影响，

1327
01:02:30,339 --> 01:02:31,630
那么它远

1328
01:02:31,630 --> 01:02:37,440
不足以处理所有这些杂草现在

1329
01:02:37,440 --> 01:02:39,609
Facebook 他们在论文中并没有真正谈论，

1330
01:02:39,609 --> 01:02:40,960
但他们确实如此 有自动

1331
01:02:40,960 --> 01:02:44,289
机器来替换故障的 memcache

1332
01:02:44,289 --> 01:02:48,010
服务器，但是需要一段时间才能

1333
01:02:48,010 --> 01:02:51,549
设置一个新服务器一个新的 memcache

1334
01:02:51,549 --> 01:02:53,850
服务器并将所有前端重定向

1335
01:02:53,850 --> 01:02:55,380
到新服务器而不是旧

1336
01:02:55,380 --> 01:02:57,150
服务器，因此同时他们需要一个

1337
01:02:57,150 --> 01:03:00,180
排序 临时解决方案，这就是

1338
01:03:00,180 --> 01:03:06,510
这个阴沟的想法，所以让我们说独家新闻

1339
01:03:06,510 --> 01:03:11,880
是我们有我们的前端我们

1340
01:03:11,880 --> 01:03:13,890
有一组普通的内存缓存

1341
01:03:13,890 --> 01:03:16,610
 

1342
01:03:17,610 --> 01:03:21,010
服务器数据库内存缓存

1343
01:03:21,010 --> 01:03:23,500
服务之一失败了我们是 ki 等待

1344
01:03:23,500 --> 01:03:26,530
直到自动 memcache 服务器

1345
01:03:26,530 --> 01:03:27,970
替换系统替换这个

1346
01:03:27,970 --> 01:03:30,780
memcache 服务器，与此同时，

1347
01:03:30,780 --> 01:03:32,980
朋友们正在向它发送请求，他们

1348
01:03:32,980 --> 01:03:35,470
得到一种服务器没有响应

1349
01:03:35,470 --> 01:03:38,800
来自网络的错误，然后

1350
01:03:38,800 --> 01:03:45,540
可能有一小部分 gutter 服务器，

1351
01:03:46,109 --> 01:03:50,920
其唯一目的是 生命就是眼睛，

1352
01:03:50,920 --> 01:03:55,960
它们必须处于空闲状态，除非真正的

1353
01:03:55,960 --> 01:03:57,579
memcache 服务器出现故障，并且当前

1354
01:03:57,579 --> 01:04:00,190
端收到错误消息说 get

1355
01:04:00,190 --> 01:04:01,810
无法联系 memcache 服务器时，

1356
01:04:01,810 --> 01:04:05,140
它会向其中一个 gutter 服务器发送相同的请求

1357
01:04:05,140 --> 01:04:06,339
，尽管 论文

1358
01:04:06,339 --> 01:04:08,349
并没有说我想前端

1359
01:04:08,349 --> 01:04:10,210
将再次对密钥进行哈希处理，以

1360
01:04:10,210 --> 01:04:13,650
选择要与之交谈

1361
01:04:13,800 --> 01:04:17,589
的排水沟服务器以及排水沟服务器是否具有很好的值

1362
01:04:17,589 --> 01:04:18,819
，

1363
01:04:18,819 --> 01:04:21,040
否则前端服务器将

1364
01:04:21,040 --> 01:04:22,630
联系数据库服务器以读取该

1365
01:04:22,630 --> 01:04:25,930
值 然后将它安装在

1366
01:04:25,930 --> 01:04:27,339
内存缓存服务器中，以防其他人

1367
01:04:27,339 --> 01:04:28,750
回答要求相同的数据，

1368
01:04:28,750 --> 01:04:32,410
所以虽然这意味着排水沟

1369
01:04:32,410 --> 01:04:38,290
服务器将处理基本上处理它的

1370
01:04:38,290 --> 01:04:39,910
请求 d 所以他们会是你知道的一个小姐，你

1371
01:04:39,910 --> 01:04:41,740
知道由租约处理

1372
01:04:41,740 --> 01:04:42,579
Thundering Herd

1373
01:04:42,579 --> 01:04:44,859
他们至少我需要一个小姐，

1374
01:04:44,859 --> 01:04:46,810
每个项目都是一个无故障的

1375
01:04:46,810 --> 01:04:49,060
内存缓存服务器，所以

1376
01:04:49,060 --> 01:04:50,319
数据库服务器会有一些负载 但是

1377
01:04:50,319 --> 01:04:51,730
希望很快这个memcache服务器

1378
01:04:51,730 --> 01:04:54,460
会得到所有正在监听使用的数据

1379
01:04:54,460 --> 01:05:00,280
并提供良好的服务，

1380
01:05:00,280 --> 01:05:01,540
然后逐渐被替换，

1381
01:05:01,540 --> 01:05:03,339
然后朋友们会知道与

1382
01:05:03,339 --> 01:05:07,180
不同的替换服务器交谈，因为

1383
01:05:07,180 --> 01:05:09,099
他们不这样做 是今天的问题，

1384
01:05:09,099 --> 01:05:13,150
我认为他们不会向

1385
01:05:13,150 --> 01:05:14,980
这些排水沟服务器发送删除，因为因为

1386
01:05:14,980 --> 01:05:16,569
排水沟服务器可能已经接管了

1387
01:05:16,569 --> 01:05:20,740
任何人，而且可能不止一个

1388
01:05:20,740 --> 01:05:22,119
普通的内存缓存服务，它

1389
01:05:22,119 --> 01:05:26,760
实际上可以缓存缓存任何密钥，

1390
01:05:26,760 --> 01:05:30,910
所以这意味着 那可能有

1391
01:05:30,910 --> 01:05:33,400
你认识的朋友在和它交谈，这

1392
01:05:33,400 --> 01:05:35,290
意味着无论何时前端

1393
01:05:35,290 --> 01:05:36,730
需要它从 memcache 中删除一个键，

1394
01:05:36,730 --> 01:05:40,569
或者当数据库上的尖叫声将

1395
01:05:40,569 --> 01:05:42,520
任何键的删除发送到相关的

1396
01:05:42,520 --> 01:05:46,420
memcache 服务器时 是的，您知道

1397
01:05:46,420 --> 01:05:47,740
自然的设计是

1398
01:05:47,740 --> 01:05:51,609
它还将该删除的副本发送到

1399
01:05:51,609 --> 01:05:53,800
每个排水沟服务器，并且

1400
01:05:53,800 --> 01:05:55,119
对于正在删除将从内存缓存存储中删除的数据的前端

1401
01:05:55,119 --> 01:05:56,619
 

1402
01:05:56,619 --> 01:05:58,180
也是如此，但他们也必须离开

1403
01:05:58,180 --> 01:05:59,989
可能来自任何

1404
01:05:59,989 --> 01:06:04,289
MCAD 排水沟服务器，这将使

1405
01:06:04,289 --> 01:06:05,460
必须发送的失败数量增加一倍，

1406
01:06:05,460 --> 01:06:06,839
即使大多数时候

1407
01:06:06,839 --> 01:06:08,220
这些排水沟服务器没有做

1408
01:06:08,220 --> 01:06:09,690
任何事情，也没有缓存任何东西，这

1409
01:06:09,690 --> 01:06:11,849
并不重要，所以为了 避免

1410
01:06:11,849 --> 01:06:15,619
所有这些额外的删除，他们实际上

1411
01:06:15,619 --> 01:06:18,299
修复了排水沟服务器，以便他们

1412
01:06:18,299 --> 01:06:22,619
非常快速地删除密钥，而不是

1413
01:06:22,619 --> 01:06:23,940
挂在他们身上，直到他们被

1414
01:06:23,940 --> 01:06:27,989
明确删除，这就是问题的答案，

1415
01:06:27,989 --> 01:06:34,349
所以我想

1416
01:06:34,349 --> 01:06:38,999
谈谈所有这些的一致性

1417
01:06:38,999 --> 01:06:43,160
超高水平你知道

1418
01:06:43,160 --> 01:06:45,210
一致性问题

1419
01:06:45,210 --> 01:06:47,579
是任何给定数据都有很多数据副本

1420
01:06:47,579 --> 01:06:50,519
你知道

1421
01:06:50,519 --> 01:06:53,069
主数据库中有一个副本在相应的数据库中有一个副本

1422
01:06:53,069 --> 01:06:54,749
 

1423
01:06:54,749 --> 01:06:58,049
每个次要区域的 ase 服务器

1424
01:06:58,049 --> 01:07:01,799
在每个本地集群中，每个本地集群

1425
01:07:01,799 --> 01:07:03,930
中的一个 memcache 键中都有

1426
01:07:03,930 --> 01:07:06,359
 

1427
01:07:06,359 --> 01:07:08,700
该键的副本 可能存在该键的副本和排水沟服务器，并且

1428
01:07:08,700 --> 01:07:11,400
 

1429
01:07:11,400 --> 01:07:13,170
memcache 中可能存在该键的副本 服务器和 gutter memcache

1430
01:07:13,170 --> 01:07:14,849
服务器在彼此的区域，因此当写入进入时，我们有

1431
01:07:14,849 --> 01:07:17,400
大量的每条数据的副本在

1432
01:07:17,400 --> 01:07:19,259
运行

1433
01:07:19,259 --> 01:07:22,319
，您知道

1434
01:07:22,319 --> 01:07:23,930
所有这些副本都必须发生这些事情，

1435
01:07:23,930 --> 01:07:26,369
而且写入可能来自

1436
01:07:26,369 --> 01:07:28,319
多个来源 同一个密钥可能

1437
01:07:28,319 --> 01:07:30,210
由多个前端同时写入，

1438
01:07:30,210 --> 01:07:32,009
这个区域也可能是

1439
01:07:32,009 --> 01:07:35,910
朋友和其他区域，所以

1440
01:07:35,910 --> 01:07:38,249
它是这种并发性和

1441
01:07:38,249 --> 01:07:40,499
多个副本以及多种写入源，

1442
01:07:40,499 --> 01:07:42,859
因为有多个前端

1443
01:07:42,859 --> 01:07:47,039
它创建了很多

1444
01:07:47,039 --> 01:07:49,440
不仅有陈旧数据的机会，而且

1445
01:07:49,440 --> 01:07:52,259
数据陈旧数据长时间留在系统

1446
01:07:52,259 --> 01:07:58,710
中的机会，所以

1447
01:07:58,710 --> 01:08:02,160
我想说明这些

1448
01:08:02,160 --> 01:08:03,450
问题是什么 从某种意义上

1449
01:08:03,450 --> 01:08:05,219
说，当

1450
01:08:05,219 --> 01:08:08,700
有人问为什么前端不

1451
01:08:08,700 --> 01:08:10,499
更新为什么他们删除而不是更新时，我们已经谈过一点了，

1452
01:08:10,499 --> 01:08:12,089
所以这肯定

1453
01:08:12,089 --> 01:08:13,570
是一种天气

1454
01:08:13,570 --> 01:08:17,050
多源数据的实例，所以我们

1455
01:08:17,050 --> 01:08:22,060
遇到了麻烦 强制执行正确的顺序，

1456
01:08:22,060 --> 01:08:25,830
但这是另一个竞赛

1457
01:08:25,830 --> 01:08:28,450
 

1458
01:08:28,450 --> 01:08:30,420
 

1459
01:08:30,420 --> 01:08:31,779
 

1460
01:08:31,779 --> 01:08:35,369
 

1461
01:08:36,540 --> 01:08:38,710
 

1462
01:08:38,710 --> 01:08:40,540
 

1463
01:08:40,540 --> 01:08:47,430
示例 一个他想读取一个键，但

1464
01:08:47,430 --> 01:08:51,760
memcache 说它没有数据，

1465
01:08:51,760 --> 01:08:55,870
它是一个 Miss，所以 C

1466
01:08:55,870 --> 01:09:02,350
将从数据库中读取数据，

1467
01:09:02,350 --> 01:09:07,750
假设它取回一些你想要的值，

1468
01:09:07,750 --> 01:09:09,590
 

1469
01:09:09,590 --> 01:09:12,990
同时客户端想要更新这个

1470
01:09:12,990 --> 01:09:18,510
数据 因此它会向您发送他

1471
01:09:18,510 --> 01:09:22,880
等于 v2 的速率并将其发送到数据库

1472
01:09:22,880 --> 01:09:26,670
，然后您知道写入代码的规则

1473
01:09:26,670 --> 01:09:28,170
是我们看到的写入代码是

1474
01:09:28,170 --> 01:09:29,729
我们接下来要做的就是

1475
01:09:29,729 --> 01:09:33,660
从我的数据库中删除它 mcache d.c c2

1476
01:09:33,660 --> 01:09:35,390
 

1477
01:09:35,390 --> 01:09:39,439
将从数据库中删除 ah 密钥哦，那是

1478
01:09:39,439 --> 01:09:41,450
星期五，您知道它实际上是 c2

1479
01:09:41,450 --> 01:09:42,979
并不真正知道 memcache d 中的内容，

1480
01:09:42,979 --> 01:09:44,359
但前导永远存在，

1481
01:09:44,359 --> 01:09:48,430
因为肯定不会导致

1482
01:09:48,430 --> 01:09:50,990
陈旧数据 删除不会导致

1483
01:09:50,990 --> 01:09:53,359
她保持静止 Leena 嗯，这

1484
01:09:53,359 --> 01:09:55,310
就是论文声称

1485
01:09:55,310 --> 01:09:59,210
删除是幂等的感觉，说删除它对

1486
01:09:59,210 --> 01:10:02,810
kabhi 来说总是安全的，但是如果你回忆一下

1487
01:10:02,810 --> 01:10:05,960
如果你错过了 read 的伪代码

1488
01:10:05,960 --> 01:10:07,550
并且你读了 来自

1489
01:10:07,550 --> 01:10:09,140
数据库的数据，您应该只是

1490
01:10:09,140 --> 01:10:12,140
将该数据插入到内存缓存中，因此您知道的客户端 1

1491
01:10:12,140 --> 01:10:13,850
可能很慢，最后

1492
01:10:13,850 --> 01:10:19,430
可以发送一组 RPC 两个内存缓存

1493
01:10:19,430 --> 01:10:21,710
T 但它读取版本 1 并读取您

1494
01:10:21,710 --> 01:10:23,870
知道现在是什么

1495
01:10:23,870 --> 01:10:26,600
数据库中数据的旧版本，但它会将其

1496
01:10:26,600 --> 01:10:29,620
设置为

1497
01:10:33,020 --> 01:10:35,660
将其设置到 memcache 中，是的，您知道

1498
01:10:35,660 --> 01:10:36,980
发生的另一件事是，我们

1499
01:10:36,980 --> 01:10:39,170
知道数据库是每当您

1500
01:10:39,170 --> 01:10:40,730
编写一些东西时，我就是发送

1501
01:10:40,730 --> 01:10:42,830
删除 t 的数据库 o memcache D 所以当然也许

1502
01:10:42,830 --> 01:10:44,270
此时数据库

1503
01:10:44,270 --> 01:10:47,510
也会发送一个

1504
01:10:47,510 --> 01:10:51,060
删除 k2m 种姓的消息，所以现在我们开始

1505
01:10:51,060 --> 01:10:52,080
删除，但

1506
01:10:52,080 --> 01:10:53,160
没关系这些租约可能

1507
01:10:53,160 --> 01:10:55,200
在客户到达

1508
01:10:55,200 --> 01:10:59,730
时已经发生 更新此密钥，因此

1509
01:10:59,730 --> 01:11:03,480
此时内存缓存 D

1510
01:11:03,480 --> 01:11:06,420
将无限期地兑现此数据的陈旧版本，

1511
01:11:06,420 --> 01:11:08,040
并且不再有任何机制

1512
01:11:08,040 --> 01:11:11,820
，或者如果系统

1513
01:11:11,820 --> 01:11:14,100
以这种方式工作，

1514
01:11:14,100 --> 01:11:16,560
内存缓存 D 就没有任何机制可以看到

1515
01:11:16,560 --> 01:11:20,310
为了获得实际的正确值，

1516
01:11:20,310 --> 01:11:23,670
它将永远存储和

1517
01:11:23,670 --> 01:11:27,230
提供密钥 K 的陈旧数据，

1518
01:11:27,369 --> 01:11:30,219
因为他们遇到了这个问题，

1519
01:11:30,219 --> 01:11:32,690
虽然他们可以接受数据

1520
01:11:32,690 --> 01:11:35,090
有些过时，但他们不能

1521
01:11:35,090 --> 01:11:37,250
接受数据已经过时 永远过时，

1522
01:11:37,250 --> 01:11:38,989
因为用户最终会

1523
01:11:38,989 --> 01:11:42,349
注意到他们看到的是古老的数据，因此

1524
01:11:42,349 --> 01:11:44,270
他们必须解决这个问题，他们必须

1525
01:11:44,270 --> 01:11:49,239
确保这种情况没有发生，

1526
01:11:49,250 --> 01:11:51,349
他们实际上

1527
01:11:51,349 --> 01:11:54,920
也通过 t 的租赁机制解决了这个问题 他

1528
01:11:54,920 --> 01:11:56,300
与我们为 Thundering hoard 描述的租约机制相同，

1529
01:11:56,300 --> 01:11:58,550
尽管

1530
01:11:58,550 --> 01:12:01,460
租约机制有一个扩展可以

1531
01:12:01,460 --> 01:12:04,159
使这项工作发挥作用，所以

1532
01:12:04,159 --> 01:12:06,469
发生的情况是，当 memcache

1533
01:12:06,469 --> 01:12:07,940
回退一个 Miss 指示时，看到

1534
01:12:07,940 --> 01:12:10,010
数据不在缓存中，它会授予

1535
01:12:10,010 --> 01:12:13,099
租约，所以 我们得到 Miss 指示加上

1536
01:12:13,099 --> 01:12:17,329
这个租约，它基本上只是一个大的

1537
01:12:17,329 --> 01:12:19,460
唯一数字，并且 memcache 服务器

1538
01:12:19,460 --> 01:12:21,590
会记住

1539
01:12:21,590 --> 01:12:23,840
这个租约和这个密钥之间的关联，它

1540
01:12:23,840 --> 01:12:27,440
知道有人有租约来

1541
01:12:27,440 --> 01:12:31,340
更新这个密钥，新规则是

1542
01:12:31,340 --> 01:12:34,699
当 memcache 服务器

1543
01:12:34,699 --> 01:12:36,800
从另一个客户端

1544
01:12:36,800 --> 01:12:39,679
或数据库服务器获得删除

1545
01:12:39,679 --> 01:12:42,440
时，memcache 服务器将以及删除该

1546
01:12:42,440 --> 01:12:44,420
项目将使该租约无效，

1547
01:12:44,420 --> 01:12:46,849
因此只要这些删除

1548
01:12:46,849 --> 01:12:49,579
进入假设 Elyse 先到达

1549
01:12:49,579 --> 01:12:52,460
memcache 服务器会相信

1550
01:12:52,460 --> 01:12:55,250
它的关于租约的表中的这个租约 当集合到达 memcach 时，这个

1551
01:12:55,250 --> 01:12:57,610
集合

1552
01:12:59,679 --> 01:13:02,739
是从前端返回的租约

1553
01:13:02,739 --> 01:13:05,739
e服务器

1554
01:13:05,739 --> 01:13:06,969
会查看租约并说

1555
01:13:06,969 --> 01:13:09,760
等一下我你没有这个密钥的租约

1556
01:13:09,760 --> 01:13:12,280
好吧如果这些适合这个

1557
01:13:12,280 --> 01:13:14,980
密钥我会忽略这个集合所以

1558
01:13:14,980 --> 01:13:16,630
因为租约是因为其中一个

1559
01:13:16,630 --> 01:13:18,969
如果一个 这些删除中的一些在

1560
01:13:18,969 --> 01:13:21,699
set 之前出现，这在 invalidated 中看起来是无效的，

1561
01:13:21,699 --> 01:13:24,040
并且 memcache 服务器

1562
01:13:24,040 --> 01:13:27,130
会忽略这个 set，这

1563
01:13:27,130 --> 01:13:29,920
意味着 key 会注意到

1564
01:13:29,920 --> 01:13:33,340
memcache 和下一个

1565
01:13:33,340 --> 01:13:34,900
尝试读取该 key 的客户端

1566
01:13:34,900 --> 01:13:37,060
会丢失 get a Miss

1567
01:13:37,060 --> 01:13:40,120
现在会从数据库中读取新数据并将其

1568
01:13:40,120 --> 01:13:41,560
安装在 memcache 中，并且

1569
01:13:41,560 --> 01:13:43,900
大概第二次

1570
01:13:43,900 --> 01:13:46,920
围绕第二个读者租约是有效的

1571
01:13:46,920 --> 01:13:49,900
 

1572
01:13:49,900 --> 01:13:51,040
 

1573
01:13:51,040 --> 01:13:53,969
 

1574
01:13:53,969 --> 01:13:56,429
而不是发生在集合之前，

1575
01:13:56,429 --> 01:13:59,489
这些删除

1576
01:13:59,489 --> 01:14:02,409
而是发生在集合之后

1577
01:14:02,409 --> 01:14:05,860
 

1578
01:14:05,860 --> 01:14:08,830
 

1579
01:14:08,830 --> 01:14:12,580
 

1580
01:14:12,580 --> 01:14:14,739
在设置之后，memcache 服务器不会

1581
01:14:14,739 --> 01:14:17,100
从它的签证表中删除这些

1582
01:14:17,100 --> 01:14:19,360
当设置到来时 Solis 仍然存在

1583
01:14:19,360 --> 01:14:22,150
，是的，我们确实仍然

1584
01:14:22,150 --> 01:14:25,630
会接受我们将

1585
01:14:25,630 --> 01:14:30,040
设置密钥设置为陈旧值的设置，但我们的

1586
01:14:30,040 --> 01:14:31,510
假设是 这次

1587
01:14:31,510 --> 01:14:33,250
删除已经晚了，这意味着

1588
01:14:33,250 --> 01:14:35,260
Dilys 还没有到达，

1589
01:14:35,260 --> 01:14:37,300
当这些删除到达时，这个

1590
01:14:37,300 --> 01:14:39,489
在 theta 上的停留将被从

1591
01:14:39,489 --> 01:14:41,380
缓存中剔除，因此过时的日期将

1592
01:14:41,380 --> 01:14:43,000
在缓存中稍长一点 但是我们

1593
01:14:43,000 --> 01:14:45,760
不会遇到这种情况，即陈旧的

1594
01:14:45,760 --> 01:14:47,610
数据无限期地存放在缓存中，

1595
01:14:47,610 --> 01:14:51,390
并且从未删除

1596
01:14:52,260 --> 01:14:54,890
任何问题

1597
01:14:54,890 --> 01:15:07,910
lissa 机器 好的 嗯，总结一下

1598
01:15:07,910 --> 01:15:10,950
 

1599
01:15:10,950 --> 01:15:12,810
，将这个系统看作是由于系统的许多复杂性

1600
01:15:12,810 --> 01:15:14,910
源于事实当然是公平的 它是

1601
01:15:14,910 --> 01:15:17,330
由彼此不了解的部分拼凑而成的

1602
01:15:17,330 --> 01:15:20,010
 

1603
01:15:20,010 --> 01:15:21,900
，例如 memcached 他

1604
01:15:21,900 --> 01:15:24,060
了解数据库

1605
01:15:24,060 --> 01:15:25,890
 

1606
01:15:25,890 --> 01:15:31,880
在一致性方案中，

1607
01:15:31,880 --> 01:15:35,940
也许如果 Facebook 在

1608
01:15:35,940 --> 01:15:38,360
一开始就可以预测

1609
01:15:38,360 --> 01:15:40,440
 

1610
01:15:40,440 --> 01:15:42,410
问题将如何发展，如果他们有

1611
01:15:42,410 --> 01:15:44,490
足够的工程师来解决这个问题，他们

1612
01:15:44,490 --> 01:15:45,600
可以从一开始就建立一个

1613
01:15:45,600 --> 01:15:48,480
系统 可以提供

1614
01:15:48,480 --> 01:15:50,120
他们需要的所有东西高性能

1615
01:15:50,120 --> 01:15:54,120
多数据中心复制分区

1616
01:15:54,120 --> 01:15:57,620
和所有东西，而且他们有

1617
01:15:57,620 --> 01:15:59,580
公司已经这样做了，

1618
01:15:59,580 --> 01:16:01,710
所以我知道的那种

1619
01:16:01,710 --> 01:16:06,420
与本文中的系统最直接可比的例子

1620
01:16:06,420 --> 01:16:08,850
是，如果你 关心

1621
01:16:08,850 --> 01:16:10,800
这些你可能想看看的东西

1622
01:16:10,800 --> 01:16:16,820
是雅虎的花生存储系统，它

1623
01:16:16,820 --> 01:16:20,540
是从头开始设计的，

1624
01:16:20,540 --> 01:16:23,100
你知道在许多细节上有所不同，

1625
01:16:23,100 --> 01:16:26,100
但它确实提供了

1626
01:16:26,100 --> 01:16:30,150
具有一致性和良好

1627
01:16:30,150 --> 01:16:32,730
性能的多站点复制，所以它是可能的

1628
01:16:32,730 --> 01:16:34,850
更好，但你知道所有的问题都

1629
01:16:34,850 --> 01:16:37,130
存在，只是有一套更

1630
01:16:37,130 --> 01:16:40,320
综合的、也许是优雅的

1631
01:16:40,320 --> 01:16:41,270
 

1632
01:16:41,270 --> 01:16:44,810
解决方案，所以对于我们来说，从这篇论文

1633
01:16:44,810 --> 01:16:47,970
o  ne 是，至少对他们来说，对于

1634
01:16:47,970 --> 01:16:50,310
许多大型操作来说，缓存

1635
01:16:50,310 --> 01:16:54,210
对于承受高负载绝对至关重要

1636
01:16:54,210 --> 01:16:57,060
，缓存与其说

1637
01:16:57,060 --> 01:16:59,580
是减少延迟，不如说是

1638
01:16:59,580 --> 01:17:02,750
关于从

1639
01:17:02,750 --> 01:17:05,570
相对较慢的

1640
01:17:05,570 --> 01:17:08,880
存储服务器中隐藏巨大的负载，这就是缓存的

1641
01:17:08,880 --> 01:17:11,519
真正含义 为 Facebook 做的事情

1642
01:17:11,519 --> 01:17:13,260
是隐藏了几乎所有

1643
01:17:13,260 --> 01:17:18,059
来自数据库服务器的负载另一个要点是

1644
01:17:18,059 --> 01:17:20,730
，你总是在大型系统中，你

1645
01:17:20,730 --> 01:17:23,130
总是需要考虑缓存

1646
01:17:23,130 --> 01:17:25,889
、控制、抱歉分区

1647
01:17:25,889 --> 01:17:28,409
和复制我的意思是你需要

1648
01:17:28,409 --> 01:17:32,249
正式或非正式的方法

1649
01:17:32,249 --> 01:17:34,019
决定您将多少资源

1650
01:17:34,019 --> 01:17:35,639
用于分区以及

1651
01:17:35,639 --> 01:17:40,579
多少用于复制，最后

1652
01:17:40,579 --> 01:17:42,780
理想情况下，您可以

1653
01:17:42,780 --> 01:17:45,239
在本文中做得更好，从一开始就

1654
01:17:45,239 --> 01:17:47,219
集成不同的存储层

1655
01:17:47,219 --> 01:17:51,469
以实现良好的一致性

1656
01:17:51,469 --> 01:17:56,219
好的，这就是我要说的，

1657
01:17:56,219 --> 01:17:59,510
如果你有问题请问我

