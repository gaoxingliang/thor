1
00:00:03,380 --> 00:00:08,670
好吧，大家好，让我们开始吧，

2
00:00:08,670 --> 00:00:11,969
我今天想谈谈一个称为

3
00:00:11,969 --> 00:00:15,360
证书透明性的系统，这

4
00:00:15,360 --> 00:00:18,960
与

5
00:00:18,960 --> 00:00:21,119
我们目前讨论的大多数主题有点不同，我们已经

6
00:00:21,119 --> 00:00:23,100
讨论过分布式系统，它

7
00:00:23,100 --> 00:00:24,990
是真正封闭的系统

8
00:00:24,990 --> 00:00:27,750
参与者是值得信赖的，他们都

9
00:00:27,750 --> 00:00:30,960
可能由同

10
00:00:30,960 --> 00:00:32,488
一种相互信任的组织运行，比如

11
00:00:32,488 --> 00:00:34,440
椽子，这样你就知道你只是

12
00:00:34,440 --> 00:00:36,059
假设在英国皇家空军的层级做

13
00:00:36,059 --> 00:00:40,800
他们应该做的事情，但也有

14
00:00:40,800 --> 00:00:42,570
很多系统在那里特别

15
00:00:42,570 --> 00:00:44,370
系统在某种程度上建立了一个互联网规模

16
00:00:44,370 --> 00:00:48,270
，系统是开放的，任何人都

17
00:00:48,270 --> 00:00:50,760
可以参与成为积极

18
00:00:50,760 --> 00:00:54,149
 

19
00:00:54,149 --> 00:00:56,129
 

20
00:00:56,129 --> 00:01:01,289
 

21
00:01:01,289 --> 00:01:03,329
 

22
00:01:03,329 --> 00:01:06,450
的参与者 信任运行

23
00:01:06,450 --> 00:01:09,150
系统或保护它是

24
00:01:09,150 --> 00:01:11,010
你可能

25
00:01:11,010 --> 00:01:14,159
相互怀疑的每个人，

26
00:01:14,159 --> 00:01:16,560
如果那样的话 在这种情况下，您必须

27
00:01:16,560 --> 00:01:18,979
能够从相互不信任的部分构建有用的系统

28
00:01:18,979 --> 00:01:23,700
，这

29
00:01:23,700 --> 00:01:26,040
使得任何类型的互联网广泛开放的

30
00:01:26,040 --> 00:01:27,930
系统

31
00:01:27,930 --> 00:01:30,000
在您考虑设计分布式系统时都会产生顶级系统问题的信任和安全问题

32
00:01:30,000 --> 00:01:31,979
 

33
00:01:31,979 --> 00:01:34,829
因此，当

34
00:01:34,829 --> 00:01:37,619
您构建开放系统时，最基本的问题是当

35
00:01:37,619 --> 00:01:38,939
我在与另一台计算机或另一个人交谈时，

36
00:01:38,939 --> 00:01:41,640
您需要知道您是

37
00:01:41,640 --> 00:01:43,439
在与正确的另一台计算机

38
00:01:43,439 --> 00:01:46,049
交谈还是在与正确的网站交谈，

39
00:01:46,049 --> 00:01:48,799
这个问题实际上是 几乎

40
00:01:48,799 --> 00:01:51,869
无法解决 事实证明确实

41
00:01:51,869 --> 00:01:54,450
有很多解决方案，但没有一个

42
00:01:54,450 --> 00:01:56,939
真正有效，但

43
00:01:56,939 --> 00:01:59,130
问题是证书透明度

44
00:01:59,130 --> 00:02:04,170
今天的主题试图帮助处理

45
00:02:04,170 --> 00:02:06,360
今天的材料，

46
00:02:06,360 --> 00:02:08,788
在课程中与一致性有点倒退

47
00:02:08,788 --> 00:02:09,869
证书

48
00:02:09,869 --> 00:02:12,209
透明度所做的很多工作是确保

49
00:02:12,209 --> 00:02:13,800
所有各方都能看到

50
00:02:13,800 --> 00:02:16,230
关于证书的相同信息，

51
00:02:16,230 --> 00:02:18,990
这是一个真正的一致性问题和这个

52
00:02:18,990 --> 00:02:21,120
问题 l 还与区块链

53
00:02:21,120 --> 00:02:23,940
等区块链系统联系在一起，这就是我们

54
00:02:23,940 --> 00:02:26,000
下周要讨论的内容，

55
00:02:26,000 --> 00:02:29,310
证书透明度是

56
00:02:29,310 --> 00:02:32,010
区块链中相对较少的非加密货币用途

57
00:02:32,010 --> 00:02:37,010
之一

58
00:02:37,010 --> 00:02:39,690
 

59
00:02:39,690 --> 00:02:45,060
 

60
00:02:45,060 --> 00:02:47,340
无论如何，网络安全性在

61
00:02:47,340 --> 00:02:50,940
1995 年之前就存在于证书之前，所以这

62
00:02:50,940 --> 00:02:56,280
是针对 1995 年的，特别是

63
00:02:56,280 --> 00:02:57,990
当时有一种人们担心的攻击

64
00:02:57,990 --> 00:03:00,150
 

65
00:03:00,150 --> 00:03:02,040
称为中间人攻击，这

66
00:03:02,040 --> 00:03:06,740
是

67
00:03:07,420 --> 00:03:10,599
中间人，这是一类

68
00:03:10,599 --> 00:03:14,200
攻击类型的名称，因此您知道当时的

69
00:03:14,200 --> 00:03:16,300
设置是

70
00:03:16,300 --> 00:03:20,770
您拥有互联网，并且有人在运行

71
00:03:20,770 --> 00:03:23,120
浏览器，

72
00:03:23,120 --> 00:03:26,519
嗯，坐在我们的计算机连接

73
00:03:26,519 --> 00:03:27,120
到互联网的

74
00:03:27,120 --> 00:03:29,099
任何人面前 我的电脑我

75
00:03:29,099 --> 00:03:31,640
想与特定的服务器交谈，

76
00:03:31,640 --> 00:03:33,780
暴露我想要做的就是与 gmail.com 交谈，

77
00:03:33,780 --> 00:03:39,209
正常情况下我

78
00:03:39,209 --> 00:03:42,209
会知道可能会联系 DNS 系统

79
00:03:42,209 --> 00:03:45,750
作为用户我可能会 输入 gmail.com 我

80
00:03:45,750 --> 00:03:47,040
会知道我

81
00:03:47,040 --> 00:03:49,859
想和李姓 gmail.com 交谈 我的浏览器

82
00:03:49,859 --> 00:03:51,780
会与 DNS 服务器交谈 说什么是

83
00:03:51,780 --> 00:03:54,180
gmail.com 它会回复一个 IP

84
00:03:54,180 --> 00:03:56,190
地址 我连接了那个 IP 地址，

85
00:03:56,190 --> 00:03:58,379
你知道我 需要对自己进行身份验证，

86
00:03:58,379 --> 00:04:00,060
所以我可能会

87
00:04:00,060 --> 00:04:02,519
在 Gmail 的网站上输入我的 Gmail 密码，然后 Gmail

88
00:04:02,519 --> 00:04:08,190
会向我显示我的电子邮件，而

89
00:04:08,190 --> 00:04:10,530
不会出于安全考虑这个系统

90
00:04:10,530 --> 00:04:12,629
实际上很容易受到攻击，

91
00:04:12,629 --> 00:04:18,120
结果也很容易受到攻击，而且 一种

92
00:04:18,120 --> 00:04:19,680
攻击方式是

93
00:04:19,680 --> 00:04:21,630
所谓的中间人攻击，其中一些邪恶的

94
00:04:21,630 --> 00:04:25,830
人设置了另一个网络服务器，该服务器

95
00:04:25,830 --> 00:04:28,560
提供的页面看起来就像 Gmail

96
00:04:28,560 --> 00:04:30,240
网络服务器一样，最后一个是您的登录名

97
00:04:30,240 --> 00:04:34,500
和密码，然后是攻击者

98
00:04:34,500 --> 00:04:39,120
可能会拦截我的 DNS 数据包，或者

99
00:04:39,120 --> 00:04:41,699
只是猜测我什么时候会发送一个 DNS

100
00:04:41,699 --> 00:04:43,830
数据包并提出一个虚假的回复

101
00:04:43,830 --> 00:04:47,250
，而不是提供真实 gmail.com 服务器的真实 IP 地址，而是

102
00:04:47,250 --> 00:04:49,889
 

103
00:04:49,889 --> 00:04:52,110
提供攻击者假冒的 ma 的电子邮件地址

104
00:04:52,110 --> 00:04:54,510
合作 mputer 然后

105
00:04:54,510 --> 00:04:56,880
用户的浏览器而不是与

106
00:04:56,880 --> 00:05:00,660
Gmail 交谈实际上他们不知道

107
00:05:00,660 --> 00:05:02,220
正在与攻击者的计算机交谈

108
00:05:02,220 --> 00:05:04,020
攻击者的计算机将提供一个

109
00:05:04,020 --> 00:05:05,729
网页看起来就像一个登录页面用户

110
00:05:05,729 --> 00:05:08,520
类型是路径日志和密码

111
00:05:08,520 --> 00:05:11,849
现在攻击者的计算机可以 将

112
00:05:11,849 --> 00:05:14,099
其转发到真正的 Gmail 登录，

113
00:05:14,099 --> 00:05:16,289
当然您不知道您知道

114
00:05:16,289 --> 00:05:18,810
将当前收件箱返回到攻击者

115
00:05:18,810 --> 00:05:20,490
计算机，攻击者计算机可能会将其

116
00:05:20,490 --> 00:05:22,680
与您的密码一起记录，然后将

117
00:05:22,680 --> 00:05:24,750
您的收件箱或其他任何内容发送到浏览器

118
00:05:24,750 --> 00:05:28,260
，这允许 你知道如果你可以

119
00:05:28,260 --> 00:05:29,340
执行这种中间人

120
00:05:29,340 --> 00:05:32,639
攻击，攻击者的计算机可以记录

121
00:05:32,639 --> 00:05:34,440
你的密码记录你的电子邮件，

122
00:05:34,440 --> 00:05:35,580
你永远不会更聪明

123
00:05:35,580 --> 00:05:36,780
，

124
00:05:36,780 --> 00:05:40,560
在 SSL 和 HTTPS 证书之前

125
00:05:40,560 --> 00:05:42,530
，这个妈妈真的没有防御

126
00:05:42,530 --> 00:05:46,260
好的，所以这是

127
00:05:46,260 --> 00:05:48,240
中间人攻击，这里的攻击者

128
00:05:48,240 --> 00:05:50,910
是中间人

129
00:05:50,910 --> 00:05:53,280
，在浏览器看来就像 Gmail 一样

130
00:05:53,280 --> 00:05:54,900
，在与 Gmail 交谈时假装是用户，所以 它

131
00:05:54,900 --> 00:05:57,630
实际上可以从 Gmail 中获取所需的信息，

132
00:05:57,630 --> 00:05:59,070
以欺骗用户

133
00:05:59,070 --> 00:06:01,260
认为它真的是 Gmail

134
00:06:01,260 --> 00:06:05,940
 

135
00:06:05,940 --> 00:06:11,280
 

136
00:06:11,280 --> 00:06:14,070
 

137
00:06:14,070 --> 00:06:15,930
 

138
00:06:15,930 --> 00:06:20,990
当您使用 HTTPS 链接时，您正在使用

139
00:06:20,990 --> 00:06:24,120
的游戏是，Gmail 通信

140
00:06:24,120 --> 00:06:28,880
将有一个公钥/私钥对，

141
00:06:28,880 --> 00:06:34,160
因此我们将拥有一个只有

142
00:06:34,160 --> 00:06:38,280
Gmail 知道的私钥，它位于其服务器中，

143
00:06:38,280 --> 00:06:41,790
然后当您连接良好时 你的用户

144
00:06:41,790 --> 00:06:44,430
你连接到某个地方你要求连接

145
00:06:44,430 --> 00:06:48,510
到 Gmail 你知道并且为了

146
00:06:48,510 --> 00:06:50,400
验证你真的在和 Gmail 交谈

147
00:06:50,400 --> 00:06:52,590
用户会要求 Gmail 证明

148
00:06:52,590 --> 00:06:55,140
它确实拥有 Gmail 当然是私钥

149
00:06:55,140 --> 00:06:55,860
 

150
00:06:55,860 --> 00:06:58,620
你的浏览器在哪里找到 out Gmail

151
00:06:58,620 --> 00:07:01,050
是来自您的 Gmail 公钥的

152
00:07:01,050 --> 00:07:03,870
私钥，您需要检查它

153
00:07:03,870 --> 00:07:05,340
是否真的有私钥

154
00:07:05,340 --> 00:07:07,830
还有证书

155
00:07:07,830 --> 00:07:09,390
颁发机构和证书的概念，所以

156
00:07:09,390 --> 00:07:11,910
会有证书颁发机构 当 Gmail

157
00:07:11,910 --> 00:07:14,729
设置其服务器时，它

158
00:07:14,729 --> 00:07:15,960
可能会通过

159
00:07:15,960 --> 00:07:17,310
电话或电子邮件或其他方式联系证书颁发机构，并说

160
00:07:17,310 --> 00:07:19,370
你知道我想要

161
00:07:19,370 --> 00:07:24,000
DNS 名称 gmail.com 的

162
00:07:24,000 --> 00:07:25,979
证书，证书颁发机构会

163
00:07:25,979 --> 00:07:28,169
尝试验证哦 是的，

164
00:07:28,169 --> 00:07:30,419
请求证书的人确实拥有该名称，

165
00:07:30,419 --> 00:07:32,130
它确实是 Google 或拥有

166
00:07:32,130 --> 00:07:35,280
gmail.com 的人，如果是这样，证书

167
00:07:35,280 --> 00:07:38,750
颁发机构

168
00:07:39,350 --> 00:07:40,840
将向 gee

169
00:07:40,840 --> 00:07:43,090
komm 提供证书，该证书基本上

170
00:07:43,090 --> 00:07:50,010
包含的内容是 Web 服务器的名称

171
00:07:50,010 --> 00:07:57,120
Web 服务器公开 密钥和使用

172
00:07:57,120 --> 00:08:01,780
证书

173
00:08:01,780 --> 00:08:04,540
颁发机构私钥制作的证书上的签名，

174
00:08:04,540 --> 00:08:08,040
因此这是一种自包含的

175
00:08:08,040 --> 00:08:11,080
断言，可通过检查签名来检查

176
00:08:11,080 --> 00:08:12,220
 

177
00:08:12,220 --> 00:08:15,310
证书颁发机构的断言，即

178
00:08:15,310 --> 00:08:18,220
gmail.com 的公钥实际上是该

179
00:08:18,220 --> 00:08:21,340
公钥 gmail。 如果您使用 HTTPS 连接到 gmail.com 服务器，我会保留

180
00:08:21,340 --> 00:08:23,490
一份证书的副本吗？

181
00:08:23,490 --> 00:08:27,010
 

182
00:08:27,010 --> 00:08:28,210
它所做的第一件事就是将这个证书发回给您

183
00:08:28,210 --> 00:08:32,169
cate 在这一点上当然只是一个

184
00:08:32,169 --> 00:08:33,429
证书，因为

185
00:08:33,429 --> 00:08:35,140
gmail.com 愿意将它提供给

186
00:08:35,140 --> 00:08:37,510
任何人它是证书本身并

187
00:08:37,510 --> 00:08:38,979
没有怀孕它是非常公开的

188
00:08:38,979 --> 00:08:42,820
，然后浏览器会发送一些

189
00:08:42,820 --> 00:08:44,560
信息，例如随机数

190
00:08:44,560 --> 00:08:48,730
到 服务器并要求

191
00:08:48,730 --> 00:08:53,350
它使用其私钥对其进行签名，然后

192
00:08:53,350 --> 00:08:55,089
浏览器可以使用

193
00:08:55,089 --> 00:08:57,790
证书中的公钥检查随机

194
00:08:57,790 --> 00:08:59,200
数是否已运行并记住确实是

195
00:08:59,200 --> 00:09:02,680
由与证书中的公钥相关联的私钥签名的，

196
00:09:02,680 --> 00:09:04,000
 

197
00:09:04,000 --> 00:09:05,980
并且 因此，与

198
00:09:05,980 --> 00:09:08,800
它交谈的人实际上是

199
00:09:08,800 --> 00:09:10,510
证书颁发机构认为

200
00:09:10,510 --> 00:09:14,140
是 gmail.com 的实体，现在

201
00:09:14,140 --> 00:09:15,279
这

202
00:09:15,279 --> 00:09:17,350
使得中间人攻击更加困难的原因是，是的，你

203
00:09:17,350 --> 00:09:20,950
知道你可以设置一个流氓服务器 这

204
00:09:20,950 --> 00:09:23,560
看起来就像 Gmail 一样平静，也许你

205
00:09:23,560 --> 00:09:25,420
甚至可以破解 DNS 系统，

206
00:09:25,420 --> 00:09:27,940
如果你足够聪明，你仍然可以

207
00:09:27,940 --> 00:09:32,380
破解 DNS 系统，告诉

208
00:09:32,380 --> 00:09:34,390
人们的浏览器哦，他们应该这样做 ld

209
00:09:34,390 --> 00:09:36,940
去你的服务器而不是gmail.com，但是

210
00:09:36,940 --> 00:09:38,980
一旦有人的浏览器联系你的

211
00:09:38,980 --> 00:09:40,000
服务器，

212
00:09:40,000 --> 00:09:42,040
你可能

213
00:09:42,040 --> 00:09:46,120
无法生成一个证书，但

214
00:09:46,120 --> 00:09:47,890
你可以生成Gmail证书，

215
00:09:47,890 --> 00:09:50,170
但是Gmail证书作为

216
00:09:50,170 --> 00:09:51,760
你的服务器的Gmail的公钥 '没有

217
00:09:51,760 --> 00:09:53,820
他们的私钥，因此您可以

218
00:09:53,820 --> 00:09:55,550
签署浏览器发送给您的挑战，

219
00:09:55,550 --> 00:09:58,320
并且可能因为您不是真正的

220
00:09:58,320 --> 00:10:01,170
谷歌而不是真正的 Gmail，您

221
00:10:01,170 --> 00:10:01,920
将无法说服

222
00:10:01,920 --> 00:10:03,450
证书颁发机构给您一个

223
00:10:03,450 --> 00:10:06,660
证书关联 gmail comm 与

224
00:10:06,660 --> 00:10:10,890
您的公钥进行通信，因此该

225
00:10:10,890 --> 00:10:11,790
证书方案使

226
00:10:11,790 --> 00:10:13,050
中间人攻击变得

227
00:10:13,050 --> 00:10:14,700
更加困难，而且您确实知道，

228
00:10:14,700 --> 00:10:16,680
由于

229
00:10:16,680 --> 00:10:21,810
证书还可以，因此它们现在确实更加困难，因此结果

230
00:10:21,810 --> 00:10:24,960
证明证书方案 因为人们

231
00:10:24,960 --> 00:10:27,680
现在有很多经验，

232
00:10:27,680 --> 00:10:30,510
近 25 年的经验，所以我们

233
00:10:30,510 --> 00:10:32,550
现在知道有些事情

234
00:10:32,550 --> 00:10:34,560
出了问题，最初

235
00:10:34,560 --> 00:10:35,810
认为只会有一个 cou 许多

236
00:10:35,810 --> 00:10:38,460
值得信赖的证书颁发机构

237
00:10:38,460 --> 00:10:40,170
会很好地检查该

238
00:10:40,170 --> 00:10:42,570
请求是否真的来自他们

239
00:10:42,570 --> 00:10:43,860
声称

240
00:10:43,860 --> 00:10:45,270
 

241
00:10:45,270 --> 00:10:46,950
 

242
00:10:46,950 --> 00:10:49,260
 

243
00:10:49,260 --> 00:10:50,520
来自的人 gmail.com

244
00:10:50,520 --> 00:10:53,490
并且不会将证书分发给

245
00:10:53,490 --> 00:10:57,600
gmail comp 的随机人员，但事实证明这

246
00:10:57,600 --> 00:11:00,210
对谷歌来说非常具有挑战性，

247
00:11:00,210 --> 00:11:02,910
也许你可以说服这个证书

248
00:11:02,910 --> 00:11:04,620
颁发机构可以说服自己一个

249
00:11:04,620 --> 00:11:06,450
请求来自谷歌，但你知道

250
00:11:06,450 --> 00:11:09,780
对于 XCOM 这很难 拥有一个

251
00:11:09,780 --> 00:11:11,670
可靠的证书颁发机构可以

252
00:11:11,670 --> 00:11:14,100
说哦，是的，天哪，这个请求真的

253
00:11:14,100 --> 00:11:16,200
来自真正

254
00:11:16,200 --> 00:11:20,700
拥有 DMS 名称 XCOM 的人，好吧，更糟糕的

255
00:11:20,700 --> 00:11:23,640
问题是，虽然最初

256
00:11:23,640 --> 00:11:25,050
他们的设想是只有少数

257
00:11:25,050 --> 00:11:26,370
证书颁发机构有 现在有

258
00:11:26,370 --> 00:11:28,140
数百个证书

259
00:11:28,140 --> 00:11:30,810
颁发机构，任何

260
00:11:30,810 --> 00:11:33,150
证书颁发机构都可

261
00:11:33,150 --> 00:11:38,070
以为任何名称生成证书 d 确实可能

262
00:11:38,070 --> 00:11:39,480
希望您被允许更改

263
00:11:39,480 --> 00:11:40,950
证书颁发机构，如果您是

264
00:11:40,950 --> 00:11:42,990
网站所有者，您可以将证书

265
00:11:42,990 --> 00:11:46,590
颁发机构更改为您喜欢的

266
00:11:46,590 --> 00:11:48,090
任何人，因此证书颁发

267
00:11:48,090 --> 00:11:49,380
机构对其权力有限制是没有意义的，

268
00:11:49,380 --> 00:11:51,720
任何证书颁发机构都可以

269
00:11:51,720 --> 00:11:56,430
产生任何 证书，现在浏览器

270
00:11:56,430 --> 00:11:57,780
让你知道有几百个

271
00:11:57,780 --> 00:11:59,310
证书颁发机构，这

272
00:11:59,310 --> 00:12:00,900
意味着每个浏览器都像 Chrome 或 Firefox 一样内置在其中，

273
00:12:00,900 --> 00:12:03,210
或者在其中

274
00:12:03,210 --> 00:12:05,490
内置了所有证书的公钥列表

275
00:12:05,490 --> 00:12:07,320
所有几百个

276
00:12:07,320 --> 00:12:09,690
良好的权威和 如果他们中的任何一个签名

277
00:12:09,690 --> 00:12:11,370
已签署由网络服务器生成的

278
00:12:11,370 --> 00:12:16,440
证书证书可接受

279
00:12:16,440 --> 00:12:18,840
，则结果

280
00:12:18,840 --> 00:12:21,180
是证书颁发机构多次生成伪造证书的事件，这些证书

281
00:12:21,180 --> 00:12:23,550
 

282
00:12:23,550 --> 00:12:27,090
生成的证书表明

283
00:12:27,090 --> 00:12:28,770
它们是 Google 或

284
00:12:28,770 --> 00:12:31,830
Gmail 或其他一些真实公司的证书

285
00:12:31,830 --> 00:12:34,170
但实际上是发给

286
00:12:34,170 --> 00:12:37,770
别人的，绝对没有发给其他人的证书 吃

287
00:12:37,770 --> 00:12:40,770
了谷歌的一个名字，但没有

288
00:12:40,770 --> 00:12:44,420
发给谷歌，发给别人

289
00:12:44,420 --> 00:12:47,850
，你知道有时这

290
00:12:47,850 --> 00:12:50,040
只是错误地发生，因为上级当局

291
00:12:50,040 --> 00:12:52,470
没有意识到他们

292
00:12:52,470 --> 00:12:53,880
做错了事，有时它实际上是

293
00:12:53,880 --> 00:12:55,080
非常恶意的，我的意思是有

294
00:12:55,080 --> 00:12:57,630
肯定是颁发给

295
00:12:57,630 --> 00:12:59,880
那些只想窥探

296
00:12:59,880 --> 00:13:01,200
人们的交通并

297
00:13:01,200 --> 00:13:02,760
发动中间人攻击的人的证书，以及

298
00:13:02,760 --> 00:13:05,550
山人中间的攻击今天的

299
00:13:05,550 --> 00:13:07,740
读数提到了其中一些

300
00:13:07,740 --> 00:13:09,960
事件，它们特别

301
00:13:09,960 --> 00:13:12,120
令人不安，因为它们是 很难

302
00:13:12,120 --> 00:13:13,920
防止，因为有这么多的

303
00:13:13,920 --> 00:13:15,540
证书颁发机构，而不是全部，

304
00:13:15,540 --> 00:13:16,970
 

305
00:13:16,970 --> 00:13:19,410
虽然抱歉，最后一个问题

306
00:13:19,410 --> 00:13:21,300
是最后一行插入框，它是

307
00:13:21,300 --> 00:13:23,520
 

308
00:13:23,520 --> 00:13:25,740
先生提示使用证书

309
00:13:25,740 --> 00:13:27,690
颁发机构使用证书

310
00:13:27,690 --> 00:13:32,010
颁发机构私钥对证书的签名，好吧，所以那里

311
00:13:32,010 --> 00:13:33,600
 

312
00:13:33,600 --> 00:13:35,610
 

313
00:13:35,610 --> 00:13:38,370
像谷歌这样的真实网站的伪造证书事件已经发给了

314
00:13:38,370 --> 00:13:40,140
完全错误的人 并且这些证书

315
00:13:40,140 --> 00:13:43,620
已被滥用，目前尚不清楚

316
00:13:43,620 --> 00:13:45,450
如何修复证书颁发机构系统

317
00:13:45,450 --> 00:13:47,970
本身以防止它们，因为有

318
00:13:47,970 --> 00:13:50,910
这么多证书颁发机构，它们

319
00:13:50,910 --> 00:13:54,210
真的你不能指望

320
00:13:54,210 --> 00:13:55,670
它们会完全可靠，

321
00:13:55,670 --> 00:14:00,540
所以我们能做些什么 关于这种

322
00:14:00,540 --> 00:14:03,240
可能性的一种可能性是拥有一个

323
00:14:03,240 --> 00:14:05,250
包含所有有效证书的单一在线数据库，

324
00:14:05,250 --> 00:14:07,950
这样当

325
00:14:07,950 --> 00:14:09,840
您知道浏览器

326
00:14:09,840 --> 00:14:11,370
Comcast 网站的浏览器提交您知道

327
00:14:11,370 --> 00:14:13,620
可能有效或可能有效的证书时，您

328
00:14:13,620 --> 00:14:15,750
可能会想象浏览器会

329
00:14:15,750 --> 00:14:18,630
联系全球 有效的证书数据库

330
00:14:18,630 --> 00:14:20,560
ins 化验 这确实是证书

331
00:14:20,560 --> 00:14:24,220
由行证书颁发机构颁发的伪造证书

332
00:14:24,220 --> 00:14:28,060
嗯，

333
00:14:28,060 --> 00:14:32,470
问题在于这种方法的问题很多

334
00:14:32,470 --> 00:14:36,340
 

335
00:14:36,340 --> 00:14:38,860
 

336
00:14:38,860 --> 00:14:40,330
 

337
00:14:40,330 --> 00:14:42,610
您只是

338
00:14:42,610 --> 00:14:44,800
不知道 DNS 名称的正确所有者是谁，

339
00:14:44,800 --> 00:14:47,680
而且您需要

340
00:14:47,680 --> 00:14:49,390
允许证书 通知所有者更改

341
00:14:49,390 --> 00:14:51,339
证书颁发机构或更新他们的

342
00:14:51,339 --> 00:14:52,779
证书，否则他们可能会丢失他们的

343
00:14:52,779 --> 00:14:54,660
私钥并需要一个新证书

344
00:14:54,660 --> 00:14:57,190
来替换他们的旧证书，因为

345
00:14:57,190 --> 00:15:00,610
使用新的公钥/私钥对所以

346
00:15:00,610 --> 00:15:02,140
人们的证书一直在

347
00:15:02,140 --> 00:15:05,830
变化，最终即使在技术上或

348
00:15:05,830 --> 00:15:07,600
有可能区分正确的

349
00:15:07,600 --> 00:15:10,240
证书和伪造的证书

350
00:15:10,240 --> 00:15:12,070
没有人人会

351
00:15:12,070 --> 00:15:14,500
信任的实体你认识

352
00:15:14,500 --> 00:15:15,940
世界上的每个人你认识的中国人

353
00:15:15,940 --> 00:15:18,640
伊朗人你认识的美国人

354
00:15:18,640 --> 00:15:21,550
没有任何一家他们都信任的机构

355
00:15:21,550 --> 00:15:23,890
，这就是为什么 有

356
00:15:23,890 --> 00:15:26,140
这么多的证书颁发机构，所以我们

357
00:15:26,140 --> 00:15:29,500
真的不能，你真的不能指望

358
00:15:29,500 --> 00:15:31,720
有一个单一的票据交换所可以

359
00:15:31,720 --> 00:15:33,970
准确地区分有效

360
00:15:33,970 --> 00:15:38,050
和无效的证书，但是

361
00:15:38,050 --> 00:15:40,060
证书颁发机构证书

362
00:15:40,060 --> 00:15:42,160
透明度所做的

363
00:15:42,160 --> 00:15:47,560
基本上是尽量不要做到

364
00:15:47,560 --> 00:15:51,370
最好 有可能你知道

365
00:15:51,370 --> 00:15:54,520
它可以迈向holid tr数据库的最长步骤吗

366
00:15:54,520 --> 00:15:59,710
值得信赖的证书，所以现在

367
00:15:59,710 --> 00:16:02,050
我要概述

368
00:16:02,050 --> 00:16:04,180
证书透明度的一般策略

369
00:16:04,180 --> 00:16:10,930
证书透明度的风格

370
00:16:10,930 --> 00:16:13,120
是它是一个审计

371
00:16:13,120 --> 00:16:18,670
系统，因为很难甚至

372
00:16:18,670 --> 00:16:21,040
不可能仅仅决定这个

373
00:16:21,040 --> 00:16:23,230
人是否拥有一个证书

374
00:16:23,230 --> 00:16:25,000
透明度的名称 t 建立一个

375
00:16:25,000 --> 00:16:27,250
防止坏事发生的系统，

376
00:16:27,250 --> 00:16:29,770
这将要求您能够立即

377
00:16:29,770 --> 00:16:32,819
检测到

378
00:16:32,819 --> 00:16:35,059
证书是伪造的，而不是

379
00:16:35,059 --> 00:16:37,169
证书透明度将

380
00:16:37,169 --> 00:16:42,720
启用审计，这将是一个

381
00:16:42,720 --> 00:16:44,819
导致所有信息的系统

382
00:16:44,819 --> 00:16:47,039
公开，以便

383
00:16:47,039 --> 00:16:49,319
关心它的人可以检查它，如果

384
00:16:49,319 --> 00:16:51,329
你认识的人，它仍然允许

385
00:16:51,329 --> 00:16:53,579
人们签发伪造的证书，但

386
00:16:53,579 --> 00:16:55,910
它会确保这些证书是

387
00:16:55,910 --> 00:16:58,379
公开的，每个人都可以看到它们，

388
00:16:58,379 --> 00:17:01,289
包括拥有它的人

389
00:17:01,289 --> 00:17:06,269
假证书中的名称

390
00:17:06,269 --> 00:17:07,949
，因此这

391
00:17:07,949 --> 00:17:10,319
解决了证书前

392
00:17:10,319 --> 00:17:12,388
透明系统的问题，其中证书

393
00:17:12,388 --> 00:17:13,500
当局可以颁发伪造的

394
00:17:13,500 --> 00:17:15,990
证书，而没有人知道

395
00:17:15,990 --> 00:17:19,230
，他们甚至可以将它们提供给

396
00:17:19,230 --> 00:17:21,059
受害者一些会被他们欺骗的受害者浏览器

397
00:17:21,059 --> 00:17:23,069
，但由于

398
00:17:23,069 --> 00:17:24,919
证书通常不公开，

399
00:17:24,919 --> 00:17:28,230
他们可能有人可以证书

400
00:17:28,230 --> 00:17:30,090
颁发机构可以颁发伪造的证书

401
00:17:30,090 --> 00:17:32,460
为 Google 或 Microsoft 和 Google 的任何人提供证书

402
00:17:32,460 --> 00:17:34,289
微软可能

403
00:17:34,289 --> 00:17:35,879
永远不会意识到这一点，并且已经曝光的事件

404
00:17:35,879 --> 00:17:37,139
通常

405
00:17:37,139 --> 00:17:41,490
只是偶然发现的，而不是因为

406
00:17:41,490 --> 00:17:43,259
它们注定要被

407
00:17:43,259 --> 00:17:46,220
发现，而不是依靠

408
00:17:46,220 --> 00:17:48,059
偶然发现假

409
00:17:48,059 --> 00:17:50,549
证书证书

410
00:17:50,549 --> 00:17:51,840
透明度将迫使他们

411
00:17:51,840 --> 00:17:54,330
进入光明，在那里他们更容易

412
00:17:54,330 --> 00:17:57,389
再次注意到他们，因此它具有某种

413
00:17:57,389 --> 00:17:59,730
审计风格或 nada 不是预防

414
00:17:59,730 --> 00:18:04,289
风格好吧，所以基本结构再次

415
00:18:04,289 --> 00:18:08,639
我们有 gmail.com 或其他一些

416
00:18:08,639 --> 00:18:11,100
服务 像往常一样想要证书，

417
00:18:11,100 --> 00:18:12,659
他们会向

418
00:18:12,659 --> 00:18:15,539
数百个 CAS 中的某个人索要证书，什么

419
00:18:15,539 --> 00:18:18,299
时候什么时候 e cert web 服务器首先

420
00:18:18,299 --> 00:18:21,779
设置，所以我们要请求一个证书

421
00:18:21,779 --> 00:18:23,759
，证书颁发机构会将

422
00:18:23,759 --> 00:18:26,820
这个证书发送回 web 服务器，

423
00:18:26,820 --> 00:18:28,110
因为当然是 web 服务器

424
00:18:28,110 --> 00:18:32,159
向浏览器提供证书，

425
00:18:32,159 --> 00:18:34,590
同时通过 证书

426
00:18:34,590 --> 00:18:36,210
颁发机构会将

427
00:18:36,210 --> 00:18:41,100
证书副本或等效信息发送

428
00:18:41,100 --> 00:18:43,179
到排序

429
00:18:43,179 --> 00:18:46,570
透明视频日志服务器那里将

430
00:18:46,570 --> 00:18:48,599
是真实系统有多个

431
00:18:48,599 --> 00:18:50,799
独立证书透明

432
00:18:50,799 --> 00:18:52,629
日志服务器我可以假设只有

433
00:18:52,629 --> 00:18:55,029
一个所以这是一些你

434
00:18:55,029 --> 00:18:56,619
知道我们不知道的服务 事实证明，我们

435
00:18:56,619 --> 00:19:00,309
不必信任证书

436
00:19:00,309 --> 00:19:01,839
颁发机构会将其证书发送到

437
00:19:01,839 --> 00:19:04,839
该证书日志服务，该服务

438
00:19:04,839 --> 00:19:08,649
一直在维护所有已颁发

439
00:19:08,649 --> 00:19:10,629
证书或

440
00:19:10,629 --> 00:19:12,129
证书颁发机构

441
00:19:12,129 --> 00:19:13,419
在获得新证书时告诉

442
00:19:13,419 --> 00:19:17,529
它的所有证书的日志 会把它附加到它的日志中，这样

443
00:19:17,529 --> 00:19:18,669
你就知道

444
00:19:18,669 --> 00:19:22,229
过了一会儿，

445
00:19:22,229 --> 00:19:26,049
当浏览器和一些 人类想与

446
00:19:26,049 --> 00:19:29,739
他们知道的网站交谈，他们

447
00:19:29,739 --> 00:19:32,559
确实建立了与 Gmail 的 HTTPS 连接

448
00:19:32,559 --> 00:19:33,969
Gmail 向他们发送

449
00:19:33,969 --> 00:19:38,889
证书，浏览器会将该

450
00:19:38,889 --> 00:19:40,450
证书发送到证书日志

451
00:19:40,450 --> 00:19:42,940
服务器看看这个证书在

452
00:19:42,940 --> 00:19:46,389
日志中有困难的日志服务器会

453
00:19:46,389 --> 00:19:48,339
说是或否是他们

454
00:19:48,339 --> 00:19:50,529
现在在日志中的证书，如果是，那么

455
00:19:50,529 --> 00:19:53,889
浏览器将继续并现在使用它

456
00:19:53,889 --> 00:19:55,509
事实上它在日志中你知道

457
00:19:55,509 --> 00:19:56,889
并不意味着它不是假的，

458
00:19:56,889 --> 00:19:58,659
因为任何证书颁发机构

459
00:19:58,659 --> 00:20:00,789
包括那些

460
00:20:00,789 --> 00:20:03,369
存在恶意或运行不良的情况，任何

461
00:20:03,369 --> 00:20:06,489
证书颁发机构都可以将

462
00:20:06,489 --> 00:20:09,450
证书插入日志系统，

463
00:20:09,450 --> 00:20:13,299
因此可能会诱骗用户使用

464
00:20:13,299 --> 00:20:14,589
它，因此到目前为止，我们还没有构建一个

465
00:20:14,589 --> 00:20:20,049
防止滥用的系统，但是

466
00:20:20,049 --> 00:20:22,509
在没有浏览器的情况下

467
00:20:22,509 --> 00:20:25,359
除非它在日志中，否则将使用证书，因此

468
00:20:25,359 --> 00:20:29,409
同时 gmail 将

469
00:20:29,409 --> 00:20:34,649
运行 CT 系统调用监视器，

470
00:20:34,649 --> 00:20:36,070
 

471
00:20:36,070 --> 00:20:37,300
现在假设有一个监视器

472
00:20:37,300 --> 00:20:39,790
关联 w 在每个网站上，因此此

473
00:20:39,790 --> 00:20:44,290
监视器还会定期与

474
00:20:44,290 --> 00:20:47,410
证书日志服务器

475
00:20:47,410 --> 00:20:49,150
 

476
00:20:49,150 --> 00:20:51,130
 

477
00:20:51,130 --> 00:20:52,540
 

478
00:20:52,540 --> 00:20:54,280
进行对话

479
00:20:54,280 --> 00:20:55,810
监视器将建立起来，

480
00:20:55,810 --> 00:20:58,120
它将知道日志中的每个

481
00:20:58,120 --> 00:21:00,250
证书都足够了

482
00:21:00,250 --> 00:21:03,070
，而且由于监视器

483
00:21:03,070 --> 00:21:05,560
与 Gmail 相关联，监视器

484
00:21:05,560 --> 00:21:10,000
知道 Gmail 的正确证书是什么，所以

485
00:21:10,000 --> 00:21:12,130
如果一些流氓证书颁发机构

486
00:21:12,130 --> 00:21:14,350
问题 Gmail 的证书它

487
00:21:14,350 --> 00:21:18,370
不是 Gmail 本身要求的，然后

488
00:21:18,370 --> 00:21:20,980
Gmail 的监视器会

489
00:21:20,980 --> 00:21:24,880
在证书日志中偶然发现它，因为 Gmail 的

490
00:21:24,880 --> 00:21:26,590
监视器现在知道 Gmail 的正确

491
00:21:26,590 --> 00:21:29,470
证书当然流氓

492
00:21:29,470 --> 00:21:30,910
证书颁发机构不必

493
00:21:30,910 --> 00:21:32,770
将其证书发送到证书

494
00:21:32,770 --> 00:21:34,150
日志 系统，但在这种情况下，当

495
00:21:34,150 --> 00:21:37,390
您知道的浏览器可能意外

496
00:21:37,390 --> 00:21:40,930
连接到攻击者的 Web 服务器

497
00:21:40,930 --> 00:21:42,310
并且攻击者会刷 rver 给

498
00:21:42,310 --> 00:21:43,780
他们假证书，如果他们

499
00:21:43,780 --> 00:21:45,790
没有把它放在日志中，那么

500
00:21:45,790 --> 00:21:47,440
浏览器不会相信它并会

501
00:21:47,440 --> 00:21:48,850
中止连接这不是因为它

502
00:21:48,850 --> 00:21:49,660
不在日志中

503
00:21:49,660 --> 00:21:53,440
所以日志有点强制，因为

504
00:21:53,440 --> 00:21:55,540
浏览器需要证书作为

505
00:21:55,540 --> 00:21:58,000
日志 该日志强制所有

506
00:21:58,000 --> 00:22:00,250
证书公开，可以

507
00:22:00,250 --> 00:22:03,850
由知道我们的

508
00:22:03,850 --> 00:22:05,890
正确证书的监视器审核和检查它们，因此一些

509
00:22:05,890 --> 00:22:07,630
监视器由大公司运行，并且

510
00:22:07,630 --> 00:22:10,390
公司知道他们自己的证书

511
00:22:10,390 --> 00:22:12,520
一些监视器由证书

512
00:22:12,520 --> 00:22:14,080
颁发机构代表他们运行 客户

513
00:22:14,080 --> 00:22:15,820
和那些证书颁发机构再次

514
00:22:15,820 --> 00:22:17,500
知道他们已经向他们的客户颁发了哪些证书，

515
00:22:17,500 --> 00:22:19,360
 

516
00:22:19,360 --> 00:22:21,160
如果他们看到

517
00:22:21,160 --> 00:22:23,560
他们没有为他们的一个客户名称颁发的证书，他们至少可以提醒他们的客户

518
00:22:23,560 --> 00:22:26,140
我另外

519
00:22:26,140 --> 00:22:28,600
还有一些完全是第三个- 第三方监控

520
00:22:28,600 --> 00:22:30,760
系统，您可以在其中向第三方

521
00:22:30,760 --> 00:22:34,180
监控您的姓名和您的姓名以及您的

522
00:22:34,180 --> 00:22:37,020
有效证书，并

523
00:22:37,020 --> 00:22:41,360
检查您的 na 的预期证书

524
00:22:41,360 --> 00:22:47,130
好吧，这是整体方案，但

525
00:22:47,130 --> 00:22:51,660
它在很大程度上取决于浏览器看到

526
00:22:51,660 --> 00:22:54,660
与监视器看到的完全相同的日志内容

527
00:22:54,660 --> 00:22:59,130
，但请记住，我们遇到了

528
00:22:59,130 --> 00:23:00,630
这个问题，我们不确定我们是否

529
00:23:00,630 --> 00:23:02,400
可以信任这个系统中的任何组件，

530
00:23:02,400 --> 00:23:04,470
所以确实我们 发现这个证书

531
00:23:04,470 --> 00:23:06,270
颁发机构中的一些是恶意的，

532
00:23:06,270 --> 00:23:07,950
或者有无法信任的员工

533
00:23:07,950 --> 00:23:11,010
或马虎且不遵守规则的员工，

534
00:23:11,010 --> 00:23:13,080
所以我们

535
00:23:13,080 --> 00:23:14,790
假设我们必须假设

536
00:23:14,790 --> 00:23:16,650
证书日志服务器也是如此

537
00:23:16,650 --> 00:23:18,660
他们中的一些人是恶意的 他们中的一些人可能

538
00:23:18,660 --> 00:23:21,720
与流氓证书

539
00:23:21,720 --> 00:23:23,130
颁发机构合谋并故意试图

540
00:23:23,130 --> 00:23:27,840
帮助他们颁发伪造证书 其中

541
00:23:27,840 --> 00:23:29,850
一些人可能草率 其中一些可能

542
00:23:29,850 --> 00:23:31,650
是合法的，但也许他们的一些

543
00:23:31,650 --> 00:23:33,990
员工或腐败 你付钱

544
00:23:33,990 --> 00:23:36,390
给他们 贿赂所以我会对日志做一些

545
00:23:36,390 --> 00:23:38,100
有趣的事情删除一些东西或添加

546
00:23:38,100 --> 00:23:41,100
一些东西所以我们需要

547
00:23:41,100 --> 00:23:43,080
构建一个日志，即使日志

548
00:23:43,080 --> 00:23:47,160
操作员可能不合作也不

549
00:23:47,160 --> 00:23:50,280
信任 为什么我们仍然可以确定或

550
00:23:50,280 --> 00:23:52,370
至少知道

551
00:23:52,370 --> 00:23:54,780
浏览器是否看到与监视器相同的日志竞赛

552
00:23:54,780 --> 00:23:56,910
，所以如果我们的浏览器使用

553
00:23:56,910 --> 00:23:59,760
日志中的证书

554
00:23:59,760 --> 00:24:01,470
，拥有该名称的监视器

555
00:24:01,470 --> 00:24:05,880
最终会看到它，所以我们 需要做的

556
00:24:05,880 --> 00:24:13,590
是我们需要构建一个仅附加的日志系统，

557
00:24:13,590 --> 00:24:16,920
以便它无法

558
00:24:16,920 --> 00:24:20,340
向浏览器显示证书，然后

559
00:24:20,340 --> 00:24:24,200
在监视器看到它之前将其删除，因此仅附加

560
00:24:27,110 --> 00:24:28,950
没有

561
00:24:28,950 --> 00:24:33,840
我们不想要的分叉 日志

562
00:24:33,840 --> 00:24:36,180
系统基本上保留两个日志，其中一个

563
00:24:36,180 --> 00:24:38,910
显示两个浏览器，

564
00:24:38,910 --> 00:24:41,880
一个显示两个监视器，因此我们不需要

565
00:24:41,880 --> 00:24:53,550
分叉，我们需要不受信任我们无法

566
00:24:53,550 --> 00:24:56,970
确定证书服务器是否

567
00:24:56,970 --> 00:25:02,210
正确，因此只需备份一下

568
00:25:02,210 --> 00:25:05,700
我们需要的日志

569
00:25:05,700 --> 00:25:08,520
系统的关键属性不仅仅是一个日志服务器，

570
00:25:08,520 --> 00:25:10,950
而是整个日志服务器系统

571
00:25:10,950 --> 00:25:14,040
加上各种检查，我们必须

572
00:25:14,040 --> 00:25:16,670
防止删除，即我们

573
00:25:16,670 --> 00:25:19,800
只需要附加日志，因为如果日志

574
00:25:19,800 --> 00:25:24,420
服务器可以 然后从其日志中删除项目

575
00:25:24,420 --> 00:25:26,880
他们可以在很长一段时间内有效地

576
00:25:26,880 --> 00:25:29,400
向浏览器索赔人显示伪造的证书，

577
00:25:29,400 --> 00:25:31,020
并且可能在

578
00:25:31,020 --> 00:25:34,140
当时浏览器使用它的日志中，但是也许

579
00:25:34,140 --> 00:25:35,850
该证书服务器可以

580
00:25:35,850 --> 00:25:38,820
从其日志中删除该证书，以便

581
00:25:38,820 --> 00:25:40,170
在监视器开始查看时

582
00:25:40,170 --> 00:25:42,180
伪造证书的日志

583
00:25:42,180 --> 00:25:44,730
不会存在，因此我们需要一个系统

584
00:25:44,730 --> 00:25:46,890
来防止删除或

585
00:25:46,890 --> 00:25:49,530
至少检测是否发生了删除

586
00:25:49,530 --> 00:25:52,140
，这就是系统

587
00:25:52,140 --> 00:25:56,040
需要仅附加的意义，我们还

588
00:25:56,040 --> 00:26:00,140
必须防止所谓的 模棱两可

589
00:26:00,140 --> 00:26:02,750
与否'我们必须防止分叉或

590
00:26:02,750 --> 00:26:06,620
等效模棱两可，

591
00:26:08,920 --> 00:26:12,540
所以你知道它

592
00:26:12,540 --> 00:26:15,450
可能是证书日志服务器可能

593
00:26:15,450 --> 00:26:17,820
正在实现仅附加日志，但

594
00:26:17,820 --> 00:26:21,060
如果它实现了两个不同的

595
00:26:21,060 --> 00:26:23,570
依赖唯一的日志并显示一个两个

596
00:26:23,570 --> 00:26:25,530
浏览器并显示另一个 仅附加

597
00:26:25,530 --> 00:26:27,990
记录两个监视器，然后我们可能处于这样的

598
00:26:27,990 --> 00:26:30,150
位置，是的，您

599
00:26:30,150 --> 00:26:31,950
知道我们显示日志

600
00:26:31,950 --> 00:26:33,540
的浏览器我们显示的浏览器包含伪造的

601
00:26:33,540 --> 00:26:36,780
证书 但是我们向监视器显示的日志

602
00:26:36,780 --> 00:26:39,710
不包含

603
00:26:39,710 --> 00:26:42,000
伪造的证书，因此我们必须在

604
00:26:42,000 --> 00:26:45,240
不信任服务器的情况下排除对所有人的模棱两可的情况，

605
00:26:45,240 --> 00:26:50,700
所以现在我们如何才能做到这一点，我们

606
00:26:50,700 --> 00:26:53,820
正在进入

607
00:26:53,820 --> 00:26:56,550
最后一个细节 任务是在

608
00:26:56,550 --> 00:27:00,870
谈论第一步是这个

609
00:27:00,870 --> 00:27:05,850
叫做默克尔树的

610
00:27:05,850 --> 00:27:08,430
东西，这有点像日志

611
00:27:08,430 --> 00:27:10,320
服务器应该建立在日志之上的东西

612
00:27:10,320 --> 00:27:12,570
，所以这个想法是有

613
00:27:12,570 --> 00:27:14,750
实际的日志本身，它是一个序列

614
00:27:14,750 --> 00:27:17,270
证书你知道证书一个

615
00:27:17,270 --> 00:27:19,890
证书大概按照

616
00:27:19,890 --> 00:27:24,840
 

617
00:27:24,840 --> 00:27:26,580
证书添加到系统的顺序

618
00:27:26,580 --> 00:27:28,409
和主要数百万我只是

619
00:27:28,409 --> 00:27:33,480
假设有几个现在

620
00:27:33,480 --> 00:27:35,520
结果你知道我们不想

621
00:27:35,520 --> 00:27:36,840
拥有 浏览器必须下载整个

622
00:27:36,840 --> 00:27:40,409
日志，因此我们需要工具，以便我们

623
00:27:40,409 --> 00:27:42,330
可以允许日志系统

624
00:27:42,330 --> 00:27:48,539
基本上将日志

625
00:27:48,539 --> 00:27:50,250
中内容的可信摘要或明确摘要发送

626
00:27:50,250 --> 00:27:53,250
到浏览器，我会在

627
00:27:53,250 --> 00:27:54,659
关于这些

628
00:27:54,659 --> 00:27:57,120
摘要的用途，但基本

629
00:27:57,120 --> 00:28:03,750
方案是日志服务器将

630
00:28:03,750 --> 00:28:07,559
使用加密哈希对日志中

631
00:28:07,559 --> 00:28:10,409
的完整记录集进行排序

632
00:28:10,409 --> 00:28:11,880
可以产生单个

633
00:28:11,880 --> 00:28:14,549
加密哈希，通常是

634
00:28:14,549 --> 00:28:16,860
这些 天大约 256 位长，所以

635
00:28:16,860 --> 00:28:19,409
加密哈希总结

636
00:28:19,409 --> 00:28:23,039
了日志的面貌，完成的方式

637
00:28:23,039 --> 00:28:25,649
是，它基本上是

638
00:28:25,649 --> 00:28:28,950
一个基于哈希的对的树结构，

639
00:28:28,950 --> 00:28:30,630
总是

640
00:28:30,630 --> 00:28:35,940
将第零级的数字对散列在一起，所以

641
00:28:35,940 --> 00:28:38,730
我要写 每个用于哈希

642
00:28:38,730 --> 00:28:40,320
每个日志条目都有一个哈希，所以我们将

643
00:28:40,320 --> 00:28:42,750
在基本级别

644
00:28:42,750 --> 00:28:46,649
拥有每个日志条目的哈希每个

645
00:28:46,649 --> 00:28:50,039
证书，然后我们将

646
00:28:50,039 --> 00:28:55,710
散列对等点，以便下一个级别 我们

647
00:28:55,710 --> 00:28:59,270
将有

648
00:28:59,270 --> 00:29:04,190
一个散列并与此连接，并将此的散列

649
00:29:04,190 --> 00:29:07,799
与这两个

650
00:29:07,799 --> 00:29:11,510
散列连接，然后在顶层

651
00:29:12,330 --> 00:29:14,519
我们正在做的过度是散列这

652
00:29:14,519 --> 00:29:16,320
两个这两个的连接

653
00:29:16,320 --> 00:29:21,679
有 他和这里的单个散列是完整日志的

654
00:29:21,860 --> 00:29:26,039
明确替代

655
00:29:26,039 --> 00:29:28,380
，

656
00:29:28,380 --> 00:29:31,019
这些加密散列（如 sha-256

657
00:29:31,019 --> 00:29:33,570
）的一个属性是，

658
00:29:33,570 --> 00:29:35,640
找到产生相同输出的散列函数的两个输入是不可行的，

659
00:29:35,640 --> 00:29:37,769
并且 意味着如果你

660
00:29:37,769 --> 00:29:39,149
告诉某人散列

661
00:29:39,149 --> 00:29:43,289
函数的输出只有一个输入

662
00:29:43,289 --> 00:29:44,840
你将能够找到

663
00:29:44,840 --> 00:29:48,360
产生该输出的输入所以如果日志服务器

664
00:29:48,360 --> 00:29:51,120
确实以这种方式散列

665
00:29:51,120 --> 00:29:54,149
其日志的内容只有这些序列 日志

666
00:29:54,149 --> 00:29:56,399
记录将永远能够产生

667
00:29:56,399 --> 00:29:59,760
该哈希或有效地

668
00:29:59,760 --> 00:30:02,460
保证日志服务器将

669
00:30:02,460 --> 00:30:05,399
无法找到其他产生

670
00:30:05,399 --> 00:30:09,179
与此日志条目序列相同的最终树哈希的其他日志，

671
00:30:09,179 --> 00:30:12,600
所以这就是

672
00:30:12,600 --> 00:30:14,850
默克尔树 是一种树

673
00:30:14,850 --> 00:30:18,659
散列，它在默克尔树的顶部总结了整个日志，

674
00:30:18,659 --> 00:30:23,190
 

675
00:30:23,190 --> 00:30:27,750
实际上将其称为签名树头，

676
00:30:27,750 --> 00:30:29,760
因为实际上日志服务器

677
00:30:29,760 --> 00:30:32,010
在树的顶部获取此散列

678
00:30:32,010 --> 00:30:33,690
并且 s 用他们的私钥对其进行签名并将其

679
00:30:33,690 --> 00:30:36,990
提供给浏览器和监视器的客户端，

680
00:30:36,990 --> 00:30:40,769
并且他们已经

681
00:30:40,769 --> 00:30:42,269
签署了它的事实意味着他们以后不能

682
00:30:42,269 --> 00:30:43,470
 

683
00:30:43,470 --> 00:30:45,570
否认它实际上是他们并制作了它，

684
00:30:45,570 --> 00:30:47,130
所以你知道只是为了能够 抓住

685
00:30:47,130 --> 00:30:53,340
躺着的日志服务器，所以这里的重点

686
00:30:53,340 --> 00:30:55,889
是，一旦日志服务器

687
00:30:55,889 --> 00:30:59,850
向浏览器显示特定的标志树头

688
00:30:59,850 --> 00:31:03,269
或监视其对

689
00:31:03,269 --> 00:31:05,669
某些特定日志内容的承诺，因为它

690
00:31:05,669 --> 00:31:06,720
永远无法产生

691
00:31:06,720 --> 00:31:08,730
不同的日志内容来 产生

692
00:31:08,730 --> 00:31:10,350
相同的哈希，所以你的哈希

693
00:31:10,350 --> 00:31:14,700
实际上是一种承诺，好吧，

694
00:31:14,700 --> 00:31:17,490
这就是日志，但默克尔

695
00:31:17,490 --> 00:31:20,370
树现在看起来像一个特定的日志，

696
00:31:20,370 --> 00:31:23,429
今天的第三次阅读概述了

697
00:31:23,429 --> 00:31:25,110
如何

698
00:31:25,110 --> 00:31:27,210
和法律如何将记录添加到

699
00:31:27,210 --> 00:31:32,790
任意数量记录的日志我

700
00:31:32,790 --> 00:31:34,380
只是假设日志总是

701
00:31:34,380 --> 00:31:37,350
以 2 倍增长，这是

702
00:31:37,350 --> 00:31:39,090
不切实际的，但更容易

703
00:31:39,090 --> 00:31:41,190
解释 Naumann，这意味着当

704
00:31:41,190 --> 00:31:43,230
证书颁发机构发送新证书时

705
00:31:43,230 --> 00:31:45,299
表示将日志添加到日志中，日志

706
00:31:45,299 --> 00:31:48,780
服务器将等待它拥有与

707
00:31:48,780 --> 00:31:50,820
旧记录一样多的新记录，

708
00:31:50,820 --> 00:31:54,179
然后生成另一个树头，

709
00:31:54,179 --> 00:31:56,760
它这样做的方式是

710
00:31:56,760 --> 00:32:01,110
为了扩展日志服务器将等待的日志

711
00:32:01,110 --> 00:32:02,790
作为另外四个记录，

712
00:32:02,790 --> 00:32:05,669
然后它会像以前一样将它们成对地散列

713
00:32:05,669 --> 00:32:10,190
，然后它会产生一个新的

714
00:32:10,490 --> 00:32:14,250
树头，它是

715
00:32:14,250 --> 00:32:19,610
这两个散列连接的散列，

716
00:32:21,380 --> 00:32:26,370
这是新扩展定律的新树头

717
00:32:26,370 --> 00:32:28,950
，所以 这意味着随着时间的

718
00:32:28,950 --> 00:32:33,000
推移和日志服务器，这个日志变得

719
00:32:33,000 --> 00:32:34,770
越来越长，它会产生

720
00:32:34,770 --> 00:32:37,679
越来越高的一系列

721
00:32:37,679 --> 00:32:42,169
越来越高的树头，因为对数

722
00:32:44,809 --> 00:32:50,400
没问题，所以这就是我们

723
00:32:50,400 --> 00:32:53,700
期望日志服务器维护的结构

724
00:32:53,700 --> 00:32:54,540
当然，谁知道他们实际上

725
00:32:54,540 --> 00:32:57,000
在做什么，特别是如果他们是恶意的，

726
00:32:57,000 --> 00:32:59,790
但是证书

727
00:32:59,790 --> 00:33:01,799
透明协议之类的协议是写的，

728
00:33:01,799 --> 00:33:03,840
你知道就好像日志服务器

729
00:33:03,840 --> 00:33:06,090
实际上在做这件事一样，所以

730
00:33:06,090 --> 00:33:08,640
我们需要做什么 但是这个

731
00:33:08,640 --> 00:33:14,309
Merkle 树的重点是使用它们来强制日志

732
00:33:14,309 --> 00:33:16,410
服务器证明

733
00:33:16,410 --> 00:33:18,840
关于日志的某些事情，他们可以

734
00:33:18,840 --> 00:33:21,059
证明他们正在维护的日志我们会

735
00:33:21,059 --> 00:33:24,059
想知道那些证明

736
00:33:24,059 --> 00:33:27,220
看起来像什么 这

737
00:33:27,220 --> 00:33:33,510
就是我所说的包含证明

738
00:33:33,510 --> 00:33:39,030
，这就是

739
00:33:40,050 --> 00:33:42,540
NEADS，当它想查明

740
00:33:42,540 --> 00:33:44,880
 

741
00:33:44,880 --> 00:33:46,320
Web 服务器刚刚提供的

742
00:33:46,320 --> 00:33:49,290
证书是否真的在法律范围内时，它

743
00:33:49,290 --> 00:33:54,180
会询问 证书它会

744
00:33:54,180 --> 00:33:57,090
询问日志服务器 看这里的证书，

745
00:33:57,090 --> 00:33:59,550
你知道它是否在你的日志中

746
00:33:59,550 --> 00:34:01,110
，证书服务器会发

747
00:34:01,110 --> 00:34:05,610
回一个证明，证明实际上

748
00:34:05,610 --> 00:34:07,080
不仅证书在日志中，

749
00:34:07,080 --> 00:34:08,520
而且实际上它在哪里

750
00:34:08,520 --> 00:34:14,760
是在日志中，当然浏览器

751
00:34:14,760 --> 00:34:16,110
想要这个证明，因为

752
00:34:16,110 --> 00:34:17,699
如果它不在日志中，它不想使用证书，

753
00:34:17,699 --> 00:34:19,590
因为如果不是我在，

754
00:34:19,590 --> 00:34:21,060
那么监视器将看不到它并且

755
00:34:21,060 --> 00:34:23,280
没有 / - 没有保护 反对他们的

756
00:34:23,280 --> 00:34:27,270
证书是伪造的 它需要

757
00:34:27,270 --> 00:34:33,300
作为一个证据，因为我们不能

758
00:34:33,300 --> 00:34:35,370
让这个日志服务器成为一个恶意日志，

759
00:34:35,370 --> 00:34:37,650
永远改变它的

760
00:34:37,650 --> 00:34:39,239
 

761
00:34:39,239 --> 00:34:40,830
 

762
00:34:40,830 --> 00:34:44,310
想法 这个证据将

763
00:34:44,310 --> 00:34:46,830
帮助我们抓住它你知道如果日志

764
00:34:46,830 --> 00:34:49,080
服务器确实撒谎这些证据将

765
00:34:49,080 --> 00:34:50,940
帮助我们抓住日志

766
00:34:50,940 --> 00:34:54,330
服务器撒谎的事实并提供证据

767
00:34:54,330 --> 00:34:56,250
证明日志服务器是恶意的并且

768
00:34:56,250 --> 00:34:59,940
从现在开始应该被忽略是那种

769
00:34:59,940 --> 00:35:01,500
对日志服务器的最终制裁

770
00:35:01,500 --> 00:35:03,840
是浏览器实际上

771
00:35:03,840 --> 00:35:05,520
有一个可接受的日志服务器列表

772
00:35:05,520 --> 00:35:10,110
，这些证据将成为

773
00:35:10,110 --> 00:35:14,370
导致其中一个日志

774
00:35:14,370 --> 00:35:16,230
服务器被从日志中删除的证据的一部分，如果它是

775
00:35:16,230 --> 00:35:18,660
恶意的，那么我们 需要一个证明我们

776
00:35:18,660 --> 00:35:20,160
希望日志服务器生成

777
00:35:20,160 --> 00:35:24,380
一个给定证书在其日志中的证明，

778
00:35:24,380 --> 00:35:29,190
所以实际上第一步是

779
00:35:29,190 --> 00:35:31,770
浏览器向日志服务器询问

780
00:35:31,770 --> 00:35:35,670
当前的符号树头，所以

781
00:35:35,670 --> 00:35:37,740
浏览器真正要求的是这个

782
00:35:37,740 --> 00:35:41,040
证书 在

783
00:35:41,040 --> 00:35:45,120
此当前由该标志树头

784
00:35:45,120 --> 00:35:47,340
和日志服务器总结的日志中指出，日志服务器可能位于

785
00:35:47,340 --> 00:35:49,860
标志树头右侧，浏览器向它

786
00:35:49,860 --> 00:35:52,220
询问当前标志树头，

787
00:35:52,220 --> 00:35:54,410
然后证明证书

788
00:35:54,410 --> 00:35:56,960
在日志中 服务器可能会

789
00:35:56,960 --> 00:35:58,310
谎报符号树头带将处理的问题

790
00:35:58,310 --> 00:36:01,160
，我们稍后会考虑，但

791
00:36:01,160 --> 00:36:06,320
现在让我们假设浏览器

792
00:36:06,320 --> 00:36:09,619
具有正确的符号树头并且

793
00:36:09,619 --> 00:36:12,800
要求提供证明，所以为简单起见，

794
00:36:12,800 --> 00:36:15,050
我将解释如何

795
00:36:15,050 --> 00:36:16,640
对具有两条记录的日志执行此操作，事实

796
00:36:16,640 --> 00:36:18,980
证明，将其扩展到

797
00:36:18,980 --> 00:36:21,859
具有其他更高功率的两条

798
00:36:21,859 --> 00:36:26,330
记录的日志相对容易嗯，因此

799
00:36:26,330 --> 00:36:27,980
浏览器实际上具有特定的符号

800
00:36:27,980 --> 00:36:32,810
树头让我们假设正确的

801
00:36:32,810 --> 00:36:35,450
日志位于它下面 符号树头是

802
00:36:35,450 --> 00:36:39,890
特定证书 a 和 B 的日志 a B 中的两个 LM

803
00:36:39,890 --> 00:36:44,050
，这

804
00:36:44,050 --> 00:36:46,280
意味着正确的

805
00:36:46,280 --> 00:36:49,550
Merkle 树

806
00:36:49,550 --> 00:36:52,849
作为 a 和 B 的哈希值安全地位于底部，

807
00:36:52,849 --> 00:36:56,630
然后符号树头实际上是 y 与

808
00:36:56,630 --> 00:37:01,220
散列连接的

809
00:37:01,220 --> 00:37:06,680
散列的散列将是所以让我们假设这

810
00:37:06,680 --> 00:37:09,859
 

811
00:37:09,859 --> 00:37:11,960
是日志服务器实际提供给

812
00:37:11,960 --> 00:37:16,609
客户端的证书的符号树头当然客户端不知道这个

813
00:37:16,609 --> 00:37:20,060
客户端只知道这个值这是

814
00:37:20,060 --> 00:37:21,410
最终哈希值实际上并不

815
00:37:21,410 --> 00:37:26,810
知道日志中的内容

816
00:37:26,810 --> 00:37:28,460
如果浏览器要求 a

817
00:37:28,460 --> 00:37:33,740
在日志中的证明，那么日志

818
00:37:33,740 --> 00:37:38,060
服务器可以返回的

819
00:37:38,060 --> 00:37:42,710
证明只是 a 在日志中的证明 只是

820
00:37:42,710 --> 00:37:50,950
日志中的eizan和日志中另一个

821
00:37:50,950 --> 00:37:55,280
元素的哈希值为零和b的哈希值

822
00:37:55,280 --> 00:37:56,940
 

823
00:37:56,940 --> 00:38:00,900
，这是足够的信息让a

824
00:38:00,900 --> 00:38:03,329
说服自己，抱歉让

825
00:38:03,329 --> 00:38:05,760
客户说服自己a

826
00:38:05,760 --> 00:38:08,069
真的在零位，因为 它可以

827
00:38:08,069 --> 00:38:10,290
知道证书对它

828
00:38:10,290 --> 00:38:13,829
感兴趣 它可以对其进行散列 部分证明是

829
00:38:13,829 --> 00:38:16,619
此最低级别散列中其他元素的

830
00:38:16,619 --> 00:38:21,030
散列，因此浏览

831
00:38:21,030 --> 00:38:23,099
器现在可以知道 H a 和 H B 您可以将

832
00:38:23,099 --> 00:38:26,099
它们散列在一起 可以执行此散列

833
00:38:26,099 --> 00:38:27,750
看看结果是否为 t 他与

834
00:38:27,750 --> 00:38:29,760
它发生的正弦树头相同，如果

835
00:38:29,760 --> 00:38:34,290
是，则意味着证书

836
00:38:34,290 --> 00:38:35,700
日志实际上产生了一个有效证明

837
00:38:35,700 --> 00:38:39,980
，证明证书 a 位于位置 B

838
00:38:39,980 --> 00:38:42,660
，很抱歉，它是

839
00:38:42,660 --> 00:38:45,390
由该符号树头总结的日志中的零位置

840
00:38:45,390 --> 00:38:50,240
事实证明，在更大的

841
00:38:50,240 --> 00:38:55,020
日志中，您知道是否正在

842
00:38:55,020 --> 00:38:57,329
寻找是否需要证明 a 确实

843
00:38:57,329 --> 00:38:59,609
在这里，您所需要的只是

844
00:38:59,609 --> 00:39:05,280
每个哈希的另一个分支的哈希序列，

845
00:39:05,280 --> 00:39:07,880
直到您的符号树头

846
00:39:07,880 --> 00:39:11,220
如果您需要证明 a 位置为零，则在 for element 日志中有这样的内容

847
00:39:11,220 --> 00:39:13,290
，则

848
00:39:13,290 --> 00:39:15,660
需要此哈希单元，然后您需要此

849
00:39:15,660 --> 00:39:17,640
哈希，如果锁更大，您知道

850
00:39:17,640 --> 00:39:19,560
八个元素，那么您还需要此

851
00:39:19,560 --> 00:39:22,109
哈希，假设您有 签名

852
00:39:22,109 --> 00:39:23,550
树命中，因此您可以获取您知道的元素

853
00:39:23,550 --> 00:39:25,710
并将其与

854
00:39:25,710 --> 00:39:28,170
这些其他哈希中的每一个一起散列，看看它是否

855
00:39:28,170 --> 00:39:32,760
等于符号树头，好吧，如果

856
00:39:32,760 --> 00:39:34,560
浏览器询问假设浏览器

857
00:39:34,560 --> 00:39:37,770
询问 X 是否在位置零的日志中

858
00:39:37,770 --> 00:39:41,720
好吧 X 不在 l 中 og 是的，所以

859
00:39:41,720 --> 00:39:44,430
希望日志服务器没有简单的方法

860
00:39:44,430 --> 00:39:46,140
来证明

861
00:39:46,140 --> 00:39:48,930
X 在位置零的日志中，但是

862
00:39:48,930 --> 00:39:50,670
假设日志服务器想要撒谎并且

863
00:39:50,670 --> 00:39:52,560
它已经

864
00:39:52,560 --> 00:39:55,500
暴露了包含日志的符号树头的位置

865
00:39:55,500 --> 00:39:59,310
a 然后 B 浏览器不

866
00:39:59,310 --> 00:40:01,109
知道是 a 和 B 不

867
00:40:01,109 --> 00:40:03,839
知道日志中的内容，并且日志服务器想要

868
00:40:03,839 --> 00:40:06,480
欺骗客户端进入浏览器

869
00:40:06,480 --> 00:40:07,980
，使其认为它确实

870
00:40:07,980 --> 00:40:11,730
位于零位置，事实证明

871
00:40:11,730 --> 00:40:17,460
，为了做到 对于这个小

872
00:40:17,460 --> 00:40:20,300
日志，证书服务器必须

873
00:40:20,300 --> 00:40:31,830
生成一些原因，它需要找到一个

874
00:40:31,830 --> 00:40:36,630
原因，如果它需要它是一个

875
00:40:36,630 --> 00:40:38,880
与 X 连接的哈希值，你知道，所以这

876
00:40:38,880 --> 00:40:41,910
就是它等于符号树

877
00:40:41,910 --> 00:40:44,100
头，因为客户端我们 '

878
00:40:44,100 --> 00:40:45,300
假设客户端已经必须签署

879
00:40:45,300 --> 00:40:48,630
树头，我们需要在这里找到一个数字

880
00:40:48,630 --> 00:40:50,820
，当与

881
00:40:50,820 --> 00:40:52,740
客户端询问的 X 的哈希一起散列时，

882
00:40:52,740 --> 00:40:55,710
会产生相同的符号树，我们

883
00:40:55,710 --> 00:40:57,090
知道符号树头或

884
00:40:57,090 --> 00:40:58,260
假设是 分配 ned tree 它

885
00:40:58,260 --> 00:40:59,580
实际上是针对其他一些日志的，

886
00:40:59,580 --> 00:41:00,750
因为我们试图

887
00:41:00,750 --> 00:41:04,590
排除日志服务器可以为

888
00:41:04,590 --> 00:41:06,540
您提供一个日志的标志树头的可能性，但这

889
00:41:06,540 --> 00:41:09,060
让您相信

890
00:41:09,060 --> 00:41:10,800
该日志中不存在其他东西，所以 符号

891
00:41:10,800 --> 00:41:14,970
树确实是由

892
00:41:14,970 --> 00:41:17,910
真正在日志中的记录的哈希产生的

893
00:41:17,910 --> 00:41:22,920
，现在我们需要，因为你

894
00:41:22,920 --> 00:41:24,870
知道 X 肯定不同于 a

895
00:41:24,870 --> 00:41:26,490
这意味着 X

896
00:41:26,490 --> 00:41:28,560
的哈希与 a 的哈希不同，这意味着

897
00:41:28,560 --> 00:41:32,550
日志服务器需要为产生相同输出

898
00:41:32,550 --> 00:41:35,550
的散列函数找到两个不同的输入，

899
00:41:35,550 --> 00:41:38,790
并且

900
00:41:38,790 --> 00:41:41,550
 

901
00:41:41,550 --> 00:41:43,350
出于实际目的被广泛认为是正确的假设

902
00:41:43,350 --> 00:41:46,040
是加密散列不可能，

903
00:41:46,040 --> 00:41:50,310
因此分号树头是

904
00:41:50,310 --> 00:41:53,670
通过散列一个日志产生的

905
00:41:53,670 --> 00:41:56,250
不可能找到这些类型

906
00:41:56,250 --> 00:42:00,060
的其他哈希值，这些哈希值

907
00:42:00,060 --> 00:42:04,200
需要生成证明

908
00:42:04,200 --> 00:42:06,210
日志中

909
00:42:06,210 --> 00:42:07,970
存在

910
00:42:07,970 --> 00:42:13,520
其他一些元素的证明 关于任何

911
00:42:17,090 --> 00:42:18,500
[音乐]

912
00:42:18,500 --> 00:42:20,700
有趣的事情，这方面的

913
00:42:20,700 --> 00:42:24,240
一个好处是，如果有 n 个证书，那么证明是由

914
00:42:24,240 --> 00:42:27,540
 

915
00:42:27,540 --> 00:42:29,970
直到根目录的其他散列组成

916
00:42:29,970 --> 00:42:32,190
的，只有登录其他

917
00:42:32,190 --> 00:42:34,830
散列，所以证明相当

918
00:42:34,830 --> 00:42:36,570
简洁 特别是它

919
00:42:36,570 --> 00:42:39,119
比完整日志小得多，而且由于您

920
00:42:39,119 --> 00:42:40,590
知道每个需要连接

921
00:42:40,590 --> 00:42:42,960
到网站的浏览器，他将需要其中

922
00:42:42,960 --> 00:42:47,690
一个证明，如果它们很小，那

923
00:42:48,110 --> 00:42:51,540
很好，好吧，这是整个讨论都

924
00:42:51,540 --> 00:42:55,200
假设标志

925
00:42:55,200 --> 00:42:57,590
 

926
00:42:58,099 --> 00:43:04,489
 

927
00:43:04,489 --> 00:43:07,880
 

928
00:43:07,880 --> 00:43:09,829
 

929
00:43:09,829 --> 00:43:11,690
如果日志是恶意的，

930
00:43:11,690 --> 00:43:13,609
并且它想欺骗客户端，你知道

931
00:43:13,609 --> 00:43:14,900
它为什么会给客户端 正确的

932
00:43:14,900 --> 00:43:16,609
看到标志树头为什么它不给

933
00:43:16,609 --> 00:43:18,529
它只是我给

934
00:43:18,529 --> 00:43:20,930
它想要欺骗客户使用的虚假日志的标志树头

935
00:43:20,930 --> 00:43:24,319
所以我们必须为日志s

936
00:43:24,319 --> 00:43:26,089
的可能性做好准备

937
00:43:26,089 --> 00:43:28,549
erver 已经

938
00:43:28,549 --> 00:43:29,900
为浏览器制作了完全不同

939
00:43:29,900 --> 00:43:31,670
的日志，它与其他任何人的日志都不一样，

940
00:43:31,670 --> 00:43:33,529
它只包含

941
00:43:33,529 --> 00:43:36,680
恶意日志服务器想要

942
00:43:36,680 --> 00:43:43,309
欺骗该客户端相信的虚假证书，所以

943
00:43:43,309 --> 00:43:47,930
我们该怎么做呢？事实证明

944
00:43:47,930 --> 00:43:50,720
，这 至少在第一种

945
00:43:50,720 --> 00:43:52,749
情况下，这是完全有可能的，

946
00:43:52,749 --> 00:43:55,819
您通常知道会发生什么通常会发生的事情

947
00:43:55,819 --> 00:43:57,289
是

948
00:43:57,289 --> 00:44:00,289
，我们会有一些浏览器，您

949
00:44:00,289 --> 00:44:03,380
知道在某个时间点看到正确的日志，直到有人

950
00:44:03,380 --> 00:44:06,319
 

951
00:44:06,319 --> 00:44:10,039
想要 攻击它，你知道你希望

952
00:44:10,039 --> 00:44:11,269
浏览器学生能够使用

953
00:44:11,269 --> 00:44:13,960
它通常看到的所有网站，

954
00:44:13,960 --> 00:44:18,799
以及一种带有伪造证书的不同日志

955
00:44:18,799 --> 00:44:21,289
，日志服务器

956
00:44:21,289 --> 00:44:23,059
想要欺骗那个客户端，只是那个

957
00:44:23,059 --> 00:44:25,579
受害者浏览器使用它，所以现在这是

958
00:44:25,579 --> 00:44:31,299
分叉攻击或更广泛的

959
00:44:31,299 --> 00:44:35,930
模棱两可，人们

960
00:44:35,930 --> 00:44:39,310
将这种

961
00:44:39,310 --> 00:44:41,380
攻击称为分叉攻击的原因是，如果我们

962
00:44:41,380 --> 00:44:42,730
暂时不介意默克尔树，如果 w  e

963
00:44:42,730 --> 00:44:45,460
只考虑日志通常日志

964
00:44:45,460 --> 00:44:47,200
已经有你知道数以百万计的

965
00:44:47,200 --> 00:44:50,370
证书，并且每个人都看到

966
00:44:50,370 --> 00:44:52,420
了日志的开头部分然后

967
00:44:52,420 --> 00:44:57,340
在某个时间点我们想要攻击我们

968
00:44:57,340 --> 00:45:00,880
想要说服我们的受害者使用一些

969
00:45:00,880 --> 00:45:04,330
伪造的证书 B 但我们 不想将

970
00:45:04,330 --> 00:45:05,920
B 显示给其他任何人，当然也不会显示

971
00:45:05,920 --> 00:45:07,510
给监视器，所以我们将

972
00:45:07,510 --> 00:45:10,300
编写另一个日志，

973
00:45:10,300 --> 00:45:12,220
像往常一样继续并包含新的提交，

974
00:45:12,220 --> 00:45:14,830
但绝对不包含伪造的

975
00:45:14,830 --> 00:45:18,550
证书 B，你知道 这

976
00:45:18,550 --> 00:45:20,470
看起来像是一个分叉，因为

977
00:45:20,470 --> 00:45:23,680
监视器显示的那种主日志

978
00:45:23,680 --> 00:45:26,380
在一个分叉上有点关闭，然后

979
00:45:26,380 --> 00:45:28,630
我们正在制作的这个 vlog 特别是为了

980
00:45:28,630 --> 00:45:31,480
欺骗受害者是一个不同的分叉 这

981
00:45:31,480 --> 00:45:33,460
是恶意的结构

982
00:45:33,460 --> 00:45:35,050
如果日志服务器

983
00:45:35,050 --> 00:45:37,590
想要欺骗浏览器使用

984
00:45:37,590 --> 00:45:42,400
伪造的证书，则必须生成，而且这些都是

985
00:45:42,400 --> 00:45:45,790
可能的

986
00:45:45,790 --> 00:45:48,760
 

987
00:45:48,760 --> 00:45:52,260
 

988
00:45:52,260 --> 00:45:54,820
虽然这还不是故事的结局

989
00:45:54,820 --> 00:45:57,550
，证书颁发机构包含

990
00:45:57,550 --> 00:46:01,180
一些工具，可以让 Forks

991
00:46:01,180 --> 00:46:06,840
变得更加困难，所以基本方案

992
00:46:06,840 --> 00:46:15,040
是这不是

993
00:46:15,040 --> 00:46:16,390
证书颁发机构

994
00:46:16,390 --> 00:46:18,010
打算工作的方式所有证书透明度都

995
00:46:18,010 --> 00:46:20,940
旨在 工作但不完全

996
00:46:20,940 --> 00:46:24,370
是这里发生的事情是

997
00:46:24,370 --> 00:46:26,290
监视器和人们没有受到

998
00:46:26,290 --> 00:46:30,460
攻击或者会看到一个标志树

999
00:46:30,460 --> 00:46:32,470
特定的标志树头假设

1000
00:46:32,470 --> 00:46:33,700
我们击中的科学当然会

1001
00:46:33,700 --> 00:46:37,240
随着日志的扩展而改变

1002
00:46:37,240 --> 00:46:39,340
我们知道受害者必须看到一些其他的标志树

1003
00:46:39,340 --> 00:46:41,350
头，因为这是一个签名的树命中

1004
00:46:41,350 --> 00:46:44,370
，在这个证书上散列，

1005
00:46:44,559 --> 00:46:46,299
保证

1006
00:46:46,299 --> 00:46:48,279
与标志树头不同这是

1007
00:46:48,279 --> 00:46:51,299
民兵服务显示两个监视器，

1008
00:46:51,299 --> 00:46:53,739
如果只有浏览器和监视器可以

1009
00:46:53,739 --> 00:46:56,859
比较它们的注释 也许会立即

1010
00:46:56,859 --> 00:46:58,329
意识到他们看到的是不同的

1011
00:46:58,329 --> 00:47:00,849
树，只需比较你

1012
00:47:00,849 --> 00:47:02,559
知道我们是否正确地打牌，

1013
00:47:02,559 --> 00:47:04,239
只需比较符号 tr  ee

1014
00:47:04,239 --> 00:47:06,969
他们从日志服务器获得了它，他们

1015
00:47:06,969 --> 00:47:08,829
意识到等一下，我们看到了

1016
00:47:08,829 --> 00:47:10,959
不同的日志，现在出现了严重

1017
00:47:10,959 --> 00:47:15,489
错误，所以我们需要做的关键事情

1018
00:47:15,489 --> 00:47:18,789
是让系统中的不同

1019
00:47:18,789 --> 00:47:21,130
参与者能够

1020
00:47:21,130 --> 00:47:24,959
比较符号树头 并且

1021
00:47:24,959 --> 00:47:27,339
证书透明度为此提供

1022
00:47:27,339 --> 00:47:30,249
了一个称为八卦的规定，以及它的

1023
00:47:30,249 --> 00:47:33,999
预期工作方式，浏览器以及

1024
00:47:33,999 --> 00:47:36,549
细节并不重要，但它

1025
00:47:36,549 --> 00:47:38,619
真正意味着所有

1026
00:47:38,619 --> 00:47:41,229
参与者都会放弃他们最近的

1027
00:47:41,229 --> 00:47:43,059
标志树头 我看到了一个大

1028
00:47:43,059 --> 00:47:47,829
池子，他们都检查过，试图

1029
00:47:47,829 --> 00:47:50,469
找出是否有不一致的标志

1030
00:47:50,469 --> 00:47:52,709
树头，清楚地表明

1031
00:47:52,709 --> 00:47:55,869
不同的日志，所以我们

1032
00:47:55,869 --> 00:47:58,380
要八卦，这真的意味着

1033
00:47:58,380 --> 00:48:01,380
交换

1034
00:48:02,000 --> 00:48:07,260
我是标志树头并比较它 事实

1035
00:48:07,260 --> 00:48:09,480
证明，当前的证书

1036
00:48:09,480 --> 00:48:12,180
透明度实现并没有这样做，

1037
00:48:12,180 --> 00:48:16,109
但他们应该这样做，他们会

1038
00:48:16,109 --> 00:48:17,160
在某个时候弄清楚，

1039
00:48:17,160 --> 00:48:21,359
好吧，所以问题

1040
00:48:21,359 --> 00:48:25,430
是签署树头如何 e 决定

1041
00:48:25,430 --> 00:48:27,660
它们是否是日志已被

1042
00:48:27,660 --> 00:48:33,270
分叉的证据 使这变得困难的事情是

1043
00:48:33,270 --> 00:48:36,180
，即使一个日志没有被分叉，因为

1044
00:48:36,180 --> 00:48:40,010
它依赖于新的标志树头

1045
00:48:40,010 --> 00:48:42,540
将成为当前的，所以你知道也许

1046
00:48:42,540 --> 00:48:46,140
标志树头之一是 合法的，所以

1047
00:48:46,140 --> 00:48:47,970
他此时有一个 vlog，然后

1048
00:48:47,970 --> 00:48:50,070
添加了更多证书，并且签署

1049
00:48:50,070 --> 00:48:54,150
树头 3 成为法律的正确头

1050
00:48:54,150 --> 00:48:55,800
，然后签署树头

1051
00:48:55,800 --> 00:48:59,820
等等，所以实际上这个八卦

1052
00:48:59,820 --> 00:49:04,440
比较最少要做的是区分以下

1053
00:49:04,440 --> 00:49:07,109
情况 符号树头

1054
00:49:07,109 --> 00:49:09,840
实际上描述了一个前缀日志，它是

1055
00:49:09,840 --> 00:49:11,580
另一个符号树头描述的日志的前缀，

1056
00:49:11,580 --> 00:49:13,170
因为这是

1057
00:49:13,170 --> 00:49:15,180
合法的情况，你有

1058
00:49:15,180 --> 00:49:17,070
两个这两个符号树头是

1059
00:49:17,070 --> 00:49:20,100
不同的，但第二个确实

1060
00:49:20,100 --> 00:49:21,780
包含第一个 我们想

1061
00:49:21,780 --> 00:49:24,180
将其与两个有符号树区分开来，因为

1062
00:49:24,180 --> 00:49:26,300
它们都不

1063
00:49:26,300 --> 00:49:28,770
描述作为另一个日志前缀

1064
00:49:28,770 --> 00:49:31,710
的日志，一个将这两种情况

1065
00:49:31,710 --> 00:49:40,020
分开，这说明情况分开

1066
00:49:40,020 --> 00:49:44,609
是 t 一致性证明

1067
00:49:44,609 --> 00:49:47,609
的目的 日志或默克尔一致性证明

1068
00:49:47,609 --> 00:49:49,260
，阅读被讨论，所以这是

1069
00:49:49,260 --> 00:49:51,410
 

1070
00:49:52,080 --> 00:49:56,610
 

1071
00:49:58,430 --> 00:50:00,490
你的一致性证明，

1072
00:50:05,749 --> 00:50:08,069
所以这里的游戏是让我们

1073
00:50:08,069 --> 00:50:12,299
签署树头 H 1 和 H 2，我们在

1074
00:50:12,299 --> 00:50:22,619
问 是 h 1s 日志前缀真的

1075
00:50:22,619 --> 00:50:24,659
不是这些 - 这些是哈希，所以它

1076
00:50:24,659 --> 00:50:26,669
真的在询问

1077
00:50:26,669 --> 00:50:38,489
哈希所代表的日志，你知道我们

1078
00:50:38,489 --> 00:50:40,380
希望答案是肯定的，如果

1079
00:50:40,380 --> 00:50:41,789
答案不是，这意味着日志

1080
00:50:41,789 --> 00:50:43,649
服务器 Fork Dustin 是

1081
00:50:43,649 --> 00:50:51,059
向一方或另一方隐瞒一些事情好吧，

1082
00:50:51,059 --> 00:50:54,089
事实证明，正如我

1083
00:50:54,089 --> 00:50:57,269
之前提到的那样，随着默克尔树随着原木的

1084
00:50:57,269 --> 00:50:59,519
生长，默克尔树也在生长，

1085
00:50:59,519 --> 00:51:03,569
我们看到的是一系列树头的迹象，

1086
00:51:03,569 --> 00:51:11,279
每个树头作为 一个日志的大小加倍，

1087
00:51:11,279 --> 00:51:14,939
每个日志都有它的左边的东西

1088
00:51:14,939 --> 00:51:17,789
让我画出

1089
00:51:17,789 --> 00:51:20,729
这个哈希函数的实际哈希函数正在对两

1090
00:51:20,729 --> 00:51:23,929
件事进行哈希处理这个哈希函数的结果

1091
00:51:24,079 --> 00:51:27,149
是下一个符号

1092
00:51:27,149 --> 00:51:28,949
树头的输入之一结果 这个哈希

1093
00:51:28,949 --> 00:51:30,959
函数是一个 o  f

1094
00:51:30,959 --> 00:51:34,999
下一个符号树头的输入我知道我们得到了

1095
00:51:34,999 --> 00:51:42,209
这种生命之树

1096
00:51:42,209 --> 00:51:45,509
符号树头，如果它们是合法的，我需要对树头进行签名

1097
00:51:45,509 --> 00:51:47,549
你知道如果每个

1098
00:51:47,549 --> 00:51:49,079
都是 log 是 H 2 的前缀

1099
00:51:49,079 --> 00:51:50,759
意味着也许这个是 H 1 和这个是

1100
00:51:50,759 --> 00:51:52,619
H 2 并且他们会有这种

1101
00:51:52,619 --> 00:51:55,499
关系，如果每个人

1102
00:51:55,499 --> 00:51:57,449
都是 H 2 的一部分，那么他们必须有

1103
00:51:57,449 --> 00:51:59,429
这种关系，其中每个 2 是

1104
00:51:59,429 --> 00:52:02,219
通过对每个人进行散列来

1105
00:52:02,219 --> 00:52:04,589
产生的 一些其他的东西，也许

1106
00:52:04,589 --> 00:52:06,719
用其他的东西来散列，

1107
00:52:06,719 --> 00:52:10,830
直到我们找到 H 2 并且

1108
00:52:10,830 --> 00:52:14,940
意味着如果浏览器或监视器

1109
00:52:14,940 --> 00:52:20,310
向日志服务器挑战日志以

1110
00:52:20,310 --> 00:52:23,460
证明每个人的日志确实是 h2s 的前缀

1111
00:52:23,460 --> 00:52:27,720
记录日志服务器必须

1112
00:52:27,720 --> 00:52:31,860
生成的是从 h1 到 h2

1113
00:52:31,860 --> 00:52:34,440
的过程中每个 Hat 符号树

1114
00:52:34,440 --> 00:52:39,200
头哈希的另一侧的序列，

1115
00:52:39,200 --> 00:52:43,140
这是证明，然后你又

1116
00:52:43,140 --> 00:52:46,040
知道这让人想起

1117
00:52:46,040 --> 00:52:51,020
包含证明 要检查

1118
00:52:51,020 --> 00:52:54,180
您需要获取每个哈希的证明 它与

1119
00:52:54,180 --> 00:52:57,150
你知道的第一件事一起散列，

1120
00:52:57,150 --> 00:52:58,680
与第二件事一起，

1121
00:52:58,680 --> 00:53:00,630
你得到最后一个

1122
00:53:00,630 --> 00:53:03,360
，最好等于 h2，如果

1123
00:53:03,360 --> 00:53:08,940
它证明 h2 是每个的后缀，

1124
00:53:08,940 --> 00:53:13,280
否则日志 服务器显然

1125
00:53:13,280 --> 00:53:18,630
试图分叉你，你又一次

1126
00:53:18,630 --> 00:53:22,790
知道，这是因为没有其他人

1127
00:53:22,790 --> 00:53:25,980
你知道 h2 真的不是假设 h1

1128
00:53:25,980 --> 00:53:29,970
不是 h2 的前缀，所以不可能，

1129
00:53:29,970 --> 00:53:34,530
因为 h2 是从一些实际的

1130
00:53:34,530 --> 00:53:36,720
日志创建的 与 h1

1131
00:53:36,720 --> 00:53:40,400
不同，日志服务器无法计算出

1132
00:53:40,400 --> 00:53:44,910
导致哈希值所需的这些值

1133
00:53:44,910 --> 00:53:47,220
 

1134
00:53:47,220 --> 00:53:50,910
 

1135
00:53:50,910 --> 00:53:53,880
 

1136
00:53:53,880 --> 00:53:55,890
不同的

1137
00:53:55,890 --> 00:53:59,210
输入产生相同的结果

1138
00:54:02,930 --> 00:54:06,230
好的，所以这是日志

1139
00:54:06,230 --> 00:54:12,710
一致性证明 好的，所以问题

1140
00:54:12,710 --> 00:54:14,420
是谁通常会挑战日志服务器，

1141
00:54:14,420 --> 00:54:15,890
所以我会在一分钟内真正讨论这个问题，

1142
00:54:15,890 --> 00:54:19,030
但事实证明，嗯，

1143
00:54:19,030 --> 00:54:24,339
浏览器和监视器都

1144
00:54:25,160 --> 00:54:28,560
很好 Lu  ke 浏览器和监视器

1145
00:54:28,560 --> 00:54:30,090
挑战日志服务器，

1146
00:54:30,090 --> 00:54:31,770
实际上通常是浏览器

1147
00:54:31,770 --> 00:54:33,600
挑战日志服务器，这是

1148
00:54:33,600 --> 00:54:35,460
最重要的事情，但有两个

1149
00:54:35,460 --> 00:54:36,600
时间点需要

1150
00:54:36,600 --> 00:54:37,920
挑战日志服务器以生成

1151
00:54:37,920 --> 00:54:41,220
这些证明，我将讨论两者

1152
00:54:41,220 --> 00:55:00,630
实际上，它们都很好，所以

1153
00:55:00,630 --> 00:55:06,030
首先将

1154
00:55:06,030 --> 00:55:07,920
这些证明用于八卦作为八卦的

1155
00:55:07,920 --> 00:55:11,250
一部分，正如我概述

1156
00:55:11,250 --> 00:55:12,780
的那样，用于八卦的方案是

1157
00:55:12,780 --> 00:55:16,770
浏览器将定期

1158
00:55:16,770 --> 00:55:18,690
与某些集合的某个中央存储库对话

1159
00:55:18,690 --> 00:55:22,860
中央存储库的数量，并且只是

1160
00:55:22,860 --> 00:55:24,900
为标志

1161
00:55:24,900 --> 00:55:28,080
树头池做出

1162
00:55:28,080 --> 00:55:30,900
 

1163
00:55:30,900 --> 00:55:34,040
 

1164
00:55:34,040 --> 00:55:36,510
 

1165
00:55:36,510 --> 00:55:37,920
 

1166
00:55:37,920 --> 00:55:39,630
贡献 池，它将是其中的多个

1167
00:55:39,630 --> 00:55:41,520
收集这些池由

1168
00:55:41,520 --> 00:55:43,530
不同的人经营，因此如果其中一个人

1169
00:55:43,530 --> 00:55:46,710
在作弊，那将是针对

1170
00:55:46,710 --> 00:55:51,120
然后浏览器将针对

1171
00:55:51,120 --> 00:55:53,370
任何随机符号树

1172
00:55:53,370 --> 00:55:56,420
从池中取出它，它会

1173
00:55:56,420 --> 00:55:59,100
要求日志服务器

1174
00:55:59,100 --> 00:56:01,020
为那对符号树头生成日志坚持性证明

1175
00:56:01,020 --> 00:56:03,570
，你知道如果没有人的

1176
00:56:03,570 --> 00:56:06,540
作弊设计，它应该始终是

1177
00:56:06,540 --> 00:56:09,240
日志服务器很容易生成您

1178
00:56:09,240 --> 00:56:12,660
知道需要它的任何一致性证明，

1179
00:56:12,660 --> 00:56:15,630
但是如果它是为某人假设的，

1180
00:56:15,630 --> 00:56:18,090
那么日志服务器是为某人提供的，并给

1181
00:56:18,090 --> 00:56:19,170
他们一个标志树，这确实

1182
00:56:19,170 --> 00:56:21,240
描述了一个完全不同的日志，

1183
00:56:21,240 --> 00:56:22,860
甚至是很长的差异

1184
00:56:22,860 --> 00:56:25,500
日志中的一个元素，

1185
00:56:25,500 --> 00:56:27,450
其他人最终都会看到，浏览器

1186
00:56:27,450 --> 00:56:30,750
将贡献那个标志树

1187
00:56:30,750 --> 00:56:34,170
头到池八卦池然后

1188
00:56:34,170 --> 00:56:36,180
最终其他人

1189
00:56:36,180 --> 00:56:38,099
我们会将标志托盘头

1190
00:56:38,099 --> 00:56:41,039
从池中拉出并要求你知道的证据

1191
00:56:41,039 --> 00:56:42,390
其他一些符号树

1192
00:56:42,390 --> 00:56:43,980
可能位于不同的 Fork 上，

1193
00:56:43,980 --> 00:56:46,980
然后日志服务器将无法

1194
00:56:46,980 --> 00:56:49,859
生成证明，我是因为它们是

1195
00:56:49,859 --> 00:56:52,049
自科学家签名或由 t 签名的

1196
00:56:52,049 --> 00:56:55,230
他的日志服务器只是绝对

1197
00:56:55,230 --> 00:56:59,849
证明日志服务器已经分叉

1198
00:56:59,849 --> 00:57:02,270
了它的两个客户端，大概是有意向

1199
00:57:02,270 --> 00:57:05,220
其中一个显示伪造的证书

1200
00:57:05,220 --> 00:57:09,869
并将其隐藏起来，

1201
00:57:09,869 --> 00:57:11,279
但实际上在另一个地方

1202
00:57:11,279 --> 00:57:15,270
你需要这些一致性

1203
00:57:15,270 --> 00:57:18,180
证明 不仅在八卦

1204
00:57:18,180 --> 00:57:19,380
期间，而且实际上在浏览器的普通操作期间也是

1205
00:57:19,380 --> 00:57:28,349
如此，所以

1206
00:57:28,349 --> 00:57:31,410
困难在于假设您知道

1207
00:57:31,410 --> 00:57:33,539
假设浏览器是一种

1208
00:57:33,539 --> 00:57:36,779
看到一致版本的日志

1209
00:57:36,779 --> 00:57:39,930
与其他人一样但是日志

1210
00:57:39,930 --> 00:57:41,609
服务器想要欺骗它 使用这个

1211
00:57:41,609 --> 00:57:48,930
伪造的证书，所以日志服务器

1212
00:57:48,930 --> 00:57:52,319
向它发送一个你知道的签名树，这使得

1213
00:57:52,319 --> 00:57:53,579
签名 RIA 与其他人不同，

1214
00:57:53,579 --> 00:57:56,150
它引用了一个你知道的

1215
00:57:56,150 --> 00:57:58,260
恶意日志，其中包含这个错误的

1216
00:57:58,260 --> 00:57:59,700
证书首选视频，因为它

1217
00:57:59,700 --> 00:58:00,779
 

1218
00:58:00,779 --> 00:58:02,309
肯定不希望其他人注意到 不希望您知道

1219
00:58:02,309 --> 00:58:04,470
监视器注意到您

1220
00:58:04,470 --> 00:58:07,500
知道制作另一个日志，这是其他

1221
00:58:07,500 --> 00:58:12,569
人都可以看到的，所以现在 你

1222
00:58:12,569 --> 00:58:16,380
知道浏览器检查并看到你

1223
00:58:16,380 --> 00:58:18,270
知道我要求包含证明和

1224
00:58:18,270 --> 00:58:20,190
包含日志服务器将

1225
00:58:20,190 --> 00:58:21,539
能够产生包含证明，因为

1226
00:58:21,539 --> 00:58:23,520
这个标志树有浏览器

1227
00:58:23,520 --> 00:58:25,859
确实引用了这个坏日志，

1228
00:58:25,859 --> 00:58:27,990
浏览器将继续执行并且 使用这个伪造的

1229
00:58:27,990 --> 00:58:30,089
证书，可能会被欺骗

1230
00:58:30,089 --> 00:58:31,470
并泄露用户的密码，

1231
00:58:31,470 --> 00:58:36,450
你知道谁知道，但取决于

1232
00:58:36,450 --> 00:58:38,400
其他浏览器工作的细节，我们

1233
00:58:38,400 --> 00:58:40,529
有可能在下次浏览

1234
00:58:40,529 --> 00:58:42,480
器没有意识到任何错误的情况下与之

1235
00:58:42,480 --> 00:58:44,279
交谈 日志服务器 日志

1236
00:58:44,279 --> 00:58:46,410
服务器可能会说你知道有一个

1237
00:58:46,410 --> 00:58:47,910
新日志，上面有一堆新东西

1238
00:58:47,910 --> 00:58:49,930
，这是当前日志的标志树

1239
00:58:49,930 --> 00:58:52,809
，你为什么不切换

1240
00:58:52,809 --> 00:58:54,880
我来使用它作为你的标志树命中

1241
00:58:54,880 --> 00:58:59,170
等等 现在，如果允许这种情况发生，

1242
00:58:59,170 --> 00:59:01,569
那么浏览器的 now 将完全

1243
00:59:01,569 --> 00:59:03,339
失去任何错误的证据，

1244
00:59:03,339 --> 00:59:04,869
因为现在浏览器正在

1245
00:59:04,869 --> 00:59:06,940
使用相同的树，其他人不，它会将

1246
00:59:06,940 --> 00:59:08,500
这个标志树头贡献

1247
00:59:08,500 --> 00:59:10,779
给 g  ossip pool 这一切都会

1248
00:59:10,779 --> 00:59:15,279
很好看，我们有这种简短的邪恶

1249
00:59:15,279 --> 00:59:17,559
树，它是邪恶的日志，被揭示了

1250
00:59:17,559 --> 00:59:20,349
邪恶的日志叉，但如果浏览器

1251
00:59:20,349 --> 00:59:22,630
愿意接受一个新的标志树头，

1252
00:59:22,630 --> 00:59:25,750
那么我们基本上可以让浏览器

1253
00:59:25,750 --> 00:59:30,369
忘记，所以我们 想要我们想要

1254
00:59:30,369 --> 00:59:34,210
的就是我们想要的如果浏览器

1255
00:59:34,210 --> 00:59:38,279
如果日志服务向浏览器显示特定的

1256
00:59:38,279 --> 00:59:41,470
日志浏览器

1257
00:59:41,470 --> 00:59:43,809
他们无法欺骗浏览器

1258
00:59:43,809 --> 00:59:46,150
切换离开

1259
00:59:46,150 --> 00:59:48,819
我们希望能够的日志

1260
00:59:48,819 --> 00:59:52,779
强制浏览器只

1261
00:59:52,779 --> 00:59:55,619
看到它已经看到的日志的严格扩展，而

1262
00:59:55,619 --> 00:59:57,819
不是简单地切换到

1263
00:59:57,819 --> 01:00:00,190
与

1264
01:00:00,190 --> 01:00:01,960
浏览器在它

1265
01:00:01,960 --> 01:00:03,279
是我们正在寻找的属性之前看到

1266
01:00:03,279 --> 01:00:12,010
的日志不兼容的日志。 与

1267
01:00:12,010 --> 01:00:14,500
前两个的一致性是，如果浏览器被

1268
01:00:14,500 --> 01:00:16,480
分叉到与其他人不同的分叉上，

1269
01:00:16,480 --> 01:00:18,970
那么他们必须留在那个分叉

1270
01:00:18,970 --> 01:00:22,830
上，它永远不能切换

1271
01:00:22,830 --> 01:00:25,270
到主分叉，原因

1272
01:00:25,270 --> 01:00:27,370
是我们想要 为了保护你需要

1273
01:00:27,370 --> 01:00:29,860
保留这个坏的标志树头及其

1274
01:00:29,860 --> 01:00:33,370
后继者，这样当浏览器

1275
01:00:33,370 --> 01:00:36,760
参与八卦协议时，它会

1276
01:00:36,760 --> 01:00:41,500
提供其他人没有的标志树头，

1277
01:00:41,500 --> 01:00:44,380
并且不能使用日志一致性证明来证明它是

1278
01:00:44,380 --> 01:00:46,450
兼容的，

1279
01:00:46,450 --> 01:00:48,220
好吧，那怎么办 我们

1280
01:00:48,220 --> 01:00:52,000
很好地实现了一致性 嗯，

1281
01:00:52,000 --> 01:00:53,740
每次日志服务器告诉浏览器时，使用我们现在拥有的工具实际上很容易

1282
01:00:53,740 --> 01:00:56,470
哦，这是

1283
01:00:56,470 --> 01:00:58,330
一个新的符号树头，用于更长的

1284
01:00:58,330 --> 01:01:01,930
日志，浏览器将需要

1285
01:01:01,930 --> 01:01:04,890
在日志出现之前不会接受新的符号树头

1286
01:01:04,890 --> 01:01:08,230
服务器已经产生了一个日志

1287
01:01:08,230 --> 01:01:10,210
一致性证明，新符号树

1288
01:01:10,210 --> 01:01:15,550
头描述了旧符号树的后缀，即旧

1289
01:01:15,550 --> 01:01:17,560
 

1290
01:01:17,560 --> 01:01:19,510
符号树的日志具有

1291
01:01:19,510 --> 01:01:21,760
新符号树日志的前缀，当然如果日志

1292
01:01:21,760 --> 01:01:24,250
服务器 就像浏览器分叉一样，它

1293
01:01:24,250 --> 01:01:26,620
使浏览器保持在同一个分叉上，它

1294
01:01:26,620 --> 01:01:28,930
可以产生证明，但当然你

1295
01:01:28,930 --> 01:01:30,880
知道它正在挖掘它的坟墓更深，

1296
01:01:30,880 --> 01:01:33,370
因为我正在生产越来越多的

1297
01:01:33,370 --> 01:01:35,800
标志树，他

1298
01:01:35,800 --> 01:01:37,120
最终会被 gossip 协议捕获的广告，

1299
01:01:37,120 --> 01:01:40,060
而如果博客服务器

1300
01:01:40,060 --> 01:01:43,960
试图使浏览器切换到

1301
01:01:43,960 --> 01:01:45,970
描述相同日志的标志树头，

1302
01:01:45,970 --> 01:01:48,700
其他人已经看到

1303
01:01:48,700 --> 01:01:50,500
浏览器将要求一致性证明

1304
01:01:50,500 --> 01:01:52,930
和日志服务器 将无法

1305
01:01:52,930 --> 01:01:55,240
产生它，因为

1306
01:01:55,240 --> 01:01:57,070
第一个符号树头

1307
01:01:57,070 --> 01:02:00,610
描述的日志不是第二个符号树描述的日志的前缀

1308
01:02:00,610 --> 01:02:03,270
 

1309
01:02:05,110 --> 01:02:11,600
好的 好的，所以系统这些日志

1310
01:02:11,600 --> 01:02:13,400
一致性证明提供了

1311
01:02:13,400 --> 01:02:15,980
一致性和一致性加上

1312
01:02:15,980 --> 01:02:20,540
八卦和 要求这种日志

1313
01:02:20,540 --> 01:02:23,390
一致性证明了通过八卦发现的科学

1314
01:02:23,390 --> 01:02:24,230
 

1315
01:02:24,230 --> 01:02:27,590
我是他们两个在一起

1316
01:02:27,590 --> 01:02:31,490
使得所有参与者很可能

1317
01:02:31,490 --> 01:02:33,350
看到相同的日志，并且如果他们

1318
01:02:33,350 --> 01:02:34,970
没有看到相同的日志，他们将

1319
01:02:34,970 --> 01:02:38,720
能够检测到 日志一致性证明失败的事实

1320
01:02:38,720 --> 01:02:42,100
 

1321
01:02:45,400 --> 01:02:48,450
任何问题都

1322
01:02:53,579 --> 01:02:58,029
可以，所以有多少日志服务

1323
01:02:58,029 --> 01:02:59,380
这是一个很好的问题，

1324
01:02:59,380 --> 01:03:02,319
所以我将系统描述为好像

1325
01:03:02,319 --> 01:03:03,730
只有一个 lo  g server 事实证明，在

1326
01:03:03,730 --> 01:03:05,680
实际系统中有很多日志服务器

1327
01:03:05,680 --> 01:03:07,660
，至少有几十个，所以这是一个部署的

1328
01:03:07,660 --> 01:03:09,940
系统，您可以在其中编程

1329
01:03:09,940 --> 01:03:12,130
，实际上由 Chrome 使用，我认为

1330
01:03:12,130 --> 01:03:15,880
Safari 至少有几十个

1331
01:03:15,880 --> 01:03:17,769
这样的日志服务器，当证书

1332
01:03:17,769 --> 01:03:19,180
并且chrome实际上要求证书颁发机构将

1333
01:03:19,180 --> 01:03:21,009
其所有

1334
01:03:21,009 --> 01:03:25,660
证书提交给日志服务器

1335
01:03:25,660 --> 01:03:29,170
到多个日志服务器不同的

1336
01:03:29,170 --> 01:03:30,220
日志服务器实际上并不保留

1337
01:03:30,220 --> 01:03:32,769
相同的日志约定是

1338
01:03:32,769 --> 01:03:34,539
证书颁发机构将提交一个新

1339
01:03:34,539 --> 01:03:37,210
证书以保存您知道 一对夫妇

1340
01:03:37,210 --> 01:03:41,190
可能有五个不同的日志服务器，

1341
01:03:41,190 --> 01:03:44,140
实际上在

1342
01:03:44,140 --> 01:03:46,299
网站告诉您的浏览器的证书信息中，它

1343
01:03:46,299 --> 01:03:50,319
包括证书透明度日志服务器的日志服务器的身份，这些日志服务器

1344
01:03:50,319 --> 01:03:52,089
 

1345
01:03:52,089 --> 01:03:54,730
在其日志中包含证书，

1346
01:03:54,730 --> 01:03:56,799
因此您的浏览器知道

1347
01:03:56,799 --> 01:04:01,359
要与哪些日志服务器通信，并且

1348
01:04:01,359 --> 01:04:03,369
有不止一个的原因

1349
01:04:03,369 --> 01:04:05,170
当然是其中一些可能会变坏，

1350
01:04:05,170 --> 01:04:06,999
其中一些可能会变成 ma  licious

1351
01:04:06,999 --> 01:04:09,489
或倒闭或谁知道什么，在

1352
01:04:09,489 --> 01:04:10,749
这种情况下，您仍然希望有

1353
01:04:10,749 --> 01:04:15,339
更多的依靠

1354
01:04:15,339 --> 01:04:17,440
它们不必相同，因为

1355
01:04:17,440 --> 01:04:20,349
只要证书

1356
01:04:20,349 --> 01:04:23,739
至少在一个日志中，它们就不必相同 这就是你知道的，就

1357
01:04:23,739 --> 01:04:25,779
任何人都知道是值得信赖的，

1358
01:04:25,779 --> 01:04:32,829
 

1359
01:04:32,829 --> 01:04:33,140
 

1360
01:04:33,140 --> 01:04:36,109
 

1361
01:04:36,109 --> 01:04:37,730
这就足够了，因为你知道这里的问题并不一定是日志中有证书的事实，因为

1362
01:04:37,730 --> 01:04:40,549
这并不能证明证书是

1363
01:04:40,549 --> 01:04:43,250
好的，我们正在寻找的只是日志

1364
01:04:43,250 --> 01:04:47,750
服务器 不会对监视器

1365
01:04:47,750 --> 01:04:50,960
和使用它们的浏览器进行分叉，因此

1366
01:04:50,960 --> 01:04:52,789
证书即使在

1367
01:04:52,789 --> 01:04:56,599
没有分叉的单个日志服务器中也足够了，

1368
01:04:56,599 --> 01:04:58,819
因为监视器可以

1369
01:04:58,819 --> 01:04:59,930
保证看到它，因为

1370
01:04:59,930 --> 01:05:04,460
监视器会检查所有日志服务器，所以如果

1371
01:05:04,460 --> 01:05:06,260
是伪造的 证书甚至会显示

1372
01:05:06,260 --> 01:05:07,970
一个日志服务器，监视器

1373
01:05:07,970 --> 01:05:10,549
最终会注意到，因为所有

1374
01:05:10,549 --> 01:05:15,200
监视器都会查看

1375
01:05:15,200 --> 01:05:18,609
浏览器愿意接受的

1376
01:05:18,609 --> 01:05:22,250
所有日志服务器，另一个问题是什么阻止

1377
01:05:22,250 --> 01:05:25,309
了 记录服务器停止运行并

1378
01:05:25,309 --> 01:05:28,490
在被抓到之前颁发假证书，

1379
01:05:28,490 --> 01:05:31,190
如果你愿意的话，你实际上一无所知

1380
01:05:31,190 --> 01:05:34,400
，这绝对是

1381
01:05:34,400 --> 01:05:36,559
系统中的一个缺陷，至少在一段

1382
01:05:36,559 --> 01:05:38,869
时间内你可以

1383
01:05:38,869 --> 01:05:43,640
恶意记录服务器提供假

1384
01:05:43,640 --> 01:05:44,720
证书，所以如果你有

1385
01:05:44,720 --> 01:05:47,420
证书 变成

1386
01:05:47,420 --> 01:05:49,609
恶意的权威，并且颁发伪造的

1387
01:05:49,609 --> 01:05:51,920
证书，它们看起来是正确的，但

1388
01:05:51,920 --> 01:05:59,059
它们是伪造的，并且是日志服务器，

1389
01:05:59,059 --> 01:06:00,589
然后愿意为这些服务提供服务，它

1390
01:06:00,589 --> 01:06:01,849
愿意将这些证书放入

1391
01:06:01,849 --> 01:06:04,009
日志中，当然它们

1392
01:06:04,009 --> 01:06:05,779
至少在一段时间内都是浏览器 会

1393
01:06:05,779 --> 01:06:07,160
愿意使用它们的事情是，

1394
01:06:07,160 --> 01:06:09,440
虽然你知道他们会被抓住

1395
01:06:09,440 --> 01:06:12,170
，这是系统的目的

1396
01:06:12,170 --> 01:06:15,440
是改善牧师的情况

1397
01:06:15,440 --> 01:06:17,930
或建立一个透明系统，如果

1398
01:06:17,930 --> 01:06:19,759
有人签发伪造的证书

1399
01:06:19,759 --> 01:06:21,410
和浏览器正在被 被骗

1400
01:06:21,410 --> 01:06:23,630
使用它们，你可能永远不会

1401
01:06:23,630 --> 01:06:26,299
在证书透明度世界中

1402
01:06:26,299 --> 01:06:28,460
发现，你可能不会马上发现，所以

1403
01:06:28,460 --> 01:06:31,000
有些人 可能会使用它们，但

1404
01:06:31,000 --> 01:06:32,960
很快你就会知道几天

1405
01:06:32,960 --> 01:06:35,059
或者监视器会开始

1406
01:06:35,059 --> 01:06:37,130
注意到日志中有错误的

1407
01:06:37,130 --> 01:06:39,829
证书，有人会去追踪

1408
01:06:39,829 --> 01:06:41,990
它并找出谁是恶意的

1409
01:06:41,990 --> 01:06:45,009
或谁在犯错误

1410
01:06:52,740 --> 01:06:56,849
是的，所以我猜 证书

1411
01:06:56,849 --> 01:06:58,470
证书透明度法可以

1412
01:06:58,470 --> 01:07:02,099
拒绝与监视器交谈 是的 我

1413
01:07:02,099 --> 01:07:08,250
不确定我最终认为如果你

1414
01:07:08,250 --> 01:07:09,599
知道我们现在正在进入一种

1415
01:07:09,599 --> 01:07:11,940
非技术领域

1416
01:07:11,940 --> 01:07:13,950
如果有证据表明某些事情

1417
01:07:13,950 --> 01:07:15,809
已经消失了你知道该怎么做 错误 这实际上很难，

1418
01:07:15,809 --> 01:07:18,270
因为很多时候

1419
01:07:18,270 --> 01:07:20,010
似乎出了问题，即使是伪造的

1420
01:07:20,010 --> 01:07:22,920
证书也常常是因为这

1421
01:07:22,920 --> 01:07:24,329
只是某人犯了一个错误，这是一个

1422
01:07:24,329 --> 01:07:26,490
合法的错误，你知道有人

1423
01:07:26,490 --> 01:07:28,859
搞砸了，这不是恶意的证据，

1424
01:07:28,859 --> 01:07:31,160
只是有人 犯了一个错误我

1425
01:07:31,160 --> 01:07:33,480
认为如果监视器

1426
01:07:33,480 --> 01:07:35,880
几乎以任何方式行为

1427
01:07:35,880 --> 01:07:37,800
不端会发生什么

1428
01:07:37,800 --> 01:07:41,460
 

1429
01:07:41,460 --> 01:07:43,859
情况 塑造或将它们

1430
01:07:43,859 --> 01:07:44,339
从列表中删除

1431
01:07:44,339 --> 01:07:46,410
停止使用它们，浏览器供应商会

1432
01:07:46,410 --> 01:07:48,690
 

1433
01:07:48,690 --> 01:07:50,760
在一段时间后将她从可接受的日志服务器列表中注销，

1434
01:07:50,760 --> 01:07:53,880
但是是的，就像一个灰色区域的不良

1435
01:07:53,880 --> 01:07:56,190
行为还不够

1436
01:07:56,190 --> 01:07:57,299
糟糕 从

1437
01:07:57,299 --> 01:08:00,630
可接受的列表中取出 我认为日志服务器

1438
01:08:00,630 --> 01:08:01,980
已被发现可以工作 问题

1439
01:08:01,980 --> 01:08:03,180
是如果在发生事情之前已经找到了日志服务器，

1440
01:08:03,180 --> 01:08:07,650
那么我认为我

1441
01:08:07,650 --> 01:08:09,030
认为会发生的事情是

1442
01:08:09,030 --> 01:08:11,760
运行的人你知道那些 浏览器

1443
01:08:11,760 --> 01:08:15,720
供应商会与日志服务器交谈并

1444
01:08:15,720 --> 01:08:17,100
询问他们运行日志

1445
01:08:17,100 --> 01:08:19,979
服务器的人员并询问他们发生了什么以及

1446
01:08:19,979 --> 01:08:21,029
他们是否提出了一个令人信服的

1447
01:08:21,029 --> 01:08:22,410
解释他们没有

1448
01:08:22,410 --> 01:08:24,929
犯错误你知道也许他们

1449
01:08:24,929 --> 01:08:26,729
不能也许我 不知道他们他们的

1450
01:08:26,729 --> 01:08:28,620
机器崩溃了它丢失了他们的部分

1451
01:08:28,620 --> 01:08:31,469
日志他们重新启动你知道从

1452
01:08:31,469 --> 01:08:34,529
日志的前缀开始并开始增长

1453
01:08:34,529 --> 01:08:37,830
不同的日志如果这看起来像是一个错误

1454
01:08:37,830 --> 01:08:41,250
诚实的错误那么这是一个

1455
01:08:41,250 --> 01:08:44,339
错误但如果它 如果日志服务器

1456
01:08:44,339 --> 01:08:46,529
运营商无法

1457
01:08:46,529 --> 01:08:48,299
对所发生的事情提供令人信服的解释，那么我

1458
01:08:48,299 --> 01:08:49,859
认为浏览器供应商只会

1459
01:08:49,859 --> 01:08:53,210
将它们从可接受的 klog 服务器列表中删除，

1460
01:08:53,640 --> 01:09:02,600
但是这些你知道

1461
01:09:02,600 --> 01:09:06,240
这些是系统的问题，

1462
01:09:06,240 --> 01:09:09,330
因为你可以

1463
01:09:09,330 --> 01:09:11,340
知道谁拥有一个名字或

1464
01:09:11,340 --> 01:09:13,020
什么可以接受的定义，但你知道

1465
01:09:13,020 --> 01:09:14,729
你的服务器是否可以关闭

1466
01:09:14,729 --> 01:09:18,470
这些很难确定

1467
01:09:18,470 --> 01:09:24,720
属性你知道我认为

1468
01:09:24,720 --> 01:09:26,819
系统没有满你肯定可以

1469
01:09:26,819 --> 01:09:28,500
侥幸逃脱 至少有一段

1470
01:09:28,500 --> 01:09:32,220
时间的行为，但希望这里有

1471
01:09:32,220 --> 01:09:35,990
足够强大的审计，如果某些

1472
01:09:35,990 --> 01:09:39,090
证书颁发机构或日志服务器

1473
01:09:39,090 --> 01:09:42,840
持续表现不佳，人们

1474
01:09:42,840 --> 01:09:44,220
会注意到监视器会注意到

1475
01:09:44,220 --> 01:09:45,720
他们可能暂时不会做任何事情，但

1476
01:09:45,720 --> 01:09:50,040
最终他们会决定 你

1477
01:09:50,040 --> 01:09:52,200
知道你要么太痛苦，

1478
01:09:52,200 --> 01:09:54,229
要么恶意成为系统的一部分，

1479
01:09:54,229 --> 01:09:58,440
然后将你从浏览器列表中删除，

1480
01:09:58,440 --> 01:09:59,910
当然他们会拆分浏览器销售 ors

1481
01:09:59,910 --> 01:10:03,060
处于非常强大的位置，所以

1482
01:10:03,060 --> 01:10:04,320
哇，系统通常非常

1483
01:10:04,320 --> 01:10:06,150
分散，是的，可能有

1484
01:10:06,150 --> 01:10:08,270
很多证书颁发机构和

1485
01:10:08,270 --> 01:10:10,470
证书透明度日志服务器

1486
01:10:10,470 --> 01:10:12,540
，只有少数浏览器

1487
01:10:12,540 --> 01:10:15,450
供应商，因为他们

1488
01:10:15,450 --> 01:10:17,880
维护着可接受的

1489
01:10:17,880 --> 01:10:21,900
证书列表 权威机构和日志服务器

1490
01:10:21,900 --> 01:10:26,390
他们确实有很大的权力，你知道

1491
01:10:26,390 --> 01:10:31,110
这是不幸的方式，所以

1492
01:10:31,110 --> 01:10:35,490
可以从证书透明度设计中拿走一些东西，

1493
01:10:35,490 --> 01:10:38,100
所以一件事是

1494
01:10:38,100 --> 01:10:40,680
它具有的关键属性非常重要，

1495
01:10:40,680 --> 01:10:43,850
就是每个人都看到相同的日志

1496
01:10:43,850 --> 01:10:46,170
即使某些方是

1497
01:10:46,170 --> 01:10:48,420
恶意的，要么每个人都看到相同的

1498
01:10:48,420 --> 01:10:50,190
长度，要么他们可以

1499
01:10:50,190 --> 01:10:53,310
从失败的证据中积累证据，证明

1500
01:10:53,310 --> 01:10:55,080
正在发生一些有趣的事情，因为

1501
01:10:55,080 --> 01:10:56,280
使用这些

1502
01:10:56,280 --> 01:10:59,280
证书的浏览器和运行监视器的 DNS 名称的所有者都会

1503
01:10:59,280 --> 01:11:01,830
看到

1504
01:11:01,830 --> 01:11:05,949
由于这些

1505
01:11:05,949 --> 01:11:08,530
证明，监视器可以检测到相同的日志，因此即使浏览器也可以检测到问题

1506
01:11:08,530 --> 01:11:10,060
 

1507
01:11:10,060 --> 01:11:11,860
服务人员实际上无法检测到伪造的

1508
01:11:11,860 --> 01:11:13,390
证书，他们至少可以

1509
01:11:13,390 --> 01:11:14,980
确信，如果那里有伪造的

1510
01:11:14,980 --> 01:11:16,570
证书，监视器

1511
01:11:16,570 --> 01:11:19,510
会检测到它们，并可能将它们

1512
01:11:19,510 --> 01:11:20,800
放在吊销列表中，实际上，

1513
01:11:20,800 --> 01:11:23,830
如果有监视器发现的证据，我没有提到

1514
01:11:23,830 --> 01:11:26,620
 

1515
01:11:26,620 --> 01:11:29,199
像麻省理工学院这样的伪造证书一定是

1516
01:11:29,199 --> 01:11:32,260
他们不知道

1517
01:11:32,260 --> 01:11:34,870
为麻省理工学院颁发证书的人，你是否

1518
01:11:34,870 --> 01:11:35,940
发现有一个预先存在的

1519
01:11:35,940 --> 01:11:38,739
撤销服务，你可以

1520
01:11:38,739 --> 01:11:41,469
在浏览器的检查中放置错误的证书，

1521
01:11:41,469 --> 01:11:44,410
这样如果监视器看到 一个伪造的证书

1522
01:11:44,410 --> 01:11:46,179
实际上可以

1523
01:11:46,179 --> 01:11:49,350
通过将其放入吊销

1524
01:11:49,350 --> 01:11:51,880
证书吊销系统中来有效地禁用它不是

1525
01:11:51,880 --> 01:11:53,440
证书透明度的一部分 它

1526
01:11:53,440 --> 01:11:57,219
已经存在了很长时间了，所以

1527
01:11:57,219 --> 01:11:58,600
关键属性是每个人都看到相同

1528
01:11:58,600 --> 01:12:02,590
的证书日志 另一件事

1529
01:12:02,590 --> 01:12:04,840
要带走 从这一点来看，如果您

1530
01:12:04,840 --> 01:12:07,380
无法找到防止不良行为的方法，

1531
01:12:07,380 --> 01:12:10,260
也许您可​​以构建这些

1532
01:12:10,260 --> 01:12:13,989
可用的依赖于的东西 审计而

1533
01:12:13,989 --> 01:12:16,300
不是阻止它可以

1534
01:12:16,300 --> 01:12:19,330
在可能已经足够好的事实之后发现坏事

1535
01:12:19,330 --> 01:12:21,190
它通常比防止坏事更容易

1536
01:12:21,190 --> 01:12:24,210
 

1537
01:12:24,210 --> 01:12:27,040
在这项工作中存在一些技术思想 一个是

1538
01:12:27,040 --> 01:12:30,040
这种模棱两可的想法，我是一个很大的

1539
01:12:30,040 --> 01:12:33,400
危险是

1540
01:12:33,400 --> 01:12:35,170
恶意服务器提供

1541
01:12:35,170 --> 01:12:38,590
拆分视图的可能性 一个查看一组人

1542
01:12:38,590 --> 01:12:39,969
另一个视图给另一组人

1543
01:12:39,969 --> 01:12:42,070
它通常被称为分叉或

1544
01:12:42,070 --> 01:12:43,870
模棱两可 它是一种重要的

1545
01:12:43,870 --> 01:12:46,570
攻击 另一个属性 这是为了

1546
01:12:46,570 --> 01:12:48,160
一致性属性 它结果证明它

1547
01:12:48,160 --> 01:12:50,199
通常很有价值 当你

1548
01:12:50,199 --> 01:12:52,330
担心分叉构建一个系统时，

1549
01:12:52,330 --> 01:12:55,780
一旦恶意服务器已经

1550
01:12:55,780 --> 01:12:57,670
形成有人将它们保留在该

1551
01:12:57,670 --> 01:13:00,460
分叉上，它就无法通过擦除分叉来擦除证据

1552
01:13:00,460 --> 01:13:03,699
我是最后的技术

1553
01:13:03,699 --> 01:13:06,940
技巧是概念 八卦是

1554
01:13:06,940 --> 01:13:08,710
为了检测，因为它

1555
01:13:08,710 --> 01:13:10,600
实际上是 gen 如果参与者不

1556
01:13:10,600 --> 01:13:13,210
相互交流，

1557
01:13:13,210 --> 01:13:14,650
实际上通常不可能

1558
01:13:14,650 --> 01:13:17,140
注意到有一个 fo  rk 所以如果

1559
01:13:17,140 --> 01:13:18,580
你想检测分叉，就必须

1560
01:13:18,580 --> 01:13:19,870
有一种或另一种方式，

1561
01:13:19,870 --> 01:13:22,020
某种八卦，某种

1562
01:13:22,020 --> 01:13:23,830
双方之间的沟通，这样

1563
01:13:23,830 --> 01:13:26,310
他们就可以比较笔记并检测分叉

1564
01:13:26,310 --> 01:13:30,990
，我们下周会再次看到这些事情中的大部分

1565
01:13:30,990 --> 01:13:36,810
在比特币，

1566
01:13:36,810 --> 01:13:40,710
这就是我要说的

