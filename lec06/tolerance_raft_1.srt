1
00:00:00,670 --> 00:00:06,970
（翻译：Allen, Adam）
（https://github.com/ivanallen/thor）
好啦，咱们开始上课
all right well let's get started

2
00:00:06,970 --> 00:00:10,490
今天和明天我们打算讲讲 RAFT
today and indeed today and tomorrow I'm

3
00:00:10,490 --> 00:00:14,329
今天和明天我们打算讲讲 RAFT
gonna talk about raft both because I

4
00:00:14,329 --> 00:00:16,239
希望这对你后面实现 labs 有所帮助
hope it'll be helpful you for you in

5
00:00:16,239 --> 00:00:19,340
希望这对你后面实现 labs 有所帮助
implementing though the labs and also

6
00:00:19,340 --> 00:00:21,650
咱们会详尽的讨论实现正确的“复制状态机”的相关细节
because you know it's just a case study

7
00:00:21,650 --> 00:00:23,210
咱们会详尽的讨论实现正确的“复制状态机”的相关细节
in the details of how to get state

8
00:00:23,210 --> 00:00:28,550
咱们会详尽的讨论实现正确的“复制状态机”的相关细节
machine replication correct so we have

9
00:00:28,550 --> 00:00:31,070
这些问题之前我们都已经介绍过
introduction to the problem you may have

10
00:00:31,070 --> 00:00:33,949
你可能已经注意到目前为止所有介绍过的容错系统中的模式
noticed a pattern in fault-tolerant

11
00:00:33,949 --> 00:00:35,800
你可能已经注意到目前为止所有介绍过的容错系统中的模式
systems that we've looked at so far

12
00:00:35,800 --> 00:00:40,640
其中之一就是 MapReduce 里的复制方案
one is that MapReduce replicates

13
00:00:40,640 --> 00:00:43,640
但是它的整个复制完全由单个 master 所控制
computation but the replication is

14
00:00:43,640 --> 00:00:45,949
但是它的整个复制完全由单个 master 所控制
controlled the whole computation is

15
00:00:45,949 --> 00:00:50,120
但是它的整个复制完全由单个 master 所控制
controlled by a single master

16
00:00:50,120 --> 00:00:52,129
另一个值得注意的例子是关于 GFS 复制数据
another example I'd like to draw your attention

17
00:00:52,129 --> 00:00:55,339
另一个值得注意的例子是关于 GFS 复制数据
to is that GFS replicates data right as

18
00:00:55,339 --> 00:00:56,780
它通过 primary backup(主备) 方案复制实际文件内容
this primary backup scheme for

19
00:00:56,780 --> 00:00:58,550
它通过 primary backup(主备) 方案复制实际文件内容
replicating the actual contents of files

20
00:00:58,550 --> 00:01:01,489
但这个方案依赖于单一的 master 节点为每一片数据选择 primary
but it relies on a single master to

21
00:01:01,489 --> 00:01:03,710
但这个方案依赖于单一的 master 节点为每一片数据选择 primary
choose who the primary is for every

22
00:01:03,710 --> 00:01:07,909
另一个是 vmware ft 复制方案
piece of data another example vmware ft

23
00:01:07,909 --> 00:01:09,710
它在一台 primary 虚拟机和 backup 虚拟机上执行写入
replicates computational write on a

24
00:01:09,710 --> 00:01:11,840
它在一台 primary 虚拟机和 backup 虚拟机上执行写入
primary virtual machine and a backup

25
00:01:11,840 --> 00:01:14,630
如果它们之一出故障 就需要搞清楚下一步该怎么做
virtual machine but in order to figure

26
00:01:14,630 --> 00:01:16,250
如果它们之一出故障 就需要搞清楚下一步该怎么做
out what to do next if one of them seems

27
00:01:16,250 --> 00:01:19,189
这需要借助 test-and-set 服务器来帮助它选择一台 backup 来接管 primary
to a fail it relies on a single test and

28
00:01:19,189 --> 00:01:22,009
这需要借助 test-and-set 服务器来帮助它选择一台 backup 来接管 primary
set server to help the choose to help it

29
00:01:22,009 --> 00:01:23,719
这需要借助 test-and-set 服务器来帮助它选择一台 backup 来接管 primary
ensure that exactly one of the primary

30
00:01:23,719 --> 00:01:26,180
这需要借助 test-and-set 服务器来帮助它选择一台 backup 来接管 primary
of the backup takes over if there's some kind of failure

31
00:01:26,180 --> 00:01:29,390
这三个案例都有一个复制系统
so in all three of these

32
00:01:29,390 --> 00:01:31,820
这三个案例都有一个复制系统
cases sure there was a replication

33
00:01:31,820 --> 00:01:34,219
它们的复制系统隐藏的比较深
system but sort of tucked away in a

34
00:01:34,219 --> 00:01:36,079
它们的复制系统隐藏的比较深
corner in the replication system there

35
00:01:36,079 --> 00:01:37,880
它们都有一个相同的模式
was some scheme where a single entity

36
00:01:37,880 --> 00:01:40,189
即需要一个单一的“实体”来判定谁是 primary
was required to make a critical decision

37
00:01:40,189 --> 00:01:43,549
即需要一个单一的 entity (实体)来判定谁是 primary
about who the primary was in the cases we care about

None
00:01:43,549 --> 00:01:50,119
单一实体的好处是它能决定谁来当 primary，它不能否定它自己
having a single entity decide who's

40
00:01:50,119 --> 00:01:53,119
单一实体的好处是它能决定谁来当 primary，它不能否定它自己
gonna be the primary is that it can't

41
00:01:53,119 --> 00:01:55,460
单一实体的好处是它能决定谁来当 primary，它不能否定它自己
disagree with itself right there's only

42
00:01:55,460 --> 00:01:57,619
只有它才能做出这个决策
one of it makes some decision that's the

43
00:01:57,619 --> 00:02:00,920
但是这也导致一些缺点，比如会出现单点故障
decision it made but the bad thing about

44
00:02:00,920 --> 00:02:03,020
但是这也导致一些缺点，比如会出现单点故障
having a single entity decide like who

45
00:02:03,020 --> 00:02:04,850
但是这也导致一些缺点，比如会出现单点故障
the primary is is that it itself as a

46
00:02:04,850 --> 00:02:06,590
但是这也导致一些缺点，比如会出现单点故障
single point of failure and so you can

47
00:02:06,590 --> 00:02:08,119
所以你会发现这些系统它把 FT 的真正的核心机制放在一个角落里
view these systems that we've looked at

48
00:02:08,119 --> 00:02:11,950
所以你会发现这些系统它把 FT 的真正的核心机制放在一个角落里
it sort of pushing the real heart of the

49
00:02:11,950 --> 00:02:13,790
所以你会发现这些系统它把 FT 的真正的核心机制放在一个角落里
fault tolerance

50
00:02:13,790 --> 00:02:16,610
所以你会发现这些系统它把 FT 的真正的核心机制放在一个角落里
Machinery into a little corner that is

51
00:02:16,610 --> 00:02:18,620
即如果发生故障，用单一实体来决策谁是 primary
the single entity that decides who's

52
00:02:18,620 --> 00:02:20,719
即如果发生故障，用单一实体来决策谁是 primary
going to be the primary if there's a

53
00:02:20,719 --> 00:02:23,810
他们这么做的目的就是为了防止 split brain(脑裂)
failure now this whole thing is about

54
00:02:23,810 --> 00:02:25,430
他们这么做的目的就是为了防止 split brain(脑裂)
how to avoid split brain the reason why

55
00:02:25,430 --> 00:02:27,560
如果系统发生故障，需要非常小心的去决策谁是 primary
we have to have have to be extremely

56
00:02:27,560 --> 00:02:29,989
如果系统发生故障，需要非常小心的去决策谁是 primary
careful about making the decision about

57
00:02:29,989 --> 00:02:31,519
如果系统发生故障，需要非常小心的去决策谁是 primary
who should be the primary if there's a

58
00:02:31,519 --> 00:02:33,950
否则就会有 split brain 的风险
failure is that otherwise we risks split

59
00:02:33,950 --> 00:02:38,030
为了让这个问题变清晰
brain and just make this point super

60
00:02:38,030 --> 00:02:45,109
我打算提醒你一下，这是个什么样的问题，为什么这个问题很严重
clear I'm gonna just remind you what the

61
00:02:45,109 --> 00:02:47,239
我打算提醒你一下，这是个什么样的问题，为什么这个问题很严重
problem is and why it's a serious

62
00:02:47,239 --> 00:02:49,989
假设我们想构建一个有复制功能的 test-and-set 服务器
problem so supposing for example where

63
00:02:49,989 --> 00:02:52,939
假设我们想构建一个有复制功能的 test-and-set 服务器
we want to build ourselves a replicated

64
00:02:52,939 --> 00:02:54,409
假设我们想构建一个有复制功能的 test-and-set 服务器
test and set server that is we're

65
00:02:54,409 --> 00:02:56,389
我们比较担心的是 vmware ft 依赖于这个 test-and-set 服务器去选择谁是 primary,
worried about the fact that vmware ft

66
00:02:56,389 --> 00:02:58,609
我们比较担心的是 vmware ft 依赖于这个 test-and-set 服务器去选择谁是 primary
relies on this test and set server to

67
00:02:58,609 --> 00:03:00,560
让我们构建一个有复制能力的 test-and-set 服务器
choose who the primary is so let's build

68
00:03:00,560 --> 00:03:02,750
让我们构建一个有复制能力的 test-and-set 服务器
a replicated test and set server i'm

69
00:03:02,750 --> 00:03:04,519
然后看看它发生故障后会是什么样子
gonna do this it's gonna be broken it's

70
00:03:04,519 --> 00:03:08,959
我只是想解释一下为什么解决脑裂的问题很难
just an illustration for why why it's

71
00:03:08,959 --> 00:03:10,609
我只是想解释一下为什么解决脑裂的问题很难
difficult to get split brain problem

72
00:03:10,609 --> 00:03:12,019
我只是想解释一下为什么解决脑裂的问题很难
correctly so you know we're gonna

73
00:03:12,019 --> 00:03:16,310
想象一下我们有一个这样的网络
imagine we have a network and maybe two

74
00:03:16,310 --> 00:03:18,379
然后这里有 2 台服务器，假设他们就是 test-and-set 服务的副本
servers which are supposed to be

75
00:03:18,379 --> 00:03:21,019
然后这里有 2 台服务器，假设他们就是 test-and-set 服务的副本
replicas of our test and set service

76
00:03:21,019 --> 00:03:23,180
这里有 2 个客户端，它们需要知道谁是 primary
connected and you know maybe two clients

77
00:03:23,180 --> 00:03:24,949
这里有 2 个客户端，它们需要知道谁是 primary
they need to know who's the primary

78
00:03:24,949 --> 00:03:26,540
事实上在这个例子里 client 就是前面课中讲的 vmware ft 中的 primary 和 backup
right now or actually maybe these

79
00:03:26,540 --> 00:03:28,940
事实上在这个例子里 client 就是前面课中讲的 vmware ft 中的 primary 和 backup
clients in this case are the primary in

80
00:03:28,940 --> 00:03:34,669
事实上在这个例子里 client 就是前面课中讲的 vmware ft 中的 primary 和 backup
the back up in vmware ft so if it's a

81
00:03:34,669 --> 00:03:36,169
如果这里是 test-and-set 服务器
test and set service then you know both

82
00:03:36,169 --> 00:03:38,120
然后这里 2 个数据库会以它们自己的状态开始启动
these databases mostly servers start out

83
00:03:38,120 --> 00:03:40,280
然后这里 2 个数据库会以它们自己的状态开始启动
with their state that is the state of

84
00:03:40,280 --> 00:03:42,620
刚开始他们的值都是 0
this test-and-set in zero and the

85
00:03:42,620 --> 00:03:44,720
客户端的通过发送 test-and-set 指令把副本的 flag 设置成 1
one operation their clients can send is

86
00:03:44,720 --> 00:03:46,250
客户端的通过发送 test-and-set 指令把副本的 flag 设置成 1
the test and set operation which is

87
00:03:46,250 --> 00:03:50,750
客户端的通过发送 test-and-set 指令把副本的 flag 设置成 1
supposed to set the flag of the

88
00:03:50,750 --> 00:03:52,879
客户端的通过发送 test-and-set 指令把副本的 flag 设置成 1
replicated service to one so i should

89
00:03:52,879 --> 00:03:55,190
我应该要对这 2 个副本都进行设置，然后返回它的旧值
set both copies and then return the old

90
00:03:55,190 --> 00:03:57,500
所以它看起来特别像一个简单版的 lock server
value so it's essentially acts as a kind

91
00:03:57,500 --> 00:04:02,510
所以它看起来特别像一个简单版的 lock server
of simplified lock server okay so the

92
00:04:02,510 --> 00:04:05,599
当有一个 client 只能与这 2 台 server 之一通信，而不能与另一台通信
我们所担心的脑裂就会发生
problem situation the lowly worried

93
00:04:05,599 --> 00:04:08,930
当有一个 client 只能与这 2 台 server 之一通信，而不能与另一台通信
我们所担心的脑裂就会发生
about split-brain arises when a client

94
00:04:08,930 --> 00:04:11,239
当有一个 client 只能与这 2 台 server 之一通信，而不能与另一台通信
我们所担心的脑裂就会发生
can talk to one of the servers but can't

95
00:04:11,239 --> 00:04:12,769
当有一个 client 只能与这 2 台 server 之一通信，而不能与另一台通信
我们所担心的脑裂就会发生
talk to the other so we're imagining

96
00:04:12,769 --> 00:04:14,989
来想象一下，当客户端发送请求给这 2 个服务器
either that when client send a request

97
00:04:14,989 --> 00:04:17,810
来想象一下，当客户端发送请求给这 2 个服务器
they send it to both I'm just gonna

98
00:04:17,810 --> 00:04:19,159
我只是假设哈，这一点也不重要
assume that now and almost doesn't

99
00:04:19,159 --> 00:04:20,930
假设客户端发送任意的请求到这 2 个服务器
matter so let's assume that the protocol

100
00:04:20,930 --> 00:04:22,190
假设客户端发送任意的请求到这 2 个服务器
is that the client supposed to send

101
00:04:22,190 --> 00:04:24,380
假设客户端发送任意的请求到这 2 个服务器
ordinarily any request to both servers

102
00:04:24,380 --> 00:04:27,260
如果其中 1 个服务器不响应，思考一下，客户端该怎么做？
and somehow we you know we need

103
00:04:27,260 --> 00:04:29,330
如果其中 1 个服务器不响应，思考一下，客户端该怎么做？
think through what the client should do

104
00:04:29,330 --> 00:04:31,270
如果其中 1 个服务器不响应，思考一下，客户端该怎么做？
if one of the server's doesn't respond

105
00:04:31,270 --> 00:04:33,410
或者说系统应该怎么做？
right or what the system should do if

106
00:04:33,410 --> 00:04:34,580
或者说系统应该怎么做？
one of the servers doesn't respond

107
00:04:34,580 --> 00:04:38,300
好，来想象一下，假设 C1 可以与 S1 通信，但不能与 S2 通信
so let's imagine now the

108
00:04:38,300 --> 00:04:40,340
好，来想象一下，假设 C1 可以与 S1 通信，但不能与 S2 通信
client one can contact server one but

109
00:04:40,340 --> 00:04:42,200
好，来想象一下，假设 C1 可以与 S1 通信，但不能与 S2 通信
not server two how should the system

110
00:04:42,200 --> 00:04:46,520
系统应该要怎么响应？
react one possibility is for is that we

111
00:04:46,520 --> 00:04:48,380
我们当然不想让 C1 只能和 S1 通信
think well you know gosh we certainly

112
00:04:48,380 --> 00:04:49,610
我们当然不想让 C1 只能和 S1 通信
don't want to just talk to client to

113
00:04:49,610 --> 00:04:50,930
我们当然不想让 C1 只能和 S1 通信
server one because that would leave the

114
00:04:50,930 --> 00:04:53,450
如果我们只把这里设置成 1，而没有把另一台设置成 1
就会导致 S1 和 S2 数据不一致
second replica inconsistent if we set

115
00:04:53,450 --> 00:04:54,980
如果我们只把这里设置成 1，而没有把另一台设置成 1
就会导致 S1 和 S2 数据不一致
this value to one but didn't also set

116
00:04:54,980 --> 00:04:55,820
如果我们只把这里设置成 1，而没有把另一台设置成 1
就会导致 S1 和 S2 数据不一致
this value to one

117
00:04:55,820 --> 00:04:57,650
正确的规则是，对任何要发送的指令，客户端必须总是能和这 2 台副本进行通信
so maybe the rule should be that the

118
00:04:57,650 --> 00:04:59,390
正确的规则是，对任何要发送的指令，客户端必须总是能和这 2 台副本进行通信
client is always required to talk to

119
00:04:59,390 --> 00:05:01,850
正确的规则是，对任何要发送的指令，客户端必须总是能和这 2 台副本进行通信
both replicas to both servers for any

120
00:05:01,850 --> 00:05:03,260
只能和其中之一通信这是不允许的
operation and shouldn't be allowed to

121
00:05:03,260 --> 00:05:05,840
只能和其中之一通信这是不允许的
just talk to one of them so why is that

122
00:05:05,840 --> 00:05:10,820
为什么这会导致错误的结果？
the wrong answer so the rule is o in our

123
00:05:10,820 --> 00:05:12,470
在这个复制系统中，客户端必须总是能和所有副本通信，以便后续步骤能正常进行
replicated system the clients always

124
00:05:12,470 --> 00:05:15,290
在这个复制系统中，客户端必须总是能和所有副本通信，以便后续步骤能正常进行
require to talk to both replicas in

125
00:05:15,290 --> 00:05:22,730
在这个复制系统中，客户端必须总是能和所有副本通信，以便后续步骤能正常进行
order to make progress

126
00:05:22,730 --> 00:05:25,490
这并不是一个容错系统，事实上这会让事情更加糟糕
it's not fault tolerant at all in fact it's worse it's worse than talking to a

127
00:05:25,490 --> 00:05:27,230
这比你和单个服务器通信还要糟糕
single server because now the system has

128
00:05:27,230 --> 00:05:30,650
因为现在系统如果有问题，其中之一宕机了
a problem if either of these servers is

129
00:05:30,650 --> 00:05:33,470
你就无法和它通信了
crashed or or you can't talk to it at

130
00:05:33,470 --> 00:05:34,880
至少 在只有一台服务的 非复制系统中，你只依赖一台 server
least with a non replicated service

131
00:05:34,880 --> 00:05:36,140
至少 在只有一台服务的 非复制系统中，你只依赖一台 server
you're only depending on one server but

132
00:05:36,140 --> 00:05:37,580
但现在，我们却要求这 2 台服务器都要在线
here we am both servers have to be alive

133
00:05:37,580 --> 00:05:40,040
如果我们要求客户端同时和 2 台服务器通信
if we require the client to talk to both

134
00:05:40,040 --> 00:05:41,840
那么所有服务器都必须在线
servers then both servers has to be alive

135
00:05:41,840 --> 00:05:43,700
事实上，我们不能要求客户端去等待所有的服务器的响应
否则这就无法容错了
so we can't possibly require the client

136
00:05:43,700 --> 00:05:46,850
事实上，我们不能要求客户端去等待所有的服务器的响应
否则这就无法容错了
to actually you know wait for both

137
00:05:46,850 --> 00:05:49,010
事实上，我们不能要求客户端去等待所有的服务器的响应
否则这就无法容错了
servers to respond if we don't have

138
00:05:49,010 --> 00:05:50,360
所以我们要能去处理这种问题
fault tolerance we need it to be able to

139
00:05:50,360 --> 00:05:52,550
一个显而易见的答案是如果客户端不能和所有服务器通信
proceed so another obvious answer is

140
00:05:52,550 --> 00:05:55,070
一个显而易见的答案是如果客户端不能和所有服务器通信
that if the client can't talk to both

141
00:05:55,070 --> 00:05:56,360
那就让它能和那个可以通信的服务器通信就行了
well it just talks to the one who can

142
00:05:56,360 --> 00:05:59,890
并且还能告诉你另一台服务器已经挂了
talk to and figures the other ones dead

143
00:05:59,890 --> 00:06:02,630
但是这样做不对，为什么？
so what's up why is that also not the

144
00:06:02,630 --> 00:06:04,900
但是这样做不对，为什么？
right answer

145
00:06:08,510 --> 00:06:10,250
麻烦的是如果另一台服务器它并没有宕机
the troubling scenario is if the other

146
00:06:10,250 --> 00:06:12,110
麻烦的是如果另一台服务器它并没有宕机
server is actually alive so suppose the

147
00:06:12,110 --> 00:06:13,940
假设这台服务器没有宕机，看起来似乎挺好的
actual problem or encountering is not

148
00:06:13,940 --> 00:06:16,760
假设这台服务器没有宕机，看起来似乎挺好的
that this server crashed which would be

149
00:06:16,760 --> 00:06:20,150
但糟糕的是这里的网线出了点问题
good for us but the much worse issue

150
00:06:20,150 --> 00:06:21,500
但糟糕的是这里的网线出了点问题
that something went wrong with the

151
00:06:21,500 --> 00:06:23,900
但糟糕的是这里的网线出了点问题
network cable and that this client can

152
00:06:23,900 --> 00:06:26,210
C1 可以和 S1 通信但不能和 S2 通信
talk to client one can talk to server one

153
00:06:26,210 --> 00:06:27,890
C1 可以和 S1 通信但不能和 S2 通信
but not server two and there's maybe

154
00:06:27,890 --> 00:06:29,600
而另一个客户端 C2 可以和 S2 通信但是不能与 S1 通信
some other client out there that conduct

155
00:06:29,600 --> 00:06:33,050
而另一个客户端 C2 可以和 S2 通信但是不能与 S1 通信
a server two but not server one so if we

156
00:06:33,050 --> 00:06:35,600
如果我们制定这样的规则：如果客户端能和所有服务通信
make the rule that if a client can talk

157
00:06:35,600 --> 00:06:38,300
如果我们制定这样的规则：如果客户端能和所有服务通信
to both servers that it's okay in order

158
00:06:38,300 --> 00:06:39,680
为了能够容错，我只要和其中之一通信就 okay
to be fault tolerant that I just talked

159
00:06:39,680 --> 00:06:43,520
然后就会不可避免的发生一些事情，比如这里的网线断了
to one then what's just inevitably gonna

160
00:06:43,520 --> 00:06:46,130
然后就会不可避免的发生一些事情，比如这里的网线断了
happen said this cable is gonna break

161
00:06:46,130 --> 00:06:48,170
然后就会不可避免的发生一些事情，比如这里的网线断了
thus cutting the network in half client

162
00:06:48,170 --> 00:06:51,320
C1 打算发送一条 test-and-set 指令请求到 S1
one is gonna send a test and set request

163
00:06:51,320 --> 00:06:53,750
C1 打算发送一条 test-and-set 指令请求到 S1
to server one server one will you know

164
00:06:53,750 --> 00:06:56,270
把它的值设置成 1，并返回旧值 0 给 C1
set it state to one and return the

165
00:06:56,270 --> 00:06:58,430
把它的值设置成 1，并返回旧值 0 给 C1
previous value of zero to client one and

166
00:06:58,430 --> 00:06:59,660
所以 C1 认为它拿到了锁
so that mean client one will think it

167
00:06:59,660 --> 00:07:02,180
如果它是一台 vmware ft 服务器，那它就认为它能接管 primary
has the lock and if it's a VMware ft

168
00:07:02,180 --> 00:07:04,310
如果它是一台 vmware ft 服务器，那它就认为它能接管 primary
server will think it can be takeovers

169
00:07:04,310 --> 00:07:06,740
但是这个副本的值仍然是 0
primarily but this replica still of zero

170
00:07:06,740 --> 00:07:08,570
如果这个客户端 C2 也发送了一条 test-and-set 请求
in it all right so now if client to

171
00:07:08,570 --> 00:07:10,310
如果这个客户端 C2 也发送了一条 test-and-set 请求
who've also sends a test and set request

172
00:07:10,310 --> 00:07:12,920
发送给所有的服务器，但是它发现 S2 挂掉了
to you know what client send them to

173
00:07:12,920 --> 00:07:14,390
发送给所有的服务器，但是它发现 S2 挂掉了
both sees that server one appears to be

174
00:07:14,390 --> 00:07:16,820
根据前面的规则，你只要能和其中之一服务器通信就 ok
down follows the rule that says well you

175
00:07:16,820 --> 00:07:17,960
根据前面的规则，你只要能和其中之一服务器通信就 ok
just send to the one server but you can

176
00:07:17,960 --> 00:07:22,460
接下来 C2 会认为它请求到了锁，你也认为它确实是请求到了这把锁
talk to then it will also think that it

177
00:07:22,460 --> 00:07:23,870
接下来 C2 会认为它请求到了锁，你也认为它确实是请求到了这把锁
would acquire because client you

178
00:07:23,870 --> 00:07:25,520
接下来 C2 会认为它请求到了锁，你也认为它确实是请求到了这把锁
also think that it acquired the lock and

179
00:07:25,520 --> 00:07:27,230
现在想象一下，这台 test-and-server 被用于 vmware ft
so now you know if we were imagining

180
00:07:27,230 --> 00:07:28,820
现在想象一下，这台 test-and-server 被用于 vmware ft
this test and that server was going to

181
00:07:28,820 --> 00:07:29,990
现在想象一下，这台 test-and-server 被用于 vmware ft
be used with the vmware ft

182
00:07:29,990 --> 00:07:35,020
在没有访问其它服务器的情况下
所有的 vmware 机器都认为它们可以成为 primary
you know both replicas both of these VMware

183
00:07:35,020 --> 00:07:37,970
在没有访问其它服务器的情况下
所有的 vmware 机器都认为它们可以成为 primary
machines I think they could be primary

184
00:07:37,970 --> 00:07:41,180
在没有访问其它服务器的情况下
所有的 vmware 机器都认为它们可以成为 primary
by themselves without consulting the

185
00:07:41,180 --> 00:07:42,650
所以这会导致一个完全错误的结果
other server so that's a complete

186
00:07:42,650 --> 00:07:45,350
对于这种情况，我们要么等待 2 台服务器，放弃容错的功能
failure so with this setup and two

187
00:07:45,350 --> 00:07:47,840
对于这种情况，我们要么等待 2 台服务器，放弃容错的功能
servers it seemed like we had this we

188
00:07:47,840 --> 00:07:49,700
对于这种情况，我们要么等待 2 台服务器，放弃容错的功能
just had to choose either you wait for

189
00:07:49,700 --> 00:07:52,120
对于这种情况，我们要么等待 2 台服务器，放弃容错的功能
both and you're not fault-tolerant or

190
00:07:52,120 --> 00:07:54,440
要么就只等待其中之一的响应，放弃正确性
you wait for just one and you're not

191
00:07:54,440 --> 00:07:57,350
这个错误的版本通常被称为脑裂(split brain)
correct and not correct version

192
00:07:57,350 --> 00:07:59,560
这个错误的版本通常被称为脑裂(split brain)
it's often called split brain so

193
00:07:59,560 --> 00:08:06,940
好，大家明白没？
everybody see this well

194
00:08:09,129 --> 00:08:12,639
这基本上就是 80 年代末的代表了
so this was basically where things stood

195
00:08:12,639 --> 00:08:16,520
这基本上就是 80 年代末的代表了
until the late 80s and when people but

196
00:08:16,520 --> 00:08:18,050
但那时候人们也的确是想构建出这样一个复制系统出来
people did want to build replicated

197
00:08:18,050 --> 00:08:20,509
比如用于控制电话交换机的计算机
systems you know like the computers that

198
00:08:20,509 --> 00:08:22,699
比如用于控制电话交换机的计算机
control telephone switches or the

199
00:08:22,699 --> 00:08:24,919
又或是运行在银行的那些计算机
computers that ran banks you know there

200
00:08:24,919 --> 00:08:26,509
在这些地方，我们花费了大量的金钱，就是为了保证服务的可靠性
was place when we spend a huge amount

201
00:08:26,509 --> 00:08:27,830
在这些地方，我们花费了大量的金钱，就是为了保证服务的可靠性
of money in order to have reliable

202
00:08:27,830 --> 00:08:29,449
所以他们会去构建这样的复制系统
service and so they would replicate they

203
00:08:29,449 --> 00:08:31,219
所以他们会去构建这样的复制系统
would build replicated systems and the

204
00:08:31,219 --> 00:08:33,529
他们会构建这样的副本
way they would deal the way would that

205
00:08:33,529 --> 00:08:35,240
但是尝试去消除掉脑裂需要一些其它技术
they would have replication but try to

206
00:08:35,240 --> 00:08:38,240
但是尝试去消除掉脑裂需要一些其它技术
rule out of rule out split brain it's a

207
00:08:38,240 --> 00:08:41,089
但是尝试去消除掉脑裂需要一些其它技术
couple of techniques one is they would

208
00:08:41,089 --> 00:08:45,079
其中之一就是构建一个不会出错的网络
build a network that could not fail and

209
00:08:45,079 --> 00:08:47,360
这什么意思呢？
so usually what that means and in fact

210
00:08:47,360 --> 00:08:49,160
你可以想象使用这样的网络基本上不可能出现故障
you guess use networks that essentially

211
00:08:49,160 --> 00:08:51,259
你可以想象使用这样的网络基本上不可能出现故障
cannot fail all the time the wires

212
00:08:51,259 --> 00:08:53,839
比如在你的电脑内，CPU 和 DRAM 之间的连接通常都很高效也不会出现故障
inside your laptop you know connecting

213
00:08:53,839 --> 00:08:57,589
比如在你的电脑内，CPU 和 DRAM 之间的连接通常都很高效也不会出现故障
the CPU to the DRAM are effectively what

214
00:08:57,589 --> 00:08:59,410
比如在你的电脑内，CPU 和 DRAM 之间的连接通常都很高效也不会出现故障
you know a network that cannot fail

215
00:08:59,410 --> 00:09:02,930
比如在你的电脑内，CPU 和 DRAM 之间的连接通常都很高效也不会出现故障
between the between your CPU and DRAM so

216
00:09:02,930 --> 00:09:05,149
所以你可以合理的去假设，大量的烧钱，小心的维护设备
you know with reasonable assumptions and

217
00:09:05,149 --> 00:09:07,310
所以你可以合理的去假设，大量的烧钱，小心的维护设备
lots of money and you know sort of

218
00:09:07,310 --> 00:09:10,250
所以你可以合理的去假设，大量的烧钱，小心的维护设备
carefully controlled physical situation

219
00:09:10,250 --> 00:09:11,180
比如你不会在地板上看到乱放的电缆
like you don't want to have a cable

220
00:09:11,180 --> 00:09:12,800
比如你不会在地板上看到乱放的电缆
snaking across the floor that somebody

221
00:09:12,800 --> 00:09:15,040
比如你不会在地板上看到乱放的电缆
can step on you know it's got to be

222
00:09:15,040 --> 00:09:17,480
因此你得好好去设计网线的安装方式
physically designed set up with a

223
00:09:17,480 --> 00:09:19,759
如果没有网络故障，那脑裂的问题自然就不会发生
network that cannot fail you can rule

224
00:09:19,759 --> 00:09:21,139
在大量资金保证和这种假设下，就能解决脑裂的问题
out split brain it's bit of an

225
00:09:21,139 --> 00:09:22,939
在大量资金保证和这种假设下，就能解决脑裂的问题
assumption but with enough money people

226
00:09:22,939 --> 00:09:25,370
在大量资金保证和这种假设下，就能解决脑裂的问题
get quite close to this because if the

227
00:09:25,370 --> 00:09:27,050
假设 C1 无法和 S2 通信，而且网络又不可能发生故障
network cannot fail that basically means

228
00:09:27,050 --> 00:09:28,699
假设 C1 无法和 S2 通信，而且网络又不可能发生故障
that the client can't talk to a server

229
00:09:28,699 --> 00:09:31,310
那就说明一定是 S2 宕机了
to that means server two must be down

230
00:09:31,310 --> 00:09:33,439
因为你网络不可能发生故障
because it can't have been the network

231
00:09:33,439 --> 00:09:35,449
所以这是一种人们构建没有脑裂的复制系统的一种方式
malfunctioning so that was one way that

232
00:09:35,449 --> 00:09:38,660
所以这是一种人们构建没有脑裂的复制系统的一种方式
people sort of built replication systems

233
00:09:38,660 --> 00:09:41,949
所以这是一种人们构建没有脑裂的复制系统的一种方式
it didn't suffer from split brain

234
00:09:42,009 --> 00:09:44,240
另一种可行的方式就是人类介入
another possibility would be to have

235
00:09:44,240 --> 00:09:46,130
另一种可行的方式就是人类介入
some human beings sort out the problem

236
00:09:46,130 --> 00:09:48,139
比如不要让系统自动的去处理任何事情
that is don't automatically do anything

237
00:09:48,139 --> 00:09:49,970
客户端它总是要去等待所有的服务器响应
instead have the clients you know by

238
00:09:49,970 --> 00:09:51,860
客户端它总是要去等待所有的服务器响应
default clients always have to wait for

239
00:09:51,860 --> 00:09:54,110
客户端它总是要去等待所有的服务器响应
you know both replicas to respond or

240
00:09:54,110 --> 00:09:56,870
决不允许只有一台服务器响应的情况下，继续执行
something never allowed to proceed with

241
00:09:56,870 --> 00:09:58,519
决不允许只有一台服务器响应的情况下，继续执行
just one of them but you can you know

242
00:09:58,519 --> 00:10:00,709
如果发生这种情况，就要拉响警报，拨打值班同学的电话
call somebody's beeper to go off some

243
00:10:00,709 --> 00:10:02,540
值班同学冲进机房，看到 2 个副本
human being goes to the machine room and

244
00:10:02,540 --> 00:10:04,250
值班同学冲进机房，看到 2 个副本
sort of looks at the two replicas and

245
00:10:04,250 --> 00:10:07,009
然后将它关机，以确保它确实关闭了
either turns one off to make sure it's

246
00:10:07,009 --> 00:10:07,850
然后将它关机，以确保它确实关闭了
definitely dead

247
00:10:07,850 --> 00:10:10,130
或者检查一下它们其中之一确实已经宕机，另一台还在线
or verifies that one of them has indeed

248
00:10:10,130 --> 00:10:13,459
或者检查一下它们其中之一确实已经宕机，另一台还在线
crashed and if the other is alive and so

249
00:10:13,459 --> 00:10:14,990
你得把人当作断路器
you're essentially using the human as a

250
00:10:14,990 --> 00:10:17,600
你得把人当作断路器
as the tie breaker and the human is a

251
00:10:17,600 --> 00:10:20,750
如果把人看作计算机的话，那人又成为了单点故障
you know if they were a computer it

252
00:10:20,750 --> 00:10:21,769
如果把人看作计算机的话，那他们自己又成为了单点故障
would be a single point of failure themselves

253
00:10:21,769 --> 00:10:25,670
所以相当长一段时间人们会使用其它方案来构建复制系统
so for a long time people use

254
00:10:25,670 --> 00:10:27,290
所以相当长一段时间人们会使用其它方案来构建复制系统
one of the other these schemes in order

255
00:10:27,290 --> 00:10:28,970
所以相当长一段时间人们会使用其它方案来构建复制系统
to build replicated systems and it's not

256
00:10:28,970 --> 00:10:31,009
他们被迫工作，而且人类通常也不能快速做出响应
you know they can be made to work the

257
00:10:31,009 --> 00:10:32,480
他们被迫工作，而且人类通常也不能快速做出响应
humans don't respond very quickly and

258
00:10:32,480 --> 00:10:34,459
让网络不出故障成本又很高
the network that cannot fail is

259
00:10:34,459 --> 00:10:38,869
所以这些方案基本都不太可行
expensive but it's not not doable but it

260
00:10:38,869 --> 00:10:42,019
但是事实证明，我们确实是能构建出能够自动容错，并且能正确工作的系统
turned out that you can actually build

261
00:10:42,019 --> 00:10:45,949
但是事实证明，我们确实是能构建出能够自动容错，并且能正确工作的系统
automated failover systems that can work

262
00:10:45,949 --> 00:10:48,980
即使遇上那种诡异的网络故障，在这种网络可以分区(partition)的情况下，也没关系
correctly in the face of flaky networks

263
00:10:48,980 --> 00:10:51,290
即使遇上那种诡异的网络故障，在这种网络可以分区(partition)的情况下，也没关系
of networks that could fail on the can

264
00:10:51,290 --> 00:10:53,209
这种将网络一分为二，两边之间互相无法进行通信
partition so this split of the network

265
00:10:53,209 --> 00:10:54,920
这种将网络一分为二，两边之间互相无法进行通信
in half where the two sides operate they

266
00:10:54,920 --> 00:10:56,600
通常被称为 partition(分区)
can't talk to each other that's usually

267
00:10:56,600 --> 00:11:04,910
通常被称为 partition(分区)
called a partition and the big insight

268
00:11:04,910 --> 00:11:06,889
人们构建自动化的，不受脑裂影响的复制系统的关键是
少数服从多数的投票思想
that people came up with in order to

269
00:11:06,889 --> 00:11:10,100
人们构建自动化的，不受脑裂影响的复制系统的关键是
少数服从多数的投票思想
build automated replication systems that

270
00:11:10,100 --> 00:11:12,589
人们构建自动化的，不受脑裂影响的复制系统的关键是
少数服从多数的投票思想
don't suffer from split brain is the

271
00:11:12,589 --> 00:11:17,649
人们构建自动化的，不受脑裂影响的复制系统的关键是
少数服从多数的投票思想
idea of a majority vote this is a

272
00:11:20,079 --> 00:11:22,459
这种概念在 raft 论文里出现过
concept that shows up in like every

273
00:11:22,459 --> 00:11:24,110
这种概念在 raft 论文里出现过
other sentence practically in the raft

274
00:11:24,110 --> 00:11:28,519
这是取得后续进展的基石
paper sort of fundamental way of

275
00:11:28,519 --> 00:11:31,459
第一步，得有奇数台服务器，而不是偶数台
proceeding the first step is to have an

276
00:11:31,459 --> 00:11:33,740
第一步，得有奇数台服务器，而不是偶数台
odd number of servers instead of an even

277
00:11:33,740 --> 00:11:35,779
比如这里就有缺陷了，看起来有点太对称了
number of servers like one flaw here is

278
00:11:35,779 --> 00:11:37,939
比如这里就有缺陷了，看起来有点太对称了
that it's a little bit too symmetric all

279
00:11:37,939 --> 00:11:39,379
分裂的两边，它们看起来没什么区别
right the two sides of the split here

280
00:11:39,379 --> 00:11:41,540
分裂的两边，它们看起来没什么区别
just they just look the same so they run

281
00:11:41,540 --> 00:11:42,589
它们运行的相同的程序，做着一样的事情
the same software they're gonna do the

282
00:11:42,589 --> 00:11:44,299
这看起来不太好
same thing and that's not good but if

283
00:11:44,299 --> 00:11:47,439
但是如果你有奇数台服务器的话
you have an odd number of servers then

284
00:11:47,439 --> 00:11:50,899
那看起来就一点也不对称了
it's not symmetric anymore right at

285
00:11:50,899 --> 00:11:52,939
在只有一个分裂的网络中
起码是一边有 2 台，另一边只有 1 台
least a single network split will be

286
00:11:52,939 --> 00:11:54,740
在只有一个分裂的网络中
起码是一边有 2 台，另一边只有 1 台
presumably two servers on one side and

287
00:11:54,740 --> 00:11:56,179
在只有一个分裂的网络中
起码是一边有 2 台，另一边只有 1 台
one server on the other side and they

288
00:11:56,179 --> 00:11:58,490
它们一点也不对称，这也是多数投票(majority vote)方案所迷人的地方
won't be symmetric at all and that's

289
00:11:58,490 --> 00:12:00,829
它们一点也不对称，这也是多数投票(majority vote)方案所迷人的地方
part of what majority vote majority

290
00:12:00,829 --> 00:12:04,220
它们一点也不对称，这也是多数投票(majority vote)方案所迷人的地方
voting schemes are appealing to so basic

291
00:12:04,220 --> 00:12:05,629
所以基本思想就是得有奇数台服务器
ideas you have an odd number of servers

292
00:12:05,629 --> 00:12:08,299
为了推进每一步，在 raft 的 leader 选举或是日志提交里
in order to make progress of any kind so

293
00:12:08,299 --> 00:12:10,939
为了推进每一步，在 raft 的 leader 选举或是日志提交里
in raft elect a leader or cause a log

294
00:12:10,939 --> 00:12:12,619
为了推进每一步，在 raft 的 leader 选举或是日志提交里
entry to be committed in order to make

295
00:12:12,619 --> 00:12:15,379
每一步都需要得到大多数的服务器，也就是超过一半的服务器支持
any progress at each step you have to

296
00:12:15,379 --> 00:12:18,649
每一步都需要得到大多数的服务器，也就是超过一半的服务器支持
assemble a majority of the server's more

297
00:12:18,649 --> 00:12:20,149
每一步都需要得到大多数的服务器，也就是超过一半的服务器支持
than half more than half of all the

298
00:12:20,149 --> 00:12:22,489
每一步都需要得到大多数的服务器，也就是超过一半的服务器支持
servers in order to sort of approve that

299
00:12:22,489 --> 00:12:25,279
这样才能让每一步（比如 leader 选举或是日志提交）得以成功执行
step like vote for a leader or accept a

300
00:12:25,279 --> 00:12:29,059
这样才能让每一步（比如 leader 选举或是日志提交）得以成功执行
new log entry and commit it so you know

301
00:12:29,059 --> 00:12:32,749
最直白的方式就是有 3 台服务器中有 2 台需要执行这些步骤
the most straightforward way is that two

302
00:12:32,749 --> 00:12:36,669
最直白的方式就是有 3 台服务器中有 2 台需要执行这些步骤
of three servers required to do anything

303
00:12:37,819 --> 00:12:40,249
这种方式能正确工作的原因是
one reason this works of course is that

304
00:12:40,249 --> 00:12:43,499
如果遇到了 partition
if there's a partition there can't be

305
00:12:43,499 --> 00:12:45,569
绝不可能有超过一个以上的 partiton 同时拥有一半以上的服务器
more than one partition with a majority

306
00:12:45,569 --> 00:12:47,639
绝不可能有超过一个以上的 partiton 同时拥有一半以上的服务器
of the server's in it that's one way to

307
00:12:47,639 --> 00:12:51,329
举个例子，一个 partition 可以只有一台服务器在里头
look at this a partition can have one

308
00:12:51,329 --> 00:12:53,009
这时它就不是一个 majority 系统
server in it which it's not a majority

309
00:12:53,009 --> 00:12:55,439
又或者这个 partition 里有 2 台服务器
那另一个 parition 铁定就只有 1 台了
or maybe you can have two but if one

310
00:12:55,439 --> 00:12:56,550
又或者这个 partition 里有 2 台服务器
那另一个 parition 铁定就只有 1 台了
partition has two then the other

311
00:12:56,550 --> 00:12:58,410
又或者这个 partition 里有 2 台服务器
那另一个 parition 铁定就只有 1 台了
partition has to have only one server in

312
00:12:58,410 --> 00:13:00,689
因此也无法聚合成为超过半数以上的服务器，也无法进行下一步操作
it and therefore will never be able to

313
00:13:00,689 --> 00:13:02,279
因此也无法聚合成为超过半数以上的服务器，也无法进行下一步操作
assemble a majority and won't be able to

314
00:13:02,279 --> 00:13:07,350
需要阐明一点的是，这里所说的大多数
make progress and just to be totally

315
00:13:07,350 --> 00:13:09,600
需要阐明一点的是，这里所说的大多数
clear when we're talking about a

316
00:13:09,600 --> 00:13:11,610
需要阐明一点的是，这里所说的大多数
majority it's always a majority out of

317
00:13:11,610 --> 00:13:14,040
是所有服务器（包括在线和宕机的）中的大多数，而不是仅指在线服务器中的大多数
all of the server's not just a live

318
00:13:14,040 --> 00:13:15,930
哈哈，关于这一点曾经也困扰了我相当长一段时间
servers this is the point that confused

319
00:13:15,930 --> 00:13:17,430
哈哈，关于这一点曾经也困扰了我相当长一段时间
me for a long time but if you have a

320
00:13:17,430 --> 00:13:19,259
如果你有 3 台服务器，或许其中有宕机的或是其它故障
system with three servers and maybe some

321
00:13:19,259 --> 00:13:20,850
如果你有 3 台服务器，或许其中有宕机的或是其它故障
of them have failed or something if you

322
00:13:20,850 --> 00:13:22,259
构成大多数的服务数据仍然是 3 个中的 2 个
need to assemble in the majority it's

323
00:13:22,259 --> 00:13:24,720
构成大多数的服务数据仍然是 3 个中的 2 个
always two out of three even if you know

324
00:13:24,720 --> 00:13:26,309
尽管你知道其中有一台宕机了
那大多数也还是指 所有服务器总量的大多数
that one has failed the majority is

325
00:13:26,309 --> 00:13:27,449
尽管你知道其中有一台宕机了
那大多数也还是指 所有服务器总量的大多数
always out of the total number of

326
00:13:27,449 --> 00:13:30,420
有一个更加通用的公式来描述它
servers there's a more general

327
00:13:30,420 --> 00:13:33,689
因为大多数投票系统中，3 个有 2 个同意，就能推进执行
formulation of this because a majority

328
00:13:33,689 --> 00:13:35,610
因为大多数投票系统中，3 个有 2 个同意，就能推进执行
voting system in which two out of three

329
00:13:35,610 --> 00:13:37,170
因为大多数投票系统中，3 个有 2 个同意，就能推进执行
are required to make progress it can

330
00:13:37,170 --> 00:13:40,889
它能在 1 台服务器宕机的情况下继续存活
survive the failure of one server right

331
00:13:40,889 --> 00:13:42,930
另外 2 台服务器依然能够继续推进工作
any two servers are enough to make

332
00:13:42,930 --> 00:13:45,180
如果你担心系统的可靠性的话，你可以使用更多的服务器
progress if you need to be able to if

333
00:13:45,180 --> 00:13:46,740
如果你担心系统的可靠性的话，你可以使用更多的服务器
you're you know you worried about how

334
00:13:46,740 --> 00:13:49,980
如果你担心系统的可靠性的话，你可以使用更多的服务器
reliable your servers are or then you

335
00:13:49,980 --> 00:13:51,569
如果你担心系统的可靠性的话，你可以使用更多的服务器
can build systems that have more servers

336
00:13:51,569 --> 00:13:53,490
所以这个通用公式是这样的
and so the more general formulation is

337
00:13:53,490 --> 00:13:59,490
如果你有 2f + 1 台服务器，你就能承受 f 台服务故障
if you have two F + 1 servers then you

338
00:13:59,490 --> 00:14:06,930
如果你有 2f + 1 台服务器，你就能承受 f 台服务故障
can withstand f failures you know

339
00:14:06,930 --> 00:14:09,779
所以如果这里是 3 的话，这里就是 1
so if it's three that means F is one and the system with

340
00:14:09,779 --> 00:14:12,809
这个系统这里有 3 台服务器，因此你就能承受 1 台服务故障
three servers you can tolerate F servers

341
00:14:12,809 --> 00:14:17,449
它仍然能够继续运行
step one failure and still keep going

342
00:14:19,769 --> 00:14:22,389
好，这些东西通常我们称之为 quorum 系统(多数派系统)
all right often these are called quorum

343
00:14:22,389 --> 00:14:25,350
3 个中有 2 个及以上存活，就说明它们是一个 quorum
systems because the two out of three is

344
00:14:25,350 --> 00:14:29,050
3 个中有 2 个及以上存活，就说明它们是一个 quorum
sometimes held a quorum okay so one

345
00:14:29,050 --> 00:14:30,519
所以我们提及关于 Majority Voting System(大多数投票系统)
的一个特征就是，至多有一个 parition 拥有大多数
property I've already mentioned about

346
00:14:30,519 --> 00:14:34,029
所以我们提及关于 Majority Voting System(大多数投票系统)
的一个特征就是，至多有一个 parition 拥有大多数
these majority voting systems is that at

347
00:14:34,029 --> 00:14:36,759
所以我们提及关于 Majority Voting System(大多数投票系统)
的一个特征就是，至多有一个 parition 拥有大多数
most one partition can have a majority

348
00:14:36,759 --> 00:14:38,110
因此，如果网络分区，我们就不能让所有的网络分区都能推进执行
and therefore if the networks

349
00:14:38,110 --> 00:14:40,569
因此，如果网络分区，我们就不能让所有的网络分区都能推进执行
partitioned we can't have both halves of

350
00:14:40,569 --> 00:14:42,550
因此，如果网络分区，我们就不能让所有的网络分区都能推进执行
the network making progress another more

351
00:14:42,550 --> 00:14:44,499
另一个比较微妙的事情况是
subtle thing that's going on here is

352
00:14:44,499 --> 00:14:48,970
你总需要得到大多数服务器的同意，才能得以继续进行下一步操作
that if you always need a majority of

353
00:14:48,970 --> 00:14:52,629
你总需要得到大多数服务器的同意，才能得以继续进行下一步操作
the servers to proceed and you go

354
00:14:52,629 --> 00:14:54,249
假设你有一系列的指令，在每一步中你都需要得到大多数的服务的支持
through a sort of succession of

355
00:14:54,249 --> 00:14:55,990
假设你有一系列的指令，在每一步中你都需要得到大多数的服务的支持
operations in which reach operations

356
00:14:55,990 --> 00:14:58,089
假设你有一系列的指令，在每一步中你都需要得到大多数的服务的支持
somebody assembled a majority like you

357
00:14:58,089 --> 00:15:00,730
比如说给 leader 投票，这里说的是 raft 中的 leader 投票
know votes for leaders or let's say

358
00:15:00,730 --> 00:15:04,689
比如说给 leader 投票，这里说的是 raft 中的 leader 投票
votes for leaders at raft then at every

359
00:15:04,689 --> 00:15:06,519
在每一步中，你所看到的 majority
step the majority you assemble for that

360
00:15:06,519 --> 00:15:09,339
至少有 1 台服务器，它也在上一步中的 majority
step must contain at least one server

361
00:15:09,339 --> 00:15:11,290
至少有 1 台服务器，它也在上一步中的 majority
that was in the previous majority that

362
00:15:11,290 --> 00:15:13,899
这就是说，任意的 2 个 majority 中，至少会有 1 台服务器是重叠的
is any two majorities overlap in at

363
00:15:13,899 --> 00:15:17,800
这就是说，任意的 2 个 majority 中，至少会有 1 台服务器是重叠的
least one server and it's really that

364
00:15:17,800 --> 00:15:21,009
这个特点比其它的特点更加重要，且被 raft 所依赖，它能避免脑裂的问题
property more than anything else that

365
00:15:21,009 --> 00:15:25,059
这个特点比其它的特点更加重要，且被 raft 所依赖，它能避免脑裂的问题
raft is relying on to avoid split brain

366
00:15:25,059 --> 00:15:27,220
举个例子
it's the fact that for example when you

367
00:15:27,220 --> 00:15:28,480
当你执行一次成功的 leader 选举，leader 的选票来自于 majority
have a leader a successful leader

368
00:15:28,480 --> 00:15:30,339
当你执行一次成功的 leader 选举，leader 的选票来自于 majority
election and leader assembles votes from

369
00:15:30,339 --> 00:15:32,980
这个 majority 保证和上一次的 majority 有重叠
a majority its majority is guaranteed to

370
00:15:32,980 --> 00:15:34,779
这个 majority 保证和上一次的 leader 选举中的 majority 有重叠
overlap with the previous leaders

371
00:15:34,779 --> 00:15:36,490
在这个例子里，新产生的 leader 保证它是知道上一代 leader 的 term 号的
majority and so for example the new

372
00:15:36,490 --> 00:15:39,220
在这个例子里，新产生的 leader 保证它是知道上一代 leader 的 term 号的
leader is guaranteed to know about the

373
00:15:39,220 --> 00:15:41,279
在这个例子里，新产生的 leader 保证它是知道上一代 leader 的 term 号的
term number used by the previous leader

374
00:15:41,279 --> 00:15:43,360
因为它的 majority 和上一代 leader 的 majority 有所重叠
because it's a majority overlaps with

375
00:15:43,360 --> 00:15:45,299
因为它的 majority 和上一代 leader 的 majority 有所重叠
the previous leaders majority and

376
00:15:45,299 --> 00:15:47,379
上一代 majority 中的每个成员都知道上一代的 leader 的 term 号
everybody in the previous leaders

377
00:15:47,379 --> 00:15:49,059
上一代 majority 中的每个成员都知道上一代的 leader 的 term 号
majority knew about the previous leaders

378
00:15:49,059 --> 00:15:50,069
上一代 majority 中的每个成员都知道上一代的 leader 的 term 号
term number

379
00:15:50,069 --> 00:15:53,019
类似的在 raft 里，上一代的 leader 所提交的数据，也必须出现在 majority 中
similarly anything the previous leader

380
00:15:53,019 --> 00:15:55,569
类似的在 raft 里，上一代的 leader 所提交的数据，也必须出现在 majority 中
could have committed must be present in

381
00:15:55,569 --> 00:15:57,970
类似的在 raft 里，上一代的 leader 所提交的数据，也必须出现在 majority 中
a majority of the servers in raft and

382
00:15:57,970 --> 00:15:59,769
因此任意一个新的 leader majority 都至少有 1 台与上次重叠
therefore any new leaders majority must

383
00:15:59,769 --> 00:16:01,869
并且这台机器拥有所有已经提交的来自于上一代 leader 的记录
overlap at at least one server with

384
00:16:01,869 --> 00:16:04,779
并且这台机器拥有所有已经提交的来自于上一代 leader 的记录
every committed entry from the previous

385
00:16:04,779 --> 00:16:08,529
这也是 raft 正确的最大的原因
leader this is a big part of why it is

386
00:16:08,529 --> 00:16:13,110
这也是 raft 正确的最大的原因
that raft is correct

387
00:16:14,440 --> 00:16:18,070
关于 majority voting system 大家还有问题吗?
any questions about the general concept

388
00:16:18,070 --> 00:16:22,860
关于 majority voting system 大家还有问题吗?
of majority voting systems

389
00:16:27,940 --> 00:16:31,470
添加服务器是可能的
it's possible to add servers

390
00:16:31,760 --> 00:16:34,070
这是可能的，在 raft 论文里，可能是第 6 节就解释了如何添加、变更服务器集合
it's possible intersection something

391
00:16:34,070 --> 00:16:36,710
这是可能的，在 raft 论文里，可能是第 6 节就解释了如何添加、变更服务器集合
maybe six in the paper explains how to

392
00:16:36,710 --> 00:16:41,110
这是可能的，在 raft 论文里，可能是第 6 节就解释了如何添加、变更服务器集合
add it or change the set of servers and

393
00:16:41,110 --> 00:16:44,600
在一个长期运行的系统中，比如运行 5 年 10 年的，你可能就需要做这件事
it's possible you need to do it in a

394
00:16:44,600 --> 00:16:45,920
在一个长期运行的系统中，比如运行 5 年 10 年的，你可能就需要做这件事
long-running system if you're running

395
00:16:45,920 --> 00:16:48,800
在一个长期运行的系统中，比如运行 5 年 10 年的，你可能就需要做这件事
your system for five ten years you know

396
00:16:48,800 --> 00:16:50,480
你需要在一段时间后更换服务器，比如有些服务永久性的损坏了
you're gonna need to replace the servers

397
00:16:50,480 --> 00:16:52,490
你需要在一段时间后更换服务器，比如有些服务永久性的损坏了
after a while you know one of them fails

398
00:16:52,490 --> 00:16:55,280
又或者升级，或者将它转移到另一个不同的机房
permanently or you upgrade or you move

399
00:16:55,280 --> 00:16:56,390
又或者升级，或者将它转移到另一个不同的机房
machine rooms to a different machine

400
00:16:56,390 --> 00:16:58,250
你确实需要做一些支持变更集群的操作
room you really do need to be able to

401
00:16:58,250 --> 00:17:00,200
你确实需要做一些支持变更集群的操作
support changing sets of servers so

402
00:17:00,200 --> 00:17:01,640
当然了，这种事也不会每天都发生，但是它确实很关键
that's a it certainly doesn't happen

403
00:17:01,640 --> 00:17:03,230
当然了，这种事也不会每天都发生，但是它确实很关键
every day but it's a critical part of

404
00:17:03,230 --> 00:17:05,390
在长期需要维护的系统中, raft 提供了一种方案
this or a long-term maintainability of

405
00:17:05,390 --> 00:17:08,480
在长期需要维护的系统中, raft 提供了一种方案来处理这种情况
these systems and you know the RAFT

406
00:17:08,480 --> 00:17:10,520
在长期需要维护的系统中, raft 提供了一种方案来处理这种情况
offers sort of pattern themselves on the

407
00:17:10,520 --> 00:17:13,099
在长期需要维护的系统中, raft 提供了一种方案来处理这种情况
back that they have a scheme that deals

408
00:17:13,099 --> 00:17:14,359
在长期需要维护的系统中, raft 提供了一种方案来处理这种情况
with this which as well they might

409
00:17:14,359 --> 00:17:21,859
因为这真的很复杂
because it's complex all right so using

410
00:17:21,859 --> 00:17:25,449
这个想法在 1990 年就被使用了
this idea in about 1990 or so there were

411
00:17:25,449 --> 00:17:28,040
当时有两个系统几乎在同一时间发表这一观点
two systems proposed at about the same

412
00:17:28,040 --> 00:17:31,550
他们意识到，你能使用 majority voting system
time that realized that you could use

413
00:17:31,550 --> 00:17:34,210
他们意识到，你能使用 majority voting system
this majority voting system to kind of

414
00:17:34,210 --> 00:17:38,020
通过使用 3 台代替 2 台服务器的方法，同时采取投票表决
来解决这种显然无法避免的的脑裂问题
get around the apparent impossibility of

415
00:17:38,020 --> 00:17:41,150
通过使用 3 台代替 2 台服务器的方法，同时采取投票表决
来解决这种显然无法避免的的脑裂问题
avoiding split brain by using basically

416
00:17:41,150 --> 00:17:43,070
通过使用 3 台代替 2 台服务器的方法，同时采取投票表决
来解决这种显然无法避免的的脑裂问题
by using three servers instead of two

417
00:17:43,070 --> 00:17:46,520
通过使用 3 台代替 2 台服务器的方法，同时采取投票表决
来解决这种显然无法避免的的脑裂问题
and taking majority votes and in one of

418
00:17:46,520 --> 00:17:48,380
出现的比较早的就是 Paxos，raft 对此也讨论了许多
these very early systems was called

419
00:17:48,380 --> 00:17:51,860
出现的比较早的就是 PAXOS，raft 对此也讨论了许多
Paxos the RAFT paper talks about this a

420
00:17:51,860 --> 00:17:54,860
另一个非常早的系统称为 View-Stamped Replication(VSR)
lot and another of these very early

421
00:17:54,860 --> 00:17:56,420
另一个非常早的系统称为 View-Stamped Replication(VSR)
systems was called View-Stamped Replication

422
00:17:56,420 --> 00:18:00,170
缩写为 VSR
a abbreviation View-Stamped Replication

423
00:18:00,170 --> 00:18:02,840
尽管 PAXOS 是更加被广为人知的系统
and even though Paxos

424
00:18:02,840 --> 00:18:05,020
尽管 PAXOS 是更加被广为人知的系统
is by far the more widely known

425
00:18:05,020 --> 00:18:07,310
尽管 PAXOS 是更加被广为人知的系统
system in this department raft is

426
00:18:07,310 --> 00:18:09,590
实际上 raft 在设计上更加接近 VSR
actually closer to design in design to

427
00:18:09,590 --> 00:18:11,650
实际上 raft 在设计上更加接近 VSR
View-Stamped Replication

428
00:18:11,650 --> 00:18:16,970
这是咱们 MIT 的大佬们发明的（自豪）
which was invented by people at MIT and

429
00:18:16,970 --> 00:18:19,280
所以这些系统都经历了数十年的历史
so there's a sort of a long many decade

430
00:18:19,280 --> 00:18:21,620
所以这些系统都经历了数十年的历史
history of these systems and they only

431
00:18:21,620 --> 00:18:24,800
大约在 15 年前（现在是 2020 年），它们才开始被用于大型分布式系统
really came to the forefront and started

432
00:18:24,800 --> 00:18:27,200
大约在 15 年前（现在是 2020 年），它们才开始被用于大型分布式系统
being used a lot in deployed big

433
00:18:27,200 --> 00:18:29,270
大约在 15 年前（现在是 2020 年），它们才开始被用于大型分布式系统
distributed systems about 15 years

434
00:18:29,270 --> 00:18:31,970
自它们被发明以来，这 15 年它们都表现的非常棒
ago a good 15 years after they were

435
00:18:31,970 --> 00:18:39,680
自它们被发明以来，这 15 年它们都表现的非常棒
originally invented okay so let me talk

436
00:18:39,680 --> 00:18:42,340
okay，接下来就要开始讨论 raft 啦
about raft now

437
00:18:42,770 --> 00:18:46,169
raft 以 lib 库的形式被链接到某些服务器程序中
raft is a takes the form of a library

438
00:18:46,169 --> 00:18:49,049
raft 以 lib 库的形式被链接到某些服务器程序中
intended to be included in some service

439
00:18:49,049 --> 00:18:51,360
所以，如果你有一个复制服务
application so if you have a replicated

440
00:18:51,360 --> 00:18:53,580
每一个副本都会添加一些类似 rpc 的代码然后再加上 raft 库
service that each of the replicas in the

441
00:18:53,580 --> 00:18:55,020
每一个副本都会添加一些类似 rpc 的代码然后再加上 raft 库
service is gonna be some application

442
00:18:55,020 --> 00:18:57,150
每一个副本都会添加一些类似 rpc 的代码然后再加上 raft 库
code which you know receives rpcs or

443
00:18:57,150 --> 00:19:00,030
每一个副本都会添加一些类似 rpc 的代码然后再加上 raft 库
something plus a raft library and the

444
00:19:00,030 --> 00:19:01,740
接下来 raft 库会互相协作来维护 replication
raft libraries cooperate with each other

445
00:19:01,740 --> 00:19:06,030
接下来 raft 库会互相协作来维护 replication
to maintain replication

446
00:19:06,030 --> 00:19:10,260
这里我们先了解一下单个 raft 副本的软件架构
so sort of software overview of a single

447
00:19:10,260 --> 00:19:13,919
在最上层，我们可以思考一下副本有哪些代码
raft replica is that at the top we can

448
00:19:13,919 --> 00:19:15,539
在最上层，我们可以思考一下副本有哪些代码
think of the replicas having the

449
00:19:15,539 --> 00:19:17,850
在 lab3 中，它是一个 key-value 服务器
application code so it might be for lab

450
00:19:17,850 --> 00:19:20,789
在 lab3 中，它是一个 key-value 服务器
3 a key-value server so maybe we have

451
00:19:20,789 --> 00:19:24,390
这个 kv 数据库它是有状态的
some key value server and it has state the

452
00:19:24,390 --> 00:19:26,880
也就是应用程序是有状态的，raft 可以帮助它管理复制状态
application has state that raft is

453
00:19:26,880 --> 00:19:28,710
也就是应用程序是有状态的，raft 可以帮助它管理复制状态
helping it manage replicated state and

454
00:19:28,710 --> 00:19:30,299
对于 kv 服务器，通常它有一张表格来记录 key value
for a key value server it's going to be

455
00:19:30,299 --> 00:19:39,179
对于 kv 服务器，通常它有一张表格来记录 key value
a table of keys and values the next

456
00:19:39,179 --> 00:19:44,340
下面这一层是 raft 层
layer down is a raft layer so the key

457
00:19:44,340 --> 00:19:45,770
所以 kv 服务器会发起函数调用进入到 raft
value server is gonna sort of make

458
00:19:45,770 --> 00:19:47,760
所以 kv 服务器会发起函数调用进入到 raft
function calls into raft and they're

459
00:19:47,760 --> 00:19:49,080
他们之间会反复通信几次，raft 会保持一些状态
gonna chitchat back and forth a little

460
00:19:49,080 --> 00:19:52,070
他们之间会反复通信几次，raft 会保持一些状态
bit and raft keeps a little bit of state

461
00:19:52,070 --> 00:19:54,840
你可以在图 2 中看到
you can see it in Figure 2 and

462
00:19:54,840 --> 00:19:56,280
raft 中最关键的一个地方就是它有一个记录所有操作的 log 日志
our purpose really the most critical piece

463
00:19:56,280 --> 00:19:59,419
raft 中最关键的一个地方就是它有一个记录所有操作的 log 日志
of state is that raft has a log of

464
00:19:59,419 --> 00:20:08,370
现在我们拥有一个 3 副本的复制系统
operations and a system with 3 replicas

465
00:20:08,370 --> 00:20:09,510
现在我们拥有一个 3 副本的复制系统
we're actually gonna have you

466
00:20:09,510 --> 00:20:12,030
它们 3 个都有着完全相同的结构
know 3 servers that have exactly the

467
00:20:12,030 --> 00:20:14,460
它们 3 个都有着完全相同的结构
same identical structure and hopefully

468
00:20:14,460 --> 00:20:19,950
在每一层都希望它们有完全相同的数据
the very same data sitting in sitting at

469
00:20:19,950 --> 00:20:22,370
在每一层都希望它们有完全相同的数据
both layers

470
00:20:32,380 --> 00:20:35,720
在这外面，还有一些客户端
right outside of this there's gonna be

471
00:20:35,720 --> 00:20:38,870
游戏是这样的，我们有客户端 C1, C2
clients and the game is that so we have

472
00:20:38,870 --> 00:20:40,640
游戏是这样的，我们有客户端 C1, C2
you know client 1 and client two whole

473
00:20:40,640 --> 00:20:42,769
clients 不必知道它和谁去通信
bunch of clients the clients don't

474
00:20:42,769 --> 00:20:44,120
它只需要增加一些加上一些外部的（lib 库) 的代码就能使用服务
really know the clients are you know

475
00:20:44,120 --> 00:20:46,789
它只需要增加一些加上一些外部的（lib 库) 的代码就能使用服务
just external code that needs to be able

476
00:20:46,789 --> 00:20:49,580
它只需要增加一些加上一些外部的（lib 库) 的代码就能使用服务
to use the service and the hope is the

477
00:20:49,580 --> 00:20:50,960
我们希望 clients 不用关心它到底是同哪一个副本服务通信
clients won't really need to be aware

478
00:20:50,960 --> 00:20:52,309
我们希望 clients 不用关心它到底是同哪一个副本服务通信
that they're talking to a replicated

479
00:20:52,309 --> 00:20:53,690
而是要让它看起来像是只和一个服务器通信
service that to the clients that are

480
00:20:53,690 --> 00:20:55,940
而是要让它看起来像是只和一个服务器通信
looking almost like it's just one server

481
00:20:55,940 --> 00:20:59,029
而是要让它看起来像是只和一个服务器通信
and they talked with one server and so

482
00:20:59,029 --> 00:21:00,740
clients 把 key 发送到当前 leader 的 application layer(应用层)
leader 指的是 raft 中的 leader
the clients actually send client

483
00:21:00,740 --> 00:21:04,220
clients 把 key 发送到当前 leader 的 application layer(应用层)
leader 指的是 raft 中的 leader
requests to the key to the application

484
00:21:04,220 --> 00:21:08,090
clients 把 key 发送到当前 leader 的 application layer(应用层)
leader 指的是 raft 中的 leader
layer of the current leader the replica

485
00:21:08,090 --> 00:21:11,720
clients 把 key 发送到当前 leader 的 application layer(应用层)
leader 指的是 raft 中的 leader
that's the current leader in raft and so

486
00:21:11,720 --> 00:21:13,970
接下来应用层请求这个 key-value 数据库
these are gonna be you know application

487
00:21:13,970 --> 00:21:15,740
接下来应用层请求这个 key-value 数据库
level requests for a database for a key

488
00:21:15,740 --> 00:21:17,419
可能是 put 和 get 请求
value server these might be put and get

489
00:21:17,419 --> 00:21:20,570
put 请求就是用 key 和 value 来更新这个 table
requests you know put takes a key and a

490
00:21:20,570 --> 00:21:26,470
put 请求就是用 key 和 value 来更新这个 table
value and updates the table and get

491
00:21:26,470 --> 00:21:29,529
get 就是根据当前的 key 来查询当前的 value
asked the service to get the current key

492
00:21:29,529 --> 00:21:34,149
get 就是根据当前的 key 来查询当前的 value
current value corresponding to some key

493
00:21:34,149 --> 00:21:36,080
看起来 raft 好像在这里啥也没干
so this like has nothing about to do

494
00:21:36,080 --> 00:21:37,070
看起来 raft 好像在这里啥也没干
with raft it's just sort of

495
00:21:37,070 --> 00:21:38,510
就只有简单的 client 和 server 之间的交互
client-server interaction for whatever

496
00:21:38,510 --> 00:21:41,990
就只有简单的 client 和 server 之间的交互
service we're building but once one of

497
00:21:41,990 --> 00:21:43,580
但是一旦这些请求被 client 发送到 server，会发生什么事？
these commands gets sent from the

498
00:21:43,580 --> 00:21:44,990
但是一旦这些请求被 client 发送到 server，会发生什么事？
requests get sent from the clients of

499
00:21:44,990 --> 00:21:48,289
但是一旦这些请求被 client 发送到 server，会发生什么事？
the server what actually happens is you

500
00:21:48,289 --> 00:21:50,769
在非副本服务器上，应用层代码执行这条请求并更新这个 table
know on a non replicated server the

501
00:21:50,769 --> 00:21:53,000
在非副本服务器上，应用层代码执行这条请求并更新这个 table
application code would like execute this

502
00:21:53,000 --> 00:21:54,830
在非副本服务器上，应用层代码执行这条请求并更新这个 table
request and say update the table and

503
00:21:54,830 --> 00:21:56,690
然后回复这条 put 请求，但是在 raft 副本服务器上不是这样的
response to a put but not in a raft

504
00:21:56,690 --> 00:21:59,149
假设 client 发送了一条请求到 leader 上
replicated service instead if assuming

505
00:21:59,149 --> 00:22:00,740
假设 client 发送了一条请求到 leader 上
the client sends a request to leader

506
00:22:00,740 --> 00:22:04,190
应用层会把请求向下透传到 raft 层
what really happens is the application

507
00:22:04,190 --> 00:22:06,559
应用层会把请求向下透传到 raft 层
layer simply sends the request the

508
00:22:06,559 --> 00:22:08,480
应用层会把请求向下透传到 raft 层
clients request down into the raft layer

509
00:22:08,480 --> 00:22:09,909
说，Hi 伙计，这儿有一条请求，请把它提交到 replicated log(复制日志)里
to say look you know here's a request

510
00:22:09,909 --> 00:22:13,130
说，Hi 伙计，这儿有一条请求，请把它提交到 replicated log(复制日志)里
please get it committed into the

511
00:22:13,130 --> 00:22:15,440
啥时候你搞定了，再通知我一下
replicated log and tell me when you're

512
00:22:15,440 --> 00:22:17,600
此时 raft 会互相进行通信
done and so at this point the rafts

513
00:22:17,600 --> 00:22:23,840
直到半数以上的副本把这条操作添加到各自的日志中，表示它已经复制完成
chitchat with each other until all the

514
00:22:23,840 --> 00:22:25,820
直到半数以上的副本把这条操作添加到各自的日志中，表示它已经复制完成
replicas are a majority the replicas get

515
00:22:25,820 --> 00:22:29,000
直到半数以上的副本把这条操作添加到各自的日志中，表示它已经复制完成
this new operation into their logs said

516
00:22:29,000 --> 00:22:31,179
当 leader 知道所有副本完成复制后，只有在这个时候，raft 才会向上面的 kv 层发送通知
it is replicated and then when its

517
00:22:31,179 --> 00:22:34,909
当 leader 知道所有副本完成复制后，只有在这个时候，raft 才会向上面的 kv 层发送通知
and leader knows that all of the replicas of

518
00:22:34,909 --> 00:22:38,029
当 leader 知道所有副本完成复制后，只有在这个时候，raft 才会向上面的 kv 层发送通知
a copy of this only then as a raft sent

519
00:22:38,029 --> 00:22:40,340
当 leader 知道所有副本完成复制后，只有在这个时候，raft 才会向上面的 kv 层发送通知
a notification up back up to the key

520
00:22:40,340 --> 00:22:42,980
说，啊哈，你 1 分钟前发我的那条操作
value layer saying aha that operation

521
00:22:42,980 --> 00:22:44,389
说，啊哈，你 1 分钟前发我的那条操作
you sent me a minute ago

522
00:22:44,389 --> 00:22:46,129
现在已经提交到所有的副本中去了，它已经被安全的复制了
it's been now committed into all the

523
00:22:46,129 --> 00:22:49,309
现在已经提交到所有的副本中去了，它已经被安全的复制了
replicas and so it's safely replicated

524
00:22:49,309 --> 00:22:51,919
此时应用层就可以执行这条操作了
and at this point it's okay to execute

525
00:22:51,919 --> 00:22:55,089
此时应用层就可以执行这条操作了
that operation the raft you know the

526
00:22:55,089 --> 00:22:57,079
raft... client 把请求把送给 kv 层
client sends a request with the key

527
00:22:57,079 --> 00:22:59,119
raft... client 把请求把送给 kv 层
value layer key value layer does not

528
00:22:59,119 --> 00:23:01,999
kv 层还没有执行，所以我们也不能保证它会执行
execute it yet so we're not sure because

529
00:23:01,999 --> 00:23:04,579
因为这条操作尚未被复制，只有它被复制到所有副本中的时候，raft 才会通知 leader
it hasn't been replicated only when it's

530
00:23:04,579 --> 00:23:09,399
因为这条操作尚未被复制，只有它被复制到所有副本中的时候，raft 才会通知 leader
in all and the logs of all the replicas

531
00:23:09,399 --> 00:23:11,779
因为这条操作尚未被复制，只有它被复制到所有副本中的时候，raft 才会通知 leader
then raft notifies the leader now the

532
00:23:11,779 --> 00:23:13,429
这时候 leader 才会真正的执行这条操作
leader actually execute the operation

533
00:23:13,429 --> 00:23:15,440
对于 put 请求，就是更新这个 kv table
which corresponds to you know for a put updating the key-value table

534
00:23:15,440 --> 00:23:20,359
对于 get 请求，就是读取这个正确的 value 值
for a get reading correct

535
00:23:20,359 --> 00:23:22,039
最后会发送一个回复消息给客户端
value out of the table and then finally

536
00:23:22,039 --> 00:23:26,659
最后会发送一个回复消息给客户端
sends the reply back to the client so

537
00:23:26,659 --> 00:23:34,759
这就是个普通操作
that's the ordinary operation of the...

538
00:23:34,759 --> 00:23:36,319
超过半数被复制就会提交的
it's committed when it's in a majority and

539
00:23:36,319 --> 00:23:38,479
为什么不能是所有副本复制完再提交的原因是
again the reason why I can't be all is

540
00:23:38,479 --> 00:23:39,589
如果我们想构建这样一个容错系统
that if we want to build a

541
00:23:39,589 --> 00:23:41,299
它就必须有能力保证在部分服务宕机的情况下，也要保证系统正常运行
fault-tolerant system it has to be able

542
00:23:41,299 --> 00:23:43,519
它就必须有能力保证在部分服务宕机的情况下，也要保证系统正常运行
to make progress even if some of the

543
00:23:43,519 --> 00:23:49,449
它就必须有能力保证在部分服务宕机的情况下，也要保证系统正常运行
server's have failed so yeah so ever

544
00:23:49,449 --> 00:23:53,679
所以有超过半数以上的副本都复制后，就能提交了
so it's committed when it's in a majority

545
00:23:54,720 --> 00:23:57,890
[提问]

546
00:24:08,170 --> 00:24:12,710
sorry，是的，还有一个额外的步骤是当所有操作被提交时
sorry，yeah and so in addition when operations

547
00:24:12,710 --> 00:24:14,770
每一个副本都会向上层发送所有操作
finally committed each of the replicas

548
00:24:14,770 --> 00:24:17,660
每一个副本都会向上层发送所有操作
sends the operation up each of the raft

549
00:24:17,660 --> 00:24:20,780
每个 raft 层都会向上层的本地的应用发送操作
library layer sends the operation up to

550
00:24:20,780 --> 00:24:22,910
每个 raft 层都会向上层的本地的应用发送操作
the local application layer in the local

551
00:24:22,910 --> 00:24:24,590
本地应用层会把所有操作应用到它的状态上
application layer applies that operation

552
00:24:24,590 --> 00:24:27,050
本地应用层会把所有操作应用到它的状态上
to its state its state and so they all

553
00:24:27,050 --> 00:24:29,300
所有的副本都能看到相同的操作序列
so hopefully all the replicas seem the

554
00:24:29,300 --> 00:24:32,780
所有的副本都能看到相同的操作序列
same stream of operations they show up

555
00:24:32,780 --> 00:24:34,760
这些向上的调用顺序都是一致的，并且以相同的顺序被应用到状态中
in these up calls in the same order they

556
00:24:34,760 --> 00:24:36,350
这些向上的调用顺序都是一致的，并且以相同的顺序被应用到状态中
get applied to the state in the same

557
00:24:36,350 --> 00:24:38,960
假设所有这些操作都是确定性的
order and you know assuming the

558
00:24:38,960 --> 00:24:41,000
假设所有这些操作都是确定性的，最好是这样
operations are deterministic which they

559
00:24:41,000 --> 00:24:45,920
假设所有这些操作都是确定性的，最好是这样
better be the state of the replicas

560
00:24:45,920 --> 00:24:48,190
在所有的副本上，副本的状态都是一样的
replicated State will of all in

561
00:24:48,190 --> 00:24:50,360
在所有的副本上，副本的状态都是一样的
identically on all the replicas so

562
00:24:50,360 --> 00:24:52,400
典型的，这里这个 table 就是论文里说的 state
typically this this table is what the

563
00:24:52,400 --> 00:24:55,780
典型的，这里这个 table 就是论文里说的 state
paper is talking about when it talks

564
00:24:55,780 --> 00:25:02,090
咱们换种方式来看这个交互过程
about state a different way of viewing

565
00:25:02,090 --> 00:25:05,480
咱们换种方式来看这个交互过程
this interaction and one that'll sort of

566
00:25:05,480 --> 00:25:07,100
其中之一是这门课里将会多次提到的一种记号，时序图
notation that will come up a lot in this

567
00:25:07,100 --> 00:25:10,220
其中之一是这门课里将会多次提到的一种记号，时序图
course is that a sort of time diagram

568
00:25:10,220 --> 00:25:11,780
我待会儿画个给你看看，时序图里，消息是怎么传递的
I'll draw you a time diagram of how the

569
00:25:11,780 --> 00:25:13,850
假设有个 client(C1)，S1(leader), S2 和 S3
messages work so let's imagine we have a

570
00:25:13,850 --> 00:25:18,590
假设有个 client(C1)，S1(leader), S2 和 S3
client and server one is the leader that

571
00:25:18,590 --> 00:25:23,750
假设有个 client(C1)，S1(leader), S2 和 S3
we also have server to server three and

572
00:25:23,750 --> 00:25:25,820
朝下的方向表示时间流逝
time flows downward on this diagram we

573
00:25:25,820 --> 00:25:27,470
client 发送一条原始请求到 S1
imagine the client sending the original

574
00:25:27,470 --> 00:25:31,940
client 发送一条原始请求到 S1
request to server one after that server

575
00:25:31,940 --> 00:25:35,330
S1 的 raft 层发送一条 AppendEntries RPC 到另 2 个副本
ones raft layer sends an append entries

576
00:25:35,330 --> 00:25:42,800
S1 的 raft 层发送一条 AppendEntries RPC 到另 2 个副本
RPC to each of the two replicas this is

577
00:25:42,800 --> 00:25:44,530
这里是个普通的 put 请求
just an ordinary I'll say a put request

578
00:25:44,530 --> 00:25:49,370
这里是 AppendEntries 请求
this is append entries requests the

579
00:25:49,370 --> 00:25:51,980
这个 server 现在正在等待回复
server is now waiting for replies and

580
00:25:51,980 --> 00:25:55,010
S1 只要收到了半数以上节点的回复（包括它自己)
the server's from other replicas as soon

581
00:25:55,010 --> 00:25:58,280
S1 只要收到了半数以上节点的回复（包括它自己)
as replies from a majority arrive back

582
00:25:58,280 --> 00:26:00,800
S1 只要收到了半数以上节点的回复（包括它自己)
including the leader itself so in a

583
00:26:00,800 --> 00:26:02,090
在这个仅有 3 副本的系统里
system with only three replicas because the

584
00:26:02,090 --> 00:26:03,770
leader 只要收到了其它任意一台副本的对 AppendEntries 的响应，就构成了 majority
leader only has to wait for one other

585
00:26:03,770 --> 00:26:06,679
leader 只要收到了其它任意一台副本的对 AppendEntries 的响应，就构成了 majority
replica to respond positively to an

586
00:26:06,679 --> 00:26:09,309
leader 只要收到了其它任意一台副本的对 AppendEntries 的响应，就构成了 majority
append entries as soon as it assembles

587
00:26:09,309 --> 00:26:14,380
leader 只要收到了其它任意一台副本的对 AppendEntries 的响应，就构成了 majority
positive responses from a majority

588
00:26:14,380 --> 00:26:15,530
leader 执行 put 或 get 命令，并回复结果
the leader

589
00:26:15,530 --> 00:26:18,230
leader 执行 put 或 get 命令，并回复结果给 client
execute a command figures out what the

590
00:26:18,230 --> 00:26:20,380
leader 执行 put 或 get 命令，并回复结果给 client
answer is like put or get

591
00:26:20,380 --> 00:26:25,420
leader 执行 put 或 get 命令，并回复结果给 client
and sends the reply back to the client

592
00:26:25,420 --> 00:26:27,250
同时，你知道，S3 实际上还是在线的，它也会回复它的结果
and meanwhile of course you know S3

593
00:26:27,250 --> 00:26:30,700
同时，你知道，S3 实际上还是在线的，它也会回复它的结果
actually alive it'll send back its

594
00:26:30,700 --> 00:26:32,200
但是我们并不需要等待它的回复了
response too but we're not waiting for

595
00:26:32,200 --> 00:26:35,470
这个对理解图 2 来说很有用
it although it's useful to know and

596
00:26:35,470 --> 00:26:40,890
大家明白了吗？
figure 2 all right everybody see this

597
00:26:40,890 --> 00:26:43,120
这些就是对于没有异常情况下的普通操作
this is the sort of ordinary operation

598
00:26:43,120 --> 00:26:46,890
这些就是对于没有异常情况下的普通操作
of the system no no failures

599
00:26:51,200 --> 00:26:55,460
Oh gosh，是的，我好像遗漏了一个重要步骤
oh gosh yeah I like I left out important

600
00:26:55,460 --> 00:26:57,560
你知道，在这个时候，leader 知道大多数的副本已经把这条操作添加到了日志中了
steps so you know this point the leader

601
00:26:57,560 --> 00:26:59,750
你知道，在这个时候，leader 知道大多数的副本已经把这条操作添加到了日志中了
knows oh I got you know majority

602
00:26:59,750 --> 00:27:01,520
我可以现在可以执行客户端发来的命令，并回复 yes
put it into log I can go ahead and

603
00:27:01,520 --> 00:27:03,230
我可以现在可以执行客户端发来的命令，并回复 yes
execute it and reply yes to the client

604
00:27:03,230 --> 00:27:05,150
因为它(leader)提交了，但是 S2 还啥也不知道
because it's committed but server two

605
00:27:05,150 --> 00:27:06,380
因为它(leader)提交了，但是 S2 还啥也不知道
doesn't know anything yet it just knows

606
00:27:06,380 --> 00:27:07,640
它只知道，我从 leader 得到了一条请求，但是我不知道 leader 是否提交了它
well you know I got this request from

607
00:27:07,640 --> 00:27:09,590
它只知道，我从 leader 得到了一条请求，但是我不知道 leader 是否提交了它
the leader but I don't know if it's

608
00:27:09,590 --> 00:27:11,780
leader 是否提交依赖于，比如说依赖 S2 的回复是否被 leader 收到
committed yet depends on for example

609
00:27:11,780 --> 00:27:13,520
leader 是否提交依赖于，比如说依赖 S2 的回复是否被 leader 收到
whether my reply got back to the leader

610
00:27:13,520 --> 00:27:15,260
比如说 S2 的回复在网络中丢失，leader 就收不到回复
for all server 2 knows it's reply was

611
00:27:15,260 --> 00:27:16,940
比如说 S2 的回复在网络中丢失，leader 就收不到回复
drop by the network maybe the leader

612
00:27:16,940 --> 00:27:18,710
leader 因此也就决不会提交这条请求
never heard the reply and never decided

613
00:27:18,710 --> 00:27:20,360
leader 因此也就决不会提交这条请求
to commit this request so there's

614
00:27:20,360 --> 00:27:24,010
实际上这里还有另一个阶段还没讲
actually another stage once the server

615
00:27:24,010 --> 00:27:28,340
一旦 leader 意识到请求被提交，那么它就需要通知其它的副本这个事实
realizes that a request is committed it

616
00:27:28,340 --> 00:27:31,070
一旦 leader 意识到请求被提交，那么它就需要通知其它的副本这个事实
then needs to tell the other replicas that fact

617
00:27:31,070 --> 00:27:37,240
所以这里还有一条额外的消息
and so there are there's

618
00:27:38,320 --> 00:27:40,730
所以这里还有一条额外的消息
there's an extra message here exactly

619
00:27:40,730 --> 00:27:42,200
这条消息是什么，依赖于发生了什么事情
what that message is depends a little

620
00:27:42,200 --> 00:27:45,860
这条消息是什么，依赖于发生了什么事情
bit on what what else is going on it's

621
00:27:45,860 --> 00:27:49,520
至少在 raft 中，并不存在这样一条日志提交的消息
at least in raft there's not an explicit

622
00:27:49,520 --> 00:27:51,320
至少在 raft 中，并不存在这样一条日志提交的消息
commit message instead the information

623
00:27:51,320 --> 00:27:53,720
取而代之，leader 会在下一次的 AppendEntries 中，记录一些信息，然后发送出去
is piggybacked inside the next append

624
00:27:53,720 --> 00:27:55,640
取而代之，leader 会在下一次的 AppendEntries 中，记录一些信息，然后发送出去
entries that leader sends out the next

625
00:27:55,640 --> 00:27:57,620
取而代之，leader 会在下一次的 AppendEntries 中，记录一些信息，然后发送出去
append entries RPC it sends out for

626
00:27:57,620 --> 00:28:00,260
不管是什么原因，像 leader commit 或是别的什么东西，都会填充到 RPC 中
whatever reason like there's a commit

627
00:28:00,260 --> 00:28:01,820
不管是什么原因，像 leader commit 或是别的什么东西，都会填充到 RPC 中
leader commit or something filled in that

628
00:28:01,820 --> 00:28:05,780
在下次 leader 需要发送 heartbeat(心跳)的时候
RPC and the next time the leader needs

629
00:28:05,780 --> 00:28:07,880
在下次 leader 需要发送 heartbeat(心跳)的时候
have to send a heartbeat heartbeat or

630
00:28:07,880 --> 00:28:10,100
或是需要发送一条新的客户端请求的时候
needs to send out a new client request

631
00:28:10,100 --> 00:28:13,370
或是需要发送一条新的客户端请求的时候
because some different client requests

632
00:28:13,370 --> 00:28:16,570
会把 leader 最新的 commit 值连带发送出去
or something it'll send out the new higher

633
00:28:16,570 --> 00:28:19,280
会把 leader 最新的 commit 值连带发送出去
leader commit value and at that point

634
00:28:19,280 --> 00:28:25,250
在那时候，副本就会去执行这些操作，应用到各自的状态机中
the replicas will execute the operation

635
00:28:25,250 --> 00:28:30,790
在那时候，副本就会去执行这些操作，应用到各自的状态机中
and apply it to their state yes

636
00:28:39,700 --> 00:28:43,390
是的，这个协议有相当多的的通信
oh yes so this is a this is a protocol

637
00:28:43,390 --> 00:28:45,270
是的，这个协议有相当多的的通信
that has a quite a bit of chitchat in it

638
00:28:45,270 --> 00:28:51,130
并且它的速度也不怎么快
and it's not super fast indeed you know

639
00:28:51,130 --> 00:28:53,050
你知道，客户端发送请求到 server，然后 server 同其它实例通信
yeah client sends in request request has

640
00:28:53,050 --> 00:28:54,730
你知道，客户端发送请求到 server，然后 server 同其它实例通信
to get to the server the server talks to

641
00:28:54,730 --> 00:28:57,460
你知道，客户端发送请求到 server，然后 server 同其它实例通信
at least you know another instance that

642
00:28:57,460 --> 00:28:58,810
这中间有多条请求的响应都需要进行等待
multiple messages has to wait for the

643
00:28:58,810 --> 00:29:00,550
这中间有多条请求的响应都需要进行等待
responses send something back so there's

644
00:29:00,550 --> 00:29:02,200
而且这里好几轮消息需要来回发送多次
a bunch of message round-trip times

645
00:29:02,200 --> 00:29:05,640
而且这里好几轮消息需要来回发送多次
and added here

646
00:29:10,760 --> 00:29:15,260
是的，实际上这取决于你的实现
yes if so this is up to you as the

647
00:29:15,260 --> 00:29:17,929
当 leader 把最新的 commitIndex 发送出去后
implementer actually exactly when the

648
00:29:17,929 --> 00:29:21,169
当 leader 把最新的 commitIndex 发送出去后
leader sends out the updated commit

649
00:29:21,169 --> 00:29:26,600
如果客户端只是偶尔发送一条请求
index if client requests a comeback only

650
00:29:26,600 --> 00:29:29,090
如果客户端只是偶尔发送一条请求
very occasionally then you know the

651
00:29:29,090 --> 00:29:30,740
leader 或许就会发送 heartbeat 或是发送一条特殊的 AppendEntries 消息
leader may want to send out a heartbeat

652
00:29:30,740 --> 00:29:33,320
leader 或许就会发送 heartbeat 或是发送一条特殊的 AppendEntries 消息
or send out a special append entries

653
00:29:33,320 --> 00:29:37,549
如果客户端请求相当频繁，那也没关系
message if client requests come quite

654
00:29:37,549 --> 00:29:38,540
如果客户端请求相当频繁，那也没关系
frequently then it doesn't matter

655
00:29:38,540 --> 00:29:40,280
因为如果每秒在上千条请求到来
because if they come you know there's

656
00:29:40,280 --> 00:29:42,080
因为如果每秒在上千条请求到来
thousand arrive per second oh jesus

657
00:29:42,080 --> 00:29:43,520
oh, 天呐，这真的是相当的快
it'll be very longer very soon and

658
00:29:43,520 --> 00:29:45,230
所以你可以不用单独再生成一条额外的消息去通知其它副本，这个代价太高了
so you can piggyback so without

659
00:29:45,230 --> 00:29:46,669
所以你可以不用单独再生成一条额外的消息去通知其它副本，这个代价太高了
generating an extra message which is

660
00:29:46,669 --> 00:29:48,410
所以你只要把你的信息放在下一条消息里就行了
somewhat expensive you can get the

661
00:29:48,410 --> 00:29:50,059
所以你只要把你的信息放在下一条消息里就行了
information out on the next message you

662
00:29:50,059 --> 00:29:53,450
所以你只要把你的信息放在下一条消息里就行了
were gonna send anyway in fact I I don't

663
00:29:53,450 --> 00:29:58,820
事实上，我认为副本执行请求的时间点并不是关键
think the time at which the replicas

664
00:29:58,820 --> 00:30:02,020
事实上，我认为副本执行请求的时间点并不是关键
execute the request is critical because

665
00:30:02,020 --> 00:30:04,640
因为没有人需要等待它的返回结果
nobody's waiting for it at least if

666
00:30:04,640 --> 00:30:06,500
至少在在没有异常的情况下是这样
there's no failures if there's no

667
00:30:06,500 --> 00:30:10,700
如果没有异常，副本执行请求就不在关键路径中
failures replicas executing the request

668
00:30:10,700 --> 00:30:12,679
如果没有异常，副本执行请求就不在关键路径中
isn't really on the critical path like

669
00:30:12,679 --> 00:30:13,970
比如客户端并不需要去等待它们（其它副本）
the client isn't waiting for them the

670
00:30:13,970 --> 00:30:15,200
而是等待 leader 执行完
client is waiting for the leader to

671
00:30:15,200 --> 00:30:20,540
所以它并不会影响客户端的延时
execute so it may not be that it may not

672
00:30:20,540 --> 00:30:23,600
所以它并不会影响客户端的延时
affect client perceived latency sort of

673
00:30:23,600 --> 00:30:26,980
严格来说，这就是它的工作方式
exactly how this gets staged

674
00:30:37,520 --> 00:30:45,900
好，还有一个必须要正视的问题
all right one question you should ask is

675
00:30:45,900 --> 00:30:48,750
为什么系统要如此关注 log(日志)，日志又是用来干什么的？
why does the system why is the system so

676
00:30:48,750 --> 00:30:52,640
为什么系统要如此关注 log(日志)，日志又是用来干什么的？
focused on logs what are the logs doing

677
00:30:52,640 --> 00:30:54,930
尝试找出这个问题的答案是有意义，有价值的
and it's sort of worth trying to come up

678
00:30:54,930 --> 00:30:56,630
尝试找出这个问题的答案是有意义，有价值的
with an explicit answers to that one

679
00:30:56,630 --> 00:31:00,210
日志如此重要的原因是，它是一种机制
answer to why the system is totally

680
00:31:00,210 --> 00:31:04,200
日志如此重要的原因是，它是一种机制
focused on logs is that the log is the

681
00:31:04,200 --> 00:31:05,700
通过这个机制，leader 可以维护操作的顺序
kind of mechanism by which the leader

682
00:31:05,700 --> 00:31:08,730
这个顺序对复制状态机业说非常重要
orders operations it's vital for these

683
00:31:08,730 --> 00:31:10,830
这个顺序对复制状态机业说非常重要
replicated state machines that all the

684
00:31:10,830 --> 00:31:13,890
所有的副本，不仅仅要应用客户端的同样的请求操作
replicas apply not just the same client

685
00:31:13,890 --> 00:31:15,720
所有的副本，不仅仅要应用客户端的同样的请求操作
operations to their start but the same

686
00:31:15,720 --> 00:31:18,690
而且还要以相同的顺序去执行
operations in the same order but they

687
00:31:18,690 --> 00:31:20,610
所有来自客户端的请求操作，都要以相同的顺序在不同副本上执行
all have to apply that these operations

688
00:31:20,610 --> 00:31:22,260
所有来自客户端的请求操作，都要以相同的顺序在不同副本上执行
coming from the clients in the same

689
00:31:22,260 --> 00:31:24,240
在众多的事情中，日志也是复制状态机的一部分
order and the log among many other

690
00:31:24,240 --> 00:31:26,580
在众多的事情中，日志也是复制状态机的一部分
things is part of the machinery by which

691
00:31:26,580 --> 00:31:30,690
通过它，leader 可以安排客户端请求操作的顺序
the or the leader assigns an order to

692
00:31:30,690 --> 00:31:32,430
通过它，leader 可以安排客户端请求操作的顺序
the incoming client operations I give

693
00:31:32,430 --> 00:31:34,620
如果有 10 个客户端并发请求 leader
you know ten clients send operations to

694
00:31:34,620 --> 00:31:36,090
如果有 10 个客户端并发请求 leader
the leader at the same time the client

695
00:31:36,090 --> 00:31:37,950
leader 需要选择一个顺序，确保所有的副本都要遵守这个顺序
the leader has to pick pick an order

696
00:31:37,950 --> 00:31:39,300
leader 需要选择一个顺序，确保所有的副本都要遵守这个顺序
make sure everybody all the replicas

697
00:31:39,300 --> 00:31:41,880
事实上，日志包含了一个一个编号的槽
obey that order and the log is you know

698
00:31:41,880 --> 00:31:44,090
事实上，日志包含了一个一个编号的槽
the fact that the log has numbered slots

699
00:31:44,090 --> 00:31:46,740
它包含了 leader 传送过来的操作顺序
this part have a leader expresses the

700
00:31:46,740 --> 00:31:52,680
它包含了 leader 传送过来的操作顺序
order it's chosen another use of the log

701
00:31:52,680 --> 00:31:56,700
日志的另一个用途是，从这里到这里这个时间中间
is that between this point and this

702
00:31:56,700 --> 00:32:00,330
S3 收到了 leader 发来的操作，但是它不确定该操作是否已经提交
point server 3 has received an operation

703
00:32:00,330 --> 00:32:02,520
S3 收到了 leader 发来的操作，但是它不确定该操作是否已经提交
that it is not yet sure is committed and

704
00:32:02,520 --> 00:32:04,560
因此它还不能去执行，它必须把这条操作暂存起来
it cannot execute it yet it has to put

705
00:32:04,560 --> 00:32:07,440
因此它还不能去执行，它必须把这条操作暂存起来
the this operation aside somewhere until

706
00:32:07,440 --> 00:32:11,340
直到接收到 leader 的 commit 号增长这条消息
the increment to the leader commit value

707
00:32:11,340 --> 00:32:13,500
所以 log 另一个作用是，对于 follower 来说
comes in and so another thing that the

708
00:32:13,500 --> 00:32:15,090
所以 log 另一个作用是，对于 follower 来说
log is doing is that on the followers

709
00:32:15,090 --> 00:32:17,130
日志是 follwer 用于暂存操作的地方，这些操作都是暂定的
the log is the place where the follower

710
00:32:17,130 --> 00:32:18,660
日志是 follwer 用于暂存操作的地方，这些操作都是暂定的
sort of sets aside operations that are

711
00:32:18,660 --> 00:32:20,490
日志是 follwer 用于暂存操作的地方，这些操作都是暂定的
still tentative that have arrived but

712
00:32:20,490 --> 00:32:21,990
虽然已经收到了，但是还不确定是否可以提交
are not yet known to be committed and

713
00:32:21,990 --> 00:32:23,340
他们也可能会把它丢弃掉，后面我们将会看到这种情况
they may have to be thrown away as we'll

714
00:32:23,340 --> 00:32:27,030
所以这是另一种用法
see so that's another use I'm the I sort

715
00:32:27,030 --> 00:32:29,730
leader 使用日志是因为 leader 需要把操作记录在日志里
of do log that use on the leader side

716
00:32:29,730 --> 00:32:33,500
leader 使用日志是因为 leader 需要把操作记录在日志里
is that the leader needs to remember

717
00:32:33,500 --> 00:32:36,300
leader 使用日志是因为 leader 需要把操作记录在日志里
operations in its log because it may

718
00:32:36,300 --> 00:32:38,970
在部分 follower 离线时，可以进行重传
need to retransmit them to followers if

719
00:32:38,970 --> 00:32:40,770
在部分 follower 离线时，可以进行重传
some followers offline maybe it's

720
00:32:40,770 --> 00:32:41,880
比如网络发生短暂的故障或是消息丢失了
something briefly happened to its

721
00:32:41,880 --> 00:32:42,269
比如网络发生短暂的故障或是消息丢失了
network

722
00:32:42,269 --> 00:32:44,149
比如网络发生短暂的故障或是消息丢失了
action or something misses some messages

723
00:32:44,149 --> 00:32:46,440
leader 就要有能力重新发送 follower 错过的日志消息
the leader needs to be able to resend

724
00:32:46,440 --> 00:32:49,109
leader 就要有能力重新发送 follower 错过的日志消息
log messages that any followers missed

725
00:32:49,109 --> 00:32:50,700
所以 leader 需要有这么一个地方来保存客户端请求的 copy
and so the leader needs a place where

726
00:32:50,700 --> 00:32:52,859
所以 leader 需要有这么一个地方来保存客户端请求的 copy
can set aside copies of messages of

727
00:32:52,859 --> 00:32:54,570
即使这些请求已经被执行过
client requests even ones that it's already executed

728
00:32:54,570 --> 00:32:56,969
就是为了能够把它们重传给 client(口误，应该是重传给 server)
in order to be able to

729
00:32:56,969 --> 00:33:00,539
就是为了能够把它们重传给 client(口误，应该是重传给 server)
resend them to the client I mean resend

730
00:33:00,539 --> 00:33:04,019
我意思是把他们重传给丢失了部分操作的副本（纠正了一下）
them to replicas that missed missed that

731
00:33:04,019 --> 00:33:05,879
最后一个他们保存日志的原因，至少在图 2 所描述的
operation and a final reason for all of

732
00:33:05,879 --> 00:33:07,950
最后一个保存日志的原因，至少在图 2 所描述的
them to keep the log is that at least in

733
00:33:07,950 --> 00:33:11,009
最后一个保存日志的原因，至少在图 2 所描述的
the world of figure 2 if a server

734
00:33:11,009 --> 00:33:15,259
如果一个 server 宕机后重启，并重新加入，那就需要这些日志
crashes and restarts and wants to rejoin

735
00:33:15,259 --> 00:33:17,759
如果你确实需要一台宕机的 server 启动并重新加入 raft 集群的话
and you really need if it you really

736
00:33:17,759 --> 00:33:19,469
如果你确实需要一台宕机的 server 启动并重新加入 raft 集群的话
want a server that crashes - in fact we

737
00:33:19,469 --> 00:33:21,599
如果你确实需要一台宕机的 server 启动并重新加入 raft 集群的话
start and rejoin the raft cluster

738
00:33:21,599 --> 00:33:23,249
如果不能重新加入，你现在可操作的机器就只剩下 3 台中的 2 台
otherwise you're now operating with only

739
00:33:23,249 --> 00:33:24,809
如果不能重新加入，你现在可操作的机器就只剩下 3 台中的 2 台
two out of three servers and you can't

740
00:33:24,809 --> 00:33:26,820
假设再发生点故障，你就无法容错了
survive any more failures we need to

741
00:33:26,820 --> 00:33:29,399
所以我们需要能把失败的机器重启并重新加入集群
reincorporate failed and rebooted

742
00:33:29,399 --> 00:33:31,950
server 在重新启动之后，会使用持久化在磁盘上的日志
servers and the log is sort of where or

743
00:33:31,950 --> 00:33:34,440
server 在重新启动之后，会使用持久化在磁盘上的日志
what a server rebooted server uses the

744
00:33:34,440 --> 00:33:37,169
server 在重新启动之后，会使用持久化在磁盘上的日志
log persisted to its disk because one of

745
00:33:37,169 --> 00:33:39,570
因为有一条规则是每个 raft server 需要把它的日志写入磁盘
the rules is that each raft server needs

746
00:33:39,570 --> 00:33:41,159
因为有一条规则是每个 raft server 需要把它的日志写入磁盘
to write its log to its disk where it

747
00:33:41,159 --> 00:33:42,539
这样即使它在宕机后，日志仍然存在
will still be after it crashes and

748
00:33:42,539 --> 00:33:44,459
重启之后，server 会使用，并对日志中的操作从头进行重演
restarts that log is what the server

749
00:33:44,459 --> 00:33:48,239
重启之后，server 会使用日志中的操作，从头进行重演
uses or replays the operations in that

750
00:33:48,239 --> 00:33:50,369
重启之后，server 会使用日志中的操作，从头进行重演
log from the beginning to sort of create

751
00:33:50,369 --> 00:33:52,709
直到创建出宕机之前的状态，然后继续运行
its state as of when it crashed and then

752
00:33:52,709 --> 00:33:54,809
直到创建出宕机之前的状态，然后继续运行
then it carries on from there so the log

753
00:33:54,809 --> 00:33:56,339
所以 log 也会被用于持久化，将来用于重建状态
is also used as part of the persistence

754
00:33:56,339 --> 00:33:58,499
所以 log 也会被用于持久化，将来用于重建状态
plan as a sequence of commands to

755
00:33:58,499 --> 00:34:01,129
所以 log 也会被用于持久化，将来用于重建状态
rebuild the state

756
00:34:16,280 --> 00:34:20,270
好吧，最后还是有人问了。。。问题是说
well ultimately okay so the question is

757
00:34:20,270 --> 00:34:23,339
假设 leader 有能力每秒处理 1000 个客户端的命令
suppose the leader is capable of

758
00:34:23,339 --> 00:34:25,199
假设 leader 有能力每秒处理 1000 个客户端的命令
executing a thousand client commands a

759
00:34:25,199 --> 00:34:26,879
但是 follower 每秒只能处理 100 个客户端命令
second and the followers are only

760
00:34:26,879 --> 00:34:28,710
但是 follower 每秒只能处理 100 个客户端命令
incapable of executing a hundred client

761
00:34:28,710 --> 00:34:30,179
但是 follower 每秒只能处理 100 个客户端命令
commands per second that's sort of

762
00:34:30,179 --> 00:34:36,060
这是它能处理的最大速率
sustained rate you know full speed v so

763
00:34:36,060 --> 00:34:41,599
其中一件事要注意的是
one thing to note is that the the

764
00:34:41,599 --> 00:34:43,800
副本，也就是 follower 在执行命令前需要先进行确认
replicas the followers acknowledge

765
00:34:43,800 --> 00:34:45,629
副本，也就是 follower 在执行命令前需要先进行确认
commands before they execute them so

766
00:34:45,629 --> 00:34:47,190
在它们的日志中，确认和累积的速率是不受限制的
the rate at which they acknowledge

767
00:34:47,190 --> 00:34:48,750
在它们的日志中，确认和累积的速率是不受限制的
and accumulate stuff in their logs is

768
00:34:48,750 --> 00:34:51,060
所以它们可能会一秒一次确认 1000 条请求
not limited so you know maybe they can

769
00:34:51,060 --> 00:34:52,469
所以它们可能会一秒一次确认 1000 条请求
acknowledge that a thousand requests per

770
00:34:52,469 --> 00:34:55,530
如果它们一直这样做，将会导致日志大小没有上限
second if they do that forever then they

771
00:34:55,530 --> 00:34:57,690
如果它们一直这样做，将会导致日志大小没有上限
will build up unbounded size logs

772
00:34:57,690 --> 00:35:00,300
因为它们执行的速率远远落后于 leader 发送请求的速率
because their execution rate falls it

773
00:35:00,300 --> 00:35:02,369
因为它们执行的速率远远落后于 leader 发送请求的速率
will fall on an unbounded amount behind

774
00:35:02,369 --> 00:35:04,710
因为它们执行的速率远远落后于 leader 发送请求的速率
the rate at which the leader has given

775
00:35:04,710 --> 00:35:06,210
在我们的游戏规则里，这意味着它们最终会在某个时间点耗尽内存
the messages sort of under the rules of

776
00:35:06,210 --> 00:35:08,820
在我们的游戏规则里，这意味着它们最终会在某个时间点耗尽内存
our game and so what that means they

777
00:35:08,820 --> 00:35:11,250
在我们的游戏规则里，这意味着它们最终会在某个时间点耗尽内存
will eventually run out of memory at

778
00:35:11,250 --> 00:35:13,440
当它落后 10 亿条日志后
some point so after they have a billion

779
00:35:13,440 --> 00:35:15,390
当它落后 10 亿条日志后
after they fall a billion log entries

780
00:35:15,390 --> 00:35:16,770
内存分配器再为新的日志条目分配内存就会失败
behind those just like they'll call the

781
00:35:16,770 --> 00:35:18,510
内存分配器再为新的日志条目分配内存就会失败
memory allocator for space for a new

782
00:35:18,510 --> 00:35:22,830
内存分配器再为新的日志条目分配内存就会失败
log entry and it will fail so yeah and

783
00:35:22,830 --> 00:35:27,420
是的，Raft 不具备流量控制来处理这样的情况
Raft doesn't Raft doesn't have the flow

784
00:35:27,420 --> 00:35:30,359
是的，Raft 不具备流量控制来处理这样的情况
controls that's required to cope with

785
00:35:30,359 --> 00:35:34,349
所以我认为，在真实的系统中
this so I think in a real system you

786
00:35:34,349 --> 00:35:36,180
你知道可能会使用 piggyback
(piggyback 捎带消息，就是前面讲过的，把消息放到下一次请求中一起发出去)
would actually need you know probably

787
00:35:36,180 --> 00:35:37,770
并且它也不需要那么的实时
piggybacked and doesn't need to be

788
00:35:37,770 --> 00:35:39,920
在这里，你可能需要一些额外的通信来表明执行到哪里了
real-time but you probably need some

789
00:35:39,920 --> 00:35:43,920
在这里，你可能需要一些额外的通信来表明执行到哪里了
kind of additional communication here

790
00:35:43,920 --> 00:35:45,570
在这里，你可能需要一些额外的通信来表明执行到哪里了
that says well here's how far I've

791
00:35:45,570 --> 00:35:48,150
这样便于 leader 发现，哦，我领先 follwer 上千条请求了
gotten in execution so that the leader

792
00:35:48,150 --> 00:35:50,520
这样便于 leader 发现，哦，我领先 follwer 上千条请求了
can say well you know too many thousands

793
00:35:50,520 --> 00:35:53,099
这样便于 leader 发现，哦，我领先 follwer 上千条请求了
of requests ahead of the point in which

794
00:35:53,099 --> 00:35:55,050
这样便于 leader 发现，哦，我领先 follwer 上千条请求了
the followers have executed yes I think

795
00:35:55,050 --> 00:35:56,630
在生产系统中，这种领先可能会推进到系统绝对最大值（达到系统上限)
there's probably you know in a

796
00:35:56,630 --> 00:35:58,859
在生产系统中，这种领先可能会推进到系统绝对最大值（达到系统上限
production system that you're trying to

797
00:35:58,859 --> 00:36:01,650
此时你就需要一些额外的信息来限制 leader，防止它领先太多
push to the absolute max you would you

798
00:36:01,650 --> 00:36:03,300
此时你就需要一些额外的信息来限制 leader，防止它领先太多
might well need an extra message to

799
00:36:03,300 --> 00:36:05,250
此时你就需要一些额外的信息来限制 leader，防止它领先太多
throttle the leader if it got too far

800
00:36:05,250 --> 00:36:07,400
此时你就需要一些额外的信息来限制 leader，防止它领先太多
ahead

801
00:36:31,700 --> 00:36:36,079
okay，问题是说如果这些 server 之一宕机
okay so the question is if if one of

802
00:36:36,079 --> 00:36:38,299
okay，问题是说如果这些 server 之一宕机
these servers crashes it has this log

803
00:36:38,299 --> 00:36:39,920
图 2 有一条规则说，日志需要持久化到磁盘上
that it persisted to disk because that's

804
00:36:39,920 --> 00:36:42,890
图 2 有一条规则说，日志需要持久化到磁盘上
one of the rules of figure two so the

805
00:36:42,890 --> 00:36:43,940
所以 server 可以从磁盘上就可以恢复出日志
server will be able to be just logged

806
00:36:43,940 --> 00:36:47,030
当然了，server 并不知道当前日志已经执行到哪里
back from disk but of course that server

807
00:36:47,030 --> 00:36:49,819
当然了，server 并不知道当前日志已经执行到哪里
doesn't know how far it got in executing

808
00:36:49,819 --> 00:36:52,549
至少第一次刚启动的时候它是不知道的
the log and also it doesn't know at

809
00:36:52,549 --> 00:36:54,710
至少第一次刚启动的时候它是不知道的
least when it first reboots by the rule

810
00:36:54,710 --> 00:36:56,599
根据图 2 的规则，它甚至不知道日志提交了多少
that figure two it doesn't even know how

811
00:36:56,599 --> 00:36:59,329
根据图 2 的规则，它甚至不知道日志提交了多少
much of the log is committed so the

812
00:36:59,329 --> 00:37:00,619
所以你的问题的答案是，如果一个 server 在宕机后重新启动
first answer to your question is that

813
00:37:00,619 --> 00:37:03,920
所以你的问题的答案是，如果一个 server 在宕机后重新启动
immediately after a restart you know

814
00:37:03,920 --> 00:37:05,599
所以你的问题的答案是，如果一个 server 在宕机后重新启动
after a server crashes and restarts and

815
00:37:05,599 --> 00:37:07,490
它会读取它的日志，除此之外它什么也不能做
reads its log it is not allowed to do

816
00:37:07,490 --> 00:37:10,220
它会读取它的日志，除此之外它什么也不能做
anything with the log because it does

817
00:37:10,220 --> 00:37:11,869
因为它不知道日志提交到多远的位置
not know how far the system has

818
00:37:11,869 --> 00:37:14,780
因为它不知道日志提交到多远的位置
committed in its log maybe as long as

819
00:37:14,780 --> 00:37:16,549
也许是 1000 条没有提交，0 条已提交
has a thousand uncommitted entries and

820
00:37:16,549 --> 00:37:18,230
也许是 1000 条没有提交，0 条已提交
zero committed entries for all it notes

821
00:37:18,230 --> 00:37:20,799
也许是 1000 条没有提交，0 条已提交
so

822
00:37:24,810 --> 00:37:26,980
如果 leader 挂了，当然就没什么用了
if a leader die of course that doesn't

823
00:37:26,980 --> 00:37:28,750
但是我们可以假设，如果他们全宕机了
help either but let's suppose they've

824
00:37:28,750 --> 00:37:32,589
这对我来说有点超纲了
all crashed this is getting ahead of its

825
00:37:32,589 --> 00:37:33,670
这对我来说有点超纲了
getting a bit ahead of me but well

826
00:37:33,670 --> 00:37:34,810
不过还是假设它们都宕机了
suppose they've all crashed and so all

827
00:37:34,810 --> 00:37:37,420
图 2 显示，它们持有的状态被标记为非易失的
they have is the state that was marked

828
00:37:37,420 --> 00:37:40,180
图 2 显示，它们持有的状态被标记为非易失的
as non-volatile in figure 2 which

829
00:37:40,180 --> 00:37:42,070
还包括日志，好像还有最新的 term(任期号)
includes the log and maybe the latest

830
00:37:42,070 --> 00:37:45,310
所以它们不知道……如果他们全宕机了
term and so they don't know some if

831
00:37:45,310 --> 00:37:46,869
所以它们不知道……如果他们全宕机了
there's a crash but they all crash and

832
00:37:46,869 --> 00:37:48,690
它们当中没有人能知道它们曾经执行到了什么地方
they always start none of them knows

833
00:37:48,690 --> 00:37:52,869
它们当中没有人能知道它们曾经执行到了什么地方
initially how far they had been have

834
00:37:52,869 --> 00:37:55,270
它们当中没有人能知道它们曾经执行到了什么地方
executed before the crash so what

835
00:37:55,270 --> 00:37:57,430
所以接下来就会发生 leader 选举
happens is that you leader election one

836
00:37:57,430 --> 00:38:00,339
它们当中之一会选择一个 leader 出来
of them gets picked as a leader and that

837
00:38:00,339 --> 00:38:03,820
如果你看过论文的话，你就能看到
leader if you sort of track through what

838
00:38:03,820 --> 00:38:06,520
图 2 中会解释，AppendEntries 是如何工作的
figure 2 says about how AppendEntries

839
00:38:06,520 --> 00:38:08,470
图 2 中会解释，AppendEntries 是如何工作的
is supposed to work the leader will

840
00:38:08,470 --> 00:38:10,680
leader 实际上会从发送AppendEntries
actually figure out as a byproduct of

841
00:38:10,680 --> 00:38:12,820
发送心跳带来的副产品中断定一些信息
sending out AppendEntries sending out the

842
00:38:12,820 --> 00:38:16,000
发送心跳带来的副产品中断定一些信息
first heartbeat really it'll

843
00:38:16,000 --> 00:38:19,690
它能够推断出最新的提交位置
figure out what the latest point is

844
00:38:19,690 --> 00:38:28,300
也就是半数以上的副本都能对它们的日志达成一致的位置
basically that that all of the that a

845
00:38:28,300 --> 00:38:30,940
也就是半数以上的副本都能对它们的日志达成一致的位置
majority of the replicas agree on their

846
00:38:30,940 --> 00:38:33,690
因为这就是提交的位置
logs because that's the commit point

847
00:38:33,690 --> 00:38:35,650
另一种看待方式是
another way of looking at it is that

848
00:38:35,650 --> 00:38:37,750
一旦你选择了一个 leader
once you choose a leader through the

849
00:38:37,750 --> 00:38:39,490
通过 AppendEntries 机制
append entries mechanism the leader

850
00:38:39,490 --> 00:38:41,560
leader 会强制所有其它副本和 leader 有完全相同的日志
forces all of the other replicas to have

851
00:38:41,560 --> 00:38:44,050
leader 会强制所有其它副本和 leader 有完全相同的日志
identical logs to the leader and at that

852
00:38:44,050 --> 00:38:46,480
在这一点，论文作了一些解释
point plus a little bit of extra the

853
00:38:46,480 --> 00:38:48,820
在这一点，论文作了一些解释
paper explains at that point since the

854
00:38:48,820 --> 00:38:50,589
由于 leader 知道它强制让所有副本拥有相同的日志
leader knows that it's forced all the

855
00:38:50,589 --> 00:38:52,570
由于 leader 知道它强制让所有副本拥有相同的日志
replicas to have logs

856
00:38:52,570 --> 00:38:54,940
由于 leader 知道它强制让所有副本拥有相同的日志
that are identicals to it then it knows

857
00:38:54,940 --> 00:38:57,119
它知道有半数以上的副本都拥有这些日志项
that all the replicas must also have a

858
00:38:57,119 --> 00:39:00,790
它知道有半数以上的副本都拥有这些日志项
there must be a majority of replicas

859
00:39:00,790 --> 00:39:03,160
它知道有半数以上的副本都拥有这些日志项
with that all those log entires in that

860
00:39:03,160 --> 00:39:04,900
这些日志是完全相同的，也必须是已被提交的
logs which are now are identical must

861
00:39:04,900 --> 00:39:06,070
因为它们被半数以上的副本所持有
also be committed because they're held

862
00:39:06,070 --> 00:39:09,880
因为它们被半数以上的副本所持有
on a majority of replicas and at that

863
00:39:09,880 --> 00:39:13,720
在这一点，leader……
point a leader you know the append

864
00:39:13,720 --> 00:39:15,820
图 2 中描述的，针对 leader 的 AppendEntires 代码
entries code described in Figure 2 for

865
00:39:15,820 --> 00:39:17,800
会递增 leader 的提交点
the leader will increment the leaders

866
00:39:17,800 --> 00:39:19,930
所有人现在都能从头开始执行完整的日志
commit point and everybody can now

867
00:39:19,930 --> 00:39:21,820
所有人现在都能从头开始执行完整的日志
execute the entire log from the

868
00:39:21,820 --> 00:39:24,400
从 0 开始重建他们的状态
beginning and recreate their state from

869
00:39:24,400 --> 00:39:29,730
这可能相当的费时
scratch possibly extremely laborious

870
00:39:29,880 --> 00:39:32,650
所以这就是图 2 中所说的
so that's what figure two says it's

871
00:39:32,650 --> 00:39:34,930
显然从 0 开始执行，显的有点不太吸引人
obviously this be executing from scratch

872
00:39:34,930 --> 00:39:37,780
显然从 0 开始执行，显的有点不太吸引人
is not very attractive but it's where

873
00:39:37,780 --> 00:39:40,000
但是这就是基础协议规定要做的
the basic protocol does and we'll see

874
00:39:40,000 --> 00:39:42,970
不过明天我们能看到一个更高效的版本
tomorrow that the the sort of version of

875
00:39:42,970 --> 00:39:44,110
不过明天我们能看到一个更高效的版本
this is more efficient to use as

876
00:39:44,110 --> 00:39:45,730
它使用 checkpoint 机制，咱们明天会讲
checkpoints and we'll talk about tomorrow

877
00:39:45,730 --> 00:39:50,890
okay，这就是普通的没异常的情况下的执行步骤
okay so this was a sequence in

878
00:39:50,890 --> 00:39:54,990
okay，这就是普通的没异常的情况下的执行步骤
sort of ordinary non failure operation

879
00:39:55,380 --> 00:39:57,250
另一件事是我想简单介绍下 raft 接口长啥样
another thing I want to briefly mention

880
00:39:57,250 --> 00:40:00,760
另一件事是我想简单介绍下 raft 接口长啥样
is what this interface looks like you've

881
00:40:00,760 --> 00:40:03,220
你们可能做 lab 的时候已经看到过了
probably all seen a little bit of it due

882
00:40:03,220 --> 00:40:05,410
你们可能做 lab 的时候已经看到过了
to working on the labs but roughly

883
00:40:05,410 --> 00:40:07,420
粗略来说，这里有一个 key-value 层，这里有它的状态
speaking if you have let's say that this

884
00:40:07,420 --> 00:40:12,400
粗略来说，这里有一个 key-value 层，这里有它的状态
key value layer with its state and the

885
00:40:12,400 --> 00:40:16,000
raft 层在它之下
raft layer underneath it there's on each

886
00:40:16,000 --> 00:40:18,330
在每个副本中，有 2 个非常重要的接口
replica there's really two main pieces

887
00:40:18,330 --> 00:40:20,920
在每个副本中，有 2 个非常重要的接口
of the interface between them there's

888
00:40:20,920 --> 00:40:24,010
如果客户端发送请求过来，那么 key-value 层可以使用这个接口请求 raft 层
this method by which the key value layer

889
00:40:24,010 --> 00:40:26,230
如果客户端发送请求过来，那么 key-value 层可以使用这个接口请求 raft 层
can relay if a client sends in a request

890
00:40:26,230 --> 00:40:27,910
key-value 层必须把它传递给 raft
the key value layer has to give it to

891
00:40:27,910 --> 00:40:29,890
说: Hi, raft, 请把这条请求放到日志的某个地方
raft and say please you know fit this

892
00:40:29,890 --> 00:40:31,420
说: Hi, raft, 请把这条请求放到日志的某个地方
request into the log somewhere and

893
00:40:31,420 --> 00:40:36,760
这个函数是 start(command)，后面你会在 raft.go 文件里看到它
that's the start function that you'll

894
00:40:36,760 --> 00:40:40,420
它只有一个参数，即客户端请求来的命令，它就是个 key-value 对
see in raft.go and really just takes one

895
00:40:40,420 --> 00:40:44,350
它只有一个参数，即客户端请求来的命令，它就是个 key-value 对
argument the client command the key

896
00:40:44,350 --> 00:40:45,550
start 函数会把这条命令放进 log，然后通知调用方日志何时被提交
value they're saying please I got this

897
00:40:45,550 --> 00:40:47,110
start 函数会把这条命令放进 log，然后通知调用方日志何时被提交
command to get into the log and tell me

898
00:40:47,110 --> 00:40:50,320
start 函数会把这条命令放进 log，然后通知调用方日志何时被提交
when it's committed and the other piece

899
00:40:50,320 --> 00:40:54,310
另一方面，调用此函数后，raft 层过会儿通知 key-value 层
of the interface is that by and by the

900
00:40:54,310 --> 00:40:55,930
另一方面，调用此函数后，raft 层过会儿通知 key-value 层
raft layer will notify the key value

901
00:40:55,930 --> 00:40:58,180
啊哈：刚刚你通过 start 命令发我的操作
layer that AHA that operation that you

902
00:40:58,180 --> 00:40:59,740
啊哈：刚刚你通过 start 命令发我的操作
sent to me in a start command a while

903
00:40:59,740 --> 00:41:01,390
注意了，不一定就是最近调用的那个 start
ago which may well not be the most

904
00:41:01,390 --> 00:41:03,430
注意了，不一定就是最近调用的那个 start
recent start right there you know a

905
00:41:03,430 --> 00:41:05,320
在任意一条日志被提交前，可能同时有 100 个客户端发起请求，并调用 start 函数
hundred client commands could come in

906
00:41:05,320 --> 00:41:07,600
在任意一条日志被提交前，可能同时有 100 个客户端发起请求，并调用 start 函数
and cause calls to start before any of

907
00:41:07,600 --> 00:41:11,290
在任意一条日志被提交前，可能同时有 100 个客户端发起请求，并调用 start 函数
them are committed so by and by this

908
00:41:11,290 --> 00:41:14,260
这里有一条向上的通信，它通过 go channel 发送一条消息
upward communication is takes the form

909
00:41:14,260 --> 00:41:16,630
这里有一条向上的通信，它通过 go channel 发送一条消息
of a message on a go channel that the

910
00:41:16,630 --> 00:41:20,170
raft 库向 channel 一端发送，key-value 层从另一端读取
raft library sends on and key value

911
00:41:20,170 --> 00:41:23,920
raft 库向 channel 一端发送，key-value 层从另一端读取
layer is supposed to read from so

912
00:41:23,920 --> 00:41:28,120
所以这里的 apply，被称之为 apply channel
there's this apply called the apply

913
00:41:28,120 --> 00:41:33,900
在它之上你可以发送 apply 消息
channel and on it on it you send apply message

915
00:41:37,440 --> 00:41:39,640
start 函数，当然了，你需要……
this start and of course you need the

916
00:41:39,640 --> 00:41:42,310
key-value 层需要将 apply channel 接收到的消息同调用的 start 函数做匹配
the key value layer needs to be able to

917
00:41:42,310 --> 00:41:44,560
key-value 层需要将 apply channel 接收到的消息同调用的 start 函数做匹配
match up message that receives an apply

918
00:41:44,560 --> 00:41:47,430
key-value 层需要将 apply channel 接收到的消息同调用的 start 函数做匹配
channel with calls to start that it made

919
00:41:47,430 --> 00:41:49,930
start 函数会返回足够的信息，以确保可以做匹配工作
and so the start command actually

920
00:41:49,930 --> 00:41:52,599
start 函数会返回足够的信息，以确保可以做匹配工作
returns enough information for that

921
00:41:52,599 --> 00:41:54,250
它会返回 index(索引号)
matchup to happen it returns the index

922
00:41:54,250 --> 00:41:58,540
start 函数最重要的工作就是返回 log 中的 index
that start functions basically returns

923
00:41:58,540 --> 00:42:00,460
start 函数最重要的工作就是返回 log 中的 index
the index in the log where if this

924
00:42:00,460 --> 00:42:02,170
如果这条命令被提交了（也可能不会被提交）
command is committed which it might not

925
00:42:02,170 --> 00:42:05,680
那么它将来就会在这个 index 上被提交
be it'll be committed at this index and

926
00:42:05,680 --> 00:42:07,150
我认为，它还会返回当前的任期号，还有一些别的东西，不过不用太关注
I think it also returns the current term

927
00:42:07,150 --> 00:42:08,380
我认为，它还会返回当前的任期号，还有一些别的东西，不过不用太关注
and some other stuff we don't care about

928
00:42:08,380 --> 00:42:11,589
然后，这里的 ApplyMsg 将会包含 index 以及 command
very much and then this apply message is

929
00:42:11,589 --> 00:42:26,530
然后，这里的 ApplyMsg 将会包含 index 以及 command
going to contain the index command and

930
00:42:26,530 --> 00:42:27,970
所有的副本都将拿到这些 apply 消息
all the replicas will get these apply

931
00:42:27,970 --> 00:42:29,770
所以他们就知道，oh, 我应该要 apply 这条命令
messages so they'll all know oh I

932
00:42:29,770 --> 00:42:33,520
所以他们就知道，oh, 我应该要 apply 这条命令
should apply this command figure out

933
00:42:33,520 --> 00:42:35,170
我要理解这些命令的含义，然后把它应用到本地的状态里
what this command means and apply it to

934
00:42:35,170 --> 00:42:37,510
我要理解这些命令的含义，然后把它应用到本地的状态里
my local state and they also get the

935
00:42:37,510 --> 00:42:38,980
同样的，他们可以拿到这个 index，它只在上 leader 有用
index the index is really only useful on the leader

936
00:42:38,980 --> 00:42:42,280
所以它能理解客户端正在发什么请求
so it can figure out what

937
00:42:42,280 --> 00:42:46,109
所以它能理解客户端正在发什么请求
client would what client requests were talking about

940
00:43:14,410 --> 00:43:16,570
这个问题的答案，有一点点不同
the answer a slightly different question

941
00:43:16,570 --> 00:43:18,910
我们假设客户端发送了做任意的请求，不管它是 put 还是 get，无所谓
let's suppose the client sends any

942
00:43:18,910 --> 00:43:21,730
我们假设客户端发送了做任意的请求，不管它是 put 还是 get，无所谓
request in let's say it's a put or a get

943
00:43:21,730 --> 00:43:23,410
我们假设客户端发送了做任意的请求，不管它是 put 还是 get，无所谓
could be put or again it doesn't really

944
00:43:23,410 --> 00:43:29,950
假设就是 GET，在这个位置客户端发送请求，然后等待响应
matter I'd say it to get the point in

945
00:43:29,950 --> 00:43:32,500
假设就是 GET，在这个位置客户端发送请求，然后等待响应
which the it's a client sense and again

946
00:43:32,500 --> 00:43:33,910
假设就是 GET，在这个位置客户端发送请求，然后等待响应
and waits for a response the point at

947
00:43:33,910 --> 00:43:37,000
leader 将会在这个位置发送响应，而不是在 leader 得知命令被提交之后
which the leader will send a response (not) at

948
00:43:37,000 --> 00:43:39,640
leader 将会在这个位置发送响应，而不是在 leader 得知命令被提交之后
all is after the leader knows that

949
00:43:39,640 --> 00:43:41,680
leader 将会在这个位置发送响应，而不是在 leader 得知命令被提交之后
command is committed so this is going to

950
00:43:41,680 --> 00:43:48,970
所以这里将会是 get 的回复
be a sort of get reply so the client

951
00:43:48,970 --> 00:43:52,230
所以客户端看不到任何东西返回
doesn't see anything back I mean and so

952
00:43:52,230 --> 00:43:54,250
这里意思是说，根据实际的 software stack(key-value 层和 raft 层形成的上下关系)
that means in terms of the actual

953
00:43:54,250 --> 00:43:56,830
这里意思是说，根据实际的 software stack(key-value 层和 raft 层形成的上下关系)
software stack that means that the key

954
00:43:56,830 --> 00:43:59,440
RPC 将到到达 key-value 层，然后调用 start 函数
value the RPC will arrive the key value

955
00:43:59,440 --> 00:44:02,020
RPC 将到到达 key-value 层，然后调用 start 函数
layer will call the start function the

956
00:44:02,020 --> 00:44:03,820
然后 start 函数返回到 key-value 层
start function will return to the key

957
00:44:03,820 --> 00:44:06,700
但是 key-value 层还不会返回给客户端
value layer but the key value layer will

958
00:44:06,700 --> 00:44:08,650
但是 key-value 层还不会返回给客户端
not yet reply to the client because it

959
00:44:08,650 --> 00:44:10,840
因为它不知道这条命令是否有效
does not know if it's good actually it

960
00:44:10,840 --> 00:44:12,550
实际上它还现在没执行客户端请求
hasn't executed the clients request now

961
00:44:12,550 --> 00:44:13,840
它甚至都不知道它是否会执行
it doesn't even know if it ever will

962
00:44:13,840 --> 00:44:16,570
因为它无法保证这条请求是否被提交
because it's not sure if the request is

963
00:44:16,570 --> 00:44:18,820
因为它无法保证这条请求是否被提交
going to be committed right in the

964
00:44:18,820 --> 00:44:20,500
比如它可能没有被提交
situation which may not be committed is

965
00:44:20,500 --> 00:44:23,590
假设 key-value 层调用 start，在 start 返回后立即宕机了
if the key value layer you know guess

966
00:44:23,590 --> 00:44:25,270
假设 key-value 层调用 start，在 start 返回后立即宕机了
the request calls start and immediately

967
00:44:25,270 --> 00:44:27,160
假设 key-value 层调用 start，在 start 返回后立即宕机了
after start return to crashes right

968
00:44:27,160 --> 00:44:28,960
当然它还没发送它的 apply，append 消息或是别的东西
certainly hasn't sent out its apply what

969
00:44:28,960 --> 00:44:30,220
当然它还没发送它的 apply，append 消息或是别的东西
append messages or whatever

970
00:44:30,220 --> 00:44:33,520
什么也没有进行提交
nothing's be committed yep so so the

971
00:44:33,520 --> 00:44:36,600
所以 raft 中的规则是，当 start 函数返回
game is start returns time passes the

972
00:44:36,600 --> 00:44:40,720
过一段时间后，当和客户端请求相一致的 apply 消息
relevant apply message corresponding to

973
00:44:40,720 --> 00:44:42,490
过一段时间后，当和客户端请求相一致的 apply 消息
that client request appears to the key

974
00:44:42,490 --> 00:44:44,200
通过 apply channel 传递到 key-value 服务层的时候
value server on the apply channel and

975
00:44:44,200 --> 00:44:47,440
只有在这个时候，key-value 服务层才会执行请求，并发送 reply
only then and that causes the key value

976
00:44:47,440 --> 00:44:53,010
只有在这个时候，key-value 服务层才会执行请求，并发送 reply
server to execute the request and send reply

978
00:44:58,230 --> 00:45:00,160
这一切都非常重要
and that's like all this is very

979
00:45:00,160 --> 00:45:02,170
如果一切都正常进行，这没什么大不了的
important when it doesn't really matter

980
00:45:02,170 --> 00:45:04,360
如果一切都正常进行，这没什么大不了的
if all everything goes well but if

981
00:45:04,360 --> 00:45:06,640
但是如果有故障产生，你知道，我们要担心错误
there's a failure we're now you know the point

982
00:45:06,640 --> 00:45:07,780
但是如果有故障产生，你知道，我们要担心错误
we worrying about failure I

983
00:45:07,780 --> 00:45:09,760
我的意思是说，我们更应该关心：如果产生错误，客户端会看到什么
mean extremely interested in if there

984
00:45:09,760 --> 00:45:13,140
我的意思是说，我们更应该关心：如果产生错误，客户端会看到什么
was a failure what did the client see

985
00:45:13,950 --> 00:45:18,550
好，还有一件事，你们也需要非常熟练
all right and so one thing that does

986
00:45:18,550 --> 00:45:23,710
好，还有一件事，你们也需要非常熟练
come up is that all of you should be

987
00:45:23,710 --> 00:45:24,940
好，还有一件事，你们也需要非常熟练
familiar with this that at least

988
00:45:24,940 --> 00:45:26,710
思考一下，各副本上的日志可能会产生不一致
initially one interesting thing about

989
00:45:26,710 --> 00:45:28,540
思考一下，各副本上的日志可能会产生不一致
the logs is that they may not be

990
00:45:28,540 --> 00:45:30,760
有很多情况会导致不一致
identical there are a whole bunch of

991
00:45:30,760 --> 00:45:33,820
至少在短时间内，不同副本的结尾的地方可能会产生分叉
situations in which at least for brief

992
00:45:33,820 --> 00:45:36,369
至少在短时间内，不同副本的结尾的地方可能会产生分叉
periods of time the ends of the

993
00:45:36,369 --> 00:45:39,160
至少在短时间内，不同副本的结尾的地方可能会产生分叉
different replicas logs may diverge like

994
00:45:39,160 --> 00:45:41,710
比如，如果一个 leader 发起一轮 AppendMessage
for example if a leader starts to send

995
00:45:41,710 --> 00:45:43,390
比如，如果一个 leader 发起一轮 AppendMessage
out a round of append messages but

996
00:45:43,390 --> 00:45:45,160
但是在发送完所有消息前宕机了
crashes before it's able to send all

997
00:45:45,160 --> 00:45:46,900
这意味着有些副本会拿到 append 消息，然后追加到日志中
them out you know that'll mean that some

998
00:45:46,900 --> 00:45:48,100
这意味着有些副本会拿到 append 消息，然后追加到日志中
of the replicas that got the append

999
00:45:48,100 --> 00:45:50,500
这意味着有些副本会拿到 AppendMessage，然后追加到日志中
message will append you know that new

1000
00:45:50,500 --> 00:45:51,940
而另一些副本拿不到 AppendMessage RPC，所以不会追加它们
log entry and the ones that didn't get

1001
00:45:51,940 --> 00:45:54,400
而另一些副本拿不到 AppendMessage RPC，所以不会追加它们
that append messages RPC won't have

1002
00:45:54,400 --> 00:45:56,440
所以很容易明白，日志有时候分产生分叉
appended them so it's easy to see that

1003
00:45:56,440 --> 00:45:58,980
所以很容易明白，日志有时候分产生分叉
the logs are I'm gonna diverge sometimes

1004
00:45:58,980 --> 00:46:02,859
好消息是，在一段时间后，raft 实际上最终会强制让日志变得完全相同
the good news is that the the way a raft

1005
00:46:02,859 --> 00:46:05,380
好消息是，在一段时间后，raft 实际上最终会强制让日志变得完全相同
works actually ends up forcing the logs

1006
00:46:05,380 --> 00:46:08,230
好消息是，在一段时间后，raft 实际上最终会强制让日志变得完全相同
to be identical after a while there may

1007
00:46:08,230 --> 00:46:10,480
尽管会存在短暂的不一致问题，但是在运行一段时间后
be transient differences but in the long

1008
00:46:10,480 --> 00:46:13,240
所有的日志都会被 leader 修改，直到 leader 确保所有日志是完全相同的
run all the logs will sort of be

1009
00:46:13,240 --> 00:46:15,340
所有的日志都会被 leader 修改，直到 leader 确保所有日志是完全相同的
modified by the leader until the leader

1010
00:46:15,340 --> 00:46:17,140
所有的日志都会被 leader 修改，直到 leader 确保所有日志是完全相同的
insurers are all identical and only then

1011
00:46:17,140 --> 00:46:24,490
并且只有在那时候，命令才会被执行
are they executed okay so I think the

1012
00:46:24,490 --> 00:46:27,190
嗐！还有 2 个大的关于 raft 的话题需要讨论！
next there's really two big topics to

1013
00:46:27,190 --> 00:46:29,290
嗐！还有 2 个大的关于 raft 的话题需要讨论！
talk about here for raft one is how

1014
00:46:29,290 --> 00:46:31,450
一个是 Leader Election(领导选举)是如何工作的，在 lab2 中需要完成
leader election works which is lab two

1015
00:46:31,450 --> 00:46:35,170
另一个是 leader 要如何处理不同的副本日志，尤其是出错之后
and the other is how the leader deals

1016
00:46:35,170 --> 00:46:37,270
另一个是 leader 要如何处理不同的副本日志，尤其是出错之后
with the different replicas logs

1017
00:46:37,270 --> 00:46:39,700
另一个是 leader 要如何处理不同的副本日志，尤其是出错之后
particularly after failure so first I

1018
00:46:39,700 --> 00:46:42,690
所以咱们先来谈谈 leader election
want to talk about leader election

1019
00:46:44,940 --> 00:46:47,380
有个要问的问题是，为什么系统需要 leader?
question to ask is how come the system

1020
00:46:47,380 --> 00:46:48,880
为什么我们需要 leader?
even has a leader why do we need a

1021
00:46:48,880 --> 00:46:51,820
答案之一是，你可以构建一个没有 leader 的系统
leader the part of the answer is you do

1022
00:46:51,820 --> 00:46:53,710
答案之一是，你可以构建一个没有 leader 的系统
not need a leader to build a system like

1023
00:46:53,710 --> 00:46:56,890
在一个集群上构建一个共识系统是可能的
this you it is possible to build an

1024
00:46:56,890 --> 00:46:59,140
在一个集群上构建一个共识系统是可能的
agreement system by which a cluster of

1025
00:46:59,140 --> 00:47:02,140
在不指定 leader 的情况下，你可以让日志中的一个序列的日志项达成一致
servers agrees you know the sequence of

1026
00:47:02,140 --> 00:47:04,210
在不指定 leader 的情况下，你可以让日志中的一个序列的日志项达成一致
entries in a log without having any kind

1027
00:47:04,210 --> 00:47:05,740
在不指定 leader 的情况下，你可以让日志中的一个序列的日志项达成一致
of designated leader

1028
00:47:05,740 --> 00:47:07,960
事实上，论文中提到了原始的 paxos 系统，它就没有 leader
and indeed the original paxos system

1029
00:47:07,960 --> 00:47:09,910
事实上，论文中提到了原始的 paxos 系统，它就没有 leader
which the paper refers to original Paxos

1030
00:47:09,910 --> 00:47:13,150
事实上，论文中提到了原始的 paxos 系统，它就没有 leader
did not have a leader so it's possible

1031
00:47:13,150 --> 00:47:15,460
那为什么在 raft 里 leader 是如此重要？
the reason why raft has a leader is

1032
00:47:15,460 --> 00:47:18,790
有很多可能的原因
basically that there's probably a lot of

1033
00:47:18,790 --> 00:47:20,380
但是，最重要的一个原因是，你能构建更加高效的系统
reasons but one of the foremost reasons

1034
00:47:20,380 --> 00:47:22,150
但是，最重要的一个原因是，你能构建更加高效的系统
is that you can build a more efficient

1035
00:47:22,150 --> 00:47:24,400
因为通常情况下，服务器很少会发生错误
in the common case in which the server's

1036
00:47:24,400 --> 00:47:27,130
所以如果有 leader 的话，你就能构建一个更加高效的系统
don't fail it's possible to build a more

1037
00:47:27,130 --> 00:47:28,660
所以如果有 leader 的话，你就能构建一个更加高效的系统
efficient system if you have a leader

1038
00:47:28,660 --> 00:47:30,640
因为指定了 leader 的话，所有人都知道 leader 是谁
because with a designated leader

1039
00:47:30,640 --> 00:47:33,310
因为指定了 leader 的话，所有人都知道 leader 是谁
everybody knows who the leader is you

1040
00:47:33,310 --> 00:47:37,540
每个客户端请求，只要发送一轮消息，就能达成一致
can basically get agreement on requests

1041
00:47:37,540 --> 00:47:39,280
每个客户端请求，只要发送一轮消息，就能达成一致
that with one round of messages per

1042
00:47:39,280 --> 00:47:41,470
在无 leader 的系统中，就需要做更多的事情
request without leader of this systems

1043
00:47:41,470 --> 00:47:43,480
在无 leader 的系统中，就需要做更多的事情
have more of the flavor of well you need

1044
00:47:43,480 --> 00:47:45,580
首先你需要发送一轮消息为一个临时 leader 达成一致
a first round to kind of agree on a

1045
00:47:45,580 --> 00:47:47,619
然后再第二轮中实际发出请求
temporary leader and then a second round

1046
00:47:47,619 --> 00:47:50,619
所以这是使用 leader 加速系统的一个可能的 case(案例)
actually send out the requests so it's

1047
00:47:50,619 --> 00:47:53,460
所以这是使用 leader 加速系统的一个可能的 case(案例)
probably the case that use of a leader

1048
00:47:53,460 --> 00:47:56,610
所以这是使用 leader 加速系统的一个可能的 case(案例)
speeds up the system by a factor two

1049
00:47:56,610 --> 00:47:58,750
并且，有了 leader 之后，我们也能很容易的思考接下来的行为
and it also makes it sort of easier to

1050
00:47:58,750 --> 00:48:04,210
并且，有了 leader 之后，我们也能很容易的思考接下来的行为
think about what's going on

1051
00:48:04,210 --> 00:48:08,680
raft 会经历一系列的 leader
raft goes through a sequence of leaders and it

1052
00:48:08,680 --> 00:48:11,170
它使用 term(任期，单调递增的逻辑时钟)号来标识不同的 leader
uses these term numbers in order to sort

1053
00:48:11,170 --> 00:48:13,240
目的是为了和 leader 通信时，避免歧义
of disambiguate which leader we're talking about

1054
00:48:13,240 --> 00:48:14,350
其实 follower 并不需要知道 leader 的标识号
it turns out that

1055
00:48:14,350 --> 00:48:15,609
其实 follower 并不需要知道 leader 的标识号
followers don't really need to know the

1056
00:48:15,609 --> 00:48:17,380
其实 follower 并不需要知道 leader 的标识号
identity of the leader they really just

1057
00:48:17,380 --> 00:48:18,520
它只要知道当前的 term 号就行了
need to know what the current term number is

1058
00:48:18,520 --> 00:48:23,200
每个 term 至多有一个 leader
each term has at most one

1059
00:48:23,200 --> 00:48:25,990
这是一个非常关键的性质
leader that's a critical property you

1060
00:48:25,990 --> 00:48:27,369
也不是每个任期内都有 leader 存在
know for every term there might be no

1061
00:48:27,369 --> 00:48:29,020
也不是每个任期内都有 leader 存在
leader during that term or there might

1062
00:48:29,020 --> 00:48:31,359
一个任期里可以有一个 leader，也可能没有 leader
be one leader but there cannot be two

1063
00:48:31,359 --> 00:48:34,180
在同一个任期里，不可能出现 2 个 leader，每个任期最多只能有 1 个
leaders during the same term every term

1064
00:48:34,180 --> 00:48:42,190
在同一个任期里，不可能出现 2 个 leader，每个任期最多只能有 1 个
has it must most one leader how do the

1065
00:48:42,190 --> 00:48:44,490
首先，怎么才能创建一个 leader 出来？
leaders get created in the first place

1066
00:48:44,490 --> 00:48:48,100
每一个 raft 服务器都会持有一个选举定时器
every raft server keeps this election

1067
00:48:48,100 --> 00:48:50,200
这个定时器超时后，就会去执行一些事情
timer which is just a it's basically

1068
00:48:50,200 --> 00:48:52,030
这个定时器超时后，就会去执行一些事情
just out of time that it has recorded

1069
00:48:52,030 --> 00:48:54,130
这个定时器超时后，就会去执行一些事情
that says well if that time occurs I'm

1070
00:48:54,130 --> 00:48:56,320
这个定时器超时后，就会去执行一些事情
going to do something and the something

1071
00:48:56,320 --> 00:48:59,200
做什么事情呢？如果一个完整的 leader 选举周期到期了
that it does is that if an entire leader

1072
00:48:59,200 --> 00:49:02,470
具体的说，如果一个完整的 leader 选举周期到期了
election period expires without the

1073
00:49:02,470 --> 00:49:04,480
但是 server （副本，follower)没有收到任何来自当前 leader 的消息
server having heard any message from the

1074
00:49:04,480 --> 00:49:08,140
但是 server （副本，follower)没有收到任何来自当前 leader 的消息
current leader then the server sort of

1075
00:49:08,140 --> 00:49:10,030
那么 server 就会假设: 咦，是不是 leader 挂了？
assumes probably that the current leader

1076
00:49:10,030 --> 00:49:12,580
然后它就开始发起一次新的选举
is dead and starts an election so we

1077
00:49:12,580 --> 00:49:15,480
所以，我们有这样一个选举定时器
have this election timer

1078
00:49:17,869 --> 00:49:23,630
如果它到期了，就发起一次选举
and if it expires we start an election

1079
00:49:28,460 --> 00:49:30,690
发起一次新的 leader 选举，主要做的事情是先执行 term++
and what it means to start an election

1080
00:49:30,690 --> 00:49:35,570
发起一次新的 leader 选举，主要做的事情是先执行 term++
is basically that you increment the term

1081
00:49:35,570 --> 00:49:38,490
然后 server 会变成 candidate 状态
the the candidate the server that's

1082
00:49:38,490 --> 00:49:39,930
然后 server 会变成 candidate 状态
decided it's going to be a candidate and

1083
00:49:39,930 --> 00:49:41,520
并且强制发起新一轮选举
sort of force a new election first

1084
00:49:41,520 --> 00:49:43,950
先增加 term 的原因是，它自己想成为新的 leader
increments this term because it wants

1085
00:49:43,950 --> 00:49:45,450
先增加 term 的原因是，它自己想成为新的 leader
them to be a new leader namely itself

1086
00:49:45,450 --> 00:49:47,880
你知道，同一个任期不允许超过一个 leader
and you know leader a term can't have

1087
00:49:47,880 --> 00:49:49,170
你知道，同一个任期不允许超过一个 leader
more than one leader so we got to start

1088
00:49:49,170 --> 00:49:51,770
所以我们需要从一个新的 term 开始，以选举出新的 leader
a new term in order to have a new leader

1089
00:49:51,770 --> 00:49:54,570
然后，它会发送 RequestVotes RPC 给其它所有的 server
and then it sends out these RequestVotes RPCs

1090
00:49:54,570 --> 00:50:00,840
然后，它会发送 RequestVotes RPC 给其它所有的 server
I'm going to send

1091
00:50:00,840 --> 00:50:02,820
然后，它会发送 RequestVotes RPC 给其它所有的 server
out a full round of request votes and

1092
00:50:02,820 --> 00:50:05,130
可能只需要发送 N-1 条 RequestVotes 出去
you may only have to send out n minus

1093
00:50:05,130 --> 00:50:06,450
可能只需要发送 N-1 条 RequestVotes 出去
one requests votes because one of the

1094
00:50:06,450 --> 00:50:08,340
因为这其中有一条规则是，在选举过程中，candidate 总是先给它自己投一票
rules is that a new candidate always

1095
00:50:08,340 --> 00:50:13,530
因为这其中有一条规则是，在选举过程中，candidate 总是先给它自己投一票
votes for itself in the election so one

1096
00:50:13,530 --> 00:50:16,470
需要注意的一点是
thing to note about this is that it's

1097
00:50:16,470 --> 00:50:17,970
如果 leader 没有产生错误，那就不会产生选举
not quite the case that if the leader

1098
00:50:17,970 --> 00:50:19,380
如果 leader 没有产生错误，那就不会产生选举
didn't fail we won't have an election

1099
00:50:19,380 --> 00:50:22,350
假设其它所有的 server 都在正常运行
但是如果 leader 出错了，那么我们才会进行选举
but if the leader does fail then we will

1100
00:50:22,350 --> 00:50:24,480
假设其它所有的 server 都在正常运行
但是如果 leader 出错了，那么我们才会进行选举
have election an election assuming any

1101
00:50:24,480 --> 00:50:26,400
假设其它所有的 server 都在正常运行
但是如果 leader 出错了，那么我们才会进行选举
other server is up because some day the

1102
00:50:26,400 --> 00:50:28,230
因为这时其它 server 的选举定时器会到期
other servers election timers go will go

1103
00:50:28,230 --> 00:50:30,240
但是 leader 一直安然无恙的话，也可能会很不幸的发起选举
off but as leader didn't fail we might

1104
00:50:30,240 --> 00:50:32,400
但是 leader 一直安然无恙的话，也可能会很不幸的发起选举
still unfortunately get an election so

1105
00:50:32,400 --> 00:50:34,920
比如网络太慢，或者心跳包丢失或是别的什么原因
if the network is slow or drops a few

1106
00:50:34,920 --> 00:50:37,050
比如网络太慢，或者心跳包丢失或是别的什么原因
heartbeats or something we may end up

1107
00:50:37,050 --> 00:50:38,820
最终还是会会导致选举定时器超时
having election timers go off and even

1108
00:50:38,820 --> 00:50:40,440
即使你有一个十分完美的 leader
though there was a perfectly good leader

1109
00:50:40,440 --> 00:50:42,390
然而也可能会有新选举产生
we may nevertheless have a new election

1110
00:50:42,390 --> 00:50:43,740
所以当我们考虑正确性的时候，需要要记住这一点
so we have to sort of keep that in mind

1111
00:50:43,740 --> 00:50:44,640
所以当我们考虑正确性的时候，需要要记住这一点
we're thinking about the

1112
00:50:44,640 --> 00:50:48,510
term 是做什么用的呢？
correctness and what that in term means

1113
00:50:48,510 --> 00:50:50,369
如果有新的选举发起，很容易想到的一个场景是
is that if there's a new election it

1114
00:50:50,369 --> 00:50:52,410
如果有新的选举发起，很容易想到的一个场景是
could easily be the case that the old

1115
00:50:52,410 --> 00:50:54,359
旧的 leader 仍然在运行，并且它仍然认为它自己是 leader
leader is still hanging around and still

1116
00:50:54,359 --> 00:50:56,190
旧的 leader 仍然在运行，并且它仍然认为它自己是 leader
thinks it's the leader like if there's a

1117
00:50:56,190 --> 00:50:58,710
比如网络产生分区的时候，旧的 leader 仍然存活
network partition for example and the

1118
00:50:58,710 --> 00:51:00,869
比如网络产生分区的时候，旧的 leader 仍然存活
old leader is still alive and well in a

1119
00:51:00,869 --> 00:51:03,359
并且处在一个只包含不到一半 server 的分区中
minority partition the majority

1120
00:51:03,359 --> 00:51:05,280
那么超过一半 server 的分区可能会发起选举
partition may run an election and indeed

1121
00:51:05,280 --> 00:51:06,869
并且也能成功选出一个新的 leader
a successful election and choose a new

1122
00:51:06,869 --> 00:51:09,990
它完全不知道旧的 leader 的存在
leader all totally unknown to the

1123
00:51:09,990 --> 00:51:11,880
所以我也们会担心，比如旧的 leader 会干啥
previous leader so we also have to worry

1124
00:51:11,880 --> 00:51:13,530
所以我也们会担心，比如旧的 leader 会干啥
about you know what's that previous

1125
00:51:13,530 --> 00:51:15,420
因为它也不知道发生了新的 leader 选举
leader gonna do since it does not know

1126
00:51:15,420 --> 00:51:19,400
因为它也不知道发生了新的 leader 选举
there was a new election yes

1127
00:51:42,130 --> 00:51:44,869
问题是：是否存在这种病态的 case，例如一个只能单向通信的网络
okay so the question is are there can

1128
00:51:44,869 --> 00:51:46,940
问题是：是否存在这种病态的 case，例如一个只能单向通信的网络
there be pathological cases in which for

1129
00:51:46,940 --> 00:51:50,450
问题是：是否存在这种病态的 case，例如一个只能单向通信的网络
example one-way network communication

1130
00:51:50,450 --> 00:51:52,339
在这种情况下，系统还能正常运行下去吗
can prevent the system from making

1131
00:51:52,339 --> 00:51:54,550
我认为答案是 yes
progress I believe the answer is yes

1132
00:51:54,550 --> 00:51:56,930
比如说，如果当前 leader，它的网络出现某种单向故障
certainly so for example if the current

1133
00:51:56,930 --> 00:52:00,980
比如说，如果当前 leader，它的网络出现某种单向故障
leader if its network somehow half fails

1134
00:52:00,980 --> 00:52:02,839
当前 leader 可以把心跳发送出去
in a way the current leader can send out

1135
00:52:02,839 --> 00:52:04,000
当前 leader 可以把心跳发送出去
heartbeats

1136
00:52:04,000 --> 00:52:07,280
但是无法接收任何客户端请求
but can't receive any client requests

1137
00:52:07,280 --> 00:52:09,950
因为网络的出口没问题，心跳包全都被发送出去了
then the heartbeats that it sends out

1138
00:52:09,950 --> 00:52:11,869
因为网络的出口没问题，心跳包全都被发送出去了
which are delivered because it's

1139
00:52:11,869 --> 00:52:13,910
因为网络的出口没问题，心跳包全都被发送出去了
outgoing network connection works its

1140
00:52:13,910 --> 00:52:18,109
它的心跳会压制住其它 server 发起选举
outgoing heartbeats will suppress any

1141
00:52:18,109 --> 00:52:20,300
它的心跳会压制住其它 server 发起选举
other server from starting an election

1142
00:52:20,300 --> 00:52:22,280
但是，网络入口却出了故障
but the fact that it's incoming Network

1143
00:52:22,280 --> 00:52:24,800
但是，网络入口却出了故障
why or apparently is broken will prevent

1144
00:52:24,800 --> 00:52:26,720
这就导致它无法接收到任何客户端的命令
it from hearing and executing any client

1145
00:52:26,720 --> 00:52:29,210
这也确实是 raft 不能解决所有疯狂的网络问题的案例
commands it's absolutely the case that

1146
00:52:29,210 --> 00:52:35,359
这也确实是 raft 不能解决所有疯狂的网络问题的案例
raft is not proof against all sort of

1147
00:52:35,359 --> 00:52:37,190
这也确实是 raft 不能解决所有疯狂的网络问题的案例
all crazy Network problems that can come

1148
00:52:37,190 --> 00:52:38,900
我觉得这样应该可以解决问题
up I believe the ones I've thought about

1149
00:52:38,900 --> 00:52:42,260
我觉得这样应该可以解决问题
I believe are fixable in the sense that

1150
00:52:42,260 --> 00:52:46,970
从某种意义上来说，你可以做一个双向的心跳功能
the we could solve this one by having a

1151
00:52:46,970 --> 00:52:49,339
从某种意义上来说，你可以做一个双向的心跳功能
sort of requiring a two-way heartbeat in

1152
00:52:49,339 --> 00:52:51,770
比如 leader 发送出心跳包后，follwer 被要求回应心跳包
which if the leader sends out heartbeats

1153
00:52:51,770 --> 00:52:53,450
比如 leader 发送出心跳包后，follwer 被要求回应心跳包
but you know there were in which

1154
00:52:53,450 --> 00:52:55,700
比如 leader 发送出心跳包后，follwer 被要求回应心跳包
followers are required to reply in some

1155
00:52:55,700 --> 00:52:56,990
比如 leader 发送出心跳包后，follwer 被要求回应心跳包
way to heartbeats I guess they are

1156
00:52:56,990 --> 00:52:59,240
我猜在 apply 这一步，这些回应是需要的
already required to apply if the leader

1157
00:52:59,240 --> 00:53:01,869
如果 leader 没有看见对心跳的回应
stop seeing replies to its heartbeats

1158
00:53:01,869 --> 00:53:04,460
过一段很长一段时间后，才看见回应
then after some amount of time and which

1159
00:53:04,460 --> 00:53:06,230
过一段很长一段时间后，才看见回应
see the replies the leader decides

1160
00:53:06,230 --> 00:53:09,230
leader 就会自己决定下台
to step down I feel like that specific

1161
00:53:09,230 --> 00:53:12,530
我感觉这个特殊的 issue 是可以被修复的
issue can be fixed and many others can

1162
00:53:12,530 --> 00:53:16,069
当然其它的问题也是能被解决的
too but I but you know you're absolutely

1163
00:53:16,069 --> 00:53:17,900
不过我觉得你的问题也完全是正确的
right that very strange things can

1164
00:53:17,900 --> 00:53:19,599
网络协议没有准备就绪的话，这种奇怪的问题是可能会发生的
happen to networks including some that

1165
00:53:19,599 --> 00:53:23,589
网络协议没有准备就绪的话，这种奇怪的问题是可能会发生的
the protocol is not prepared for

1166
00:53:28,740 --> 00:53:32,260
okay，leader 选举 就是这些
okay so we got these leader elections we

1167
00:53:32,260 --> 00:53:33,849
我们需要确保一个 term 至多只有一个 leader
need to ensure that there is at most at

1168
00:53:33,849 --> 00:53:35,440
我们需要确保一个 term 至多只有一个 leader
most one leader per term

1169
00:53:35,440 --> 00:53:38,080
raft 如何做呢？对于一个 term 来说
how does raft do that well raft requires

1170
00:53:38,080 --> 00:53:40,240
raft 要求 candidate 得到半数以上 server 的投票
in order to be elected for a term Raft

1171
00:53:40,240 --> 00:53:42,700
raft 要求 candidate 得到半数以上 server 的投票
requires a candidate to get yes votes

1172
00:53:42,700 --> 00:53:46,030
raft 要求 candidate 得到半数以上 server 的 yes 投票
from a majority of the server's the

1173
00:53:46,030 --> 00:53:47,980
每个 server 在一个 term 中只能投一票 yes
servers and each server will only cast

1174
00:53:47,980 --> 00:53:52,390
每个 server 在一个 term 中只能投一票 yes
one yes vote per term so in any given

1175
00:53:52,390 --> 00:53:55,690
所以在任何一个 term 中，只能为一个 candidate 投一票
term you know it basically means that in

1176
00:53:55,690 --> 00:53:58,180
所以在任何一个 term 中，只能为一个 candidate 投一票
any given term either votes only once

1177
00:53:58,180 --> 00:54:01,060
所以在任何一个 term 中，只能为一个 candidate 投一票
for only one candidate you can't have

1178
00:54:01,060 --> 00:54:03,280
这样就不可能同时有 2 个 candidate 获得半数以上的选票
two candidates both get a majority of

1179
00:54:03,280 --> 00:54:06,570
因为每个只能投一次票
votes because everybody votes only once

1180
00:54:06,570 --> 00:54:09,670
所以 majority 规则保证了至多只有一个 candidate 胜出
so the majorities majority rule causes

1181
00:54:09,670 --> 00:54:11,530
所以 majority 规则保证了至多只有一个 candidate 胜出
there to be at most one winning

1182
00:54:11,530 --> 00:54:17,400
也以我们也能保证在一个 term 中至多只有一个 candidate 被选出
candidate and so then we get at most one

1183
00:54:17,400 --> 00:54:21,150
也以我们也能保证在一个 term 中至多只有一个 candidate 被选出
candidate elected per term

1184
00:54:24,450 --> 00:54:28,630
另外，majority 规则的关键含义是
and in addition critically the majority

1185
00:54:28,630 --> 00:54:31,930
即使有一些 server 宕机了，也能选举成功
rule means that you can get elected even

1186
00:54:31,930 --> 00:54:34,450
即使有一些 server 宕机了，也能选举成功
if some servers have crashed right if a

1187
00:54:34,450 --> 00:54:36,010
如果有不到一半的 server 宕机了，不可用了，网络故障了
minority of servers are crashed aren't

1188
00:54:36,010 --> 00:54:37,690
如果有不到一半的 server 宕机了，不可用了，网络故障了
available and network problems we can

1189
00:54:37,690 --> 00:54:39,700
我们仍然能选出一个 leader
still elect a leader if more than half a

1190
00:54:39,700 --> 00:54:41,530
如果有超过一半宕机，不可用或处于其它的分区中
crash or not available or in another

1191
00:54:41,530 --> 00:54:43,390
那么整个系统就坐那不动了（停止）
partition or something then actually the

1192
00:54:43,390 --> 00:54:44,830
那么整个系统就坐那不动了（停止）
system will just sit there trying again

1193
00:54:44,830 --> 00:54:47,080
它会一遍又一遍的发起 leader 选举，但是却又永远选不出 leader
and again to elect a leader and never

1194
00:54:47,080 --> 00:54:49,480
因为存活的机器不超过一半，事实上也不能选出 leader
elect one if it cannot in fact they're

1195
00:54:49,480 --> 00:54:54,730
因为存活的机器不超过一半，事实上也不能选出 leader
not a majority of live servers if an

1196
00:54:54,730 --> 00:54:57,400
如果选举成功，并且每个节点都知道了这件事，那么一切安好
election succeeds everybody would be

1197
00:54:57,400 --> 00:54:58,960
如果选举成功，并且每个节点都知道了这件事，那么一切安好
great if everybody learned about it I

1198
00:54:58,960 --> 00:55:01,359
我们需要问一下自己，假设没有 server 宕机
mean need to ask ourselves how do all

1199
00:55:01,359 --> 00:55:02,980
所有的 server 是如何知道哪个 server 赢得了选举？
the parties learn learn what happened

1200
00:55:02,980 --> 00:55:04,750
所有的 server 是如何知道哪个 server 赢得了选举？
the server that wins an election

1201
00:55:04,750 --> 00:55:07,300
所有的 server 是如何知道哪个 server 赢得了选举？
assuming it doesn't crash the server

1202
00:55:07,300 --> 00:55:09,550
赢得选举的 server 也确实看到了半数以上对它的投票
that wins election will actually see a

1203
00:55:09,550 --> 00:55:12,730
赢得选举的 server 也确实看到了半数以上其它 server 对它的投票
majority or positive votes for its

1204
00:55:12,730 --> 00:55:15,400
赢得选举的 server 也确实看到了半数以上其它 server 对它的投票
request vote from a majority of the

1205
00:55:15,400 --> 00:55:17,740
发起选举的 candidate 赢得了投票
other servers so the candidates running

1206
00:55:17,740 --> 00:55:19,540
发起选举的 candidate 赢得了投票
the election that wins it the candidates

1207
00:55:19,540 --> 00:55:20,710
发起选举的 candidate 赢得了投票
that wins the election will actually

1208
00:55:20,710 --> 00:55:22,960
它自己当然很清楚自己赢得了半数以上的选票
know directly uh I got a majority of

1209
00:55:22,960 --> 00:55:26,020
但是其它的 server 不知道呀
votes but nobody else directly knows who

1210
00:55:26,020 --> 00:55:28,900
但是其它的 server 不知道呀
the winner was or whether anybody one so

1211
00:55:28,900 --> 00:55:30,790
所以取胜的 candidate 需要通知其它 server
the way that the candidate informs other

1212
00:55:30,790 --> 00:55:33,670
也就是使用心跳
servers is that heartbeat the rules and

1213
00:55:33,670 --> 00:55:34,869
图 2 中说，如果你赢得了选举
figure 2 say oh if you win an

1214
00:55:34,869 --> 00:55:36,280
就应该立刻发送 AppendEntries 到其它 server
election your immediately required to

1215
00:55:36,280 --> 00:55:37,359
就应该立刻发送 AppendEntries 到其它 server
send out AppendEntries

1216
00:55:37,359 --> 00:55:39,940
就应该立刻发送 AppendEntries 到其它 server
to all the other servers now the

1217
00:55:39,940 --> 00:55:41,920
AppendEntries 并不直接会包含这个信息
append entries that heartbeat append

1218
00:55:41,920 --> 00:55:45,160
哦，我赢得了选票，我是 term 23 的 leader
entries doesn't explicitly say I won the

1219
00:55:45,160 --> 00:55:47,829
哦，我赢得了选票，我是 term 23 的 leader
election you know I'm a leader for term

1220
00:55:47,829 --> 00:55:51,009
这里有一点微妙的地方
23 it's a little more subtle than that

1221
00:55:51,009 --> 00:55:53,710
除了 leader，其它人是不允许发送 AppendEntries 消息的
the the way the information is

1222
00:55:53,710 --> 00:55:57,549
除了 leader，其它人是不允许发送 AppendEntries 消息的
communicated is that no one is allowed

1223
00:55:57,549 --> 00:56:00,249
除了 leader，其它人是不允许发送 AppendEntries 消息的
to send out an append entries unless

1224
00:56:00,249 --> 00:56:02,799
除了 leader，其它人是不允许发送 AppendEntries 消息的
they're a leader for that term so the

1225
00:56:02,799 --> 00:56:05,559
所以事实上是这样，我是一个 server
fact that I I'm a you know I'm a server

1226
00:56:05,559 --> 00:56:07,029
我看到了在 term 19 的那次选举
and I saw oh there's an election for

1227
00:56:07,029 --> 00:56:09,579
过了一会儿，我leader 发送了一条 term 为 19 的 AppendEntires
term 19 and then by-and-by I sent an

1228
00:56:09,579 --> 00:56:12,730
过了一会儿，leader 发送了一条 term 为 19 的 AppendEntires
append entries whose term is 19 that

1229
00:56:12,730 --> 00:56:15,009
然后我收到了，我就知道有人赢得了这次选举，虽然我不清楚是谁赢得了选举
tells me that somebody I don't know who

1230
00:56:15,009 --> 00:56:18,099
然后我收到了，我就知道有人赢得了这次选举，虽然我不清楚是谁赢得了选举
but somebody won the election so that's

1231
00:56:18,099 --> 00:56:19,390
所以这就是其它 server 如何得知有人赢得选举的
how the other servers knows they were

1232
00:56:19,390 --> 00:56:21,359
它们接收到那个 term 的 AppendEntries 消息
receiving append entries for that term

1233
00:56:21,359 --> 00:56:24,670
那条 AppendEntries 消息，也会重置每个 server 的选举定时器
and that append entries also has the

1234
00:56:24,670 --> 00:56:27,369
那条 AppendEntries 消息，也会重置每个 server 的选举定时器
effect of resetting everybody's election

1235
00:56:27,369 --> 00:56:30,279
只要 leader 存活，那就会发送心跳消息，或者说是 AppendEntries
time timer so as long as the leader is

1236
00:56:30,279 --> 00:56:32,109
只要 leader 存活，那就会发送心跳消息，或者说是 AppendEntries
up and it sends out heartbeat messages

1237
00:56:32,109 --> 00:56:34,599
只要 leader 存活，那就会发送心跳消息，或者说是 AppendEntries
or append entries at least you know at

1238
00:56:34,599 --> 00:56:36,910
每次 server 收到了一条 AppendEntries
the rate that's supposed to every time a

1239
00:56:36,910 --> 00:56:38,650
每次 server 收到了一条 AppendEntries
server receives an append entries it'll

1240
00:56:38,650 --> 00:56:42,569
它就会重置它的选举定时器
reset its selection timer and sort of

1241
00:56:42,569 --> 00:56:45,249
压制任何人变成为 candidate
suppress anybody from being a new

1242
00:56:45,249 --> 00:56:47,289
只要一切运作正常，这些重复的心跳就能阻止新的选举产生
candidate so as long as everything's

1243
00:56:47,289 --> 00:56:49,539
只要一切运作正常，这些重复的心跳就能阻止新的选举产生
functioning the repeated heartbeats will

1244
00:56:49,539 --> 00:56:52,299
只要一切运作正常，这些重复的心跳就能阻止新的选举产生
prevent any further elections of course

1245
00:56:52,299 --> 00:56:53,859
当然了，如果有网络故障，或是丢失消息
it the network fails or packets are

1246
00:56:53,859 --> 00:56:55,569
仍然会导致新的选举被发起
dropped there may nevertheless be an

1247
00:56:55,569 --> 00:56:57,880
若一切安好，那就不太可能发起新的选举
election but if all goes well we're sort

1248
00:56:57,880 --> 00:57:03,489
若一切安好，那就不太可能发起新的选举
of unlikely to get an election this

1249
00:57:03,489 --> 00:57:05,739
这个方案可能会失效
scheme could fail in the sense that it

1250
00:57:05,739 --> 00:57:07,329
对于同一个 term 来说，不会选出 2 个 leader 出来
can't fail in the sense of electing two

1251
00:57:07,329 --> 00:57:09,849
对于同一个 term 来说，不会选出 2 个 leader 出来
leaders for a term but it can fail in the

1252
00:57:09,849 --> 00:57:11,380
但可能会一个 leader 都选不出来，这时候就失败了
sense of electing zero leaders for a

1253
00:57:11,380 --> 00:57:14,319
有太多种情况会导致失败
term that's sort of many way it may

1254
00:57:14,319 --> 00:57:16,210
比如有太多的服务器宕机或不可用，网络连接故障
fail is that if too many servers are

1255
00:57:16,210 --> 00:57:18,279
比如有太多的服务器宕机或不可用，网络连接故障
dead or unavailable or a bad network

1256
00:57:18,279 --> 00:57:19,690
所以这个时候，你就没办法组合出 majoirity 出来
connection so if you can't assemble a

1257
00:57:19,690 --> 00:57:21,880
因此也就无法选出任何 leader 出来，啥也不会发生
majority you can't be elected nothing

1258
00:57:21,880 --> 00:57:24,489
还有一些更有趣的选举失败的方式
happens the more interesting way in

1259
00:57:24,489 --> 00:57:27,150
还有一些更有趣的选举失败的方式
which an election can fail is if

1260
00:57:27,150 --> 00:57:30,069
所有人都是健在的，也没有网络丢包
everybody's up you know there's no

1261
00:57:30,069 --> 00:57:33,130
所有人都是健在的，也没有网络丢包
failures no packets are dropped but two

1262
00:57:33,130 --> 00:57:35,799
但是同时有 2 个 leaders(可能是口误，应该是2个 follower)
几乎在同一时刻成为了 candidate
leaders become candidate close together

1263
00:57:35,799 --> 00:57:38,499
他们之间将会瓜分选票，或者说是有 3 个人一起瓜分吧
enough in time that they split the vote

1264
00:57:38,499 --> 00:57:43,109
他们之间将会瓜分选票，或者说是有 3 个人一起瓜分吧
between them or say three leaders

1265
00:57:45,020 --> 00:57:46,369
假设我们有 3 个 leader
so supposing we have three leaders

1266
00:57:46,369 --> 00:57:49,180
假设我们的系统中有 3 个副本
supposing we have a three replica system

1267
00:57:49,180 --> 00:57:51,860
他们 3 个人的选举定时器几乎在同一时刻到期，每个人都先给自己投一票
all their election timers go off at the

1268
00:57:51,860 --> 00:57:54,760
他们 3 个人的选举定时器几乎在同一时刻到期，每个人都先给自己投一票
same time every server votes for itself

1269
00:57:54,760 --> 00:57:57,650
接下来，他们每个人又会收到其它 server 的选票请求
and then when each of them receives a

1270
00:57:57,650 --> 00:57:59,060
接下来，他们每个人又会收到其它 server 的选票请求
request vote from another server well

1271
00:57:59,060 --> 00:58:00,710
好了，因为它自己已经把票投给了自己，所以它就会回复 no.
it's already cast its vote for itself

1272
00:58:00,710 --> 00:58:02,780
这样的结果就是 3 个服务器各自有一张选票
and so it says no so that means that it

1273
00:58:02,780 --> 00:58:04,100
这样的结果就是 3 个服务器各自有一张选票
all three of the servers each get

1274
00:58:04,100 --> 00:58:05,930
没有一个人的选票超过半数，所以也就没有 leader 被选出
one vote each nobody gets a majority and

1275
00:58:05,930 --> 00:58:09,800
没有一个人的选票超过半数，所以也就没有 leader 被选出
nobody's elected so then their election

1276
00:58:09,800 --> 00:58:11,450
然后他们的选举定时器会再一次超时
timers will go off again because the

1277
00:58:11,450 --> 00:58:12,890
因为只有在收到 AppendEntires 时选举定时器才会被重置
election timers only reset if it gets

1278
00:58:12,890 --> 00:58:14,360
但是没有 leader 被选出来，因此也就没有 AppendEntries 消息
an append entries but there's no leader

1279
00:58:14,360 --> 00:58:16,460
但是没有 leader 被选出来，因此也就没有 AppendEntries 消息
so no append entries they'll all have

1280
00:58:16,460 --> 00:58:17,930
他们的选举定时器会再一次超时
their election timers go off again and

1281
00:58:17,930 --> 00:58:19,100
如果很不幸的是又在同一时刻超时
if we're unlucky

1282
00:58:19,100 --> 00:58:20,270
如果很不幸的是又在同一时刻超时
they'll all go off at the same time

1283
00:58:20,270 --> 00:58:22,160
于是他们又会自己给自己投票
they'll all vote for themselves nobody

1284
00:58:22,160 --> 00:58:27,140
然后又没有人拿到半数以上的选票
will get a majority so so clearly I'm

1285
00:58:27,140 --> 00:58:28,360
我相信你们都已经注意到这一点了
sure you're all aware at this point

1286
00:58:28,360 --> 00:58:31,520
这个故事还有更多的后续
there's more to this story and the way

1287
00:58:31,520 --> 00:58:35,630
raft 让这种瓜分选票的概率变的非常低，但是也不是不可能发生
Raft makes this possibility of split

1288
00:58:35,630 --> 00:58:38,720
raft 让这种瓜分选票的概率变的非常低，但是也不是不可能发生
votes unlikely but not impossible

1289
00:58:38,720 --> 00:58:41,060
raft 通过随机化选举定时器的超时时间
is by randomizing these election timers

1290
00:58:41,060 --> 00:58:44,210
怎么去想这件事呢？
so the way to think of it and the

1291
00:58:44,210 --> 00:58:46,400
怎么去思考随机化呢？
randomization the way to think of it is

1292
00:58:46,400 --> 00:58:47,900
假设有一条时间线
that supposing you have some time line

1293
00:58:47,900 --> 00:58:52,130
我打算在某些位置上画一些事件
I'm gonna draw events on there's some

1294
00:58:52,130 --> 00:58:54,170
在这里，是每个人收到最后一次 AppendEntries 的时间
point at which everybody received the

1295
00:58:54,170 --> 00:58:57,440
在这里，是每个人收到最后一次 AppendEntries 的时间
last append entries right and then maybe

1296
00:58:57,440 --> 00:58:58,790
然后我们假设发送最后一个心跳的服务器宕机了
the server died let's just assume the

1297
00:58:58,790 --> 00:59:01,100
然后我们假设发送最后一个心跳的服务器宕机了
server send out a last heartbeat and

1298
00:59:01,100 --> 00:59:07,990
所有 follower 会在这个位置重置他们的选举定时器
then died well all of the followers have

1299
00:59:08,109 --> 00:59:11,119
所有 follower 会在这个位置重置他们的选举定时器
this we set their election timers when

1300
00:59:11,119 --> 00:59:13,160
因为他们可能会同时收到这条 AppendEntries
they received at the same time because

1301
00:59:13,160 --> 00:59:14,570
因为他们可能会同时收到这条 AppendEntries
they probably all receive this append

1302
00:59:14,570 --> 00:59:16,040
因为他们可能会同时收到这条 AppendEntries
enters at the same time they all reset

1303
00:59:16,040 --> 00:59:18,290
然后在这个位置重置选举定时器
their election timers for some point in

1304
00:59:18,290 --> 00:59:21,530
在未来的某个时间点这些定时器会到期
the future the future but they chose

1305
00:59:21,530 --> 00:59:23,630
它们会选择一个随机的时间来设定这个定时器
different random times in the future

1306
00:59:23,630 --> 00:59:25,369
它们会选择一个随机的时间来设定这个定时器
which then we're gonna go off

1307
00:59:25,369 --> 00:59:27,050
假设 leader S1 宕机了
so it's suppose the dead leader server

1308
00:59:27,050 --> 00:59:30,230
所以现在 S2 和 S2 会在这里设置他们选举定时器
one so now server two and server 3 at

1309
00:59:30,230 --> 00:59:32,359
所以现在 S2 和 S2 会在这里设置他们选举定时器
this point set their election timers for

1310
00:59:32,359 --> 00:59:34,010
并未来的某个时刻随机选一个位置表示到期时间
a random point in the future let's say

1311
00:59:34,010 --> 00:59:37,970
假设 S2 设定在这个位置表示到期
server 2 set there I like some timer to

1312
00:59:37,970 --> 00:59:41,030
S3 选择在这个位置到期
go off here and server 3 set its

1313
00:59:41,030 --> 00:59:43,880
S3 选择在这个位置到期
election timer to go off there and the

1314
00:59:43,880 --> 00:59:46,210
这幅图的一个关键点是假设他们选择了一个不同的随机数字
crucial point about this picture is that

1315
00:59:46,210 --> 00:59:48,080
这幅图的一个关键点是假设他们选择了一个不同的随机数字
assuming they picked different random

1316
00:59:48,080 --> 00:59:51,260
它是第一个，它是第二个
numbers one of them is first and the

1317
00:59:51,260 --> 00:59:54,560
它是第一个，它是第二个
other one is second right that's what's

1318
00:59:54,560 --> 00:59:56,600
这里将会发生什么？
going on here and the one that's first

1319
00:59:56,600 --> 00:59:58,069
假设这里的间隙足够长
assuming

1320
00:59:58,069 --> 01:00:00,079
假设这里的间隙足够长
this gap is big enough the one that's

1321
01:00:00,079 --> 01:00:01,400
第一个位置选举定时器会在另一个之前到期
first it's election time will go off

1322
01:00:01,400 --> 01:00:02,869
第一个位置选举定时器会在另一个之前到期
first before the other ones election

1323
01:00:02,869 --> 01:00:05,930
如果我们走运的话
timer and if we were not

1324
01:00:05,930 --> 01:00:06,410
如果我们走运的话
unlucky

1325
01:00:06,410 --> 01:00:08,420
那么这里就有足够长的时间发送一轮投票，并能得到每个人的回复
it'll have time to send out a full round

1326
01:00:08,420 --> 01:00:11,750
那么这里就有足够长的时间发送一轮投票，并能得到每个人的回复
of vote requests and get answers from

1327
01:00:11,750 --> 01:00:13,630
那么这里就有足够长的时间发送一轮投票，并能得到每个人的回复
everybody who everybody's alive before

1328
01:00:13,630 --> 01:00:16,819
这些都会在第二个选举定时器到期之前发生
the second election timer goes off from

1329
01:00:16,819 --> 01:00:22,569
所以，大家明白随机化是怎么去同步化操作的了吗？
any other server so does everybody see

1330
01:00:22,569 --> 01:00:26,140
所以，大家明白随机化是怎么去同步化操作的了吗？
how the randomization desynchronizes

1331
01:00:26,140 --> 01:00:30,710
不幸的是，给定时器设定超时时间需要一点技巧
these candidates unfortunately there's a

1332
01:00:30,710 --> 01:00:33,230
不幸的是，给定时器设定超时时间需要一点技巧
bit of art in setting the contents

1333
01:00:33,230 --> 01:00:34,970
不幸的是，给定时器设定超时时间需要一点技巧
constants for these election timers

1334
01:00:34,970 --> 01:00:36,490
你可能需要满足一些条件
there's some sort of competing

1335
01:00:36,490 --> 01:00:40,210
你可能需要满足一些条件
requirements you might want to fulfill

1336
01:00:40,210 --> 01:00:43,309
典型的条件之一是
so one obvious requirement is that the

1337
01:00:43,309 --> 01:00:45,230
定时器的超时时间至少要和 2 次心跳间隔的时间一样长
election timer has to be at least as

1338
01:00:45,230 --> 01:00:47,030
定时器的超时时间至少要和 2 次心跳间隔的时间一样长
long as the expected interval between

1339
01:00:47,030 --> 01:00:47,809
定时器的超时时间至少要和 2 次心跳间隔的时间一样长
heartbeats

1340
01:00:47,809 --> 01:00:49,790
这一点很明显
you know this is pretty obvious that the

1341
01:00:49,790 --> 01:00:51,410
leader 每隔几百毫秒发送一次心跳
leader sends out heartbeats every

1342
01:00:51,410 --> 01:00:53,690
每隔几百毫秒发送一次心跳
hundred milliseconds you better make

1343
01:00:53,690 --> 01:00:55,520
你最好得确保在心跳之间
比如 100ms 内不会有定时器超时
sure there's no point in having the

1344
01:00:55,520 --> 01:00:57,319
你最好得确保在心跳之间
比如 100ms 内不会有定时器超时
election time or anybody's election time

1345
01:00:57,319 --> 01:00:58,849
你最好得确保在心跳之间
比如 100ms 内不会有定时器超时
or ever go off for 100

1346
01:00:58,849 --> 01:01:00,530
如果它在最低的限制之前超时
milliseconds because then it will go off

1347
01:01:00,530 --> 01:01:06,799
如果它在最低的限制之前超时
before the lower limit is certainly the

1348
01:01:06,799 --> 01:01:08,569
最低的限制就是心跳之间的间隔
lower limit is one heartbeat interval in

1349
01:01:08,569 --> 01:01:10,940
因为网络可能会丢弃数据包
fact because the network may drop

1350
01:01:10,940 --> 01:01:13,700
所以你可能会想着把这个最小的选举超时时间设定为心跳间隔时间的 2 倍
packets you probably want to have the

1351
01:01:13,700 --> 01:01:16,309
所以你可能会想着把这个最小的选举超时时间设定为心跳间隔时间的 2 倍
minimum election timer value be a couple

1352
01:01:16,309 --> 01:01:18,829
所以你可能会想着把这个最小的选举超时时间设定为心跳间隔时间的 2 倍
of times the heartbeat interval so 400

1353
01:01:18,829 --> 01:01:20,089
所以你可以设置成 400ms，也可能设置一个最短的选举时间
millisecond heartbeats you probably want

1354
01:01:20,089 --> 01:01:21,440
所以你可以设置成 400ms，也可能设置一个最短的选举时间
to have the very shortest possible

1355
01:01:21,440 --> 01:01:24,319
又或是设置成心跳间隔时间的 3 倍，比如 300ms
election time or be you know say 300

1356
01:01:24,319 --> 01:01:26,119
又或是设置成心跳间隔时间的 3 倍，比如 300ms
milliseconds you know three times the

1357
01:01:26,119 --> 01:01:29,450
这里是最小的心跳时间间隔
heartbeat interval so that's the sort of

1358
01:01:29,450 --> 01:01:33,710
这里是最小的心跳时间间隔
minimum is the heart heartbeat so this

1359
01:01:33,710 --> 01:01:35,569
这里是最小的心跳时间间隔
frequent you want the minimum to be you

1360
01:01:35,569 --> 01:01:39,470
这里是心跳间隔的 2 倍
know a couple of times that or here so

1361
01:01:39,470 --> 01:01:40,640
最大值在哪里呢
what about the maximum you know you're

1362
01:01:40,640 --> 01:01:43,010
你可以假定使用一个均匀分布生成某个范围的随机值
gonna presumably randomize uniformly

1363
01:01:43,010 --> 01:01:45,710
你可以假定使用一个均匀分布生成某个范围的随机值
over some range of times you know where

1364
01:01:45,710 --> 01:01:50,960
我们应该设置一个最大值在这儿，这是能够随机出的最大时间
should we set the kind of maximum time

1365
01:01:50,960 --> 01:01:54,710
我们应该设置一个最大值在这儿，这是能够随机出的最大时间
that we're randomizing over there's a

1366
01:01:54,710 --> 01:01:57,740
在真实系统中，这里有 2 点考虑
couple of considerations here in a real

1367
01:01:57,740 --> 01:02:04,410
最大时间会影响系统有多快能从故障中恢复
system you know this maximum time effect

1368
01:02:04,410 --> 01:02:06,240
最大时间会影响系统有多快能从故障中恢复
how quickly the system can recover from

1369
01:02:06,240 --> 01:02:09,420
因为，假设服务器从这个位置开始出故障
failure because remember from the time

1370
01:02:09,420 --> 01:02:11,910
因为，假设服务器从这个位置开始出故障
at which the server fails until the

1371
01:02:11,910 --> 01:02:14,730
那么在选举定时器超时之前，整个系统都处于不可用状态
first election timer goes off the whole

1372
01:02:14,730 --> 01:02:17,430
那么在选举定时器超时之前，整个系统都处于不可用状态
system is frozen there's no leader you

1373
01:02:17,430 --> 01:02:18,870
此时没有任何 leader，客户端发的所有请求都会被丢弃
know the clients requests are being

1374
01:02:18,870 --> 01:02:20,190
此时没有任何 leader，客户端发的所有请求都会被丢弃
thrown away because there's no leader

1375
01:02:20,190 --> 01:02:22,320
而且我们也没有重新指定一个新的 leader 出来
and we're not assigning a new leader

1376
01:02:22,320 --> 01:02:24,870
即使你知道其它的这些 server 是健康的
even though you know presumably these

1377
01:02:24,870 --> 01:02:27,390
即使你知道其它的这些 server 是健康的
other servers are up so the be away

1378
01:02:27,390 --> 01:02:29,670
所以我们选的最大值越靠后，延迟就越长
choose this maximum the longer delay

1379
01:02:29,670 --> 01:02:32,040
在系统恢复前，对客户端的影响就越长
we're imposing on clients before

1380
01:02:32,040 --> 01:02:34,770
你知道，关于这一点
取决于你想要多高的性能、故障发生的频率
recovery occurs you know whether that's

1381
01:02:34,770 --> 01:02:38,220
你知道，关于这一点
取决于你想要多高的性能、故障发生的频率
important depends on sort of how high

1382
01:02:38,220 --> 01:02:40,200
你知道，关于这一点
取决于你想要多高的性能、故障发生的频率
performance we need this to be and how

1383
01:02:40,200 --> 01:02:42,870
你知道，关于这一点
取决于你想要多高的性能、故障发生的频率
often we think there will be failures

1384
01:02:42,870 --> 01:02:46,310
一年只发生一次故障的话，鬼才会去关心这个问题
failures happen once a year then who cares

1386
01:02:46,310 --> 01:02:48,600
如果故障发生很频繁的话
we're expecting failures frequently we

1387
01:02:48,600 --> 01:02:51,330
那我们就需要去关心到底要设置的多长的时间，让故障恢复
may care very much how long it takes to

1388
01:02:51,330 --> 01:02:53,670
所以这是第一个我们需要考虑的问题
recover okay so that's one consideration

1389
01:02:53,670 --> 01:02:56,330
另一个要考虑的事情是这里这个间隔
the other consideration is that this gap

1390
01:02:56,330 --> 01:02:59,400
S1 超时，到 S2 超时这个时间间隔
that is the expected gap in time between

1391
01:02:59,400 --> 01:03:01,410
S1 超时，到 S2 超时这个时间间隔
the first time are going off and the

1392
01:03:01,410 --> 01:03:04,890
S1 超时，到 S2 超时这个时间间隔
second timer going off this gap really

1393
01:03:04,890 --> 01:03:07,890
这个间隔非常有用，而且它要足够的长
in order to be useful has to be longer

1394
01:03:07,890 --> 01:03:09,930
足够让 candidate 能收到其它人的投票
than the time it takes for the candidate

1395
01:03:09,930 --> 01:03:12,330
足够让 candidate 能收到其它人的投票
to assemble votes from everybody that is

1396
01:03:12,330 --> 01:03:15,060
它要比一次 RPC 请求到响应的来回时间要长一些
longer than the expected round-trip time

1397
01:03:15,060 --> 01:03:16,590
它要比一次 RPC 请求到响应的来回时间要长一些
the amount of time it takes to send an

1398
01:03:16,590 --> 01:03:19,050
它要比一次 RPC 请求到响应的来回时间要长一些
RPC and get the response and so maybe it

1399
01:03:19,050 --> 01:03:21,840
比如发送一次 RPC 到收到所有其它 server 响应需要 10ms
takes 10 milliseconds to send an RPC and

1400
01:03:21,840 --> 01:03:25,860
比如发送一次 RPC 到收到所有其它 server 响应需要 10ms
get a response a response from all the

1401
01:03:25,860 --> 01:03:27,810
在这种情况下，我们设置的最大值，至少要让这个间隔大于 10ms
other servers and if that's the case we

1402
01:03:27,810 --> 01:03:28,980
在这种情况下，我们设置的最大值，至少要让这个间隔大于 10ms
need to make maximum at least long

1403
01:03:28,980 --> 01:03:30,570
在这种情况下，我们设置的最大值，至少要让这个间隔大于 10ms
enough that there's pretty likely to be

1404
01:03:30,570 --> 01:03:32,220
也就是最小的这个随机数到下一个最小的随机数之间的差值能大于 10ms
10 milliseconds difference between the

1405
01:03:32,220 --> 01:03:34,110
也就是最小的这个随机数到下一个最小的随机数之间的差值能大于 10ms
smallest random number and the next

1406
01:03:34,110 --> 01:03:37,040
也就是最小的这个随机数到下一个最小的随机数之间的差值能大于 10ms
smallest random number

1407
01:03:40,550 --> 01:03:46,470
对你们来说，那些测试代码可能会让你们感觉到痛苦
and for you the test code will get upset

1408
01:03:46,470 --> 01:03:54,359
如果经过若干秒后你的 leader 都未能从故障中恢复
if you if you don't recover from a

1409
01:03:54,359 --> 01:03:56,850
如果经过若干秒后你的 leader 都未能从故障中恢复
leader failure in a couple seconds and

1410
01:03:56,850 --> 01:03:58,920
那你就需要考虑一下调优这个最大值，把它设置的小一点
so just pragmatically you need to tune

1411
01:03:58,920 --> 01:04:00,990
那你就需要考虑一下调优这个最大值，把它设置的小一点
this maximum down so that it's highly

1412
01:04:00,990 --> 01:04:03,720
只要它能让你在几秒内完成 leader 选举就行
likely that you'll be able to complete a

1413
01:04:03,720 --> 01:04:05,940
只要它能让你在几秒内完成 leader 选举就行
leader election within a few seconds but

1414
01:04:05,940 --> 01:04:09,540
这就算是一个不那么紧的约束
that's not a very tight constraint any

1415
01:04:09,540 --> 01:04:13,670
关于选举时间大家还有问题吗？
questions about the election time outs

1416
01:04:13,670 --> 01:04:19,910
还有一个不起眼的问题是
one tiny point is that you want to

1417
01:04:19,910 --> 01:04:23,190
每次你都应该选择一个新的随机超时时间
choose new random time outs every time

1418
01:04:23,190 --> 01:04:26,700
是的，每次都需要随机生成一个
there's every time you every time I note

1419
01:04:26,700 --> 01:04:28,740
每次你都需要重新设定这个定时器
sets it to like me sets its election

1420
01:04:28,740 --> 01:04:31,230
你不要在服务器启动的时候，随机生成一个数字重复使用它
timer that is don't choose a random

1421
01:04:31,230 --> 01:04:34,830
你不要在服务器启动的时候，随机生成一个数字重复使用它
number when the server is first created

1422
01:04:34,830 --> 01:04:36,090
你不要在服务器启动的时候，随机生成一个数字重复使用它
and then we use that same number over

1423
01:04:36,090 --> 01:04:37,470
你不要在服务器启动的时候，随机生成一个数字重复使用它
and over again because you make an

1424
01:04:37,470 --> 01:04:39,720
如果你这样做，你的服务器可能会产生一些不良行为
unlucky choice that is you choose this

1425
01:04:39,720 --> 01:04:42,270
如果你这样做，你的服务器可能会产生一些不良行为
one server happens by ill chance to

1426
01:04:42,270 --> 01:04:44,160
比如会导致每次选举的选票都被瓜分掉，直到永远
choose the same random number as another

1427
01:04:44,160 --> 01:04:46,050
比如会导致每次选举的选票都被瓜分掉，直到永远
server that means that you're gonna have

1428
01:04:46,050 --> 01:04:48,830
比如会导致每次选举的选票都被瓜分掉，直到永远
split votes over and over again forever

1429
01:04:48,830 --> 01:04:51,300
这就是为什么你需要每次都生成一个新的随机数来设定选举超时时间
that's why you want to almost certainly

1430
01:04:51,300 --> 01:04:53,340
这就是为什么你需要每次都生成一个新的随机数来设定选举超时时间
choose a different a new fresh random

1431
01:04:53,340 --> 01:04:56,130
这就是为什么你需要每次都生成一个新的随机数来设定选举超时时间
number for the election time out value

1432
01:04:56,130 --> 01:05:02,940
这就是为什么你需要每次都生成一个新的随机数来设定选举超时时间
every time you reset the timer all right

1433
01:05:02,940 --> 01:05:06,800
好，最后一个关于 leader 选举的问题
so the final issue about leader election

1434
01:05:06,800 --> 01:05:09,030
假设我们在这样一种情形
suppose we are in this situation where

1435
01:05:09,030 --> 01:05:11,190
旧的 leader 处于一个网络分区中，比如网线断了
the old leaders partition you know the

1436
01:05:11,190 --> 01:05:12,960
旧的 leader 处于一个网络分区中，比如网线断了
network cable is broken and the old

1437
01:05:12,960 --> 01:05:14,790
旧 leader 以及 2 个客户端
leader is sort of out there with a

1438
01:05:14,790 --> 01:05:17,220
还有不超过半数的 server 在这个分区中
couple clients and a minority of servers

1439
01:05:17,220 --> 01:05:20,520
另一半的网络分区中有超过半数的 server
and there's a majority in the other half

1440
01:05:20,520 --> 01:05:21,630
在这个超过半数 server 的分区中又选举出了一个新的 leader
of the network and the majority of the

1441
01:05:21,630 --> 01:05:22,710
在这个超过半数 server 的分区中又选举出了一个新的 leader
new half of the network elects a new

1442
01:05:22,710 --> 01:05:28,200
那旧的 leader 会怎么样？
leader what about the old leader why why

1443
01:05:28,200 --> 01:05:35,390
为什么旧的 leader 不会导致错误的行为
won't the old leader cause incorrect execution

1445
01:06:06,310 --> 01:06:09,980
是的，有 2 个潜在的问题
yes to two potential problems one is or

1446
01:06:09,980 --> 01:06:12,860
其中一个问题是
one some non problem is that if there's

1447
01:06:12,860 --> 01:06:14,510
如果有一个 leader 处于一个不超过半数 server 的分区中
a leader off in another partition and it

1448
01:06:14,510 --> 01:06:17,030
如果有一个 leader 处于一个不超过半数 server 的分区中
doesn't have a majority then the next

1449
01:06:17,030 --> 01:06:20,930
客户端发送给它请求后，你知道这个 leader 处在少数派的分区中
time a client sends it a request that

1450
01:06:20,930 --> 01:06:24,260
客户端发送给它请求后，你知道这个 leader 处在少数派的分区中
that leader that you know in a partition

1451
01:06:24,260 --> 01:06:25,400
客户端发送给它请求后，你知道这个 leader 处在少数派的分区中
with a minority yeah it'll send out

1452
01:06:25,400 --> 01:06:27,500
它会发送 AppendEntries，但是因为在少数派中
append entries but because it's in the

1453
01:06:27,500 --> 01:06:29,930
所以它无法得到半数以上 server（包括自己） 的回应
minority partition it won't be able to

1454
01:06:29,930 --> 01:06:31,940
所以它无法得到半数以上 server（包括自己） 的回应
get responses back from a majority of

1455
01:06:31,940 --> 01:06:33,860
所以它无法得到半数以上 server（包括自己） 的回应
the server's including itself and so it

1456
01:06:33,860 --> 01:06:36,110
所以它永远都不会把客户端请求的操作进行提交
will never commit the operation it will

1457
01:06:36,110 --> 01:06:37,100
也永远不会去执行它
never execute it

1458
01:06:37,100 --> 01:06:39,830
它永远也不会去响应客户端说它执行完了这条命令
it'll never respond to the client saying

1459
01:06:39,830 --> 01:06:42,470
它永远也不会去响应客户端说它执行完了这条命令
that it executed it either and so that

1460
01:06:42,470 --> 01:06:45,860
这意思是说如果一个旧的 server(leader)
means that yeah an old server often a

1461
01:06:45,860 --> 01:06:47,930
经常处于不同的分区中
different partition people many clients

1462
01:06:47,930 --> 01:06:49,670
许多客户可能发送的请求都无法得到响应
may send a request but they'll never get

1463
01:06:49,670 --> 01:06:54,020
所以客户端也不会误以为旧的 server 执行过任何命令
responses so no client will be fooled

1464
01:06:54,020 --> 01:06:56,630
所以客户端也不会误以为旧的 server 执行过任何命令
into thinking that that old server

1465
01:06:56,630 --> 01:07:02,000
所以客户端也不会误以为旧的 server 执行过任何命令
executed anything for it the other sort

1466
01:07:02,000 --> 01:07:05,450
另一个更加 tricky（巧合) 的问题，待会儿咱们再说
of more tricky issue which actually I'll

1467
01:07:05,450 --> 01:07:07,040
另一个更加 tricky（巧合) 的问题，待会儿咱们再说
talk about in a few minutes is the

1468
01:07:07,040 --> 01:07:10,670
是关于 server 在发送 AppendEntries 到一部分 server 后宕机的可能性
possibility that before server fails it

1469
01:07:10,670 --> 01:07:14,080
是关于 server 在发送 AppendEntries 到一部分 server 后宕机的可能性
sends out append entries to a subset of

1470
01:07:14,080 --> 01:07:17,660
是关于 server 在发送 AppendEntries 到一部分 server 后宕机的可能性
the servers and then crashes before

1471
01:07:17,660 --> 01:07:21,050
在做 commit 决策之前，它就宕机了
making a commit decision and as a very

1472
01:07:21,050 --> 01:07:24,830
这是一个很有趣的问题，我可能得花 45 分钟来讨论它
interesting question which I'll probably

1473
01:07:24,830 --> 01:07:27,760
这是一个很有趣的问题，我可能得花 45 分钟来讨论它
spend a good 45 minutes talking about

1474
01:07:27,760 --> 01:07:30,050
我们先回到刚刚话题
and so actually before I turn to the

1475
01:07:30,050 --> 01:07:33,260
关于 leader 选举，大家还有其它问题吗？
back topic in general any more questions

1476
01:07:33,260 --> 01:07:40,390
关于 leader 选举，大家还有其它问题吗？
about in leader election okay

1477
01:07:42,220 --> 01:07:44,930
好，关于 log 中的内容是什么样的
okay so how about the contents of the

1478
01:07:44,930 --> 01:07:49,160
在前一个 leader 挂掉之后，如何进行新一轮 leader 选举
logs and how in particular how a newly

1479
01:07:49,160 --> 01:07:51,740
在前一个 leader 挂掉之后，如何进行新一轮 leader 选举
elected leader possibly picking up the

1480
01:07:51,740 --> 01:07:54,440
在前一个 leader 挂掉之后，如何进行新一轮 leader 选举
pieces after an awkward crash of the

1481
01:07:54,440 --> 01:07:56,750
log 产生分叉的话，如何进行 leader 选举
previous leader how does a newly elected

1482
01:07:56,750 --> 01:07:59,630
log 产生分叉的话，如何进行 leader 选举
leader sort out the possibly divergent

1483
01:07:59,630 --> 01:08:02,300
log 产生分叉的话，如何进行 leader 选举
logs on the different replicas in order

1484
01:08:02,300 --> 01:08:06,140
来恢复系统中的一致性的状态
to restore sort of consistent state in

1485
01:08:06,140 --> 01:08:14,660
来恢复系统中的一致性的状态
the system all right so the first

1486
01:08:14,660 --> 01:08:17,870
关于第一个问题，你能想到什么
question is what can think this is this

1487
01:08:17,870 --> 01:08:19,670
这是一个完整的话题
whole topic it's really only interesting

1488
01:08:19,670 --> 01:08:21,920
关于 server 宕机后我们唯一比较感兴趣的事情
after a server crashes right if the

1489
01:08:21,920 --> 01:08:25,460
如果 server 一直很健康，并且一切事情进展顺利
server stays up then relatively few

1490
01:08:25,460 --> 01:08:26,930
如果 server 一直很健康，并且一切事情进展顺利
things can go wrong if we have a server

1491
01:08:26,930 --> 01:08:28,640
我们拥有一个健康的 server 和超过半数的机器
that's up and has a majority you know

1492
01:08:28,640 --> 01:08:29,870
在一段时间内他们都是健康的
during the period of time when it's up

1493
01:08:29,870 --> 01:08:34,069
在一段时间内他们都是健康的
and has a majority it just tells the

1494
01:08:34,069 --> 01:08:35,899
leader 只要通知 follwer 日志应该是什么样的就行
followers what the logs should look like

1495
01:08:35,899 --> 01:08:37,759
follwer 是不允许反对 leader 的
and the followers are not allowed to

1496
01:08:37,759 --> 01:08:39,649
如果它们基本上都是保持最新的状态的
那么只需要服从 leader，只要按照图 2 中的规则做事就行
disagree they're required to accept they

1497
01:08:39,649 --> 01:08:41,420
如果它们基本上都是保持最新的状态的
那么只需要服从 leader，只要按照图 2 中的规则做事就行
just do by the rules of figure two if

1498
01:08:41,420 --> 01:08:43,100
如果它们基本上都是保持最新的状态的
那么只需要服从 leader，只要按照图 2 中的规则做事就行
they've been more or less keeping up you

1499
01:08:43,100 --> 01:08:44,660
它们就只是简单的使用 leader 发给他们的 AppendEntires
know they just take whatever the leader

1500
01:08:44,660 --> 01:08:46,219
它们就只是简单的使用 leader 发给他们的 AppendEntires
sends them AppendEntries appended

1501
01:08:46,219 --> 01:08:48,500
追加到自己的日志上，并提交这些消息，然后执行
to the log and obey commit messages and

1502
01:08:48,500 --> 01:08:50,299
这几乎不会发生什么错误
execute there's hardly anything to go

1503
01:08:50,299 --> 01:08:52,069
在 raft 中，有些事情会导致故障
wrong the things that go wrong in raft

1504
01:08:52,069 --> 01:08:55,609
比如当一个旧的 leader 在发送消息的中途宕机了
go wrong when a the old leader crashes

1505
01:08:55,609 --> 01:08:58,520
比如当一个旧的 leader 在发送消息的中途宕机了
sort of midway through you know sending

1506
01:08:58,520 --> 01:09:01,939
又或者是刚刚新选举的 leader 宕机了
out messages or a new leader crashes you

1507
01:09:01,939 --> 01:09:03,229
又或者是刚刚新选举的 leader，啥也没干就宕机了
know sort of just after it's been

1508
01:09:03,229 --> 01:09:06,950
又或者是刚刚新选举的 leader，啥也没干就宕机了
elected but before it's done anything

1509
01:09:06,950 --> 01:09:10,130
所以我们感兴趣的是，这经过一连串的 crash 后，log 长啥样？
very useful so one thing we're very

1510
01:09:10,130 --> 01:09:11,779
所以我们感兴趣的是，这经过一连串的 crash 后，log 长啥样？
interested in is what can the logs look

1511
01:09:11,779 --> 01:09:16,670
所以我们感兴趣的是，这经过一连串的 crash 后，log 长啥样？
like after some sequence of crashes okay

1512
01:09:16,670 --> 01:09:19,520
来，咱们讲个例子，假设我们有 3 台服务器
so here's an example supposing we have

1513
01:09:19,520 --> 01:09:26,180
我准备画一些图，等会我们会看到很多情况
three servers and the way I'm gonna draw

1514
01:09:26,180 --> 01:09:27,589
我准备画一些图，等会我们会看到很多情况
out these diagrams because we're gonna

1515
01:09:27,589 --> 01:09:30,880
我准备画一些图，等会我们会看到很多情况
be looking a lot at a lot of sort of

1516
01:09:30,880 --> 01:09:32,988
不同情况下的 log 都是什么样的
situations where the logs look like this

1517
01:09:32,988 --> 01:09:34,790
我们需要推演各种可能性下会发生什么
and we're gonna be wondering is that

1518
01:09:34,790 --> 01:09:36,649
我们需要推演各种可能性下会发生什么
possible and what happens if they do

1519
01:09:36,649 --> 01:09:38,479
我会在这里使用一些记号表示日志项
look like that so my notation is going

1520
01:09:38,479 --> 01:09:40,370
我会在这里使用一些记号表示日志项
to be I'm gonna write out log entries

1521
01:09:40,370 --> 01:09:44,870
对于每个 server，相同位置的槽都是对齐的
for each of the servers sort of aligned

1522
01:09:44,870 --> 01:09:47,839
对于每个 server，相同位置的槽都是对齐的
to indicate slots corresponding slots in

1523
01:09:47,839 --> 01:09:50,270
这里这个数字表示的是 term 号，不是客户端命令
the log and the values I'm going to

1524
01:09:50,270 --> 01:09:54,340
这里这个数字表示的是 term 号，不是客户端命令
write here are the term numbers rather than

1526
01:09:54,340 --> 01:09:56,889
这里这个数字表示的是 term 号，不是客户端命令
client operations I'm going to you know

1527
01:09:56,889 --> 01:09:59,219
这里是槽 1，这里这是槽 2
this is slot one this is slot two

1528
01:09:59,219 --> 01:10:02,380
所有的服务器在 1 号槽上都看到了来自 term 3 的命令
everybody saw a command from term three

1529
01:10:02,380 --> 01:10:05,230
S2 和 S3 看到了来自 term 3 的命令
in slot 1 and server 2 server 3

1530
01:10:05,230 --> 01:10:08,320
S2 和 S3 看到了来自 term 3 的命令
saw command from also term three and the

1531
01:10:08,320 --> 01:10:10,239
而在 2 号槽上，S1 什么也没有
second slot the server one has nothing

1532
01:10:10,239 --> 01:10:14,800
所以，这个问题，也是咱们的第一个问题，它是如何发生的？
there at all and so question for this

1533
01:10:14,800 --> 01:10:16,480
所以，这个问题，也是咱们的第一个问题，它是如何发生的？
like the very first question is can this

1534
01:10:16,480 --> 01:10:21,659
这种情况会发生吗？怎么发生的？
arrive could this setup arise and how

1535
01:10:21,659 --> 01:10:24,659
是的
yes

1536
01:11:02,130 --> 01:11:04,840
S3 可能是 leader
so you know maybe server 3 was the

1537
01:11:04,840 --> 01:11:06,280
我就把你刚刚说的话重复一下
leader for just repeating what you said

1538
01:11:06,280 --> 01:11:08,320
S3 可能是 term 3 的 leader
maybe server 3 is the leader for term 3

1539
01:11:08,320 --> 01:11:09,970
它收到了一条命令，然后发给每个人
he got a command that sent out to

1540
01:11:09,970 --> 01:11:11,380
然后每个收到它追加到自己的 log 中
everybody everybody received and apended

1541
01:11:11,380 --> 01:11:14,350
接下来 S3 又收到了一条来自客户端的请求
at the log and then I got a server 3 got

1542
01:11:14,350 --> 01:11:18,160
接下来 S3 又收到了一条来自客户端的请求
a second request from a client and maybe

1543
01:11:18,160 --> 01:11:19,810
它可能发它发送给了所有的 server
it sent it to all three servers but the

1544
01:11:19,810 --> 01:11:21,130
但是这条消息在发送给 S1 时丢失了，也可能是 S1 宕机了
message got lost on the way to server

1545
01:11:21,130 --> 01:11:23,020
但是这条消息在发送给 S1 时丢失了，也可能是 S1 宕机了
one or maybe server was down at the time

1546
01:11:23,020 --> 01:11:25,030
leader 在发送 AppendEntires 之前
or something and so only server two the

1547
01:11:25,030 --> 01:11:28,150
总是能追加新的命令到自己的 log 中的
leader always append new commands to its

1548
01:11:28,150 --> 01:11:29,830
总是能追加新的命令到自己的 log 中的
log before it sends out append entries

1549
01:11:29,830 --> 01:11:32,380
AppendEntires RPC 仅仅被  S2 收到
and maybe the append entry RPC only got

1550
01:11:32,380 --> 01:11:34,390
所以在这种情况下
to server 2 so this situation you know

1551
01:11:34,390 --> 01:11:36,160
这只是一种很简单的日志不一致的情况
it's like the simplest situation in which

1552
01:11:36,160 --> 01:11:38,460
这只是一种很简单的日志不一致的情况
actually the logs are not different and

1553
01:11:38,460 --> 01:11:43,480
我们知道它可能会怎么样发生
we know how it could possibly arise and

1554
01:11:43,480 --> 01:11:45,250
所以如果作为 leader 的 S3 宕机了
so if server 3 which is a leadership

1555
01:11:45,250 --> 01:11:46,480
那么现在你就必须得再选一个新的 server
crash now you know the next server

1556
01:11:46,480 --> 01:11:49,300
那么现在你就必须得再选一个新的 server
they're gonna need to make sure server 1

1557
01:11:49,300 --> 01:11:54,820
那么现在你就必须得再选一个新的 server
well first of all if server 3 crashes or

1558
01:11:54,820 --> 01:11:56,140
那么现在你就必须得再选一个新的 server
we'll be at an election and some of the

1559
01:11:56,140 --> 01:11:57,790
会有某个 leader 被选出来
leader is chosen you know two things

1560
01:11:57,790 --> 01:12:00,160
有 2 件事件一定会发生
have to happen the new leader has got to

1561
01:12:00,160 --> 01:12:04,990
新的 leader 需要能识别出这条命令是提交过的
recognize that this command could have

1562
01:12:04,990 --> 01:12:07,750
它也不允许丢弃这条日志
committed it's not allowed to throw it away

1564
01:12:07,750 --> 01:12:09,940
另外它需要保证 S1 填充此处的空白
and it needs to make sure server one

1565
01:12:09,940 --> 01:12:12,070
另外它需要保证 S1 填充此处的空白
fills in this blank here with indeed

1566
01:12:12,070 --> 01:12:13,600
以和别人在同样的位置保持一致
this very same command that everybody

1567
01:12:13,600 --> 01:12:17,950
以和别人在同样的位置保持一致
else had in that slot all right so after

1568
01:12:17,950 --> 01:12:20,440
所以在某个 server 宕机后
a crash somebody you know server 3

1569
01:12:20,440 --> 01:12:22,420
所以另一种可能出现此情况的方式是
suppose another way this can come up is

1570
01:12:22,420 --> 01:12:24,160
S3 在给 S2 发送 AppendEntries 后
但是在给 S1 发送前宕机了
server 3 might have sent out the append

1571
01:12:24,160 --> 01:12:26,140
S3 在给 S2 发送 AppendEntries 后
但是在给 S1 发送前宕机了
entries the server 2 but then crashed

1572
01:12:26,140 --> 01:12:27,700
S3 在给 S2 发送 AppendEntries 后
但是在给 S1 发送前宕机了
before sending the append entries to server 3（口误，应该是 S1）

1573
01:12:27,700 --> 01:12:30,400
所以，如果你选了一个新的 leader 出来
so if were you know electing a

1574
01:12:30,400 --> 01:12:32,410
在发送消息之前就宕机了，这就导致了这种情况
new leader it could because we got a

1575
01:12:32,410 --> 01:12:34,530
在发送消息之前就宕机了，这就导致了这种情况
crash before the message was sent

1576
01:12:34,530 --> 01:12:37,080
我们再考虑另一种情况，仍然有 3 个 server
here's another scenario to think about

1577
01:12:37,080 --> 01:12:44,830
我们再考虑另一种情况，仍然有 3 个 server
three servers again now I mean a number

1578
01:12:44,830 --> 01:12:48,190
日志里有一些槽，假设它们编号分别是 10, 11, 12, 13
the slots in the log and so we can refer

1579
01:12:48,190 --> 01:12:57,150
日志里有一些槽，假设它们编号分别是 10, 11, 12, 13
to them got slot 10 11 12 13

1581
01:12:57,150 --> 01:13:04,360
这里设置相同的值，除了 12 号槽
again it's same setup except now we have

1582
01:13:04,360 --> 01:13:07,780
我们假设 S2 在 term 4 有一条命令
in slot 12 we have server 2 as a

1583
01:13:07,780 --> 01:13:11,170
而 S3 在 term 5 时有一条命令
command from term 4 and server 3 has a

1584
01:13:11,170 --> 01:13:14,730
而 S3 在 term 5 时有一条命令
term command from term 5

1585
01:13:15,790 --> 01:13:19,610
呃，在我们分析这个情形前，我们先思考一下
so you know before we analyze these to

1586
01:13:19,610 --> 01:13:21,470
这种情况会发生吗？
figure out what would happen and what

1587
01:13:21,470 --> 01:13:22,970
如果 server 看到这种情况，应该要怎么做？
would a server do if it saw this we need

1588
01:13:22,970 --> 01:13:24,980
如果 server 看到这种情况，应该要怎么做？
to ask could this even occur because

1589
01:13:24,980 --> 01:13:27,050
如果出现了这种情况的话，有时候大家的回答是
sometimes the answer to the question oh

1590
01:13:27,050 --> 01:13:28,520
Oh! 上帝，这发生了什么？
jeez what would happen if this

1591
01:13:28,520 --> 01:13:30,620
Oh! 上帝，这发生了什么？
configuration arose sometimes the answer

1592
01:13:30,620 --> 01:13:32,900
有时候的答案是，它不可能出现，所以我们也不用担心这个问题
is it cannot arise so we do not have to

1593
01:13:32,900 --> 01:13:37,130
所以我们的问题是，这种情况会发生吗？如果会的话，怎么才能出现？
worry about it the question is could

1594
01:13:37,130 --> 01:13:39,940
所以我们的问题是，这种情况会发生吗？如果会的话，怎么才能出现？
this arise and how

1595
01:13:57,900 --> 01:14:02,990
不错
all right so any

1596
01:14:12,820 --> 01:14:15,910
(回答问题)

1597
01:14:52,659 --> 01:14:55,659
是的
yeah

1598
01:14:59,060 --> 01:15:02,430
我简单说一下，这种情况是可能出现的
in brief we know this configuration can

1599
01:15:02,430 --> 01:15:05,670
这里变成 4 和 5 的方式可以是这样的
arise and so the way we can then get the

1600
01:15:05,670 --> 01:15:07,530
这里变成 4 和 5 的方式可以是这样的
four and a five here is let's suppose in

1601
01:15:07,530 --> 01:15:08,910
我们假设开始进行一次 leader 选举
the next leader election server twos

1602
01:15:08,910 --> 01:15:11,700
S2 成为了 term 4 的 leader
elected leader now for term 4 its

1603
01:15:11,700 --> 01:15:13,440
这时候客户端发起一次请求，S2 追加了一条日志后 crash 掉
selected leader because a request from a

1604
01:15:13,440 --> 01:15:15,900
这时候客户端发起一次请求，S2 追加了一条日志后 crash 掉
client it appends it to its own log and

1605
01:15:15,900 --> 01:15:20,040
所以这里变成了 4
crashes so now we have this right we

1606
01:15:20,040 --> 01:15:21,480
因为 leader S2 刚刚 crash 了
need a new election because the leader

1607
01:15:21,480 --> 01:15:25,410
现在我们需要进行一次新的选举
just crashed now in this election and

1608
01:15:25,410 --> 01:15:27,510
现在我们需要问一下自己，谁可以被选为 leader
then so now we have to ask whether who

1609
01:15:27,510 --> 01:15:29,370
我们必须回过头好好想想，什么样的 server 可以被选出来
could be elected or we have to give him

1610
01:15:29,370 --> 01:15:30,720
我们必须回过头好好想想，什么样的 server 可以被选出来
back of our heads oh gosh what could be

1611
01:15:30,720 --> 01:15:32,730
这里 S3 可以被选为 leader
elected so we're gonna claim server

1612
01:15:32,730 --> 01:15:34,470
这里 S3 可以被选为 leader
three could be elected the reason why I

1613
01:15:34,470 --> 01:15:35,760
为什么我能选它是因为它只要获得了大多数的选票就行
could be elected is because it only

1614
01:15:35,760 --> 01:15:38,130
为什么我能选它是因为它只要获得了大多数的选票就行
needs request vote responses from

1615
01:15:38,130 --> 01:15:40,500
这里 majority 是 S1 和 S3
majority that majority is server one and

1616
01:15:40,500 --> 01:15:42,780
因为 S1 和 S3 的 log 并没什么冲突
server three you know there's no no

1617
01:15:42,780 --> 01:15:44,370
因为 S1 和 S3 的 log 并没什么冲突
problem no conflict between these two

1618
01:15:44,370 --> 01:15:46,560
所以 S3 可以被选为 term 5 的 leader
logs so server three can be elected for

1619
01:15:46,560 --> 01:15:48,770
然后 S3 收到了客户端的请求，追加了一条日志后就 crash
term five get a request from a client

1620
01:15:48,770 --> 01:15:51,810
然后 S3 收到了客户端的请求，追加了一条日志后就 crash
append it to its own log and crash and

1621
01:15:51,810 --> 01:15:54,180
这就是形成这种情况的方式
that's how you get this this

1622
01:15:54,180 --> 01:15:57,150
你需要反复思考这些事情，并达到理解的程度
configuration so you know you need to be

1623
01:15:57,150 --> 01:16:04,140
你需要反复思考这些事情，并达到理解的程度
able to to work through these things in

1624
01:16:04,140 --> 01:16:05,790
并能够回答这个问题：是的，这种情况可以发生
order to get to the stage of saying yes

1625
01:16:05,790 --> 01:16:07,140
因此 raft 必须为此做一些明智的事情
this could happen and therefore raft

1626
01:16:07,140 --> 01:16:09,390
而不是因为有些事不能发生，你就说不会发生这种情况
must do something sensible as opposed to

1627
01:16:09,390 --> 01:16:11,310
而不是因为有些事不能发生，你就说不会发生这种情况
it cannot happen because some things

1628
01:16:11,310 --> 01:16:13,730
而不是因为有些事不能发生，你就说不会发生这种情况
can't happen

1629
01:16:17,539 --> 01:16:23,929
好，现在我们已经知道这种情况发生的原因
all right so so what can happen now we

1630
01:16:23,929 --> 01:16:27,050
好，现在我们已经知道这种情况发生的原因
know this can occur so hopefully we can

1631
01:16:27,050 --> 01:16:29,110
我们要让自己信服，raft 确实是做了一些明智的事情
convince ourselves that raft actually

1632
01:16:29,110 --> 01:16:34,550
我们要让自己信服，raft 确实是做了一些明智的事情
does something sensible now as for the

1633
01:16:34,550 --> 01:16:36,769
对于这些事情，在讨论 raft 实际做了什么之前
range of things before we talk about

1634
01:16:36,769 --> 01:16:39,860
对于这些事情，在讨论 raft 实际做了什么之前
what raft would actually would actually

1635
01:16:39,860 --> 01:16:43,610
我们需要对什么样的结果是可接受的要有一定的认知
do we need to have some sense of what

1636
01:16:43,610 --> 01:16:48,489
我们需要对什么样的结果是可接受的要有一定的认知
would be an acceptable outcome right and

1637
01:16:48,489 --> 01:16:53,449
请认真看这里，我们知道 10 号槽里的命令，在所有副本上都有
just eyeballing this we know that the

1638
01:16:53,449 --> 01:16:55,190
请认真看这里，我们知道 10 号槽里的命令，在所有副本上都有
command in slot 10 since it's known by

1639
01:16:55,190 --> 01:16:59,030
请认真看这里，我们知道 10 号槽里的命令，在所有副本上都有
all all the replicas it could have been

1640
01:16:59,030 --> 01:17:01,610
它可能是会被提交的，所以我们不能丢弃它
committed so we cannot throw it away

1641
01:17:01,610 --> 01:17:04,070
类似的，11 号槽里的命令，因为它被复制到了半数以上节点
similarly the command in slot 11 since

1642
01:17:04,070 --> 01:17:05,659
类似的，11 号槽里的命令，因为它被复制到了半数以上节点
it's in a majority of the replicas it

1643
01:17:05,659 --> 01:17:06,949
它也是有可能被提交的，所以不能丢弃
could for all we know have been

1644
01:17:06,949 --> 01:17:09,380
它也是有可能被提交的，所以不能丢弃
committed so we can't throw it away the

1645
01:17:09,380 --> 01:17:11,300
在 12 号槽中，这里面的命令都不可能被提交
command in slot 12 however neither of

1646
01:17:11,300 --> 01:17:13,190
在 12 号槽中，这里面的命令都不可能被提交
them could possibly have been committed

1647
01:17:13,190 --> 01:17:16,150
所以我们有权利……我们不知道实际上要怎么做
so we're entitled we don't know haven't

1648
01:17:16,150 --> 01:17:18,739
但是 raft 是有权利把它丢弃掉的
we'll actually do but raft is entitled

1649
01:17:18,739 --> 01:17:21,679
但是 raft 是有权利把它(12 号槽)丢弃掉的
to drop both of these even though it is

1650
01:17:21,679 --> 01:17:23,480
即便它没有权利丢弃 10 或 11 号槽的命令
not entitled to drop it and either of

1651
01:17:23,480 --> 01:17:26,889
即便它没有权利丢弃 10 或 11 号槽的命令
the commands in a 10 or 11

1652
01:17:26,889 --> 01:17:28,849
这是有权利丢弃的，但这不是必须要把 2 个都丢弃
this is entitled dropped it's not

1653
01:17:28,849 --> 01:17:31,579
这是有权利丢弃的，但这不是必须要把 2 个都丢弃
required to drop either one of them but

1654
01:17:31,579 --> 01:17:33,380
我意思是它必须丢弃其中一个，至少是一个
I mean oh it certainly must drop one at

1655
01:17:33,380 --> 01:17:35,329
因为你必须要让 log 尾部的内容保持完全一致
least one because you have to have

1656
01:17:35,329 --> 01:17:39,639
因为你必须要让 log 尾部的内容保持完全一致
identical log contents in the end

1657
01:17:43,290 --> 01:17:47,560
这是可能被提交的
this could have been committed it the we

1658
01:17:47,560 --> 01:17:50,100
通过看 log 是无法判断的
can't tell by looking at the logs

1659
01:17:50,100 --> 01:17:52,330
严格的说，我们无法判断 leader 在 crash 前 log 提交到哪个位置
exactly how far the leader got before

1660
01:17:52,330 --> 01:17:55,510
一种可能性是，对于这条命令，又甚至是这条命令
crashing so one possibility is that for

1661
01:17:55,510 --> 01:17:59,140
一种可能性是，对于这条命令，又甚至是这条命令
this command or even this command one

1662
01:17:59,140 --> 01:18:00,790
leader 发送带有新命令的 Append 消息后，立即 crash 了
possibility is that leaders send out the

1663
01:18:00,790 --> 01:18:02,830
leader 发送带有新命令的 Append 消息后，立即 crash 了
append messages with a new command and

1664
01:18:02,830 --> 01:18:05,620
leader 发送带有新命令的 Append 消息后，立即 crash 了
then immediately crashed so it never got

1665
01:18:05,620 --> 01:18:08,110
所以它就永远无法收到响应，因为它 crash 了
any response back because it crashed so

1666
01:18:08,110 --> 01:18:09,640
因此旧的 leader 并不知道它是否已经被提交
the old leader did not know if it was

1667
01:18:09,640 --> 01:18:12,340
如果它没有收到响应，这也意味着它没有去执行它
committed and if it didn't get a

1668
01:18:12,340 --> 01:18:14,410
如果它没有收到响应，这也意味着它没有去执行它
response back that means it didn't

1669
01:18:14,410 --> 01:18:17,590
它也不会发送推进 commit index 的消息
execute it and it didn't send out but

1670
01:18:17,590 --> 01:18:18,940
它也不会发送推进 commit index 的消息
you know it didn't send out that

1671
01:18:18,940 --> 01:18:22,239
它也不会发送推进 commit index 的消息
incremented commit index and so maybe

1672
01:18:22,239 --> 01:18:24,610
所以，副本也不会去执行这条命令
the replicas didn't execute it either so

1673
01:18:24,610 --> 01:18:26,949
所以实际上可能这个位置是没有提交的
it's actually possible that this wasn't

1674
01:18:26,949 --> 01:18:29,980
所以实际上可能这个位置是没有提交的
committed so even though raft doesn't

1675
01:18:29,980 --> 01:18:35,610
所以尽管 raft 不知道，对于 raft，它也是合法的
know it could be legal for raft

1676
01:18:35,610 --> 01:18:40,780
如果 raft 知道更多的事情话，丢弃这条日志可能是合法的
if raft knew more than it does know it

1677
01:18:40,780 --> 01:18:43,600
如果 raft 知道更多的事情话，丢弃这条日志可能是合法的
might be legal to drop this log entry

1678
01:18:43,600 --> 01:18:45,040
因为它可能没被提交
because it might not have been committed

1679
01:18:45,040 --> 01:18:48,310
但是，仅根据当前这些证据
你也没有任何方式去反驳它已被提交
but because on the evidence there's no

1680
01:18:48,310 --> 01:18:51,010
但是，仅根据当前这些证据
你也没有任何方式去反驳它已被提交
way to disprove it was committed based

1681
01:18:51,010 --> 01:18:52,989
它可能被提交，但是 raft 无法去证明它
on this evidence it could have been

1682
01:18:52,989 --> 01:18:55,300
它可能被提交，但是 raft 无法去证明它
committed and raft can't prove it wasn't

1683
01:18:55,300 --> 01:18:58,449
所以 raft 只能当作它被提交
so it must treat it as committed because

1684
01:18:58,449 --> 01:19:01,060
因为 leader 也可能在收到 AppendEntries 的响应之后
并且回复了客户端之后 crash 掉
the leader might have received it might

1685
01:19:01,060 --> 01:19:03,310
因为 leader 也可能在收到 AppendEntries 的响应之后
并且回复了客户端之后 crash 掉
have crashed just after receiving the

1686
01:19:03,310 --> 01:19:05,620
因为 leader 也可能在收到 AppendEntries 的响应之后
并且回复了客户端之后 crash 掉
append entry replies and replying to the

1687
01:19:05,620 --> 01:19:08,260
所以看到这种情形，我们不能排除掉这种可能性
client so just looking at this we can't

1688
01:19:08,260 --> 01:19:10,600
所以看到这种情形，我们不能排除掉这种可能性
rule out the possibility that either

1689
01:19:10,600 --> 01:19:14,140
即 leader 回复了客户端之后（crash）
possibility that the leader responded to

1690
01:19:14,140 --> 01:19:15,790
在这种情况下，我们不能丢弃这条日志
the client in which case we cannot throw

1691
01:19:15,790 --> 01:19:17,230
因为客户端知道它请求成功了
away this entry because a client knows

1692
01:19:17,230 --> 01:19:18,969
又或是另一种可能，leader 可能什么也没做过
about it or the possibility the leader

1693
01:19:18,969 --> 01:19:23,080
是的，我们不得不假设它是被提交过的
never did and yeah we could you know if

1694
01:19:23,080 --> 01:19:26,670
是的，我们不得不假设它是被提交过的
we have to assume that it was committed

1695
01:19:33,390 --> 01:19:36,390
嗯呢
yeah

1696
01:19:46,489 --> 01:19:51,590
不是，没有。我意思是在这种情况下
no there's no. I mean in this situation maybe

1697
01:19:51,590 --> 01:19:53,630
服务器可能会在收到响应之前 crash 掉
the server crash before getting the response

1698
01:19:53,630 --> 01:19:59,000
好啦，咱们周四继续讨论，拜拜！
it's alright well let's continue this on Thursday

