1
00:00:00,540 --> 00:00:04,850
all right everybody let's get started

2
00:00:05,359 --> 00:00:10,620
today the paper four days I'm is aunt

3
00:00:10,620 --> 00:00:12,450
Aurora paper which is all about how to

4
00:00:12,450 --> 00:00:17,520
get a high-performance reliable database

5
00:00:17,520 --> 00:00:19,650
going as a piece of cloud infrastructure

6
00:00:19,650 --> 00:00:22,800
and itself built out of infrastructure

7
00:00:22,800 --> 00:00:29,100
that Amazon itself makes available so

8
00:00:29,100 --> 00:00:30,210
the reason why we're reading this paper

9
00:00:30,210 --> 00:00:32,098
is that first of all it's a very

10
00:00:32,098 --> 00:00:34,290
successful recent cloud service from

11
00:00:34,290 --> 00:00:38,480
Amazon a lot of their customers use it

12
00:00:38,480 --> 00:00:41,460
it shows sort of in its own way an

13
00:00:41,460 --> 00:00:44,820
example of a very big payoff from clever

14
00:00:44,820 --> 00:00:46,530
design table one which sort of

15
00:00:46,530 --> 00:00:48,380
summarizes the performance shows that

16
00:00:48,380 --> 00:00:51,210
relative to some other system which is

17
00:00:51,210 --> 00:00:53,430
not very well explained the paper claims

18
00:00:53,430 --> 00:00:55,770
to get a thirty five times speed up in

19
00:00:55,770 --> 00:00:57,480
transaction throughput which is

20
00:00:57,480 --> 00:01:00,329
extremely impressive this paper also

21
00:01:00,329 --> 00:01:03,149
kind of explores the limits of how well

22
00:01:03,149 --> 00:01:04,680
you can do for performance and fault

23
00:01:04,680 --> 00:01:06,750
tolerance using general-purpose storage

24
00:01:06,750 --> 00:01:08,310
because one of the themes of the papers

25
00:01:08,310 --> 00:01:10,470
they basically abandoned general-purpose

26
00:01:10,470 --> 00:01:12,510
storage they switch from a design in

27
00:01:12,510 --> 00:01:14,250
which they were using their Amazon's own

28
00:01:14,250 --> 00:01:16,040
general-purpose storage infrastructure

29
00:01:16,040 --> 00:01:17,970
decided it was not good enough and

30
00:01:17,970 --> 00:01:19,409
basically built totally

31
00:01:19,409 --> 00:01:22,320
application-specific storage

32
00:01:22,320 --> 00:01:23,940
furthermore the paper has a lot of

33
00:01:23,940 --> 00:01:25,590
little tidbits about what turned out to

34
00:01:25,590 --> 00:01:29,100
be important in this and the kind of

35
00:01:29,100 --> 00:01:32,490
cloud infrastructure world so before

36
00:01:32,490 --> 00:01:35,010
talking about aurora i want to spend a

37
00:01:35,010 --> 00:01:36,510
bit of time kind of going over the back

38
00:01:36,510 --> 00:01:38,729
history or what my impression is about

39
00:01:38,729 --> 00:01:41,270
the story that led up to the design of

40
00:01:41,270 --> 00:01:43,830
aurora because it's you know the sort of

41
00:01:43,830 --> 00:01:47,310
m f-- way that amazon has in mind that

42
00:01:47,310 --> 00:01:49,950
you ought to build that their cloud

43
00:01:49,950 --> 00:01:51,810
customers ought to build databases on

44
00:01:51,810 --> 00:01:55,140
amazon's infrastructure so in the

45
00:01:55,140 --> 00:02:02,850
beginning amazon had basically their

46
00:02:02,850 --> 00:02:05,369
very first offering cloud offering to

47
00:02:05,369 --> 00:02:06,659
support people who wanted to build

48
00:02:06,659 --> 00:02:09,419
websites but using Amazon's hardware and

49
00:02:09,419 --> 00:02:11,459
in Amazon's machine room their first

50
00:02:11,459 --> 00:02:14,900
offering was something called ec2

51
00:02:14,900 --> 00:02:20,099
for elastic cloud apparently too and the

52
00:02:20,099 --> 00:02:21,750
idea here is that Amazon had big machine

53
00:02:21,750 --> 00:02:23,520
rooms full of servers and they ran

54
00:02:23,520 --> 00:02:25,020
virtual machine monitors on their

55
00:02:25,020 --> 00:02:26,730
servers and they'd rent out virtual

56
00:02:26,730 --> 00:02:30,420
machines to their customers and their

57
00:02:30,420 --> 00:02:32,190
customers would then you know rent a

58
00:02:32,190 --> 00:02:34,020
bunch of virtual machines and run web

59
00:02:34,020 --> 00:02:36,030
servers and databases and whatever ever

60
00:02:36,030 --> 00:02:39,330
all else they needed to run inside these

61
00:02:39,330 --> 00:02:42,500
ec2 instances so the picture of one

62
00:02:42,500 --> 00:02:47,989
physical server looked like this Amazon

63
00:02:47,989 --> 00:02:50,519
we control the virtual machine monitor

64
00:02:50,519 --> 00:02:53,010
on this hardware server and then there'd

65
00:02:53,010 --> 00:02:54,810
be a bunch of guests a bunch of ec2

66
00:02:54,810 --> 00:02:57,720
instances each one rented out to a

67
00:02:57,720 --> 00:02:59,730
different cloud customer each of these

68
00:02:59,730 --> 00:03:01,049
would just run a standard operating

69
00:03:01,049 --> 00:03:06,989
system like Linux and then you know a

70
00:03:06,989 --> 00:03:11,060
web server or maybe a database server

71
00:03:11,060 --> 00:03:14,069
and these were relatively cheap

72
00:03:14,069 --> 00:03:17,100
relatively easy to set up and as a very

73
00:03:17,100 --> 00:03:22,290
successful service so one little detail

74
00:03:22,290 --> 00:03:23,940
that's extremely important for us is

75
00:03:23,940 --> 00:03:28,500
that initially the way you get storage

76
00:03:28,500 --> 00:03:30,180
the way you've got storage if you rented

77
00:03:30,180 --> 00:03:33,269
an ec2 instance was that every one of

78
00:03:33,269 --> 00:03:35,480
their servers had a disk attached a

79
00:03:35,480 --> 00:03:38,430
physical disk attached and each one of

80
00:03:38,430 --> 00:03:41,400
these instances that they rented to

81
00:03:41,400 --> 00:03:43,470
their customers will get us you know a

82
00:03:43,470 --> 00:03:46,890
slice of the disk so they said locally

83
00:03:46,890 --> 00:03:48,959
attached storage and you got a bit of

84
00:03:48,959 --> 00:03:50,430
locally attached storage which itself

85
00:03:50,430 --> 00:03:52,109
just look like a hard drive an emulated

86
00:03:52,109 --> 00:03:56,810
hard drive to the virtual machine guests

87
00:03:56,870 --> 00:04:00,480
ec2 is like perfect for web servers for

88
00:04:00,480 --> 00:04:02,220
stateless web servers you know your

89
00:04:02,220 --> 00:04:04,200
customers with their web browsers would

90
00:04:04,200 --> 00:04:07,230
connect to a bunch of rented ec2

91
00:04:07,230 --> 00:04:10,920
instances that ran a web server and if

92
00:04:10,920 --> 00:04:12,299
you added all of a sudden more customers

93
00:04:12,299 --> 00:04:14,190
you could just instantly rent more ec2

94
00:04:14,190 --> 00:04:15,540
instances from

95
00:04:15,540 --> 00:04:17,940
Amazon and fire up web servers on them

96
00:04:17,940 --> 00:04:20,039
and sort of an easy way to scale up your

97
00:04:20,039 --> 00:04:23,280
ability to handle web load so it was

98
00:04:23,280 --> 00:04:26,040
good for web servers

99
00:04:26,040 --> 00:04:27,660
but the other main thing that people ran

100
00:04:27,660 --> 00:04:30,510
in ec2 instance this was databases

101
00:04:30,510 --> 00:04:32,280
because usually a website is constructed

102
00:04:32,280 --> 00:04:34,800
of a set of stateless web servers that

103
00:04:34,800 --> 00:04:37,500
anytime they need to get out permanent

104
00:04:37,500 --> 00:04:40,590
data go talk to a back-end database so

105
00:04:40,590 --> 00:04:43,590
what you would get is is maybe a bunch

106
00:04:43,590 --> 00:04:48,060
of client browsers in the outside world

107
00:04:48,060 --> 00:04:50,910
outside of Amazon's web infrastructure

108
00:04:50,910 --> 00:04:56,670
and then a number of ec2 web server

109
00:04:56,670 --> 00:04:58,470
instances as many as you need it to run

110
00:04:58,470 --> 00:05:00,630
the sort of logic of the website this

111
00:05:00,630 --> 00:05:05,310
this is now inside Amazon and then also

112
00:05:05,310 --> 00:05:10,880
some also typically one ec2 instance

113
00:05:10,880 --> 00:05:13,830
running a database your web servers

114
00:05:13,830 --> 00:05:15,510
would talk to your database instance and

115
00:05:15,510 --> 00:05:16,920
ask it to read and write records in the

116
00:05:16,920 --> 00:05:19,890
database unfortunately ec2 wasn't

117
00:05:19,890 --> 00:05:22,560
perfect was it nearly as well-suited to

118
00:05:22,560 --> 00:05:24,270
running a database as it was to running

119
00:05:24,270 --> 00:05:25,890
web servers and the most immediate

120
00:05:25,890 --> 00:05:29,820
reason is that the storage or the sort

121
00:05:29,820 --> 00:05:32,550
of main easy way to get storage for your

122
00:05:32,550 --> 00:05:35,100
ec2 database instance was on the locally

123
00:05:35,100 --> 00:05:39,600
attached disk attached to whatever a

124
00:05:39,600 --> 00:05:41,670
piece of hardware your database instance

125
00:05:41,670 --> 00:05:44,070
was currently running on in fact

126
00:05:44,070 --> 00:05:46,740
hardware crashed then you also lost

127
00:05:46,740 --> 00:05:48,300
access to whatever what is on its hard

128
00:05:48,300 --> 00:05:51,750
drive so if it's a hardware that it was

129
00:05:51,750 --> 00:05:54,210
actually implementing a web server

130
00:05:54,210 --> 00:05:55,590
crashed no problem at all because

131
00:05:55,590 --> 00:05:57,660
there's really keeps no state itself you

132
00:05:57,660 --> 00:05:59,280
just fire up a new web server on a new

133
00:05:59,280 --> 00:06:02,010
ec2 instance if the ec2 instance it's a

134
00:06:02,010 --> 00:06:04,740
hardware running it crashes have become

135
00:06:04,740 --> 00:06:06,210
unavailable you have a serious problem

136
00:06:06,210 --> 00:06:08,940
if the data is stored on the locally

137
00:06:08,940 --> 00:06:13,050
attached disk so initially at least

138
00:06:13,050 --> 00:06:15,030
there wasn't sort of a lot of help for

139
00:06:15,030 --> 00:06:17,130
doing this one thing that did work out

140
00:06:17,130 --> 00:06:19,050
well is that Amazon did provide this

141
00:06:19,050 --> 00:06:22,620
sort of large scheme for storing large

142
00:06:22,620 --> 00:06:24,420
chunks of data called s3 and you could

143
00:06:24,420 --> 00:06:25,950
take snapshots you could take Prius

144
00:06:25,950 --> 00:06:27,720
periodic snapshots if you need a basis

145
00:06:27,720 --> 00:06:30,870
state and stored in s3 and use that for

146
00:06:30,870 --> 00:06:34,860
sort of backup disaster recovery but you

147
00:06:34,860 --> 00:06:36,870
know that style of periodic snapshots

148
00:06:36,870 --> 00:06:38,460
means you're gonna lose updates that

149
00:06:38,460 --> 00:06:39,270
happen

150
00:06:39,270 --> 00:06:43,080
between the periodic backups all right

151
00:06:43,080 --> 00:06:45,390
so the next thing that came along that's

152
00:06:45,390 --> 00:06:47,640
that's relevant to the sort of Aurora

153
00:06:47,640 --> 00:06:51,120
database story is that in order to

154
00:06:51,120 --> 00:06:55,170
provide their customers with disks for

155
00:06:55,170 --> 00:06:57,300
their ec2 instances that didn't go away

156
00:06:57,300 --> 00:06:59,370
if there was a failure that is more sort

157
00:06:59,370 --> 00:07:01,920
of fault tolerant long-term storage was

158
00:07:01,920 --> 00:07:04,470
guaranteed to be there Amazon introduced

159
00:07:04,470 --> 00:07:08,280
the service called EBS and this stands

160
00:07:08,280 --> 00:07:09,840
for elastic block store

161
00:07:09,840 --> 00:07:12,540
so with EBS is is a service that looks

162
00:07:12,540 --> 00:07:16,530
to an ec2 instances it looks to one of

163
00:07:16,530 --> 00:07:17,940
these instances one of these guest

164
00:07:17,940 --> 00:07:19,710
virtual machines just as if it were a

165
00:07:19,710 --> 00:07:21,990
hard drive an ordinary way you could

166
00:07:21,990 --> 00:07:24,150
format it as a hard drive but a file

167
00:07:24,150 --> 00:07:27,120
system like ext3 or whatever Linux file

168
00:07:27,120 --> 00:07:28,890
system you like on this on this thing

169
00:07:28,890 --> 00:07:30,630
that looks to be guest just like a hard

170
00:07:30,630 --> 00:07:31,920
drive but the way it's actually

171
00:07:31,920 --> 00:07:35,280
implemented is as a replicated pair of

172
00:07:35,280 --> 00:07:40,890
storage servers so this is the local

173
00:07:40,890 --> 00:07:43,520
this is one of local storage with Mike

174
00:07:43,520 --> 00:07:47,550
if when EBS came out then you could you

175
00:07:47,550 --> 00:07:49,590
could rent an e BS volume which this

176
00:07:49,590 --> 00:07:50,670
thing that looks just like an ordinary

177
00:07:50,670 --> 00:07:53,130
hard drive but it's actually implemented

178
00:07:53,130 --> 00:07:59,090
as a pair so these are EBS servers a

179
00:07:59,090 --> 00:08:03,840
pair of EBS servers each with an

180
00:08:03,840 --> 00:08:09,360
attached hard drive so if your software

181
00:08:09,360 --> 00:08:10,920
here maybe you're running a database now

182
00:08:10,920 --> 00:08:13,080
and your databases mount's one of these

183
00:08:13,080 --> 00:08:15,120
EBS volumes as its storage when the

184
00:08:15,120 --> 00:08:16,350
database server doesn't write what that

185
00:08:16,350 --> 00:08:18,120
actually means is that the right to send

186
00:08:18,120 --> 00:08:19,830
out over the network and using chain

187
00:08:19,830 --> 00:08:21,300
replication which we talked about last

188
00:08:21,300 --> 00:08:24,030
week you're right is you know first

189
00:08:24,030 --> 00:08:27,450
written to the EBS server one on the

190
00:08:27,450 --> 00:08:28,970
first CBS server that's backing your

191
00:08:28,970 --> 00:08:30,960
volume and then the second one and

192
00:08:30,960 --> 00:08:33,330
finally you get the reply and similarly

193
00:08:33,330 --> 00:08:35,760
when you do a read I guess some chain

194
00:08:35,760 --> 00:08:37,380
replication you'll be the last of the

195
00:08:37,380 --> 00:08:41,789
chain so now database is running on ec2

196
00:08:41,789 --> 00:08:44,250
instances had available a storage system

197
00:08:44,250 --> 00:08:46,040
that actually would survive the crash of

198
00:08:46,040 --> 00:08:48,660
or the you know death of the hardware

199
00:08:48,660 --> 00:08:50,040
that they were running on if this

200
00:08:50,040 --> 00:08:53,430
physical server died you could just get

201
00:08:53,430 --> 00:08:55,170
another ec2 instance fire up your

202
00:08:55,170 --> 00:08:58,110
database and have it attached to the

203
00:08:58,110 --> 00:09:01,110
same old EBS volume that the sort of

204
00:09:01,110 --> 00:09:03,540
previous version of your database was

205
00:09:03,540 --> 00:09:04,800
attached to and it would see all the old

206
00:09:04,800 --> 00:09:07,110
data just as it had been left off by the

207
00:09:07,110 --> 00:09:10,500
previous database just like you moved a

208
00:09:10,500 --> 00:09:11,760
hard drive from one machine to another

209
00:09:11,760 --> 00:09:14,910
so EBS was like really a good deal for

210
00:09:14,910 --> 00:09:16,230
people who need it to keep permanent

211
00:09:16,230 --> 00:09:26,850
state like people running databases one

212
00:09:26,850 --> 00:09:29,520
thing to that is sort of important for

213
00:09:29,520 --> 00:09:33,180
us about EBS is that it's really it's

214
00:09:33,180 --> 00:09:36,260
not a system for sharing at any one time

215
00:09:36,260 --> 00:09:41,339
only one ec2 instance only one virtual

216
00:09:41,339 --> 00:09:43,770
machine can mount a given EBS volume so

217
00:09:43,770 --> 00:09:45,300
the EBS volumes are implemented on a

218
00:09:45,300 --> 00:09:47,730
huge fleet of you know hundreds or

219
00:09:47,730 --> 00:09:49,620
whatever storage servers with disks at

220
00:09:49,620 --> 00:09:52,410
Amazon and they're all you know

221
00:09:52,410 --> 00:09:55,170
everybody's EBS volumes are stored on

222
00:09:55,170 --> 00:09:58,740
this big pool of servers but each one of

223
00:09:58,740 --> 00:10:01,080
each PPS volume can only be used by only

224
00:10:01,080 --> 00:10:08,270
one ec2 instance only one customer all

225
00:10:08,510 --> 00:10:13,290
right still EBS was a big step up but it

226
00:10:13,290 --> 00:10:18,180
had still has some problems so there's

227
00:10:18,180 --> 00:10:19,230
still some things that are not quite as

228
00:10:19,230 --> 00:10:22,830
perfect as it could be one is that if

229
00:10:22,830 --> 00:10:24,750
you run a database on EBS it ends up

230
00:10:24,750 --> 00:10:27,750
sending large volumes of data across the

231
00:10:27,750 --> 00:10:31,740
network and this is uh we're now

232
00:10:31,740 --> 00:10:33,450
starting to sort of sneak up on figure

233
00:10:33,450 --> 00:10:36,750
two in the the paper where they start

234
00:10:36,750 --> 00:10:38,670
complaining about how many just how many

235
00:10:38,670 --> 00:10:40,950
writes it takes if you run a database on

236
00:10:40,950 --> 00:10:45,660
top of a network storage system so

237
00:10:45,660 --> 00:10:48,000
there's the database on EBS ended up

238
00:10:48,000 --> 00:10:50,459
generating a lot of network traffic and

239
00:10:50,459 --> 00:10:53,220
one of the kind of things in the paper

240
00:10:53,220 --> 00:10:55,890
that the paper implies is that they're

241
00:10:55,890 --> 00:10:59,910
as much network limited as they are CPU

242
00:10:59,910 --> 00:11:01,770
or storage limited that is they pay a

243
00:11:01,770 --> 00:11:03,810
huge amount of attention to reducing the

244
00:11:03,810 --> 00:11:05,430
Aurora paper sends a huge amount of

245
00:11:05,430 --> 00:11:07,260
attention for reducing the network

246
00:11:07,260 --> 00:11:09,720
that the database generates and seems to

247
00:11:09,720 --> 00:11:12,060
be worrying less about how much CPU time

248
00:11:12,060 --> 00:11:15,860
or disk space is being consumed that's a

249
00:11:15,860 --> 00:11:18,150
sort of a hint at what they think is

250
00:11:18,150 --> 00:11:20,640
important the other problem with EBS is

251
00:11:20,640 --> 00:11:22,710
not very fault tolerant it turns out

252
00:11:22,710 --> 00:11:25,320
that for performance reasons they I'm

253
00:11:25,320 --> 00:11:26,970
done would always put both of the EBS

254
00:11:26,970 --> 00:11:29,490
both of the replicas of your EBS volume

255
00:11:29,490 --> 00:11:32,730
in the same data center and so we have a

256
00:11:32,730 --> 00:11:34,650
single server crashed if you know one of

257
00:11:34,650 --> 00:11:36,030
the two EBS servers that you're using

258
00:11:36,030 --> 00:11:37,440
crashed it's okay because you switch to

259
00:11:37,440 --> 00:11:39,180
the other one but there was just no

260
00:11:39,180 --> 00:11:40,650
story at all for what happens if an

261
00:11:40,650 --> 00:11:50,240
entire data center went down and and

262
00:11:50,240 --> 00:11:53,580
apparently a lot of customers really

263
00:11:53,580 --> 00:11:55,260
wanted a story that would allow their

264
00:11:55,260 --> 00:11:57,840
data to survive an outage of an entire

265
00:11:57,840 --> 00:12:00,210
data center maybe it lost his network

266
00:12:00,210 --> 00:12:01,920
connection it was a fire in the building

267
00:12:01,920 --> 00:12:04,530
or a power failure to the whole building

268
00:12:04,530 --> 00:12:05,730
or something people really wanted to

269
00:12:05,730 --> 00:12:07,110
have at least the option if they're

270
00:12:07,110 --> 00:12:09,330
willing to pay more of having their data

271
00:12:09,330 --> 00:12:10,590
stored in a way they hid they could

272
00:12:10,590 --> 00:12:13,860
still get at it I'm even if one data

273
00:12:13,860 --> 00:12:20,390
center goes down and the way that Amazon

274
00:12:20,390 --> 00:12:25,470
described this there is that both an

275
00:12:25,470 --> 00:12:29,940
instance and its EBS to EBS replicas are

276
00:12:29,940 --> 00:12:32,360
in the same ability veil ability zone

277
00:12:32,360 --> 00:12:34,740
and an Amazon jargon an availability

278
00:12:34,740 --> 00:12:36,900
zone is a particular data center and the

279
00:12:36,900 --> 00:12:38,790
way they structure their data centers is

280
00:12:38,790 --> 00:12:42,170
that there's usually multiple

281
00:12:42,170 --> 00:12:44,760
independent data centers in more or less

282
00:12:44,760 --> 00:12:46,680
the same city or relatively close to

283
00:12:46,680 --> 00:12:50,010
each other and all the multiple

284
00:12:50,010 --> 00:12:52,560
availability zones maybe two or three

285
00:12:52,560 --> 00:12:54,180
that are near by each other are all

286
00:12:54,180 --> 00:12:56,340
connected by redundant high speed

287
00:12:56,340 --> 00:12:58,290
networks so there's always payers or

288
00:12:58,290 --> 00:13:00,360
triples of nearby availability

289
00:13:00,360 --> 00:13:01,740
availability centers and we'll see the

290
00:13:01,740 --> 00:13:03,360
buy that's important in a little bit but

291
00:13:03,360 --> 00:13:05,760
at least for EBS in order to keep the

292
00:13:05,760 --> 00:13:08,040
sort of costs of using chain replication

293
00:13:08,040 --> 00:13:12,210
down they required the two replicas to

294
00:13:12,210 --> 00:13:15,740
be in the same availability zone

295
00:13:16,730 --> 00:13:21,900
all right um before I dive into more

296
00:13:21,900 --> 00:13:27,630
into how Aurora actually works it turns

297
00:13:27,630 --> 00:13:31,170
out that the details of the design in

298
00:13:31,170 --> 00:13:32,580
order to understand them we first have

299
00:13:32,580 --> 00:13:34,650
to know a fair amount about the sort of

300
00:13:34,650 --> 00:13:36,450
design of typical databases because what

301
00:13:36,450 --> 00:13:40,230
they taken is sort of the main machinery

302
00:13:40,230 --> 00:13:42,360
of a database my sequel as it happens

303
00:13:42,360 --> 00:13:44,940
and split it up in an interesting way so

304
00:13:44,940 --> 00:13:46,650
we need to know sort of what it but it

305
00:13:46,650 --> 00:13:48,390
is a database does so we can understand

306
00:13:48,390 --> 00:13:50,880
how they split it up so this is really a

307
00:13:50,880 --> 00:13:58,140
kind of database tutorial really

308
00:13:58,140 --> 00:14:01,760
focusing on what it takes to implement

309
00:14:01,760 --> 00:14:04,110
transactions crashed recoverable

310
00:14:04,110 --> 00:14:06,210
transactions so what I really care about

311
00:14:06,210 --> 00:14:14,430
is transactions and crash recovery and

312
00:14:14,430 --> 00:14:17,070
there's a lot else going on in databases

313
00:14:17,070 --> 00:14:18,960
but this is really the part that matters

314
00:14:18,960 --> 00:14:22,320
for this paper so first what's a

315
00:14:22,320 --> 00:14:24,270
transaction you know transaction is just

316
00:14:24,270 --> 00:14:27,000
a way of wrapping multiple operations on

317
00:14:27,000 --> 00:14:28,710
maybe different pieces of data and

318
00:14:28,710 --> 00:14:31,380
declare in that that that's entire

319
00:14:31,380 --> 00:14:33,420
sequence of operations should appear a

320
00:14:33,420 --> 00:14:35,970
Tomic to anyone else who's reading or

321
00:14:35,970 --> 00:14:38,750
writing the data so you might see

322
00:14:38,750 --> 00:14:40,800
transposing we're running a bank and we

323
00:14:40,800 --> 00:14:43,110
want to do transfers between different

324
00:14:43,110 --> 00:14:46,410
accounts maybe you would say well we

325
00:14:46,410 --> 00:14:48,600
would see code or you know see a

326
00:14:48,600 --> 00:14:50,220
transaction looks like this is you have

327
00:14:50,220 --> 00:14:51,960
to clear the beginning of the sequence

328
00:14:51,960 --> 00:14:53,880
of instructions that you want to be

329
00:14:53,880 --> 00:14:55,890
atomic in the in transaction maybe we're

330
00:14:55,890 --> 00:14:59,250
going to transfer money from account Y

331
00:14:59,250 --> 00:15:02,580
to account X so we might see where I'll

332
00:15:02,580 --> 00:15:05,190
just pretend X is a bank balance Jordan

333
00:15:05,190 --> 00:15:06,420
the database you might see the

334
00:15:06,420 --> 00:15:08,610
transaction looks like oh can I add $10

335
00:15:08,610 --> 00:15:11,589
to X's account and

336
00:15:11,589 --> 00:15:14,029
deduct the same ten dollars from my

337
00:15:14,029 --> 00:15:16,430
account and that's the end of the

338
00:15:16,430 --> 00:15:17,209
transaction

339
00:15:17,209 --> 00:15:19,940
I want the database to just do them both

340
00:15:19,940 --> 00:15:21,949
without allowing anybody else to sneak

341
00:15:21,949 --> 00:15:24,019
in and see the state between these two

342
00:15:24,019 --> 00:15:27,230
statements and also with respect to

343
00:15:27,230 --> 00:15:29,570
crashes if there's a crash at this point

344
00:15:29,570 --> 00:15:31,070
somewhere in here we're going to make

345
00:15:31,070 --> 00:15:32,720
sure that after the crash and recovery

346
00:15:32,720 --> 00:15:34,850
that either the entire transactions

347
00:15:34,850 --> 00:15:36,470
worth the modifications are visible or

348
00:15:36,470 --> 00:15:40,100
none of them are so that's the effect we

349
00:15:40,100 --> 00:15:41,389
want from transactions there's

350
00:15:41,389 --> 00:15:44,360
additionally people expect database

351
00:15:44,360 --> 00:15:46,639
users expect that the database will tell

352
00:15:46,639 --> 00:15:48,829
them tell the client that submitted the

353
00:15:48,829 --> 00:15:51,199
transaction whether the transaction

354
00:15:51,199 --> 00:15:52,880
really finished and committed or not and

355
00:15:52,880 --> 00:15:55,329
if a transaction is committed we expect

356
00:15:55,329 --> 00:15:58,040
clients expect that the transaction will

357
00:15:58,040 --> 00:15:59,990
be permanent will be durable still there

358
00:15:59,990 --> 00:16:02,000
even if the database should crash and

359
00:16:02,000 --> 00:16:05,720
reboot um one thing it's a bit important

360
00:16:05,720 --> 00:16:08,120
is that the usual way these are

361
00:16:08,120 --> 00:16:10,010
implemented is that the transaction

362
00:16:10,010 --> 00:16:12,800
locks each piece of data before it uses

363
00:16:12,800 --> 00:16:15,980
it so you can view the they're being

364
00:16:15,980 --> 00:16:20,839
locks x and y for the duration of the

365
00:16:20,839 --> 00:16:22,490
transaction and these are only released

366
00:16:22,490 --> 00:16:24,560
after the transaction finally commits

367
00:16:24,560 --> 00:16:29,209
that is known to be permanent this is

368
00:16:29,209 --> 00:16:31,850
important if you for some of the things

369
00:16:31,850 --> 00:16:33,260
that you have to if you some of the

370
00:16:33,260 --> 00:16:35,060
details in the paper really only makes

371
00:16:35,060 --> 00:16:36,440
sense if you realize that the database

372
00:16:36,440 --> 00:16:38,720
is actually locking out other access to

373
00:16:38,720 --> 00:16:40,220
the data during the life of a

374
00:16:40,220 --> 00:16:43,339
transaction so how this actually

375
00:16:43,339 --> 00:16:47,620
implemented it turns out the database

376
00:16:48,699 --> 00:16:53,060
consists of at least for the simple

377
00:16:53,060 --> 00:16:55,250
database model where the databases are

378
00:16:55,250 --> 00:16:56,750
typically written to run on a single

379
00:16:56,750 --> 00:16:58,190
server with you know some storage

380
00:16:58,190 --> 00:17:00,260
directly attached and a game that the

381
00:17:00,260 --> 00:17:01,550
Aurora paper is playing is sort of

382
00:17:01,550 --> 00:17:05,329
moving that software only modestly

383
00:17:05,329 --> 00:17:07,339
revised in order to run on a much more

384
00:17:07,339 --> 00:17:09,559
complex network system but the starting

385
00:17:09,559 --> 00:17:11,390
point is we just assume we have a

386
00:17:11,390 --> 00:17:16,520
database with a attached to a disk the

387
00:17:16,520 --> 00:17:18,819
on disk structure that stores these

388
00:17:18,819 --> 00:17:21,559
records is some kind of indexing

389
00:17:21,559 --> 00:17:24,190
structure like a b-tree maybe so

390
00:17:24,190 --> 00:17:25,960
there's a sort of pages with the paper

391
00:17:25,960 --> 00:17:27,819
calls data pages that holds us you know

392
00:17:27,819 --> 00:17:32,260
real data of the of the database you

393
00:17:32,260 --> 00:17:34,630
know maybe this is excess balances and

394
00:17:34,630 --> 00:17:36,580
this is wise balance these data pages

395
00:17:36,580 --> 00:17:40,260
typically hold lots and lots of records

396
00:17:40,260 --> 00:17:42,340
whereas X and y are typically just a

397
00:17:42,340 --> 00:17:44,320
couple bites on some page in the

398
00:17:44,320 --> 00:17:46,740
database so on the disk there's the

399
00:17:46,740 --> 00:17:49,990
actual data plus on the disk there's

400
00:17:49,990 --> 00:17:55,660
also a right ahead log or wal and the

401
00:17:55,660 --> 00:17:57,400
right ahead logs are a critical part of

402
00:17:57,400 --> 00:18:00,010
why the system is gonna be fault

403
00:18:00,010 --> 00:18:03,010
tolerant inside the database server

404
00:18:03,010 --> 00:18:05,530
there's the database software the

405
00:18:05,530 --> 00:18:08,230
database typically has a cache of pages

406
00:18:08,230 --> 00:18:11,050
that it's read from the disk that it's

407
00:18:11,050 --> 00:18:13,210
recently used when you execute a

408
00:18:13,210 --> 00:18:15,250
transaction what that actually executes

409
00:18:15,250 --> 00:18:16,990
these statements what that really means

410
00:18:16,990 --> 00:18:19,330
is you know what x equals x plus 10

411
00:18:19,330 --> 00:18:21,880
turns into the runtime is that the

412
00:18:21,880 --> 00:18:23,800
database reads the current page holding

413
00:18:23,800 --> 00:18:27,520
X from the disk and adds 10 to it but so

414
00:18:27,520 --> 00:18:29,920
far until the transaction commits it

415
00:18:29,920 --> 00:18:31,480
only makes the modifications in the

416
00:18:31,480 --> 00:18:34,030
local cache not on the disk because we

417
00:18:34,030 --> 00:18:35,080
don't want to expose we don't want to

418
00:18:35,080 --> 00:18:37,030
write on the disk yet and the part

419
00:18:37,030 --> 00:18:42,720
possibly expose a partial transaction so

420
00:18:42,990 --> 00:18:46,180
while then when the database but before

421
00:18:46,180 --> 00:18:47,980
because the database wants to sort of

422
00:18:47,980 --> 00:18:50,590
pre to clear the complete transaction so

423
00:18:50,590 --> 00:18:53,140
it's available to the software after a

424
00:18:53,140 --> 00:18:56,290
crash and during recovery before the

425
00:18:56,290 --> 00:18:57,910
database is allowed to modify the real

426
00:18:57,910 --> 00:18:59,950
data pages on disk its first required to

427
00:18:59,950 --> 00:19:03,960
add log entries that describe the

428
00:19:03,960 --> 00:19:06,400
transaction so it has to in order before

429
00:19:06,400 --> 00:19:07,870
it can commit the transaction it needs

430
00:19:07,870 --> 00:19:09,310
to put a complete set of log ahead

431
00:19:09,310 --> 00:19:11,710
entries in the right ahead log on disk

432
00:19:11,710 --> 00:19:13,720
I'm describing all the data bases

433
00:19:13,720 --> 00:19:15,940
modification so let's suppose here that

434
00:19:15,940 --> 00:19:20,740
x and y start out as say 500 and y

435
00:19:20,740 --> 00:19:24,040
starts out as 750 and we want to execute

436
00:19:24,040 --> 00:19:26,830
this transaction before committing and

437
00:19:26,830 --> 00:19:29,170
before writing the pages the database is

438
00:19:29,170 --> 00:19:31,750
going to add at least typically 3 log

439
00:19:31,750 --> 00:19:34,480
records 1 this that says well as part of

440
00:19:34,480 --> 00:19:37,380
this transaction I'm modifying X

441
00:19:37,380 --> 00:19:43,530
and it's old value is 500 make more room

442
00:19:43,530 --> 00:19:50,250
here this is the on dis log so each log

443
00:19:50,250 --> 00:19:52,350
entry might say here's the value I'm

444
00:19:52,350 --> 00:19:56,730
modifying here's the old value and we're

445
00:19:56,730 --> 00:19:58,680
adding and here's the new value say five

446
00:19:58,680 --> 00:20:02,070
ten so that's one log record another 4y

447
00:20:02,070 --> 00:20:04,800
may be old value is 750 we're

448
00:20:04,800 --> 00:20:07,410
subtracting 10 so the new value is 740

449
00:20:07,410 --> 00:20:11,310
and then when the database if it

450
00:20:11,310 --> 00:20:12,810
actually manages to get to the end of

451
00:20:12,810 --> 00:20:14,400
the transaction before crashing its

452
00:20:14,400 --> 00:20:18,450
gonna write a commit record saying and

453
00:20:18,450 --> 00:20:20,310
typically these are all tagged with some

454
00:20:20,310 --> 00:20:23,220
sort with a transaction ID so that the

455
00:20:23,220 --> 00:20:24,930
recovery software eventually will know

456
00:20:24,930 --> 00:20:27,660
how this commit record refers to these

457
00:20:27,660 --> 00:20:32,420
log records yes

458
00:20:36,590 --> 00:20:38,970
in a simple database will be enough to

459
00:20:38,970 --> 00:20:41,610
just store the new values and say well

460
00:20:41,610 --> 00:20:43,980
it is a crash we're gonna just reapply

461
00:20:43,980 --> 00:20:47,240
all the new values the reason most

462
00:20:47,240 --> 00:20:50,850
serious databases store the old as well

463
00:20:50,850 --> 00:20:52,380
as a new value is to give them freedom

464
00:20:52,380 --> 00:20:56,430
to even for a long-running traction for

465
00:20:56,430 --> 00:20:57,840
a long-running transaction even before

466
00:20:57,840 --> 00:20:59,610
the transaction is finished it gives the

467
00:20:59,610 --> 00:21:00,900
database the freedom to write the

468
00:21:00,900 --> 00:21:04,490
updated page to disk with the new value

469
00:21:04,490 --> 00:21:07,350
740 let's say from the from an

470
00:21:07,350 --> 00:21:10,590
uncompleted transaction as long as it's

471
00:21:10,590 --> 00:21:11,970
written the log record to disk and then

472
00:21:11,970 --> 00:21:13,920
if there's a crash before the commit the

473
00:21:13,920 --> 00:21:15,420
recovery software always say aha well

474
00:21:15,420 --> 00:21:17,190
this transaction never finished

475
00:21:17,190 --> 00:21:19,050
therefore we have to undo all of its

476
00:21:19,050 --> 00:21:21,300
changes and these values these old

477
00:21:21,300 --> 00:21:22,680
values are the values you need in order

478
00:21:22,680 --> 00:21:24,330
to undo a transaction that's been

479
00:21:24,330 --> 00:21:26,610
partially written to the data pages so

480
00:21:26,610 --> 00:21:32,730
the aurora indeed uses undo redo logging

481
00:21:32,730 --> 00:21:35,870
to be able to undo partially applied

482
00:21:35,870 --> 00:21:40,200
transactions okay so if the database

483
00:21:40,200 --> 00:21:42,240
manages to get as far as getting the

484
00:21:42,240 --> 00:21:44,190
transactions log records on the disk and

485
00:21:44,190 --> 00:21:46,430
the commit record marking is finished

486
00:21:46,430 --> 00:21:48,990
then it is entitled to apply to the

487
00:21:48,990 --> 00:21:50,160
client we said the transactions

488
00:21:50,160 --> 00:21:51,900
committed the database can reply to the

489
00:21:51,900 --> 00:21:53,850
client and the client can be assured

490
00:21:53,850 --> 00:21:56,400
that its transaction will be sort of

491
00:21:56,400 --> 00:21:59,970
visible forever and now one of two

492
00:21:59,970 --> 00:22:01,320
things happens the database server

493
00:22:01,320 --> 00:22:04,500
doesn't crash then eventually so it's

494
00:22:04,500 --> 00:22:08,880
modified in its cache these these X&Y

495
00:22:08,880 --> 00:22:13,020
records to be 510 and 740 eventually the

496
00:22:13,020 --> 00:22:15,930
database will write it's cached updated

497
00:22:15,930 --> 00:22:18,180
blocks to their real places on the disk

498
00:22:18,180 --> 00:22:20,640
over writing you know these be tree

499
00:22:20,640 --> 00:22:22,380
nodes or something and then the database

500
00:22:22,380 --> 00:22:26,550
can reuse this part of the log so

501
00:22:26,550 --> 00:22:27,990
databases tend to be lazy about that

502
00:22:27,990 --> 00:22:30,240
because they like to accumulate you know

503
00:22:30,240 --> 00:22:32,430
maybe there'll be many updates to these

504
00:22:32,430 --> 00:22:34,820
pages in the cache it's nice to

505
00:22:34,820 --> 00:22:37,050
accumulate a lot of updates before being

506
00:22:37,050 --> 00:22:39,900
forced to write the disk if the database

507
00:22:39,900 --> 00:22:41,520
server crashes before writing the day

508
00:22:41,520 --> 00:22:43,770
writing these pages to the disk so they

509
00:22:43,770 --> 00:22:47,160
still have their old values then it's

510
00:22:47,160 --> 00:22:49,050
guaranteed that the recovery software

511
00:22:49,050 --> 00:22:49,880
when you restart that

512
00:22:49,880 --> 00:22:53,600
debase scan the log see these records

513
00:22:53,600 --> 00:22:54,950
for the transaction see that that

514
00:22:54,950 --> 00:22:58,550
transaction was committed and apply the

515
00:22:58,550 --> 00:23:03,970
new values to the to the stored data and

516
00:23:03,970 --> 00:23:07,070
that's called a redo it basically does

517
00:23:07,070 --> 00:23:11,870
all the rights in the transaction so

518
00:23:11,870 --> 00:23:15,260
that's how transactional databases work

519
00:23:15,260 --> 00:23:18,440
in a nutshell and so this is a sort of

520
00:23:18,440 --> 00:23:22,150
very extremely abbreviated version of

521
00:23:22,150 --> 00:23:25,340
how for example the my sequel database

522
00:23:25,340 --> 00:23:28,820
works that an Aurora is based on this

523
00:23:28,820 --> 00:23:30,170
open source software thing called

524
00:23:30,170 --> 00:23:32,540
database called my sequel which does

525
00:23:32,540 --> 00:23:34,610
crash recovery transaction and crash

526
00:23:34,610 --> 00:23:40,370
recovery in much this way ok so the next

527
00:23:40,370 --> 00:23:44,690
step in Amazon's development a better

528
00:23:44,690 --> 00:23:46,730
and better database infrastructure for

529
00:23:46,730 --> 00:23:50,260
its cloud customers is something called

530
00:23:50,260 --> 00:23:53,870
RDS and I'm only talking about RDS

531
00:23:53,870 --> 00:23:55,640
because it turns out that even though

532
00:23:55,640 --> 00:23:56,720
the paper doesn't quite mention it

533
00:23:56,720 --> 00:23:58,880
figure 2 in the paper is basically a

534
00:23:58,880 --> 00:24:01,550
description of RDS so what's going on

535
00:24:01,550 --> 00:24:04,280
and RDS is that it was a first attempt

536
00:24:04,280 --> 00:24:07,160
to get a database that was replicated in

537
00:24:07,160 --> 00:24:09,440
multiple availability zones so that if

538
00:24:09,440 --> 00:24:12,740
an entire data center went down you

539
00:24:12,740 --> 00:24:14,360
could get back your database contents

540
00:24:14,360 --> 00:24:16,850
without missing any rights so that deal

541
00:24:16,850 --> 00:24:20,330
with RDS is that there's one you have

542
00:24:20,330 --> 00:24:22,910
one ec2 instance that's the database

543
00:24:22,910 --> 00:24:23,570
server

544
00:24:23,570 --> 00:24:24,920
you just have one you just want to

545
00:24:24,920 --> 00:24:28,490
running one database it stores its data

546
00:24:28,490 --> 00:24:31,690
pages and log just basically with this

547
00:24:31,690 --> 00:24:34,460
instead of on the local disk its stores

548
00:24:34,460 --> 00:24:36,350
them in EBS so whenever the database

549
00:24:36,350 --> 00:24:38,090
does a log write or page write or

550
00:24:38,090 --> 00:24:40,970
whatever those rights actually go to

551
00:24:40,970 --> 00:24:47,960
these two EBS volumes EBS replicas in

552
00:24:47,960 --> 00:24:50,180
addition so and so this is in one

553
00:24:50,180 --> 00:24:54,230
availability zone in addition for every

554
00:24:54,230 --> 00:24:55,910
write that the database software does

555
00:24:55,910 --> 00:24:58,100
Amazon would transparently without the

556
00:24:58,100 --> 00:24:59,900
database even realizing necessarily this

557
00:24:59,900 --> 00:25:03,890
was happened also send those rights to

558
00:25:03,890 --> 00:25:06,020
a special set up in a second

559
00:25:06,020 --> 00:25:07,760
availability zone in a second machine

560
00:25:07,760 --> 00:25:13,190
room - just going from figure 2 to

561
00:25:13,190 --> 00:25:14,960
apparently a separate computer or ec2

562
00:25:14,960 --> 00:25:16,730
instance or something whose job was just

563
00:25:16,730 --> 00:25:20,240
a mirror writes that the main database

564
00:25:20,240 --> 00:25:22,610
did so this other sort of mirroring

565
00:25:22,610 --> 00:25:25,100
server would then just copy these rights

566
00:25:25,100 --> 00:25:30,980
to a second pair of EBS servers and so

567
00:25:30,980 --> 00:25:33,170
with this set up with this RDS set up

568
00:25:33,170 --> 00:25:36,050
and that's what figure - every time the

569
00:25:36,050 --> 00:25:38,690
database appends to the log or writes to

570
00:25:38,690 --> 00:25:43,040
one of its pages it has to the data has

571
00:25:43,040 --> 00:25:44,750
to be sent to these two replicas has to

572
00:25:44,750 --> 00:25:47,210
be sent on the network connection across

573
00:25:47,210 --> 00:25:49,490
the other availability zone on the other

574
00:25:49,490 --> 00:25:51,380
side of town sent to this mirroring

575
00:25:51,380 --> 00:25:53,000
server which would then send it to it's

576
00:25:53,000 --> 00:25:56,960
two separate EBS replicas and then

577
00:25:56,960 --> 00:25:59,210
finally this reply would come back and

578
00:25:59,210 --> 00:26:00,590
then only then with the right be

579
00:26:00,590 --> 00:26:03,590
finished with a DAT bc AHA my writes

580
00:26:03,590 --> 00:26:07,010
finished I can you know count this log

581
00:26:07,010 --> 00:26:08,270
record it was really being appendage of

582
00:26:08,270 --> 00:26:09,260
the log or whatever

583
00:26:09,260 --> 00:26:13,550
so this RDS arrangement gets you betcha

584
00:26:13,550 --> 00:26:14,960
better fault tolerance because now you

585
00:26:14,960 --> 00:26:17,060
have a complete up-to-date copy of the

586
00:26:17,060 --> 00:26:18,770
database like seeing them all the very

587
00:26:18,770 --> 00:26:21,140
latest writes in a separate availability

588
00:26:21,140 --> 00:26:23,660
zone even if you know fire burns down

589
00:26:23,660 --> 00:26:26,150
this entire data center boom you can

590
00:26:26,150 --> 00:26:28,670
weaken you can run the database in a new

591
00:26:28,670 --> 00:26:30,860
instance and the second availability

592
00:26:30,860 --> 00:26:36,640
zone and lose no data at all yes

593
00:26:45,350 --> 00:26:48,869
um I don't know how to answer that I

594
00:26:48,869 --> 00:26:51,059
mean that is just not what they do and

595
00:26:51,059 --> 00:26:54,600
my guess is that it would be that for

596
00:26:54,600 --> 00:26:56,279
most EVs customers it would be too

597
00:26:56,279 --> 00:26:58,499
painfully slow to forward every right

598
00:26:58,499 --> 00:27:02,399
across two separate data center I'm not

599
00:27:02,399 --> 00:27:04,289
really sure what's going on but I think

600
00:27:04,289 --> 00:27:06,539
the main answers they don't do that and

601
00:27:06,539 --> 00:27:09,869
this is sort of a a little bit of a

602
00:27:09,869 --> 00:27:11,879
workaround for the way EBS works too

603
00:27:11,879 --> 00:27:14,639
kind of tricky BS and actually producing

604
00:27:14,639 --> 00:27:17,009
and sort of using the existing EBS

605
00:27:17,009 --> 00:27:20,909
infrastructure unchanged I stableman

606
00:27:20,909 --> 00:27:24,269
chose this turns out to be extremely

607
00:27:24,269 --> 00:27:28,859
expensive or anyway it's expensive as

608
00:27:28,859 --> 00:27:29,429
you might think

609
00:27:29,429 --> 00:27:30,929
you know we're writing fairly large

610
00:27:30,929 --> 00:27:33,559
volumes of data because you know even

611
00:27:33,559 --> 00:27:36,600
this transaction which seems like it

612
00:27:36,600 --> 00:27:38,789
just modifies two integers like maybe

613
00:27:38,789 --> 00:27:41,100
eight bytes or I don't know what sixteen

614
00:27:41,100 --> 00:27:43,019
who knows only a few bytes of data are

615
00:27:43,019 --> 00:27:45,059
being modified here what that translates

616
00:27:45,059 --> 00:27:46,889
to as far as the database reading and

617
00:27:46,889 --> 00:27:49,710
writing the disk is I actually these log

618
00:27:49,710 --> 00:27:51,720
records are that also quite small so

619
00:27:51,720 --> 00:27:53,159
this these two log records might

620
00:27:53,159 --> 00:27:55,049
themself only be dozens of bytes long so

621
00:27:55,049 --> 00:27:57,359
that's nice but the reads and writes of

622
00:27:57,359 --> 00:27:58,950
the actual data pages are likely to be

623
00:27:58,950 --> 00:28:02,009
much much larger than just a couple of

624
00:28:02,009 --> 00:28:03,359
dozen bytes because each of these pages

625
00:28:03,359 --> 00:28:05,519
is going to be you know eight kilobytes

626
00:28:05,519 --> 00:28:08,129
or 16 kilobytes or some relatively large

627
00:28:08,129 --> 00:28:10,049
number the file system or disk block

628
00:28:10,049 --> 00:28:14,879
size and it means that just to read and

629
00:28:14,879 --> 00:28:17,399
write these two numbers when it comes

630
00:28:17,399 --> 00:28:19,559
time to update the data pages there's a

631
00:28:19,559 --> 00:28:21,119
lot of data being pushed around on to

632
00:28:21,119 --> 00:28:23,340
the disk a locally attached disk now

633
00:28:23,340 --> 00:28:26,460
it's reasonably fast but I guess what

634
00:28:26,460 --> 00:28:27,960
they found is when they start sending

635
00:28:27,960 --> 00:28:30,869
those big 8 kilobyte writes across the

636
00:28:30,869 --> 00:28:34,409
network that that used up too much

637
00:28:34,409 --> 00:28:37,999
network capacity to be supported and so

638
00:28:37,999 --> 00:28:40,080
this arrangement this figure 2

639
00:28:40,080 --> 00:28:47,330
arrangement evidently was too slow yes

640
00:28:51,209 --> 00:28:56,309
so in this in this figure to set up the

641
00:28:56,309 --> 00:28:58,929
you know unknown to the database server

642
00:28:58,929 --> 00:29:02,469
every time it called write erode its EBS

643
00:29:02,469 --> 00:29:05,379
disk a copy of every write went over

644
00:29:05,379 --> 00:29:08,349
across availabilities zones and had to

645
00:29:08,349 --> 00:29:10,359
be written to the was written to the

646
00:29:10,359 --> 00:29:12,580
both of these EBS servers and then

647
00:29:12,580 --> 00:29:15,269
acknowledged and only then did the write

648
00:29:15,269 --> 00:29:18,009
appear to complete to the database so I

649
00:29:18,009 --> 00:29:19,839
really had to wait for all the fall for

650
00:29:19,839 --> 00:29:22,269
copies to be updated and for the data to

651
00:29:22,269 --> 00:29:24,239
be sent on the link across to the other

652
00:29:24,239 --> 00:29:30,789
availability zone and you know as far as

653
00:29:30,789 --> 00:29:33,149
table one it's concerned that first

654
00:29:33,149 --> 00:29:37,979
performance table the reason why the

655
00:29:39,089 --> 00:29:42,820
reason why the slow the mirrored my

656
00:29:42,820 --> 00:29:45,579
sequel line is much much slower than the

657
00:29:45,579 --> 00:29:47,889
Aurora line is basically that it sends

658
00:29:47,889 --> 00:29:50,499
huge amounts of data over these

659
00:29:50,499 --> 00:29:52,599
relatively slow Network links and that

660
00:29:52,599 --> 00:29:54,099
was the problem that was the performance

661
00:29:54,099 --> 00:29:55,929
problem they're really trying to fix so

662
00:29:55,929 --> 00:29:57,759
this is good for fault tolerance because

663
00:29:57,759 --> 00:29:59,079
now we have a second copy and another

664
00:29:59,079 --> 00:30:02,049
availability zone but it was bad news

665
00:30:02,049 --> 00:30:05,579
for performance all right the way Aurora

666
00:30:05,579 --> 00:30:07,859
and the next step after this is Aurora

667
00:30:07,859 --> 00:30:14,320
and to set up there the high level view

668
00:30:14,320 --> 00:30:15,809
is we still have a database server

669
00:30:15,809 --> 00:30:18,549
although now it's running custom

670
00:30:18,549 --> 00:30:21,579
software that Amazon supplies so I can

671
00:30:21,579 --> 00:30:23,979
rent an Aurora server from Amazon but

672
00:30:23,979 --> 00:30:26,320
it's not I'm not running my software on

673
00:30:26,320 --> 00:30:28,779
it I'm renting a server running Amazon's

674
00:30:28,779 --> 00:30:32,259
Aurora database software on it rent an

675
00:30:32,259 --> 00:30:35,559
Aurora database server from them and

676
00:30:35,559 --> 00:30:38,499
it's it's just one instance it sits in

677
00:30:38,499 --> 00:30:44,679
some availability zone and there's two

678
00:30:44,679 --> 00:30:46,779
interesting things about the way it's

679
00:30:46,779 --> 00:30:52,269
set up first of all is that the data you

680
00:30:52,269 --> 00:30:54,690
know it's replacement basically for EBS

681
00:30:54,690 --> 00:30:59,640
involves six replicas now

682
00:30:59,640 --> 00:31:05,390
- in each of three availability zones

683
00:31:09,680 --> 00:31:12,180
for super fault tolerance and so every

684
00:31:12,180 --> 00:31:14,460
time the database complicated we'll talk

685
00:31:14,460 --> 00:31:15,930
but basically when the database writes

686
00:31:15,930 --> 00:31:19,580
or reads when the database writes it's

687
00:31:19,580 --> 00:31:22,710
we're not sure exactly how its managed

688
00:31:22,710 --> 00:31:24,900
but it more or less needs to send a

689
00:31:24,900 --> 00:31:27,300
write one way or another writes have to

690
00:31:27,300 --> 00:31:31,280
get sent to all six of these replicas

691
00:31:31,280 --> 00:31:33,840
the key to making and so this looks like

692
00:31:33,840 --> 00:31:35,370
more replicas gosh you know why isn't it

693
00:31:35,370 --> 00:31:37,590
slower why isn't it slower than this

694
00:31:37,590 --> 00:31:38,970
previous scheme which only had four

695
00:31:38,970 --> 00:31:41,190
replicas and the answer to that is that

696
00:31:41,190 --> 00:31:43,110
what's being the only thing being

697
00:31:43,110 --> 00:31:44,850
written over the network is the log

698
00:31:44,850 --> 00:31:47,190
records so that's really the key to

699
00:31:47,190 --> 00:31:50,010
success is that the data that goes over

700
00:31:50,010 --> 00:31:51,480
these links in the sense of the replicas

701
00:31:51,480 --> 00:31:58,130
it's just the log records log entries

702
00:31:58,130 --> 00:32:02,460
and as you can see you know a log entry

703
00:32:02,460 --> 00:32:04,200
here you know at least and this is a

704
00:32:04,200 --> 00:32:06,060
simple example now it's not quite this

705
00:32:06,060 --> 00:32:08,220
small but it's really not vastly more

706
00:32:08,220 --> 00:32:10,350
than a couple of dozen bytes needed to

707
00:32:10,350 --> 00:32:11,910
store the old value and the new value

708
00:32:11,910 --> 00:32:14,520
for the piece of data we're writing so

709
00:32:14,520 --> 00:32:16,250
the log entries tend to be quite small

710
00:32:16,250 --> 00:32:20,250
whereas when the database you know we

711
00:32:20,250 --> 00:32:21,390
had a database that thought it was

712
00:32:21,390 --> 00:32:23,100
writing a local disk and it was updating

713
00:32:23,100 --> 00:32:24,900
its data pages these tended to be

714
00:32:24,900 --> 00:32:26,940
enormous like doesn't really say in the

715
00:32:26,940 --> 00:32:28,170
paper I don't think that eight kilobytes

716
00:32:28,170 --> 00:32:31,500
or more so this set up here was sending

717
00:32:31,500 --> 00:32:33,540
for each transaction was sending

718
00:32:33,540 --> 00:32:36,570
multiple 8 kilobyte pages across to the

719
00:32:36,570 --> 00:32:38,760
replicas whereas this set up is just

720
00:32:38,760 --> 00:32:41,040
sending these small log entries to more

721
00:32:41,040 --> 00:32:43,770
replicas but the log entries are so very

722
00:32:43,770 --> 00:32:46,380
much smaller than 8k pages that it's a

723
00:32:46,380 --> 00:32:51,200
net performance win okay so that's one

724
00:32:51,200 --> 00:32:56,520
this is like one of their big insights

725
00:32:56,520 --> 00:32:58,740
is just in the log entries of course a

726
00:32:58,740 --> 00:33:00,480
fallout from this is that their storage

727
00:33:00,480 --> 00:33:01,950
system is now not very general purpose

728
00:33:01,950 --> 00:33:03,210
this is a storage system that

729
00:33:03,210 --> 00:33:06,570
understands what to do with my sequel

730
00:33:06,570 --> 00:33:09,300
log entries right it's not just you know

731
00:33:09,300 --> 00:33:11,640
EBS was a very general purpose just

732
00:33:11,640 --> 00:33:13,320
emulated to disk you read them right

733
00:33:13,320 --> 00:33:15,480
block's doesn't understand anything

734
00:33:15,480 --> 00:33:17,159
about anything except for blocks this is

735
00:33:17,159 --> 00:33:19,440
a storage system that really understands

736
00:33:19,440 --> 00:33:20,309
that it's sitting underneath the

737
00:33:20,309 --> 00:33:23,190
database so that's one thing they've

738
00:33:23,190 --> 00:33:25,080
done is ditched general-purpose storage

739
00:33:25,080 --> 00:33:28,320
and switched to a very application

740
00:33:28,320 --> 00:33:31,519
specific storage system

741
00:33:31,529 --> 00:33:34,289
the other big thing I'll also go into in

742
00:33:34,289 --> 00:33:36,529
more detail is that they don't require

743
00:33:36,529 --> 00:33:40,710
that the rights be acknowledged by all

744
00:33:40,710 --> 00:33:43,049
six replicas in order for the database

745
00:33:43,049 --> 00:33:47,580
server to continue instead the database

746
00:33:47,580 --> 00:33:49,649
server can continue as long as a quorum

747
00:33:49,649 --> 00:33:51,659
and which turns out to be for as long as

748
00:33:51,659 --> 00:33:54,570
any four of these servers responds so if

749
00:33:54,570 --> 00:33:57,350
one of these availability zones is

750
00:33:57,350 --> 00:33:59,970
offline or maybe the network connection

751
00:33:59,970 --> 00:34:02,159
to it is slow or maybe even just these

752
00:34:02,159 --> 00:34:04,350
servers just happen to be slow doing

753
00:34:04,350 --> 00:34:05,490
something else at the moment we're

754
00:34:05,490 --> 00:34:08,790
trying to write the database server can

755
00:34:08,790 --> 00:34:12,270
basically ignore the two slowest or the

756
00:34:12,270 --> 00:34:14,699
two most dead of the server's when it's

757
00:34:14,699 --> 00:34:16,050
doing it right so it only requires

758
00:34:16,050 --> 00:34:17,849
acknowledgments from any four out of six

759
00:34:17,849 --> 00:34:19,829
and then it can continue and so this

760
00:34:19,829 --> 00:34:25,379
quorum scheme is the other big trick

761
00:34:25,379 --> 00:34:30,810
they use to help them have more replicas

762
00:34:30,810 --> 00:34:33,359
in more availability zones and yet not

763
00:34:33,359 --> 00:34:35,550
pay a huge performance penalty because

764
00:34:35,550 --> 00:34:36,839
they never have to wait for all of them

765
00:34:36,839 --> 00:34:39,690
just the four fastest of the six

766
00:34:39,690 --> 00:34:45,750
replicas so the rest of the lecture is

767
00:34:45,750 --> 00:34:47,699
gonna be explaining first quorums and

768
00:34:47,699 --> 00:34:49,679
then log entries and then this idea of

769
00:34:49,679 --> 00:34:53,010
just sending log entries basically table

770
00:34:53,010 --> 00:34:54,569
one summarizes the result if you look at

771
00:34:54,569 --> 00:34:56,849
table one by switching from this

772
00:34:56,849 --> 00:34:58,800
architecture in which they send the big

773
00:34:58,800 --> 00:35:02,970
data pages to four places to this Aurora

774
00:35:02,970 --> 00:35:04,800
schema sending just the log entries to

775
00:35:04,800 --> 00:35:08,579
six replicas they get a amazing 35 times

776
00:35:08,579 --> 00:35:11,670
performance increase over some other

777
00:35:11,670 --> 00:35:15,200
system you know this system over here

778
00:35:15,200 --> 00:35:17,490
but by playing these two tricks and

779
00:35:17,490 --> 00:35:19,160
paper is not very good about explaining

780
00:35:19,160 --> 00:35:21,300
how much of the performance is due to

781
00:35:21,300 --> 00:35:23,190
quorums and how much is due to just

782
00:35:23,190 --> 00:35:25,170
sending log entries but anyway you slice

783
00:35:25,170 --> 00:35:27,250
it 35

784
00:35:27,250 --> 00:35:31,330
times improvement performance is very

785
00:35:31,330 --> 00:35:33,010
respectable and of course extremely

786
00:35:33,010 --> 00:35:34,660
valuable to their customers and to them

787
00:35:34,660 --> 00:35:37,660
and it's like transformative I am sure

788
00:35:37,660 --> 00:35:44,040
for many of Amazon's customers all right

789
00:35:44,040 --> 00:35:46,690
okay so the first thing I want to talk

790
00:35:46,690 --> 00:35:50,590
about in in detail is their quorum

791
00:35:50,590 --> 00:35:52,060
arrangement what they actually mean by

792
00:35:52,060 --> 00:35:55,180
quorums so first of all the quorums is

793
00:35:55,180 --> 00:35:57,310
all about the arrangement of

794
00:35:57,310 --> 00:35:59,290
fault-tolerant of this fault-tolerant

795
00:35:59,290 --> 00:36:03,610
storage so it's worth thinking a little

796
00:36:03,610 --> 00:36:05,290
bit about what their fault tolerance

797
00:36:05,290 --> 00:36:09,760
goals were so this is like fault

798
00:36:09,760 --> 00:36:15,820
tolerance goals they wanted to be able

799
00:36:15,820 --> 00:36:18,970
to do rights even if one reads and

800
00:36:18,970 --> 00:36:21,760
writes even if one availability zone was

801
00:36:21,760 --> 00:36:26,070
completely dead so they're gonna write

802
00:36:26,070 --> 00:36:37,990
you know even with they wanted to be

803
00:36:37,990 --> 00:36:40,780
able to read even if there was one dead

804
00:36:40,780 --> 00:36:43,600
availability zone plus one other dead

805
00:36:43,600 --> 00:36:46,930
server and the reason for this is that

806
00:36:46,930 --> 00:36:48,880
an availability zone might be offline

807
00:36:48,880 --> 00:36:50,860
for quite a while because maybe it's you

808
00:36:50,860 --> 00:36:52,780
know was suffered from a flood or

809
00:36:52,780 --> 00:36:54,970
something and while it's down for a

810
00:36:54,970 --> 00:36:56,560
couple of days or a week or something

811
00:36:56,560 --> 00:36:58,420
well people prepare the damage from the

812
00:36:58,420 --> 00:37:00,700
flood we're now reliant on just you know

813
00:37:00,700 --> 00:37:01,660
the servers and the other two

814
00:37:01,660 --> 00:37:03,550
availability zones if one of them should

815
00:37:03,550 --> 00:37:05,830
go down we still we don't want it to be

816
00:37:05,830 --> 00:37:09,250
a disaster so they're going to be able

817
00:37:09,250 --> 00:37:11,080
to write with one even with one dead

818
00:37:11,080 --> 00:37:13,090
availability zone they furthermore they

819
00:37:13,090 --> 00:37:16,750
wanted to be able to read with one dead

820
00:37:16,750 --> 00:37:19,540
availability zone plus one other dead

821
00:37:19,540 --> 00:37:20,980
server so they wanted to be able to

822
00:37:20,980 --> 00:37:23,560
still read you know and get the correct

823
00:37:23,560 --> 00:37:26,500
data even if there was one dead

824
00:37:26,500 --> 00:37:28,510
availability zone plus one other server

825
00:37:28,510 --> 00:37:30,430
and the live availability zones were

826
00:37:30,430 --> 00:37:34,510
dead so you know they we have to sort of

827
00:37:34,510 --> 00:37:36,460
take take it for granted that they know

828
00:37:36,460 --> 00:37:38,680
what their they know their own business

829
00:37:38,680 --> 00:37:40,480
and that this is really

830
00:37:40,480 --> 00:37:43,130
you know kind of a sweet spot for how

831
00:37:43,130 --> 00:37:46,580
fault-tolerant you want to be um and in

832
00:37:46,580 --> 00:37:47,870
addition I already mentioned they want

833
00:37:47,870 --> 00:37:49,640
to be able to taller to sur ride out

834
00:37:49,640 --> 00:37:55,550
temporarily slow replicas I think from a

835
00:37:55,550 --> 00:37:58,940
lot of sources it's clear that the if

836
00:37:58,940 --> 00:38:01,100
you read and write EBS for example you

837
00:38:01,100 --> 00:38:03,290
don't get consistently high performance

838
00:38:03,290 --> 00:38:04,610
all the time sometimes there's little

839
00:38:04,610 --> 00:38:06,320
glitches because maybe some part of the

840
00:38:06,320 --> 00:38:08,240
network is overloaded or something is

841
00:38:08,240 --> 00:38:10,790
doing a software upgrade or whatever and

842
00:38:10,790 --> 00:38:13,520
it's temporarily slow so they want to be

843
00:38:13,520 --> 00:38:15,350
able to just keep going despite

844
00:38:15,350 --> 00:38:21,350
transient transiently slow or maybe

845
00:38:21,350 --> 00:38:27,770
briefly unavailable storage servers and

846
00:38:27,770 --> 00:38:30,230
a final requirement is that if something

847
00:38:30,230 --> 00:38:33,800
if a storage server should fail it's a

848
00:38:33,800 --> 00:38:36,230
bit of a race against time before the

849
00:38:36,230 --> 00:38:39,020
next storage server fails sort of always

850
00:38:39,020 --> 00:38:42,920
the case and it's not the statistics are

851
00:38:42,920 --> 00:38:44,450
not as favorable as you might hope

852
00:38:44,450 --> 00:38:47,270
because typically you buy basically

853
00:38:47,270 --> 00:38:50,660
because server failure is often not

854
00:38:50,660 --> 00:38:53,000
independent like the fact that one

855
00:38:53,000 --> 00:38:56,720
server is down often means that there's

856
00:38:56,720 --> 00:38:58,340
a much increased probability that

857
00:38:58,340 --> 00:39:00,410
another one of your servers will soon go

858
00:39:00,410 --> 00:39:03,320
down because it's identical Hardware may

859
00:39:03,320 --> 00:39:05,540
be bought from the same company came off

860
00:39:05,540 --> 00:39:07,520
the same production line one after

861
00:39:07,520 --> 00:39:09,650
another and so a flaw and one of them is

862
00:39:09,650 --> 00:39:11,720
extremely likely to be reflected in a

863
00:39:11,720 --> 00:39:14,570
flaw and another one so people always

864
00:39:14,570 --> 00:39:16,100
nervous off there's one failure boy

865
00:39:16,100 --> 00:39:17,330
there could be a second failure very

866
00:39:17,330 --> 00:39:21,500
soon and in a system like this well it

867
00:39:21,500 --> 00:39:24,470
turns out in these quorum systems you

868
00:39:24,470 --> 00:39:26,030
know you can only recover it's a little

869
00:39:26,030 --> 00:39:28,160
bit like raft you can recover as long as

870
00:39:28,160 --> 00:39:31,460
not too many of the replicas fail so

871
00:39:31,460 --> 00:39:35,270
they really needed to have fast we

872
00:39:35,270 --> 00:39:37,130
replicate them that is of one server

873
00:39:37,130 --> 00:39:38,870
seems permanently dead we'd like to be

874
00:39:38,870 --> 00:39:41,180
able to generate a new replica as fast

875
00:39:41,180 --> 00:39:43,160
as possible from the remaining replicas

876
00:39:43,160 --> 00:39:46,990
I mean a fast food replication

877
00:39:48,039 --> 00:39:50,299
these are the main fault tolerance goals

878
00:39:50,299 --> 00:39:56,089
the peeper lays out and by the way this

879
00:39:56,089 --> 00:39:57,859
discussion is only about the storage

880
00:39:57,859 --> 00:40:00,140
servers and you know what their failure

881
00:40:00,140 --> 00:40:01,430
character is too excited you know the

882
00:40:01,430 --> 00:40:03,589
failures how to recover and it's a

883
00:40:03,589 --> 00:40:05,390
completely separate topic what to do if

884
00:40:05,390 --> 00:40:10,039
the database server fails and Aurora has

885
00:40:10,039 --> 00:40:17,079
a totally different set of machinery for

886
00:40:17,079 --> 00:40:19,009
noticing a database servers fail

887
00:40:19,009 --> 00:40:20,989
creating a new instance running in a new

888
00:40:20,989 --> 00:40:22,400
database server on the new instance

889
00:40:22,400 --> 00:40:24,380
which is intense it's not what I'm

890
00:40:24,380 --> 00:40:25,430
talking about right now we'll talk about

891
00:40:25,430 --> 00:40:27,259
it a little bit later on right now it's

892
00:40:27,259 --> 00:40:29,479
just gonna build a storage system that's

893
00:40:29,479 --> 00:40:32,089
a lot that's where the storage system is

894
00:40:32,089 --> 00:40:36,589
fault tolerant okay so they use this

895
00:40:36,589 --> 00:40:43,940
idea called quorums and for a little

896
00:40:43,940 --> 00:40:45,890
while now I'm going to describe the sort

897
00:40:45,890 --> 00:40:49,039
of classic quorum idea which is dates

898
00:40:49,039 --> 00:40:52,940
back to the late 70s so this is quorum

899
00:40:52,940 --> 00:40:57,529
replicate quorum replication I'm gonna

900
00:40:57,529 --> 00:40:59,089
describe to you this or abstract quorum

901
00:40:59,089 --> 00:41:02,059
idea they use a variant of what I'm

902
00:41:02,059 --> 00:41:05,299
gonna explain and the idea of behind

903
00:41:05,299 --> 00:41:07,339
quorum quorum systems is to be able to

904
00:41:07,339 --> 00:41:10,819
build storage systems that provide fault

905
00:41:10,819 --> 00:41:13,089
tolerance storage using replications and

906
00:41:13,089 --> 00:41:15,229
guarantee that even if some of the

907
00:41:15,229 --> 00:41:18,109
replicas fail your that reads will still

908
00:41:18,109 --> 00:41:22,430
see the most recent writes and typically

909
00:41:22,430 --> 00:41:25,430
quorum systems are sort of simple

910
00:41:25,430 --> 00:41:28,219
readwrite systems put get systems and

911
00:41:28,219 --> 00:41:31,009
they don't typically directly support

912
00:41:31,009 --> 00:41:33,140
more complex operations just you can

913
00:41:33,140 --> 00:41:34,849
read you could have objects you can read

914
00:41:34,849 --> 00:41:36,349
an object or you can overwrite an entire

915
00:41:36,349 --> 00:41:38,359
object and so the idea is you have n

916
00:41:38,359 --> 00:41:48,259
replicas if you want to write or you

917
00:41:48,259 --> 00:41:49,699
have to get you have to in order to

918
00:41:49,699 --> 00:41:51,140
write you have to make sure your write

919
00:41:51,140 --> 00:41:53,930
is acknowledged by W where W is less

920
00:41:53,930 --> 00:41:58,700
than n of the replicas so W

921
00:41:58,700 --> 00:42:02,360
right you have to send each right to

922
00:42:02,360 --> 00:42:04,520
these W are the replicas and if you want

923
00:42:04,520 --> 00:42:07,550
to do a read you have to get input read

924
00:42:07,550 --> 00:42:13,570
information from at least our replicas

925
00:42:14,950 --> 00:42:20,240
and so a typical setup that's so well

926
00:42:20,240 --> 00:42:23,960
first of all the key thing here is that

927
00:42:23,960 --> 00:42:27,620
W and our have to be set relative to end

928
00:42:27,620 --> 00:42:31,070
so that any quorum of W servers that you

929
00:42:31,070 --> 00:42:33,380
manage to send a right to must

930
00:42:33,380 --> 00:42:36,260
necessarily overlap with any quorum of

931
00:42:36,260 --> 00:42:38,900
our servers that any future reader might

932
00:42:38,900 --> 00:42:42,130
read from and so what that means is that

933
00:42:42,130 --> 00:42:50,030
our plus W has to be greater than n so

934
00:42:50,030 --> 00:42:52,970
that any W servers must overlap in at

935
00:42:52,970 --> 00:42:58,930
least one server with any our servers

936
00:42:58,930 --> 00:43:01,370
and so you might have three we can

937
00:43:01,370 --> 00:43:05,890
imagine there's three servers s1 s2 s3

938
00:43:05,890 --> 00:43:08,060
each of them holds I say we just have

939
00:43:08,060 --> 00:43:10,130
one object that we're updating we send

940
00:43:10,130 --> 00:43:11,600
out a write maybe we want to set the

941
00:43:11,600 --> 00:43:15,830
value of our object to 23 well in order

942
00:43:15,830 --> 00:43:17,360
to do a write we need to get our new

943
00:43:17,360 --> 00:43:22,520
value on to at least W of the of the

944
00:43:22,520 --> 00:43:24,800
replicas let's say for this system that

945
00:43:24,800 --> 00:43:29,300
R and W are both equals 2 and n is equal

946
00:43:29,300 --> 00:43:32,420
to 3 that's the setup to do a write we

947
00:43:32,420 --> 00:43:35,180
need to get our new value onto a quorum

948
00:43:35,180 --> 00:43:38,030
onto a beast to the server so maybe we

949
00:43:38,030 --> 00:43:40,760
get our right onto these two so they

950
00:43:40,760 --> 00:43:43,280
both now know that the value of the of

951
00:43:43,280 --> 00:43:47,750
our data object is 23 if somebody comes

952
00:43:47,750 --> 00:43:51,140
along and reads or read it also requires

953
00:43:51,140 --> 00:43:53,150
that the reader check with at least a

954
00:43:53,150 --> 00:43:55,700
read quorum of the servers so that's

955
00:43:55,700 --> 00:43:58,820
also 2 in this set up so you know that

956
00:43:58,820 --> 00:44:00,650
quorum could include a server that

957
00:44:00,650 --> 00:44:02,510
didn't see the right but it has to

958
00:44:02,510 --> 00:44:03,830
include at least one other in order to

959
00:44:03,830 --> 00:44:07,490
get to so that means the any future read

960
00:44:07,490 --> 00:44:09,500
must for example consult both this

961
00:44:09,500 --> 00:44:11,270
server that didn't see the write plus at

962
00:44:11,270 --> 00:44:12,380
least one that did

963
00:44:12,380 --> 00:44:14,599
that is a requirement of right form must

964
00:44:14,599 --> 00:44:17,359
overlap in at least one server so any

965
00:44:17,359 --> 00:44:20,509
read must consult a server that saw any

966
00:44:20,509 --> 00:44:31,519
previous right now what's cool about

967
00:44:31,519 --> 00:44:34,430
this well actually there's still one

968
00:44:34,430 --> 00:44:38,150
critical missing piece here the reader

969
00:44:38,150 --> 00:44:41,029
is gonna get back our results possibly

970
00:44:41,029 --> 00:44:44,359
are different results because and the

971
00:44:44,359 --> 00:44:46,670
question is how does a reader know which

972
00:44:46,670 --> 00:44:48,680
of the our results it got back from the

973
00:44:48,680 --> 00:44:51,049
our servers in its forum which one

974
00:44:51,049 --> 00:44:54,789
actually uses the correct value

975
00:44:55,029 --> 00:44:57,079
something that doesn't work is voting

976
00:44:57,079 --> 00:44:59,720
like just voting by popularity of the

977
00:44:59,720 --> 00:45:01,670
different values it gets back it turns

978
00:45:01,670 --> 00:45:03,619
out not to work because we're only

979
00:45:03,619 --> 00:45:05,630
guaranteed that our reader overlaps of

980
00:45:05,630 --> 00:45:07,400
the writer in at most one server so that

981
00:45:07,400 --> 00:45:09,619
could mean that the correct value is

982
00:45:09,619 --> 00:45:11,420
only represented by one of the servers

983
00:45:11,420 --> 00:45:15,589
that the reader consulted and you know

984
00:45:15,589 --> 00:45:17,509
in a system with say six replicas you

985
00:45:17,509 --> 00:45:19,819
know you might have Reaper might be four

986
00:45:19,819 --> 00:45:23,390
you might get back for answers and only

987
00:45:23,390 --> 00:45:26,779
one of them is the answer that is the

988
00:45:26,779 --> 00:45:29,000
correct answer from the server in which

989
00:45:29,000 --> 00:45:31,519
you overlap with the previous right so

990
00:45:31,519 --> 00:45:33,079
you can't use voting and instead these

991
00:45:33,079 --> 00:45:35,750
quorum systems need version numbers so

992
00:45:35,750 --> 00:45:38,509
every right every time you do a right

993
00:45:38,509 --> 00:45:40,490
you need to accompany your new value

994
00:45:40,490 --> 00:45:42,859
with you know an increasing version

995
00:45:42,859 --> 00:45:45,680
number and then the reader it gets back

996
00:45:45,680 --> 00:45:47,029
a bunch of different values from the

997
00:45:47,029 --> 00:45:48,619
read quorum and it can just use them

998
00:45:48,619 --> 00:45:51,319
only the highest version number I'm said

999
00:45:51,319 --> 00:45:53,390
that means that this 21 here

1000
00:45:53,390 --> 00:45:57,789
you know maybe s2 had a old value of 20

1001
00:45:57,789 --> 00:45:59,869
each of these needs to be tagged with a

1002
00:45:59,869 --> 00:46:01,490
version number so maybe this is version

1003
00:46:01,490 --> 00:46:03,380
number three this was also version

1004
00:46:03,380 --> 00:46:04,609
number three because it came from the

1005
00:46:04,609 --> 00:46:06,710
same original right and we're imagining

1006
00:46:06,710 --> 00:46:08,480
that this server that didn't see the

1007
00:46:08,480 --> 00:46:09,980
right is gonna have version number two

1008
00:46:09,980 --> 00:46:11,450
then the reader gets back these two

1009
00:46:11,450 --> 00:46:13,519
values these two version numbers fix the

1010
00:46:13,519 --> 00:46:15,049
version were the highest the value with

1011
00:46:15,049 --> 00:46:18,019
the highest version number and in Aurora

1012
00:46:18,019 --> 00:46:23,480
this was essentially about well never

1013
00:46:23,480 --> 00:46:26,529
mind about Aurora for a moment

1014
00:46:28,570 --> 00:46:33,350
okay furthermore if you can't talk to if

1015
00:46:33,350 --> 00:46:35,720
you can't actually contact a quorum or a

1016
00:46:35,720 --> 00:46:37,490
read or write you really just have to

1017
00:46:37,490 --> 00:46:41,000
keep trying those are the rules so keep

1018
00:46:41,000 --> 00:46:45,200
trying until the server's are brought

1019
00:46:45,200 --> 00:46:49,370
back up or connected again so the reason

1020
00:46:49,370 --> 00:46:51,260
why this is preferable to something like

1021
00:46:51,260 --> 00:46:54,530
chain replication is that it can easily

1022
00:46:54,530 --> 00:46:59,870
ride out temporary dead or disconnected

1023
00:46:59,870 --> 00:47:01,670
or slow servers so in fact the way it

1024
00:47:01,670 --> 00:47:02,900
would work is that if you want to read

1025
00:47:02,900 --> 00:47:04,790
or write if you want to write you would

1026
00:47:04,790 --> 00:47:06,020
saying your newly written about you

1027
00:47:06,020 --> 00:47:08,780
would send the newly written value plus

1028
00:47:08,780 --> 00:47:11,240
its version number to all of the servers

1029
00:47:11,240 --> 00:47:13,430
to all n of the servers but only wait

1030
00:47:13,430 --> 00:47:17,090
for W of them to respond and similarly

1031
00:47:17,090 --> 00:47:18,590
if you want to read you would in a

1032
00:47:18,590 --> 00:47:20,000
quorum system you would send the read to

1033
00:47:20,000 --> 00:47:21,320
all the servers and only wait for a

1034
00:47:21,320 --> 00:47:23,710
quorum for R of the servers to respond

1035
00:47:23,710 --> 00:47:26,150
and that and because you only have to

1036
00:47:26,150 --> 00:47:29,720
wait for are out of n of them that means

1037
00:47:29,720 --> 00:47:31,640
that you can continue after the fastest

1038
00:47:31,640 --> 00:47:35,480
are have responded or the fastest W and

1039
00:47:35,480 --> 00:47:37,040
you don't have to wait for a slow server

1040
00:47:37,040 --> 00:47:39,080
or a server that's dead and there's not

1041
00:47:39,080 --> 00:47:43,240
any you know the machinery for ignoring

1042
00:47:43,240 --> 00:47:45,800
slow or dead servers is completely

1043
00:47:45,800 --> 00:47:47,780
implicit there's nothing here or about

1044
00:47:47,780 --> 00:47:49,610
oh we have to sort of make decisions

1045
00:47:49,610 --> 00:47:51,860
about which servers are up or down or

1046
00:47:51,860 --> 00:47:54,310
like the leaders or anything it just

1047
00:47:54,310 --> 00:47:57,590
kind of automatically proceeds as long

1048
00:47:57,590 --> 00:48:02,480
as the quorum is available so we get

1049
00:48:02,480 --> 00:48:04,130
very smooth handling of dead or slow

1050
00:48:04,130 --> 00:48:07,280
servers in addition there's not much

1051
00:48:07,280 --> 00:48:09,050
leeway for it here well actually you

1052
00:48:09,050 --> 00:48:11,300
even in this simple case you can adjust

1053
00:48:11,300 --> 00:48:14,270
the R and W to make either reads to

1054
00:48:14,270 --> 00:48:17,570
favor either reads or writes so here we

1055
00:48:17,570 --> 00:48:19,280
could actually say that well the right

1056
00:48:19,280 --> 00:48:21,560
forum is three every write has to go to

1057
00:48:21,560 --> 00:48:23,240
all three servers and in that case the

1058
00:48:23,240 --> 00:48:26,690
read quorum can be want so you could if

1059
00:48:26,690 --> 00:48:28,610
you wanted to favored reads with this

1060
00:48:28,610 --> 00:48:31,610
setup you could have read equals one

1061
00:48:31,610 --> 00:48:33,860
write equals three memories are much

1062
00:48:33,860 --> 00:48:35,480
faster they only have to wait for one

1063
00:48:35,480 --> 00:48:37,070
server but then return the writes are

1064
00:48:37,070 --> 00:48:38,840
slow if you wanted to favor right

1065
00:48:38,840 --> 00:48:40,670
you could say that Oh any reader has to

1066
00:48:40,670 --> 00:48:42,290
be from all of them but a writer only

1067
00:48:42,290 --> 00:48:45,380
has to write one so I mean the only one

1068
00:48:45,380 --> 00:48:48,400
server might have the latest value but

1069
00:48:48,400 --> 00:48:53,990
readers have to consult all three but

1070
00:48:53,990 --> 00:48:55,190
they're guaranteed that their three will

1071
00:48:55,190 --> 00:48:57,380
overlap with this of course these

1072
00:48:57,380 --> 00:49:00,380
particular values makes writes not fault

1073
00:49:00,380 --> 00:49:02,660
tolerant and here reads not fault

1074
00:49:02,660 --> 00:49:04,760
tolerant because all the server's have

1075
00:49:04,760 --> 00:49:06,410
to be up so you probably wouldn't want

1076
00:49:06,410 --> 00:49:08,150
to do this in real life you might have

1077
00:49:08,150 --> 00:49:10,460
you would have as Knowle Rohrer does a

1078
00:49:10,460 --> 00:49:13,310
larger number of servers and sort of

1079
00:49:13,310 --> 00:49:15,590
intermediate numbers of vinum right

1080
00:49:15,590 --> 00:49:23,030
corns Aurora in order to achieve its

1081
00:49:23,030 --> 00:49:26,990
goals here of being able to write with

1082
00:49:26,990 --> 00:49:30,680
one debt availability zone and read with

1083
00:49:30,680 --> 00:49:32,510
one dead availability zone plus one

1084
00:49:32,510 --> 00:49:35,030
other server it uses a quorum system

1085
00:49:35,030 --> 00:49:45,200
with N equals 6 w equals 4 and R equals

1086
00:49:45,200 --> 00:49:48,140
3 so the W equals 4 means that it can do

1087
00:49:48,140 --> 00:49:51,260
a write with one dead availability zone

1088
00:49:51,260 --> 00:49:53,060
if this availability zone can't be

1089
00:49:53,060 --> 00:49:54,770
contacted well these other four servers

1090
00:49:54,770 --> 00:49:58,700
are enough to complete right the reform

1091
00:49:58,700 --> 00:50:01,550
of 3 so 4 plus week so 7 so they

1092
00:50:01,550 --> 00:50:04,190
definitely guaranteed overlap a read

1093
00:50:04,190 --> 00:50:05,510
quorum of 3 means that even if one

1094
00:50:05,510 --> 00:50:07,640
availability is zone is dead plus one

1095
00:50:07,640 --> 00:50:09,560
more server the three remaining servers

1096
00:50:09,560 --> 00:50:12,080
are enough to serve a read now in this

1097
00:50:12,080 --> 00:50:15,200
case we're three servers are now down

1098
00:50:15,200 --> 00:50:17,600
the system can do reads and as you know

1099
00:50:17,600 --> 00:50:20,450
can reconstruct the confine the current

1100
00:50:20,450 --> 00:50:21,980
state of the database but it can't do

1101
00:50:21,980 --> 00:50:24,890
writes without further work so if they

1102
00:50:24,890 --> 00:50:28,780
were in a situation where there was

1103
00:50:28,840 --> 00:50:31,880
three dead servers there they have

1104
00:50:31,880 --> 00:50:33,560
enough of a quorum to be able to read

1105
00:50:33,560 --> 00:50:35,960
the data and reconstruct more cop more

1106
00:50:35,960 --> 00:50:38,870
replicas but until they've created more

1107
00:50:38,870 --> 00:50:41,720
replicas to basically replace these dead

1108
00:50:41,720 --> 00:50:45,670
ones they can't serve as rights

1109
00:50:47,790 --> 00:50:50,670
and also the quorum system as I

1110
00:50:50,670 --> 00:50:52,980
explained before allows them to ride out

1111
00:50:52,980 --> 00:51:02,690
these transient slow replicas all right

1112
00:51:02,690 --> 00:51:07,200
as it happens as explained before what

1113
00:51:07,200 --> 00:51:09,839
the rights in Aurora aren't really over

1114
00:51:09,839 --> 00:51:12,890
writing objects as in a sort of classic

1115
00:51:12,890 --> 00:51:16,950
quorum system what Aurora in fact its

1116
00:51:16,950 --> 00:51:20,010
rights never overwrite anything its

1117
00:51:20,010 --> 00:51:22,680
rights just append log entries to the

1118
00:51:22,680 --> 00:51:23,579
current law

1119
00:51:23,579 --> 00:51:25,920
so the way it's using quorums is

1120
00:51:25,920 --> 00:51:27,690
basically to say well when the database

1121
00:51:27,690 --> 00:51:29,400
sends out our new log record because

1122
00:51:29,400 --> 00:51:31,770
it's executing some transaction it needs

1123
00:51:31,770 --> 00:51:33,780
to make sure that that log record is

1124
00:51:33,780 --> 00:51:38,280
present on at least four of the store of

1125
00:51:38,280 --> 00:51:40,829
its storage servers before it's allowed

1126
00:51:40,829 --> 00:51:42,150
to proceed with the transaction are

1127
00:51:42,150 --> 00:51:43,799
committed so that's really the meaning

1128
00:51:43,799 --> 00:51:46,170
of its other Wars right porins is that

1129
00:51:46,170 --> 00:51:49,020
each new log record has to be appended

1130
00:51:49,020 --> 00:51:50,609
to the storage and at least for the

1131
00:51:50,609 --> 00:51:52,589
replicas before the write can be

1132
00:51:52,589 --> 00:52:01,500
considered to to have completed and when

1133
00:52:01,500 --> 00:52:03,900
a when Aurora gets to the end of a

1134
00:52:03,900 --> 00:52:05,819
transaction before it can reply to the

1135
00:52:05,819 --> 00:52:07,530
client until the client tell the client

1136
00:52:07,530 --> 00:52:08,790
a hi you know your transaction is

1137
00:52:08,790 --> 00:52:10,849
committed and finished and durable

1138
00:52:10,849 --> 00:52:14,130
Aurora has to wait for acknowledgments

1139
00:52:14,130 --> 00:52:16,319
from a write quorum for each of the log

1140
00:52:16,319 --> 00:52:18,510
records that made up that transaction

1141
00:52:18,510 --> 00:52:24,599
and in fact because because if there

1142
00:52:24,599 --> 00:52:25,980
were a crash in a recovery you're not

1143
00:52:25,980 --> 00:52:30,260
allowed to recover one transaction if

1144
00:52:30,260 --> 00:52:33,809
preceding transactions don't aren't also

1145
00:52:33,809 --> 00:52:36,690
recovered in practice Aurora has before

1146
00:52:36,690 --> 00:52:38,250
Aurora can acknowledge a transaction it

1147
00:52:38,250 --> 00:52:42,690
has to wait for a write quorum of

1148
00:52:42,690 --> 00:52:44,369
storage servers to respond for all

1149
00:52:44,369 --> 00:52:46,589
previously committed transaction and the

1150
00:52:46,589 --> 00:52:48,750
transaction of interest and then can

1151
00:52:48,750 --> 00:52:51,799
respond to the client

1152
00:52:54,740 --> 00:52:57,440
okay so these these storage servers are

1153
00:52:57,440 --> 00:52:59,990
getting incoming log records

1154
00:52:59,990 --> 00:53:02,869
that's what rights look like to them and

1155
00:53:02,869 --> 00:53:04,220
so what do they actually do you know

1156
00:53:04,220 --> 00:53:06,410
they're not getting new data pages from

1157
00:53:06,410 --> 00:53:07,609
the database server they're just getting

1158
00:53:07,609 --> 00:53:10,700
log records that just describe changes

1159
00:53:10,700 --> 00:53:16,010
to the data pages so internally one of

1160
00:53:16,010 --> 00:53:22,369
these one of these storage servers it

1161
00:53:22,369 --> 00:53:25,190
has internally it has copies of all that

1162
00:53:25,190 --> 00:53:30,680
data of all the data pages at some point

1163
00:53:30,680 --> 00:53:34,190
in the database data pages evolution so

1164
00:53:34,190 --> 00:53:39,380
it has maybe in its cache on its disk a

1165
00:53:39,380 --> 00:53:41,359
whole bunch of these pages you know page

1166
00:53:41,359 --> 00:53:47,450
1 page 2 so forth when a new write comes

1167
00:53:47,450 --> 00:53:52,820
in the storage server would win a new

1168
00:53:52,820 --> 00:53:54,290
log rec over in a new write arrives

1169
00:53:54,290 --> 00:53:56,599
carrying with it just a log record what

1170
00:53:56,599 --> 00:53:58,400
has to happen some day but not right

1171
00:53:58,400 --> 00:54:00,560
away is that the changes in that log

1172
00:54:00,560 --> 00:54:02,780
record the new value here has to be

1173
00:54:02,780 --> 00:54:05,480
applied to the relevant page but we

1174
00:54:05,480 --> 00:54:06,650
don't at the source of it doesn't have

1175
00:54:06,650 --> 00:54:09,109
to do that until someone asks just until

1176
00:54:09,109 --> 00:54:11,240
the database server or the recovery

1177
00:54:11,240 --> 00:54:13,520
software asks to see that page so

1178
00:54:13,520 --> 00:54:15,440
immediately what happens to a new log

1179
00:54:15,440 --> 00:54:17,510
record is that the log records are just

1180
00:54:17,510 --> 00:54:20,210
appended to lists of log records that

1181
00:54:20,210 --> 00:54:23,180
effect each page so for every page that

1182
00:54:23,180 --> 00:54:26,510
the storage server stores if it's been

1183
00:54:26,510 --> 00:54:29,270
recently modified by a log record by a

1184
00:54:29,270 --> 00:54:31,310
transaction what the storage server will

1185
00:54:31,310 --> 00:54:34,099
actually store is an old version of the

1186
00:54:34,099 --> 00:54:37,460
page plus the string of the sequence of

1187
00:54:37,460 --> 00:54:40,609
log records that have come in from trend

1188
00:54:40,609 --> 00:54:42,740
from the database server since that page

1189
00:54:42,740 --> 00:54:45,500
was last brought up to date so if

1190
00:54:45,500 --> 00:54:47,060
nothing else happens the storage server

1191
00:54:47,060 --> 00:54:49,880
just stores these old pages plus lists

1192
00:54:49,880 --> 00:54:53,570
of log records if the database server

1193
00:54:53,570 --> 00:54:56,119
later you know fix the page from its

1194
00:54:56,119 --> 00:54:58,310
cache and then needs to read the page

1195
00:54:58,310 --> 00:55:00,440
again for a future transaction it'll

1196
00:55:00,440 --> 00:55:03,140
send a read request out to one of the

1197
00:55:03,140 --> 00:55:04,430
storage servers and say look you know I

1198
00:55:04,430 --> 00:55:06,140
need a copy I need an updated copy a

1199
00:55:06,140 --> 00:55:06,789
page one

1200
00:55:06,789 --> 00:55:09,099
and at that point the storage server

1201
00:55:09,099 --> 00:55:12,819
will apply these log records to the page

1202
00:55:12,819 --> 00:55:15,849
you know do do these writes of new data

1203
00:55:15,849 --> 00:55:18,039
that are implied that are described in

1204
00:55:18,039 --> 00:55:19,390
the log records and then send that

1205
00:55:19,390 --> 00:55:22,239
updated page back to the database server

1206
00:55:22,239 --> 00:55:27,999
and presumably maybe then like a racist

1207
00:55:27,999 --> 00:55:29,829
list and just store the newly updated

1208
00:55:29,829 --> 00:55:35,549
page although it's not quite that simple

1209
00:55:35,759 --> 00:55:37,949
all right so the storage servers just

1210
00:55:37,949 --> 00:55:41,289
store these strings of log records plus

1211
00:55:41,289 --> 00:55:53,380
old log page versions now the database

1212
00:55:53,380 --> 00:55:54,819
server as I mentioned sometimes needs to

1213
00:55:54,819 --> 00:55:57,309
read pages so by the way one thing to

1214
00:55:57,309 --> 00:55:58,660
observe is that the database server is

1215
00:55:58,660 --> 00:56:00,969
writing log records but it's reading

1216
00:56:00,969 --> 00:56:03,489
data pages so there's also different my

1217
00:56:03,489 --> 00:56:05,619
corns poram system in the sense that the

1218
00:56:05,619 --> 00:56:07,119
sort of things that are being read and

1219
00:56:07,119 --> 00:56:09,099
written are quite different in addition

1220
00:56:09,099 --> 00:56:11,890
it turns out that in ordinary operation

1221
00:56:11,890 --> 00:56:16,839
the database server knows doesn't have

1222
00:56:16,839 --> 00:56:20,469
to send quorum reads because the

1223
00:56:20,469 --> 00:56:23,739
database server tracks for each one of

1224
00:56:23,739 --> 00:56:27,309
the storage servers how far how much of

1225
00:56:27,309 --> 00:56:29,829
the prefix of the log that storage

1226
00:56:29,829 --> 00:56:32,169
server is actually received so the

1227
00:56:32,169 --> 00:56:34,329
database server is keeping track of

1228
00:56:34,329 --> 00:56:36,099
these six numbers so so first of all log

1229
00:56:36,099 --> 00:56:37,929
entries are numbered just one two three

1230
00:56:37,929 --> 00:56:40,419
four five the database server sends that

1231
00:56:40,419 --> 00:56:42,669
new log entries to all the storage

1232
00:56:42,669 --> 00:56:44,229
servers the storage servers that receive

1233
00:56:44,229 --> 00:56:45,909
them respond saying oh yeah I got log

1234
00:56:45,909 --> 00:56:48,579
entries 79 and furthermore you know I

1235
00:56:48,579 --> 00:56:51,279
have every log entry before 79 also the

1236
00:56:51,279 --> 00:56:52,779
database server keeps track of these

1237
00:56:52,779 --> 00:56:56,429
numbers how far each server has gotten

1238
00:56:56,429 --> 00:56:59,429
or what the highest sort of contiguous

1239
00:56:59,429 --> 00:57:02,349
log entry number is that each of the

1240
00:57:02,349 --> 00:57:04,719
servers has gotten so that way when the

1241
00:57:04,719 --> 00:57:06,400
database server needs to do a read it

1242
00:57:06,400 --> 00:57:09,880
just picks a storage server that's up to

1243
00:57:09,880 --> 00:57:12,880
date and sends the read request for the

1244
00:57:12,880 --> 00:57:14,559
page it wants just to that storage

1245
00:57:14,559 --> 00:57:18,549
server so the the database server does

1246
00:57:18,549 --> 00:57:19,809
have to do quorum writes but it

1247
00:57:19,809 --> 00:57:20,590
basically

1248
00:57:20,590 --> 00:57:22,120
doesn't ordinarily have to do quorum

1249
00:57:22,120 --> 00:57:23,980
reads and knows which of these storage

1250
00:57:23,980 --> 00:57:25,120
servers are up to date and just reads

1251
00:57:25,120 --> 00:57:27,250
from one of them so the reason I keep ur

1252
00:57:27,250 --> 00:57:30,430
than they would be in a that just reads

1253
00:57:30,430 --> 00:57:32,320
one copy of the page and doesn't have to

1254
00:57:32,320 --> 00:57:36,360
go through the expense of a quorum read

1255
00:57:36,450 --> 00:57:39,580
now it does sometimes use quorum reads

1256
00:57:39,580 --> 00:57:41,860
it turns out that during crash recovery

1257
00:57:41,860 --> 00:57:44,170
you know if the crash during crash

1258
00:57:44,170 --> 00:57:46,810
recovery of the database server and so

1259
00:57:46,810 --> 00:57:49,360
this is different from a crash recovery

1260
00:57:49,360 --> 00:57:50,800
of the storage service if the database

1261
00:57:50,800 --> 00:57:53,380
server itself sir crash in me because

1262
00:57:53,380 --> 00:57:55,840
the it's running in an ec2 instance on

1263
00:57:55,840 --> 00:57:57,490
some piece of hardware some real piece

1264
00:57:57,490 --> 00:57:58,570
of hardware may be that piece of

1265
00:57:58,570 --> 00:58:01,210
hardware suffers a failure the database

1266
00:58:01,210 --> 00:58:02,950
server crashes there's some monitoring

1267
00:58:02,950 --> 00:58:04,510
infrastructure at Amazon that says oh

1268
00:58:04,510 --> 00:58:06,370
wait a minute you know the database the

1269
00:58:06,370 --> 00:58:08,170
Aurora database server over running for

1270
00:58:08,170 --> 00:58:12,900
a customer or whatever just crashed and

1271
00:58:12,900 --> 00:58:15,580
Amazon will automatically fire up a new

1272
00:58:15,580 --> 00:58:18,010
ec2 instance start up the database

1273
00:58:18,010 --> 00:58:20,770
software and that ec2 instance and sort

1274
00:58:20,770 --> 00:58:23,290
of tell it look your data is sitting on

1275
00:58:23,290 --> 00:58:26,410
this particular volume this set of

1276
00:58:26,410 --> 00:58:29,340
storage systems please clean up any

1277
00:58:29,340 --> 00:58:32,080
partially executed transactions that are

1278
00:58:32,080 --> 00:58:34,840
evident in the logs stored in these

1279
00:58:34,840 --> 00:58:38,950
storage servers and continue so we have

1280
00:58:38,950 --> 00:58:44,460
to and that's the point at which Aurora

1281
00:58:44,460 --> 00:58:48,550
uses quorum logic for weeds because this

1282
00:58:48,550 --> 00:58:52,330
database server when the old when the

1283
00:58:52,330 --> 00:58:54,160
previous database server crashed it was

1284
00:58:54,160 --> 00:58:56,380
almost certainly partway through

1285
00:58:56,380 --> 00:58:59,230
executing some set of transactions so

1286
00:58:59,230 --> 00:59:00,520
the state of play at the time of the

1287
00:59:00,520 --> 00:59:01,990
crash was well it's completed some

1288
00:59:01,990 --> 00:59:03,550
transactions and committed them and

1289
00:59:03,550 --> 00:59:06,370
their log entries are on a quorum plus

1290
00:59:06,370 --> 00:59:09,580
it's in the middle of executing some

1291
00:59:09,580 --> 00:59:12,160
other set of transactions which also may

1292
00:59:12,160 --> 00:59:14,830
have log entries on on a quorum but

1293
00:59:14,830 --> 00:59:16,720
because a database server crashed midway

1294
00:59:16,720 --> 00:59:18,340
through those transactions they can

1295
00:59:18,340 --> 00:59:23,200
never be completed and for those

1296
00:59:23,200 --> 00:59:24,940
transactions that haven't completed in

1297
00:59:24,940 --> 00:59:27,640
addition there may be you know we may

1298
00:59:27,640 --> 00:59:30,880
have a situation in which you know maybe

1299
00:59:30,880 --> 00:59:33,310
log entry this server has log on three

1300
00:59:33,310 --> 00:59:33,790
hundred

1301
00:59:33,790 --> 00:59:36,940
and the Surrey has logon 302 and there's

1302
00:59:36,940 --> 00:59:41,320
a hundred and four somewhere but no you

1303
00:59:41,320 --> 00:59:42,730
know for I as yet uncommitted

1304
00:59:42,730 --> 00:59:44,470
transaction before the crash made me

1305
00:59:44,470 --> 00:59:48,670
know server got a copy of log entry 103

1306
00:59:48,670 --> 00:59:52,270
so after a crash and remember the new

1307
00:59:52,270 --> 00:59:54,610
database service recovering it does

1308
00:59:54,610 --> 00:59:56,590
quorum reads to basically find the point

1309
00:59:56,590 --> 00:59:59,470
in the log the highest log number for

1310
00:59:59,470 --> 01:00:02,530
which every preceding log entry exists

1311
01:00:02,530 --> 01:00:04,660
somewhere in the storage service so

1312
01:00:04,660 --> 01:00:07,390
basically it finds the first missing the

1313
01:00:07,390 --> 01:00:08,980
number of the first missing log entry

1314
01:00:08,980 --> 01:00:12,430
which is 103 and says well and so we're

1315
01:00:12,430 --> 01:00:14,470
missing a log entry we can't do anything

1316
01:00:14,470 --> 01:00:16,540
with a log after this point because

1317
01:00:16,540 --> 01:00:20,440
we're like missing an update so the

1318
01:00:20,440 --> 01:00:21,850
database server does these quorum reads

1319
01:00:21,850 --> 01:00:23,110
it finds a hundred and three is the

1320
01:00:23,110 --> 01:00:27,490
first entry that's MIT that's I can't

1321
01:00:27,490 --> 01:00:28,810
you know I look at my quorum the

1322
01:00:28,810 --> 01:00:31,120
server's I can reach and 103 is not

1323
01:00:31,120 --> 01:00:32,890
there and the database server will send

1324
01:00:32,890 --> 01:00:34,300
out a message to all the server saying

1325
01:00:34,300 --> 01:00:37,330
look please just discard every log entry

1326
01:00:37,330 --> 01:00:39,640
from 103 onwards and those mussels

1327
01:00:39,640 --> 01:00:43,030
necessarily not include log entries from

1328
01:00:43,030 --> 01:00:45,160
committed transactions because we know a

1329
01:00:45,160 --> 01:00:46,870
transaction can't commit until all of

1330
01:00:46,870 --> 01:00:49,390
its entries are on a right corner so we

1331
01:00:49,390 --> 01:00:50,950
would be guaranteed to see them so we're

1332
01:00:50,950 --> 01:00:53,110
only discarding log entries from

1333
01:00:53,110 --> 01:00:58,210
uncommitted transactions of course so

1334
01:00:58,210 --> 01:00:59,440
we're sort of cutting off the log here

1335
01:00:59,440 --> 01:01:03,190
at login 302 these log entries that

1336
01:01:03,190 --> 01:01:04,930
we're preserving now may actually

1337
01:01:04,930 --> 01:01:07,300
include log entries from uncommitted

1338
01:01:07,300 --> 01:01:08,860
transactions from transactions that were

1339
01:01:08,860 --> 01:01:10,720
interrupted by the crash and the

1340
01:01:10,720 --> 01:01:12,070
database server actually has to detect

1341
01:01:12,070 --> 01:01:14,110
those which you can by seeing a hope you

1342
01:01:14,110 --> 01:01:16,480
know a certain transaction there's it

1343
01:01:16,480 --> 01:01:18,640
has update entries in the log but no

1344
01:01:18,640 --> 01:01:20,500
commit record the database server will

1345
01:01:20,500 --> 01:01:22,810
find the full set of those uncompleted

1346
01:01:22,810 --> 01:01:25,480
transactions and basically issue undo

1347
01:01:25,480 --> 01:01:28,330
operations I sort of knew log entries

1348
01:01:28,330 --> 01:01:32,730
that undo all of the changes that that

1349
01:01:32,730 --> 01:01:35,680
that those uncommitted transactions made

1350
01:01:35,680 --> 01:01:38,280
and you know that's the point at which

1351
01:01:38,280 --> 01:01:41,710
Aurora needs this these old values in

1352
01:01:41,710 --> 01:01:44,690
the log entries so that a

1353
01:01:44,690 --> 01:01:46,849
server that's doing recovery after a

1354
01:01:46,849 --> 01:01:49,760
crash can sort of back out of partially

1355
01:01:49,760 --> 01:02:00,400
completed transactions all right one

1356
01:02:00,400 --> 01:02:04,000
another thing I'd like to talk about is

1357
01:02:04,000 --> 01:02:09,020
how Aurora deals with big databases so

1358
01:02:09,020 --> 01:02:13,099
so far I've explained the storage setup

1359
01:02:13,099 --> 01:02:17,020
as if the database just has these six

1360
01:02:17,020 --> 01:02:20,359
replicas of its storage and if that was

1361
01:02:20,359 --> 01:02:22,099
all there was to it basically a database

1362
01:02:22,099 --> 01:02:23,900
couldn't be you know each of these just

1363
01:02:23,900 --> 01:02:25,970
a computer with a disk or two or

1364
01:02:25,970 --> 01:02:28,609
something attached to it if this were

1365
01:02:28,609 --> 01:02:31,010
the way the full situation then we

1366
01:02:31,010 --> 01:02:32,329
couldn't have a database that was bigger

1367
01:02:32,329 --> 01:02:34,400
than the amount of storage that you

1368
01:02:34,400 --> 01:02:36,230
could put on a single machine there's

1369
01:02:36,230 --> 01:02:37,010
the fact that we have six machines

1370
01:02:37,010 --> 01:02:39,319
doesn't give us six times as much usable

1371
01:02:39,319 --> 01:02:41,420
storage because each one I'm storing a

1372
01:02:41,420 --> 01:02:43,220
replica of the same old data again and

1373
01:02:43,220 --> 01:02:46,700
again and you know so I want to use

1374
01:02:46,700 --> 01:02:48,319
solid-state drives or something we can

1375
01:02:48,319 --> 01:02:50,930
put you know terabytes of storage on a

1376
01:02:50,930 --> 01:02:53,960
single machine but we can't put you know

1377
01:02:53,960 --> 01:02:55,460
hundreds of terabytes on a single

1378
01:02:55,460 --> 01:02:59,510
machine so in order to support customers

1379
01:02:59,510 --> 01:03:02,000
who need like more than ten terabytes

1380
01:03:02,000 --> 01:03:06,710
who need to have vast databases Amazon

1381
01:03:06,710 --> 01:03:09,079
is happy Amazon will split up the

1382
01:03:09,079 --> 01:03:12,970
databases data onto multiple sets of six

1383
01:03:12,970 --> 01:03:19,180
replicas so and the kind of unit of

1384
01:03:19,180 --> 01:03:21,290
sharding the unit of splitting up the

1385
01:03:21,290 --> 01:03:23,960
data I think is 10 gigabytes so a

1386
01:03:23,960 --> 01:03:25,910
database that needs 20 gigabytes of data

1387
01:03:25,910 --> 01:03:28,400
will use two protection groups these

1388
01:03:28,400 --> 01:03:32,060
these PG things to its data you know sit

1389
01:03:32,060 --> 01:03:35,569
on half of it will sit on the six

1390
01:03:35,569 --> 01:03:41,240
servers of protection Group one and then

1391
01:03:41,240 --> 01:03:44,810
they'll be another six servers you know

1392
01:03:44,810 --> 01:03:46,640
possibly a different set of six storage

1393
01:03:46,640 --> 01:03:48,470
servers because Amazon's running and

1394
01:03:48,470 --> 01:03:49,819
like a huge fleet of these storage

1395
01:03:49,819 --> 01:03:51,770
servers that are jointly used by all of

1396
01:03:51,770 --> 01:03:54,740
its Aurora customers the second ten

1397
01:03:54,740 --> 01:03:57,680
gigabytes of the databases 20 gigabytes

1398
01:03:57,680 --> 01:03:58,250
of data

1399
01:03:58,250 --> 01:04:02,740
we'll be replicated on another set of

1400
01:04:02,740 --> 01:04:05,180
you know typically different I'll you

1401
01:04:05,180 --> 01:04:06,470
know there could be overlap between

1402
01:04:06,470 --> 01:04:08,720
these but typically just a different set

1403
01:04:08,720 --> 01:04:11,210
of six server so now we get 20 gigabytes

1404
01:04:11,210 --> 01:04:15,740
a day done and we have more of these as

1405
01:04:15,740 --> 01:04:18,890
a database goes bigger one interesting

1406
01:04:18,890 --> 01:04:21,050
piece of fallout from this is that while

1407
01:04:21,050 --> 01:04:25,670
it's clear that you can take the data

1408
01:04:25,670 --> 01:04:28,910
pages and split them up over multiple

1409
01:04:28,910 --> 01:04:30,830
independent protection groups maybe you

1410
01:04:30,830 --> 01:04:32,450
know odd numbered data pages from your

1411
01:04:32,450 --> 01:04:35,390
b-tree go on PG one and even number

1412
01:04:35,390 --> 01:04:38,060
pages go on PG - it's good you can shard

1413
01:04:38,060 --> 01:04:40,640
split up the data pages it's not

1414
01:04:40,640 --> 01:04:41,960
immediately obvious what to do with a

1415
01:04:41,960 --> 01:04:44,810
log all right how do you split up the

1416
01:04:44,810 --> 01:04:46,910
log if you have two of these two

1417
01:04:46,910 --> 01:04:48,620
protection groups or more in a mantra

1418
01:04:48,620 --> 01:04:52,160
tection group and the answer that amazon

1419
01:04:52,160 --> 01:04:54,140
does is that that that Aurora uses is

1420
01:04:54,140 --> 01:04:55,250
that the database server when it's

1421
01:04:55,250 --> 01:04:57,200
sending out a log record it looks at the

1422
01:04:57,200 --> 01:04:59,930
data that the log record modifies and

1423
01:04:59,930 --> 01:05:03,620
figures out which protection groups

1424
01:05:03,620 --> 01:05:06,260
store that data and it sends each log

1425
01:05:06,260 --> 01:05:08,240
record just to the protection groups

1426
01:05:08,240 --> 01:05:11,360
that store data that's mentioned that's

1427
01:05:11,360 --> 01:05:14,540
modified in the log entry and so that

1428
01:05:14,540 --> 01:05:16,730
means that each of these protection

1429
01:05:16,730 --> 01:05:19,430
groups store some fraction of the data

1430
01:05:19,430 --> 01:05:22,340
pages plus all the log records that

1431
01:05:22,340 --> 01:05:25,280
apply to those data pages see these

1432
01:05:25,280 --> 01:05:27,140
protection groups stores a subset of a

1433
01:05:27,140 --> 01:05:36,290
log that's relevant to its pages so a

1434
01:05:36,290 --> 01:05:41,450
final maybe I erase the photons

1435
01:05:41,450 --> 01:05:43,820
requirements but a final requirement is

1436
01:05:43,820 --> 01:05:48,260
that if a if ass one of these storage

1437
01:05:48,260 --> 01:05:50,600
servers crashes we want to be able to

1438
01:05:50,600 --> 01:05:53,060
replace it as soon as possible right

1439
01:05:53,060 --> 01:05:55,400
because you know if we wait too long

1440
01:05:55,400 --> 01:05:57,500
then we risk maybe three of them are

1441
01:05:57,500 --> 01:05:58,850
four of them crashing and a four of them

1442
01:05:58,850 --> 01:06:01,550
crash then we actually can't recover

1443
01:06:01,550 --> 01:06:02,750
because then we don't have a reform

1444
01:06:02,750 --> 01:06:05,990
anymore so we need to regain replication

1445
01:06:05,990 --> 01:06:08,030
as soon as possible if you think about

1446
01:06:08,030 --> 01:06:11,480
any one storage server sure this this do

1447
01:06:11,480 --> 01:06:13,700
which server is storing 10 gigabytes for

1448
01:06:13,700 --> 01:06:15,619
you know my databases protection group

1449
01:06:15,619 --> 01:06:17,810
but in fact the physical thing you know

1450
01:06:17,810 --> 01:06:19,430
the physical setup of any one of these

1451
01:06:19,430 --> 01:06:21,530
servers is that it has a you know maybe

1452
01:06:21,530 --> 01:06:23,330
a one or two or something

1453
01:06:23,330 --> 01:06:26,900
terabyte disk on it that's storing 10

1454
01:06:26,900 --> 01:06:31,369
gigabyte segments of a hundred or more

1455
01:06:31,369 --> 01:06:34,670
different Aurora instances so what's

1456
01:06:34,670 --> 01:06:37,460
what's on this physical machine is you

1457
01:06:37,460 --> 01:06:39,410
know 10 terabyte era byte or 10

1458
01:06:39,410 --> 01:06:42,109
terabytes or whatever of data in total

1459
01:06:42,109 --> 01:06:44,540
so when there's a when one of these

1460
01:06:44,540 --> 01:06:47,600
storage servers crashes it's taking with

1461
01:06:47,600 --> 01:06:50,630
it not just the 10 gigabytes from my

1462
01:06:50,630 --> 01:06:53,359
database but also 10 gigabytes from a

1463
01:06:53,359 --> 01:06:55,310
hundred other people's databases as well

1464
01:06:55,310 --> 01:06:58,100
and what has to be replicated is not

1465
01:06:58,100 --> 01:07:00,320
just my 10 gigabytes but the entire

1466
01:07:00,320 --> 01:07:03,020
terabyte or whatever or more that's

1467
01:07:03,020 --> 01:07:05,540
stored on this servers solid-state drive

1468
01:07:05,540 --> 01:07:08,060
and if you think through the numbers you

1469
01:07:08,060 --> 01:07:10,160
know maybe we have 10 gigabit per second

1470
01:07:10,160 --> 01:07:15,080
network interfaces if we need to move 10

1471
01:07:15,080 --> 01:07:18,440
terabytes across a 10 gigabyte per

1472
01:07:18,440 --> 01:07:19,730
second network interface from one

1473
01:07:19,730 --> 01:07:22,420
machine to another it's gonna take I

1474
01:07:22,420 --> 01:07:25,220
don't know a thousand seconds ten

1475
01:07:25,220 --> 01:07:26,930
thousand seconds maybe ten thousand

1476
01:07:26,930 --> 01:07:31,100
seconds and that's way too long right we

1477
01:07:31,100 --> 01:07:32,240
don't want to have to sit there and wait

1478
01:07:32,240 --> 01:07:34,580
you know it we don't want to have a

1479
01:07:34,580 --> 01:07:37,040
strategy in which the way we weak we can

1480
01:07:37,040 --> 01:07:40,070
reconstruct this is to find is to have

1481
01:07:40,070 --> 01:07:41,630
another machine that was replicating

1482
01:07:41,630 --> 01:07:43,609
everything on it and had that machine

1483
01:07:43,609 --> 01:07:46,940
send 10 terabytes to a replacement

1484
01:07:46,940 --> 01:07:48,410
machine we're gonna be able to

1485
01:07:48,410 --> 01:07:50,090
reconstruct the data far faster than

1486
01:07:50,090 --> 01:07:52,850
that and so the actual setup they use is

1487
01:07:52,850 --> 01:07:56,450
that if I have a particular storage

1488
01:07:56,450 --> 01:07:57,609
server

1489
01:07:57,609 --> 01:08:01,850
it stores many many segments you know

1490
01:08:01,850 --> 01:08:04,430
replicas of many 10 gigabyte protection

1491
01:08:04,430 --> 01:08:07,480
groups so maybe this protection group

1492
01:08:07,480 --> 01:08:09,830
maybe this segment that it's storing

1493
01:08:09,830 --> 01:08:12,830
data for the other envy for this one the

1494
01:08:12,830 --> 01:08:17,479
other replicas are you know these five

1495
01:08:17,479 --> 01:08:19,819
other machines all right so these are

1496
01:08:19,819 --> 01:08:22,600
all storing

1497
01:08:22,738 --> 01:08:25,089
segments of protection group a and so

1498
01:08:25,089 --> 01:08:26,319
you know there's a whole bunch of other

1499
01:08:26,319 --> 01:08:27,698
ones that we're also storing so I mean

1500
01:08:27,698 --> 01:08:29,288
we may be this particular machine also

1501
01:08:29,288 --> 01:08:33,578
stores a replica for protecting group B

1502
01:08:33,578 --> 01:08:36,130
but the other copies of the data for B

1503
01:08:36,130 --> 01:08:38,979
are going to be put on a disjoint set of

1504
01:08:38,979 --> 01:08:41,439
servers right so now there's five

1505
01:08:41,439 --> 01:08:43,269
servers that have the other copies of B

1506
01:08:43,269 --> 01:08:48,788
and so on for all of the segments that

1507
01:08:48,788 --> 01:08:50,439
this server that are sitting on this

1508
01:08:50,439 --> 01:08:52,420
storage servers hard drive for you know

1509
01:08:52,420 --> 01:08:55,569
many many different Aurora instances so

1510
01:08:55,569 --> 01:08:57,179
that means that this machine goes down

1511
01:08:57,179 --> 01:09:00,339
the replacement strategy is that we pick

1512
01:09:00,339 --> 01:09:01,899
if we're say we're storing a hundred of

1513
01:09:01,899 --> 01:09:04,059
these segments on it we pick a hundred

1514
01:09:04,059 --> 01:09:09,460
different storage servers each of which

1515
01:09:09,460 --> 01:09:13,448
is gonna pick up one new segment that is

1516
01:09:13,448 --> 01:09:14,948
each of which is going to now be

1517
01:09:14,948 --> 01:09:17,170
participating in one more protection

1518
01:09:17,170 --> 01:09:20,049
group so one one we miss like one server

1519
01:09:20,049 --> 01:09:22,809
to be replicate on for each of these ten

1520
01:09:22,809 --> 01:09:24,639
gigabytes segments and now we have you

1521
01:09:24,639 --> 01:09:28,238
know maybe 100 sort of different segment

1522
01:09:28,238 --> 01:09:29,439
servers and you know I probably storing

1523
01:09:29,439 --> 01:09:30,788
other stuff but they have a little bit

1524
01:09:30,788 --> 01:09:32,559
of free disk space and then for each of

1525
01:09:32,559 --> 01:09:35,859
these we pick one machine one of the

1526
01:09:35,859 --> 01:09:38,139
replicas that we're going to copy the

1527
01:09:38,139 --> 01:09:39,908
data from one of the remaining replicas

1528
01:09:39,908 --> 01:09:41,408
so maybe for a we're going to copy from

1529
01:09:41,408 --> 01:09:43,749
there for B from here you know if we

1530
01:09:43,749 --> 01:09:47,738
have five other copies with C we pick a

1531
01:09:47,738 --> 01:09:50,889
different server for C and so we have we

1532
01:09:50,889 --> 01:09:53,408
copy a from this server to that server

1533
01:09:53,408 --> 01:09:57,849
and B like this and C like this and so

1534
01:09:57,849 --> 01:10:01,749
now we have a hundred different 10

1535
01:10:01,749 --> 01:10:03,960
gigabyte copies going on in parallel

1536
01:10:03,960 --> 01:10:07,360
across the network and assuming you know

1537
01:10:07,360 --> 01:10:09,369
we have enough servers that these can

1538
01:10:09,369 --> 01:10:11,999
all be disjoint and we have plenty of

1539
01:10:11,999 --> 01:10:14,889
bandwidth in switching network that

1540
01:10:14,889 --> 01:10:17,849
connects them now we can copy our

1541
01:10:17,849 --> 01:10:20,139
terabyte or 10 terabytes or whatever of

1542
01:10:20,139 --> 01:10:23,110
data and total in parallel with a

1543
01:10:23,110 --> 01:10:25,570
hundredfold parallelism and the whole

1544
01:10:25,570 --> 01:10:27,489
thing will take you know 10 seconds or

1545
01:10:27,489 --> 01:10:29,289
something instead of taking a thousand

1546
01:10:29,289 --> 01:10:30,729
seconds if there were just two machines

1547
01:10:30,729 --> 01:10:34,449
involved anyway so this is

1548
01:10:34,449 --> 01:10:35,739
this is the strategies they use and it

1549
01:10:35,739 --> 01:10:37,090
means that they can recover you know for

1550
01:10:37,090 --> 01:10:39,699
machine dies they can recover in

1551
01:10:39,699 --> 01:10:41,679
parallel from one machine's death

1552
01:10:41,679 --> 01:10:45,340
extremely quickly if lots of machines

1553
01:10:45,340 --> 01:10:49,090
diets doesn't work as well but they can

1554
01:10:49,090 --> 01:10:50,380
recover from single they can be

1555
01:10:50,380 --> 01:10:52,179
replicate from single machine crashes

1556
01:10:52,179 --> 01:10:58,119
extremely quickly alright so a final

1557
01:10:58,119 --> 01:10:59,829
thing that the paper mentions if you

1558
01:10:59,829 --> 01:11:02,949
look at figure three you'll see that not

1559
01:11:02,949 --> 01:11:06,280
only do they have this main database but

1560
01:11:06,280 --> 01:11:09,880
they also have replica databases so for

1561
01:11:09,880 --> 01:11:12,130
many of their customers many of their

1562
01:11:12,130 --> 01:11:14,829
customers see far more read-only queries

1563
01:11:14,829 --> 01:11:17,619
than they see readwrite queries that is

1564
01:11:17,619 --> 01:11:19,209
if you think about a web server if you

1565
01:11:19,209 --> 01:11:21,219
just view a web page on some website

1566
01:11:21,219 --> 01:11:24,070
then chances are the web server you

1567
01:11:24,070 --> 01:11:25,719
connected to has to read lots and lots

1568
01:11:25,719 --> 01:11:28,150
and stuff in order to generate all the

1569
01:11:28,150 --> 01:11:30,190
things that are shown on the page to you

1570
01:11:30,190 --> 01:11:32,019
maybe hundreds of different items have

1571
01:11:32,019 --> 01:11:33,969
to be read out of the database or so out

1572
01:11:33,969 --> 01:11:35,499
of some database but the number of

1573
01:11:35,499 --> 01:11:37,630
writes for a typical web page view is

1574
01:11:37,630 --> 01:11:39,340
usually much much smaller maybe some

1575
01:11:39,340 --> 01:11:41,260
statistics have to be updated or a

1576
01:11:41,260 --> 01:11:42,639
little bit of history for you or

1577
01:11:42,639 --> 01:11:44,440
something so you might have a hundred to

1578
01:11:44,440 --> 01:11:48,400
one ratio of reads to writes that is you

1579
01:11:48,400 --> 01:11:50,739
may typically have a large large large

1580
01:11:50,739 --> 01:11:54,519
number of straight read only database

1581
01:11:54,519 --> 01:11:57,729
queries now with this set up the writes

1582
01:11:57,729 --> 01:11:59,889
can only go through the one database

1583
01:11:59,889 --> 01:12:01,150
server because we really can only

1584
01:12:01,150 --> 01:12:03,130
support one writer for this storage

1585
01:12:03,130 --> 01:12:06,070
strategy and I think you know one place

1586
01:12:06,070 --> 01:12:07,479
where the rubber really hits the road

1587
01:12:07,479 --> 01:12:09,489
there is that the log entries have to be

1588
01:12:09,489 --> 01:12:11,769
numbered sequentially and that's easy to

1589
01:12:11,769 --> 01:12:13,479
do if all the writes go through a single

1590
01:12:13,479 --> 01:12:15,459
server and extremely difficult if we

1591
01:12:15,459 --> 01:12:17,440
have lots of different servers all sort

1592
01:12:17,440 --> 01:12:19,090
of writing in an uncoordinated way to

1593
01:12:19,090 --> 01:12:21,880
the same database so the writes really

1594
01:12:21,880 --> 01:12:24,329
have to be go through one database but

1595
01:12:24,329 --> 01:12:27,429
we could set up and indeed Amazon does

1596
01:12:27,429 --> 01:12:29,469
set up a situation where we have read

1597
01:12:29,469 --> 01:12:32,709
only database replicas that can read

1598
01:12:32,709 --> 01:12:35,469
from these storage servers and so the

1599
01:12:35,469 --> 01:12:38,530
full glory of figure three is that in

1600
01:12:38,530 --> 01:12:40,719
addition to the main database server

1601
01:12:40,719 --> 01:12:42,880
that handles the write requests there's

1602
01:12:42,880 --> 01:12:48,280
also a set of read-only

1603
01:12:48,280 --> 01:12:50,960
databases and they say they can support

1604
01:12:50,960 --> 01:12:53,030
up to 15 so you can actually get a lot

1605
01:12:53,030 --> 01:12:56,510
of you know if your senior we'd have you

1606
01:12:56,510 --> 01:12:58,850
workload a lot of it can be you know

1607
01:12:58,850 --> 01:13:01,190
most of it can be sort of hived off to a

1608
01:13:01,190 --> 01:13:02,960
whole bunch of these read-only databases

1609
01:13:02,960 --> 01:13:05,450
and when a client sends a read request

1610
01:13:05,450 --> 01:13:07,160
to read only database what happens is

1611
01:13:07,160 --> 01:13:09,470
the read only database figures out you

1612
01:13:09,470 --> 01:13:11,780
know what data pages it needs to serve

1613
01:13:11,780 --> 01:13:14,120
that request and sends reads into the

1614
01:13:14,120 --> 01:13:15,920
directly into the storage system without

1615
01:13:15,920 --> 01:13:21,500
bothering the main readwrite database so

1616
01:13:21,500 --> 01:13:23,180
the the read-only replica database

1617
01:13:23,180 --> 01:13:25,640
ascend page requests read requests

1618
01:13:25,640 --> 01:13:27,560
directly the storage servers and then

1619
01:13:27,560 --> 01:13:31,490
they'll be no cache those pages so that

1620
01:13:31,490 --> 01:13:33,680
they can you know respond to future read

1621
01:13:33,680 --> 01:13:35,810
requests right out of their cache of

1622
01:13:35,810 --> 01:13:36,830
course they need to be able to update

1623
01:13:36,830 --> 01:13:40,370
those caches and for that reason Aurora

1624
01:13:40,370 --> 01:13:43,280
also the main database sends a copy of

1625
01:13:43,280 --> 01:13:46,790
its log to each of the read-only

1626
01:13:46,790 --> 01:13:49,130
databases and that's the horizontal

1627
01:13:49,130 --> 01:13:51,260
lines you see between the blue boxes and

1628
01:13:51,260 --> 01:13:52,970
figure three that the main database

1629
01:13:52,970 --> 01:13:55,490
sends all the log entries do these mean

1630
01:13:55,490 --> 01:13:57,550
only databases which they use to update

1631
01:13:57,550 --> 01:14:03,740
their cached copies to reflect recent

1632
01:14:03,740 --> 01:14:05,420
transactions in the database and it

1633
01:14:05,420 --> 01:14:07,940
means it does mean that the read only

1634
01:14:07,940 --> 01:14:09,530
database is lag a little bit behind the

1635
01:14:09,530 --> 01:14:12,260
main database but it turns out for a lot

1636
01:14:12,260 --> 01:14:13,820
of read-only workloads that's okay if

1637
01:14:13,820 --> 01:14:15,650
you look at a web page and it's you know

1638
01:14:15,650 --> 01:14:17,330
20 milliseconds out of date that's

1639
01:14:17,330 --> 01:14:24,230
usually not a big problem there are some

1640
01:14:24,230 --> 01:14:26,750
complexities from this like one problem

1641
01:14:26,750 --> 01:14:28,340
is that we don't want these relay

1642
01:14:28,340 --> 01:14:31,010
databases to see data from uncommitted

1643
01:14:31,010 --> 01:14:34,310
transactions yet and so in this stream

1644
01:14:34,310 --> 01:14:36,980
of log entries the database may need to

1645
01:14:36,980 --> 01:14:39,470
be sort of denotes which transactions

1646
01:14:39,470 --> 01:14:42,050
have committed and they're read-only

1647
01:14:42,050 --> 01:14:43,510
databases are careful not to apply

1648
01:14:43,510 --> 01:14:44,800
uncommon

1649
01:14:44,800 --> 01:14:47,870
uncommitted transactions to their caches

1650
01:14:47,870 --> 01:14:49,670
they wait till the transactions commit

1651
01:14:49,670 --> 01:14:54,770
the other complexity that these

1652
01:14:54,770 --> 01:14:59,410
read-only replicas impose is that

1653
01:14:59,410 --> 01:15:03,430
the the the these structures he of these

1654
01:15:03,430 --> 01:15:05,380
andhe structures are quite complex this

1655
01:15:05,380 --> 01:15:06,670
might be a b-tree it might need to be

1656
01:15:06,670 --> 01:15:09,520
rebalanced periodically for example I'm

1657
01:15:09,520 --> 01:15:10,720
the rebalancing is quite a complex

1658
01:15:10,720 --> 01:15:12,430
operation in which a lot of the tree has

1659
01:15:12,430 --> 01:15:15,580
to be modified in atomically and so the

1660
01:15:15,580 --> 01:15:17,350
tree is incorrect while it's being be

1661
01:15:17,350 --> 01:15:19,000
balanced and you only allowed to look at

1662
01:15:19,000 --> 01:15:21,520
it after the rebalancing is done if

1663
01:15:21,520 --> 01:15:23,950
these read-only replicas directly read

1664
01:15:23,950 --> 01:15:25,390
the pages out of the database there's a

1665
01:15:25,390 --> 01:15:28,120
risk they might see the be tree that the

1666
01:15:28,120 --> 01:15:30,190
database that's being stored here in

1667
01:15:30,190 --> 01:15:31,810
these data pages they may see the bee

1668
01:15:31,810 --> 01:15:34,030
tree in the middle of a rebalancing or

1669
01:15:34,030 --> 01:15:37,450
some other operation and the data is

1670
01:15:37,450 --> 01:15:39,070
just totally illegal and they might

1671
01:15:39,070 --> 01:15:43,360
crash or just malfunction and when the

1672
01:15:43,360 --> 01:15:45,640
paper talks about mini transactions and

1673
01:15:45,640 --> 01:15:49,720
the vdl verses vcl distinction what it's

1674
01:15:49,720 --> 01:15:51,760
talking about is the machinery by which

1675
01:15:51,760 --> 01:15:54,700
the database server can tell the storage

1676
01:15:54,700 --> 01:15:57,550
servers look this complex sequence of

1677
01:15:57,550 --> 01:16:02,560
log entries must only be revealed all or

1678
01:16:02,560 --> 01:16:04,690
nothing' atomically to any read-only

1679
01:16:04,690 --> 01:16:07,420
transactions that's what the mini

1680
01:16:07,420 --> 01:16:09,250
transactions and VDL are about and

1681
01:16:09,250 --> 01:16:10,780
basically the read when a read only

1682
01:16:10,780 --> 01:16:13,600
database asks to see data a data page

1683
01:16:13,600 --> 01:16:15,580
from a storage server the storage server

1684
01:16:15,580 --> 01:16:17,800
is careful to either show it data from

1685
01:16:17,800 --> 01:16:20,650
just before one of these sequence many

1686
01:16:20,650 --> 01:16:23,740
transaction sequences of log entries or

1687
01:16:23,740 --> 01:16:28,630
just after but not in the middle all

1688
01:16:28,630 --> 01:16:33,370
right so that's the all the technical

1689
01:16:33,370 --> 01:16:34,840
stuff I have to talk about just to kind

1690
01:16:34,840 --> 01:16:36,430
of summarize what's interesting about

1691
01:16:36,430 --> 01:16:37,720
the paper and what can be learned from

1692
01:16:37,720 --> 01:16:41,470
the paper one thing to learn which is

1693
01:16:41,470 --> 01:16:43,540
just good in general not specific to

1694
01:16:43,540 --> 01:16:45,400
this paper but everybody in systems

1695
01:16:45,400 --> 01:16:48,360
should know is the basics of how

1696
01:16:48,360 --> 01:16:50,620
transaction processing databases work

1697
01:16:50,620 --> 01:16:53,520
and the sort of impact that the

1698
01:16:53,520 --> 01:16:55,920
interaction between transaction

1699
01:16:55,920 --> 01:16:58,450
processing databases and the storage

1700
01:16:58,450 --> 01:17:00,340
systems because this comes up a lot it's

1701
01:17:00,340 --> 01:17:01,900
like a pervasive you know the

1702
01:17:01,900 --> 01:17:05,160
performance and crash recoverability

1703
01:17:05,160 --> 01:17:07,240
complexity of running a real database

1704
01:17:07,240 --> 01:17:10,050
just comes up over and over again in

1705
01:17:10,050 --> 01:17:13,210
systems design another thing to learn

1706
01:17:13,210 --> 01:17:15,820
this paper is this idea of quorums and

1707
01:17:15,820 --> 01:17:18,700
overlap the technique of overlapping

1708
01:17:18,700 --> 01:17:20,950
read/write quorums in order to always be

1709
01:17:20,950 --> 01:17:22,540
able to see the latest data but also get

1710
01:17:22,540 --> 01:17:24,250
fault tolerance and of course this comes

1711
01:17:24,250 --> 01:17:27,250
up in raft also raft has a strong kind

1712
01:17:27,250 --> 01:17:29,070
of quorum flavor to it

1713
01:17:29,070 --> 01:17:31,570
another interesting thought from this

1714
01:17:31,570 --> 01:17:33,760
paper is that the database and the

1715
01:17:33,760 --> 01:17:35,830
storage system are basically Co designed

1716
01:17:35,830 --> 01:17:37,870
as kind of an integrated there's

1717
01:17:37,870 --> 01:17:39,460
integration across the database layer

1718
01:17:39,460 --> 01:17:41,170
and the storage layer or nearly

1719
01:17:41,170 --> 01:17:43,480
redesigned to try to design systems so

1720
01:17:43,480 --> 01:17:45,370
they have you know good separation

1721
01:17:45,370 --> 01:17:49,180
between consumers of services and the

1722
01:17:49,180 --> 01:17:50,770
sort of infrastructure services like

1723
01:17:50,770 --> 01:17:52,840
typically storage is very

1724
01:17:52,840 --> 01:17:54,880
general-purpose not aimed at a

1725
01:17:54,880 --> 01:17:57,780
particular application just you know

1726
01:17:57,780 --> 01:18:00,010
because that's a pleasant design and it

1727
01:18:00,010 --> 01:18:01,930
also means that lots of different uses

1728
01:18:01,930 --> 01:18:03,460
can be made of the same infrastructure

1729
01:18:03,460 --> 01:18:06,100
but here the performance issues were so

1730
01:18:06,100 --> 01:18:07,360
extreme you know they would have to get

1731
01:18:07,360 --> 01:18:09,820
a 35 times performance improvement by

1732
01:18:09,820 --> 01:18:13,540
sort of blurring this boundary this was

1733
01:18:13,540 --> 01:18:14,830
a situation in which general-purpose

1734
01:18:14,830 --> 01:18:16,900
storage was actually really not

1735
01:18:16,900 --> 01:18:19,260
advantageous and they got a big win by

1736
01:18:19,260 --> 01:18:22,930
abandoning that idea and a final set of

1737
01:18:22,930 --> 01:18:24,540
things to get out of the papers all the

1738
01:18:24,540 --> 01:18:26,770
interesting sometimes kind of implicit

1739
01:18:26,770 --> 01:18:30,040
information about what was valuable to

1740
01:18:30,040 --> 01:18:32,560
these Amazon engineers who you know

1741
01:18:32,560 --> 01:18:35,320
really know what they're doing about

1742
01:18:35,320 --> 01:18:37,300
what concerns they had about cloud

1743
01:18:37,300 --> 01:18:41,050
infrastructure like the amount of worry

1744
01:18:41,050 --> 01:18:42,970
that they put into the possibility of an

1745
01:18:42,970 --> 01:18:45,610
entire availability zone might fail it's

1746
01:18:45,610 --> 01:18:48,250
an important tidbit the fact that

1747
01:18:48,250 --> 01:18:51,550
transient slowness of individual storage

1748
01:18:51,550 --> 01:18:53,980
servers was important is another thing

1749
01:18:53,980 --> 01:18:57,720
that actually also comes up a lot and

1750
01:18:57,720 --> 01:19:00,490
finally the implication that the network

1751
01:19:00,490 --> 01:19:02,530
is the main bottleneck because after all

1752
01:19:02,530 --> 01:19:04,660
they were it went to extreme lengths to

1753
01:19:04,660 --> 01:19:06,610
send less data over the network

1754
01:19:06,610 --> 01:19:08,050
but in return the storage servers have

1755
01:19:08,050 --> 01:19:10,810
to do more work and they put it they're

1756
01:19:10,810 --> 01:19:12,610
willing to you know 6 copies the data

1757
01:19:12,610 --> 01:19:16,800
and have 6 CPUs all replicating the

1758
01:19:16,800 --> 01:19:19,480
execution of applying these redo log

1759
01:19:19,480 --> 01:19:21,400
entries apparently CPU is relatively

1760
01:19:21,400 --> 01:19:24,460
cheap for them whereas the network

1761
01:19:24,460 --> 01:19:26,560
capacity was extremely important

1762
01:19:26,560 --> 01:19:31,630
all right that's all I have to say and

1763
01:19:31,900 --> 01:19:35,290
see you next week

