1
00:00:02,649 --> 00:00:07,220
好，今天，我想更多地讨论一些

2
00:00:07,220 --> 00:00:08,510
关于容错和复制的问题

3
00:00:08,510 --> 00:00:10,549
然后深入研究

4
00:00:10,549 --> 00:00:13,269
今天的关于 VMware 容错的论文的详细内容

5
00:00:13,269 --> 00:00:16,010
话题回到容错上来

6
00:00:16,010 --> 00:00:19,040
容错以提供高可用性————

7
00:00:19,040 --> 00:00:20,600
例如：当你想构建一个服务器时

8
00:00:20,600 --> 00:00:22,820
提供服务的硬件总是有崩溃的可能

9
00:00:22,820 --> 00:00:24,080
但是

10
00:00:24,080 --> 00:00:27,860
我们还是希望能稳定地提供服务

11
00:00:27,860 --> 00:00:29,120
甚至，我们想（并且可以）在即使出现了网络问题的时候

12
00:00:29,120 --> 00:00:31,250
依旧提供我们的服务————

13
00:00:31,250 --> 00:00:33,019
我们所使用到的工具就是“复制”

14
00:00:33,019 --> 00:00:36,620
至少在本课程的这一部分是这样

15
00:00:36,620 --> 00:00:39,070
一个很有价值的问题：

16
00:00:39,070 --> 00:00:42,039
复制能处理什么样的“失败”呢？

17
00:00:42,039 --> 00:00:46,480
因为这无论如何都不是一件小事

18
00:00:52,510 --> 00:00:55,609
使用最简单的方法来描述一下

19
00:00:55,609 --> 00:00:57,170
我们所能处理的那种“失败”————

20
00:00:57,170 --> 00:01:01,010
那就是单个计算机的“停止-失败”

21
00:01:01,010 --> 00:01:11,119
我所谓的“停止-失败”是什么呢？

22
00:01:11,119 --> 00:01:14,840
其实是一种通用的术语

23
00:01:14,840 --> 00:01:16,759
容错就是说如果有一些东西出了故障

24
00:01:16,759 --> 00:01:18,350
比如说一台计算机出了什么问题

25
00:01:18,350 --> 00:01:23,840
它就会简单地停止运行

26
00:01:23,840 --> 00:01:27,649
如果任何东西出了什么故障的话

27
00:01:27,649 --> 00:01:29,240
尤其需要注意的是：它不会计算出不正确的结果

28
00:01:29,240 --> 00:01:31,640
所以，如果有人断了你的电源

29
00:01:31,640 --> 00:01:35,240
把电源线从你的服务器上拔了出来

30
00:01:35,240 --> 00:01:36,950
那就有可能产生一个“停止-失败”

31
00:01:36,950 --> 00:01:41,090
类似地，如果他们拔了你的服务器的网络插头

32
00:01:41,090 --> 00:01:42,680
这也是一个“停止-失败”

33
00:01:42,680 --> 00:01:44,390
尽管你知道服务器仍在运行

34
00:01:44,390 --> 00:01:46,100
所以这就有点可笑

35
00:01:46,100 --> 00:01:47,420
因为对于网络另一头的我来说

36
00:01:47,420 --> 00:01:50,479
服务器断了网就和停止运行没啥两样

37
00:01:50,479 --> 00:01:51,890
所以这些错误是我们可以处理的错误

38
00:01:51,890 --> 00:01:55,810
复制能处理的问题也包括一些硬件问题

39
00:01:55,810 --> 00:01:59,479
比如

40
00:01:59,479 --> 00:02:02,299
你的服务器的风扇坏了

41
00:02:02,299 --> 00:02:04,909
可能因为太便宜了，哈哈

42
00:02:04,909 --> 00:02:06,740
这就有可能使 CPU 过热

43
00:02:06,740 --> 00:02:10,038
然后 CPU 就停止运行了

44
00:02:10,038 --> 00:02:12,849
干净利落

45
00:02:14,079 --> 00:02:18,469
我们所讨论的这种复制系统

46
00:02:18,469 --> 00:02:20,500
也有一些它不能处理的问题

47
00:02:20,500 --> 00:02:24,109
比如软件问题、软件漏洞

48
00:02:24,109 --> 00:02:29,359
或者一些更基本的、不是软件漏洞的硬件设计缺陷

49
00:02:29,359 --> 00:02:33,379
如果我们接受一些服务

50
00:02:33,379 --> 00:02:35,659
假如说，你有一台 MapReduce master 主机

51
00:02:35,659 --> 00:02:37,459
我们复制运行它

52
00:02:37,459 --> 00:02:39,530
我们在两台计算机上复制运行它

53
00:02:39,530 --> 00:02:41,180
如果你的 MapReduce master 有一个漏洞

54
00:02:41,180 --> 00:02:43,540
或者我的 MapReduce master 有一个漏洞

55
00:02:43,540 --> 00:02:45,379
那么复制对我们没有任何帮助

56
00:02:45,379 --> 00:02:46,760
我们还是会得到计算错误的结果

57
00:02:46,760 --> 00:02:50,169
在两台 MapReduce master 主机上都是这样

58
00:02:50,169 --> 00:02:53,959
并且从表面上看一切都好好的

59
00:02:53,959 --> 00:02:55,669
它们会默默允许让你碰上一个错误答案

60
00:02:55,669 --> 00:02:58,370
所以

61
00:02:58,370 --> 00:03:01,129
我们不能依赖于复制软件中的漏洞

62
00:03:01,129 --> 00:03:02,780
并且

63
00:03:02,780 --> 00:03:05,269
我们管理复制的方案中的漏洞也是不可防御的

64
00:03:05,269 --> 00:03:08,180
和我刚才提到的类似

65
00:03:08,180 --> 00:03:12,739
我们不能期望处理硬件中的漏洞

66
00:03:12,739 --> 00:03:14,180
这个硬件呢

67
00:03:14,180 --> 00:03:15,950
它会计算出不正确的结果

68
00:03:15,950 --> 00:03:18,530
事情也就这样了

69
00:03:18,530 --> 00:03:21,829
至少对于这种技术来说，也就如此了

70
00:03:21,829 --> 00:03:23,930
尽管肯定有一些硬件和软件漏洞

71
00:03:23,930 --> 00:03:26,540
是复制能解决的

72
00:03:26,540 --> 00:03:28,699
如果你足够幸运的话

73
00:03:28,699 --> 00:03:30,470
如果

74
00:03:30,470 --> 00:03:32,239
有一些不相关的软件运行在你的服务器上

75
00:03:32,239 --> 00:03:34,430
它使你的服务器崩溃了

76
00:03:34,430 --> 00:03:36,620
或者可能使你的 kernel 出现 panic 并重启

77
00:03:36,620 --> 00:03:38,449
或者什么也不做

78
00:03:38,449 --> 00:03:40,639
对你正复制的服务什么也不做

79
00:03:40,639 --> 00:03:42,709
那么

80
00:03:42,709 --> 00:03:45,650
这种错误对于我们的服务来说

81
00:03:45,650 --> 00:03:47,290
就是一种“停止-失败”

82
00:03:47,290 --> 00:03:50,810
你懂的，kernel 将会 panic

83
00:03:50,810 --> 00:03:56,479
并且备份复制会取而代之

84
00:03:56,479 --> 00:03:59,060
有一些种类的硬件错误

85
00:03:59,060 --> 00:04:03,260
可以被转化为“停止-失败”错误

86
00:04:03,260 --> 00:04:05,599
例如：如果你通过网络发送了一个包

87
00:04:05,599 --> 00:04:08,209
但是网络损坏了这个包，它翻转了一个比特位

88
00:04:08,209 --> 00:04:10,069
像这种情况

89
00:04:10,069 --> 00:04:11,930
几乎肯定可以通过校验和而检测出来

90
00:04:11,930 --> 00:04:13,939
一个磁盘块也是一样的

91
00:04:13,939 --> 00:04:15,949
如果你往磁盘上写了一些数据

92
00:04:15,949 --> 00:04:18,199
然后一个月后又把它读出来

93
00:04:18,199 --> 00:04:20,779
也许磁表面不是很完美

94
00:04:20,779 --> 00:04:22,010
在这个块上，最重要的那几个比特位是错的

95
00:04:22,010 --> 00:04:23,539
但是它能被正确地读出来

96
00:04:23,539 --> 00:04:24,980
这实际上是纠错功能

97
00:04:24,980 --> 00:04:26,990
能在一定程度上

98
00:04:26,990 --> 00:04:28,460
修复磁盘块中地错误

99
00:04:28,460 --> 00:04:31,420
这样的话

100
00:04:31,420 --> 00:04:35,600
一些随机的硬件错误可以被纠正

101
00:04:35,600 --> 00:04:39,140
如果你超级幸运的话

102
00:04:39,140 --> 00:04:40,910
或者至少可以检测到错误

103
00:04:40,910 --> 00:04:43,730
从而让软件知道

104
00:04:43,730 --> 00:04:45,470
知道发生了错误

105
00:04:45,470 --> 00:04:47,690
从而可以把硬件错误转化为一个“停止-失败”错误

106
00:04:47,690 --> 00:04:49,910
即时地停止运行或者采取一些其他的补救措施

107
00:04:49,910 --> 00:04:55,190
但是，一般来说

108
00:04:55,190 --> 00:04:57,560
我们只能期望去处理一些“停止-失败”错误

109
00:04:57,560 --> 00:05:02,180
复制还有一些其他的限制

110
00:05:02,180 --> 00:05:06,470
啊，其他限制

111
00:05:06,470 --> 00:05:08,630
不管失败发生在主要的那个复制中

112
00:05:08,630 --> 00:05:10,610
还是发生在备份的那个复制中或者其他怎样

113
00:05:10,610 --> 00:05:12,800
我们总是假设

114
00:05:12,800 --> 00:05:16,160
两个复制中的失败是相互独立的

115
00:05:16,160 --> 00:05:18,310
如果两个复制中总是有相关联的失败

116
00:05:18,310 --> 00:05:20,390
那么，复制将对我们没有帮助

117
00:05:20,390 --> 00:05:22,340
例如，如果我们有一整套设备

118
00:05:22,340 --> 00:05:24,380
我们买了成千上万的计算机

119
00:05:24,380 --> 00:05:26,390
啊，成千上万台计算机

120
00:05:26,390 --> 00:05:28,310
同一家厂商生产的成千上万的相同的计算机

121
00:05:28,310 --> 00:05:31,070
我们把我们的复制运行在上面

122
00:05:31,070 --> 00:05:33,650
我们一次在同一个地方买那么多电脑

123
00:05:33,650 --> 00:05:35,510
这可有一点风险

124
00:05:35,510 --> 00:05:35,990
啊，有点风险

125
00:05:35,990 --> 00:05:39,020
因为很可能

126
00:05:39,020 --> 00:05:40,730
其中一个有了缺陷

127
00:05:40,730 --> 00:05:43,130
其他的也有相同的缺陷

128
00:05:43,130 --> 00:05:44,390
比如说

129
00:05:44,390 --> 00:05:47,810
由于制造商没有设计好散热系统

130
00:05:47,810 --> 00:05:49,220
导致其中的一个过热了

131
00:05:49,220 --> 00:05:51,500
那么很有可能这一批货都有这个问题

132
00:05:51,500 --> 00:05:53,990
所以如果其中一个过热、宕机了

133
00:05:53,990 --> 00:05:56,350
那么其他的也很有可能同样宕机

134
00:05:56,350 --> 00:05:59,060
这是相关失败的一种

135
00:05:59,060 --> 00:06:01,040
你要小心的是另一种

136
00:06:01,040 --> 00:06:02,570
比如说

137
00:06:02,570 --> 00:06:03,890
地震了

138
00:06:03,890 --> 00:06:05,510
地震正好发生在存储着我们的数据的数据中心所在的城市

139
00:06:05,510 --> 00:06:07,310
在这种情况下

140
00:06:07,310 --> 00:06:08,630
无论我们在那个数据中心里弄多少复制

141
00:06:08,630 --> 00:06:10,010
也无济于事

142
00:06:10,010 --> 00:06:12,080
因为这种失败

143
00:06:12,080 --> 00:06:14,060
这种由地震、全市停电引起的失败

144
00:06:14,060 --> 00:06:15,950
或者建筑失火这种

145
00:06:15,950 --> 00:06:17,720
它是相关失败

146
00:06:17,720 --> 00:06:19,490
同一建筑内的复制之间的相关失败

147
00:06:19,490 --> 00:06:21,290
所以如果我们想处理地震带来的问题

148
00:06:21,290 --> 00:06:24,020
那么

149
00:06:24,020 --> 00:06:26,150
我们需要把我们的复制放在不同的城市

150
00:06:26,150 --> 00:06:28,010
至少把它们在物理上足够分隔开

151
00:06:28,010 --> 00:06:29,720
让它们分别供电

152
00:06:29,720 --> 00:06:31,760
这样它们就不会被同一自然灾害所影响了

153
00:06:31,760 --> 00:06:34,750
对，不会

154
00:06:35,140 --> 00:06:37,790
好了，这就是全部种类的不稳定性了

155
00:06:37,790 --> 00:06:39,170
至少在我们这次讨论的背景下

156
00:06:39,170 --> 00:06:41,510
我们所讨论的正是你可能会使用的技术

157
00:06:41,510 --> 00:06:44,660
还有一个关于复制的问题

158
00:06:44,660 --> 00:06:46,640
你可能会问你自己

159
00:06:46,640 --> 00:06:49,520
天呐

160
00:06:49,520 --> 00:06:51,760
使用 2 倍甚至 3 倍计算机资源的复制方案，这真的值得吗

161
00:06:51,760 --> 00:06:55,190
使用 2 倍甚至 3 倍计算机资源的复制方案，这真的值得吗

162
00:06:55,190 --> 00:06:57,740
对了

163
00:06:57,740 --> 00:06:59,480
我们需要让 GFS 的每一个 block 都有三份拷贝的话

164
00:06:59,480 --> 00:07:01,130
我们就得买三倍容量的磁盘

165
00:07:01,130 --> 00:07:03,590
啊，今天的那篇论文呢

166
00:07:03,590 --> 00:07:05,870
只复制了一次

167
00:07:05,870 --> 00:07:07,760
但是那意味着我们有两倍的计算机、CPU 和 RAM

168
00:07:07,760 --> 00:07:10,520
这些东西都是很昂贵的

169
00:07:10,520 --> 00:07:11,990
这真的很值得吗

170
00:07:11,990 --> 00:07:16,070
并且

171
00:07:16,070 --> 00:07:17,540
这不是一个我们能从技术上回答正确的问题

172
00:07:17,540 --> 00:07:19,040
这是一个经济上的问题

173
00:07:19,040 --> 00:07:21,140
这个问题取决于获取一个可用的服务的价值

174
00:07:21,140 --> 00:07:22,940
这个问题取决于获取一个可用的服务的价值

175
00:07:22,940 --> 00:07:26,090
比如说你在运行一个银行服务

176
00:07:26,090 --> 00:07:27,740
计算机宕机的后果就是

177
00:07:27,740 --> 00:07:29,300
你不能服务你的顾客了

178
00:07:29,300 --> 00:07:31,220
你也就不能获得收入了

179
00:07:31,220 --> 00:07:33,440
你的顾客们也会恨你

180
00:07:33,440 --> 00:07:35,540
权衡之下，多花一两万在一台备份计算机上很可能是值得的

181
00:07:35,540 --> 00:07:37,370
权衡之下，多花一两万在一台备份计算机上很可能是值得的

182
00:07:37,370 --> 00:07:40,220
所以，你可以复制一份

183
00:07:40,220 --> 00:07:41,900
另一方面，假如你是我，你在运行维护 6.824 的网站服务器

184
00:07:41,900 --> 00:07:46,220
另一方面，假如你是我，你在运行维护 6.824 的网站服务器

185
00:07:46,220 --> 00:07:48,680
我觉得不值得给 6.824 网站做热备份

186
00:07:48,680 --> 00:07:50,960
我觉得不值得给 6.824 网站做热备份

187
00:07:50,960 --> 00:07:55,340
因为运行失败所造成的后果没什么大不了的

188
00:07:55,340 --> 00:07:58,460
复制是否值得？

189
00:07:58,460 --> 00:08:00,230
该复制多少份？

190
00:08:00,230 --> 00:08:02,090
这都取决于

191
00:08:02,090 --> 00:08:04,220
你愿意花费多少在这上面

192
00:08:04,220 --> 00:08:08,330
取决于当失败发生时会给你带来多大的损失和不便

193
00:08:08,330 --> 00:08:11,840
好了

194
00:08:11,840 --> 00:08:14,810
开头提到的这篇论文

195
00:08:14,810 --> 00:08:16,270
介绍了几种不同的复制方法

196
00:08:16,270 --> 00:08:19,820
啊，其实介绍了两种

197
00:08:19,820 --> 00:08:21,740
一种叫做 状态转移

198
00:08:21,740 --> 00:08:30,350
另一种叫做 复制状态机

199
00:08:30,350 --> 00:08:35,150
在这个班上呢

200
00:08:35,150 --> 00:08:36,230
我们主要讨论复制状态机

201
00:08:36,230 --> 00:08:39,280
我们主要讨论复制状态机

202
00:08:39,789 --> 00:08:42,799
但我们也会讨论状态转移的

203
00:08:42,799 --> 00:08:44,179
状态转移背后的思想是

204
00:08:44,179 --> 00:08:49,100
如果我们有一个服务器的两份复制

205
00:08:49,100 --> 00:08:51,470
你让它们保持同步的方式就是

206
00:08:51,470 --> 00:08:55,010
让它们成为实际上的复制

207
00:08:55,010 --> 00:08:57,529
使备份拥有它需要的一切

208
00:08:57,529 --> 00:08:59,630
以便当主机宕机时备份能够接管

209
00:08:59,630 --> 00:09:02,390
在一个状态转移模式中

210
00:09:02,390 --> 00:09:04,490
它工作的方式就是，主机发送一份整个自身状态的拷贝

211
00:09:04,490 --> 00:09:06,320
比如

212
00:09:06,320 --> 00:09:09,140
它内存的内容，把它发送给备份

213
00:09:09,140 --> 00:09:11,209
备份只是存储最新的状态

214
00:09:11,209 --> 00:09:13,279
这样，备份就有全部的主机状态

215
00:09:13,279 --> 00:09:15,470
主机如果宕机了的话

216
00:09:15,470 --> 00:09:18,680
备份就可以开始运行在最新状态

217
00:09:18,680 --> 00:09:20,899
如果主机宕机了的话

218
00:09:20,899 --> 00:09:23,750
所以这完全就是发送主机的状态

219
00:09:23,750 --> 00:09:26,450
今天

220
00:09:26,450 --> 00:09:28,250
如果今天的论文以一个状态转移系统来运行的话

221
00:09:28,250 --> 00:09:29,899
其实并不是

222
00:09:29,899 --> 00:09:31,339
我们所讨论的状态就是 RAM 里的内容

223
00:09:31,339 --> 00:09:33,320
主机的内存里的内容

224
00:09:33,320 --> 00:09:35,959
所以

225
00:09:35,959 --> 00:09:38,390
可能每次主机复制了一大份拷贝

226
00:09:38,390 --> 00:09:39,890
一大份自身内存的拷贝并且发送的时候

227
00:09:39,890 --> 00:09:41,600
需要通过网络发送给备份

228
00:09:41,600 --> 00:09:42,860

229
00:09:42,860 --> 00:09:44,089

230
00:09:44,089 --> 00:09:45,950

231
00:09:45,950 --> 00:09:48,020

232
00:09:48,020 --> 00:09:51,709

233
00:09:51,709 --> 00:09:52,940

234
00:09:52,940 --> 00:09:55,850

235
00:09:55,850 --> 00:09:57,560

236
00:09:57,560 --> 00:10:00,589

237
00:10:00,589 --> 00:10:05,330
确定性的操作

238
00:10:05,330 --> 00:10:08,839
除非外部输入到来

239
00:10:08,839 --> 00:10:10,880
通常情况下，如果计算机没有外部影响

240
00:10:10,880 --> 00:10:12,770
通常情况下，如果计算机没有外部影响

241
00:10:12,770 --> 00:10:14,330
它只是一个接一个地执行指令

242
00:10:14,330 --> 00:10:16,010
每条指令做的是

243
00:10:16,010 --> 00:10:18,770
一个计算机内存和寄存器中内容的确定性函数

244
00:10:18,770 --> 00:10:20,390
一个计算机内存和寄存器中内容的确定性函数

245
00:10:20,390 --> 00:10:22,400
而且只有当外部事件干预时，才可能发生意外情况

246
00:10:22,400 --> 00:10:25,190
而且只有当外部事件干预时，才可能发生意外情况

247
00:10:25,190 --> 00:10:27,440
像是某个随机时间到达的数据包

248
00:10:27,440 --> 00:10:31,550
导致服务器开始做些不一样的事

249
00:10:31,550 --> 00:10:33,800
导致服务器开始做些不一样的事

250
00:10:33,800 --> 00:10:36,410
复制的状态机方案不会在副本之间发送状态

251
00:10:36,410 --> 00:10:39,260
复制的状态机方案不会在副本之间发送状态

252
00:10:39,260 --> 00:10:41,029
相反，他们只是发送这些外部事件

253
00:10:41,029 --> 00:10:45,500
相反，他们只是发送这些外部事件

254
00:10:45,500 --> 00:10:47,839
只是从primary发送到backup

255
00:10:47,839 --> 00:10:50,420
只是发送backup需要了解的信息，例如从外界获取的输入

256
00:10:50,420 --> 00:10:52,550
只是发送backup需要了解的信息，例如从外界获取的输入

257
00:10:52,550 --> 00:10:52,910
只是发送backup需要了解的信息，例如从外界获取的输入

258
00:10:52,910 --> 00:10:55,370
观察结果是

259
00:10:55,370 --> 00:10:57,050
如果有两台计算机

260
00:10:57,050 --> 00:11:00,110
并且它们从相同的状态开始

261
00:11:00,110 --> 00:11:03,740
并且它们以相同的顺序或相同的时间看到相同的输入

262
00:11:03,740 --> 00:11:05,810
并且它们以相同的顺序或相同的时间看到相同的输入

263
00:11:05,810 --> 00:11:08,150
则两台计算机将继续互为彼此的复制

264
00:11:08,150 --> 00:11:10,490
并以相同的方式执行

265
00:11:10,490 --> 00:11:12,020
只要他们俩同时看到相同的输入

266
00:11:12,020 --> 00:11:17,360
这可能转移了内存

267
00:11:17,360 --> 00:11:21,380
这传递给primary和backup

268
00:11:21,380 --> 00:11:25,670
来自client的操作或外部输入或外部事件

269
00:11:25,670 --> 00:11:27,890
来自client的操作或外部输入或外部事件

270
00:11:27,890 --> 00:11:33,230
人们倾向于使用复制状态机的原因

271
00:11:33,230 --> 00:11:35,810
人们倾向于使用复制状态机的原因

272
00:11:35,810 --> 00:11:39,350
在于通常操作要比状态小

273
00:11:39,350 --> 00:11:41,630
在于通常操作要比状态小

274
00:11:41,630 --> 00:11:43,130
服务器的状态，如果是数据库服务器

275
00:11:43,130 --> 00:11:44,630
可能是整个数据库

276
00:11:44,630 --> 00:11:47,060
可能是千兆字节

277
00:11:47,060 --> 00:11:48,680
而操作只是一些客户端发送的

278
00:11:48,680 --> 00:11:51,110
比如，请读写key27

279
00:11:51,110 --> 00:11:53,690
操作通常很小

280
00:11:53,690 --> 00:11:55,190
状态通常很大

281
00:11:55,190 --> 00:11:57,470
因此复制状态机通常看起来很吸引人

282
00:11:57,470 --> 00:11:59,090
轻微的缺点是这些方案往往要复杂得多

283
00:11:59,090 --> 00:12:01,490
轻微的缺点是这些方案往往要复杂得多

284
00:12:01,490 --> 00:12:05,900
并且依赖于计算机运行方式的更多假设

285
00:12:05,900 --> 00:12:08,930
并且依赖于计算机运行方式的更多假设

286
00:12:08,930 --> 00:12:10,640
然而这种方案则简单粗暴

287
00:12:10,640 --> 00:12:12,380
我只是要寄给你 我的整个状态

288
00:12:12,380 --> 00:12:14,440
没什么要担心的

289
00:12:14,440 --> 00:12:22,180
关于这些策略，有什么问题吗

290
00:12:27,649 --> 00:12:30,930
好吧，所以问题是

291
00:12:30,930 --> 00:12:32,760
假设我们的方案出了点问题

292
00:12:32,760 --> 00:12:34,410
backup实际上与primary不一样

293
00:12:34,410 --> 00:12:40,579
backup实际上与primary不一样

294
00:12:40,579 --> 00:12:44,790
假设我们正在运行一个GFS master服务器

295
00:12:44,790 --> 00:12:47,220
这是master

296
00:12:47,220 --> 00:12:49,949
它刚刚将租约分发给了chunk服务器一

297
00:12:49,949 --> 00:12:55,019
但是因为

298
00:12:55,019 --> 00:12:56,910
因为因为我们允许primary和backup节点的状态不同步

299
00:12:56,910 --> 00:12:59,910
因为因为我们允许primary和backup节点的状态不同步

300
00:12:59,910 --> 00:13:01,470
备份没有向任何人发出租约

301
00:13:01,470 --> 00:13:02,850
甚至没有意识到有人请求租约

302
00:13:02,850 --> 00:13:04,380
现在primary服务器认为chunk服务器持有某些块的租约

303
00:13:04,380 --> 00:13:05,880
现在primary服务器认为chunk服务器持有某些块的租约

304
00:13:05,880 --> 00:13:08,600
而backup并没有，primary服务器失败

305
00:13:08,600 --> 00:13:11,250
backup接手 现在chunk服务器一

306
00:13:11,250 --> 00:13:13,620
认为它持有某些块的租约

307
00:13:13,620 --> 00:13:17,850
但是当前的primary服务器不知道

308
00:13:17,850 --> 00:13:19,440
并且很乐意将租约分发给其他chunk服务器

309
00:13:19,440 --> 00:13:20,880
现在我们有两个chunk服务器提供相同的租约

310
00:13:20,880 --> 00:13:23,250
现在我们有两个chunk服务器提供相同的租约

311
00:13:23,250 --> 00:13:25,230
那只是一个接近家庭的例子

312
00:13:25,230 --> 00:13:28,019
但实际上几乎所有坏事

313
00:13:28,019 --> 00:13:30,230
我认为你可以构造任何坏的情况

314
00:13:30,230 --> 00:13:32,880
想象某些服务会因为状态不同，导致计算出错误答案

315
00:13:32,880 --> 00:13:35,579
想象某些服务会因为状态不同，导致计算出错误答案

316
00:13:35,579 --> 00:13:38,480
想象某些服务会因为状态不同，导致计算出错误答案

317
00:13:42,740 --> 00:13:46,610
你问了随机化的问题

318
00:13:50,600 --> 00:13:53,850
是的，哦，你们都在谈论这个

319
00:13:53,850 --> 00:13:55,950
我待会儿再说

320
00:13:55,950 --> 00:13:58,320
当primary和backup正在执行的相同的指令时

321
00:13:58,320 --> 00:14:02,880
当primary和backup正在执行的相同的指令时

322
00:14:02,880 --> 00:14:04,320
复制状态机方案绝对是最有意义的

323
00:14:04,320 --> 00:14:06,570
复制状态机方案绝对是最有意义的

324
00:14:06,570 --> 00:14:08,370
只要没有外部事件

325
00:14:08,370 --> 00:14:10,740
这对于add指令之类的东西几乎是正确的

326
00:14:10,740 --> 00:14:12,480
这对于add指令之类的东西几乎是正确的

327
00:14:12,480 --> 00:14:14,880
是的

328
00:14:14,880 --> 00:14:16,350
如果它们的寄存器和存储器都相同

329
00:14:16,350 --> 00:14:17,790
并且它们都执行一条add指令

330
00:14:17,790 --> 00:14:19,080
那么add指令在相同的输出中具有相同的输入

331
00:14:19,080 --> 00:14:20,730
那么add指令在相同的输出中具有相同的输入

332
00:14:20,730 --> 00:14:22,200
但是在某些指令中

333
00:14:22,200 --> 00:14:23,880
正如你指出的那样

334
00:14:23,880 --> 00:14:26,400
比如一条获取当前时间的指令可以

335
00:14:26,400 --> 00:14:27,690
可能会在略有不同的时间执行

336
00:14:27,690 --> 00:14:29,790
可能会在略有不同的时间执行

337
00:14:29,790 --> 00:14:32,250
或者获得当前处理器唯一ID

338
00:14:32,250 --> 00:14:34,830
和序列号的指令将产生不同的答案

339
00:14:34,830 --> 00:14:38,400
和序列号的指令将产生不同的答案

340
00:14:38,400 --> 00:14:39,930
这些问题的统一的答案

341
00:14:39,930 --> 00:14:42,360
是primary执行指令

342
00:14:42,360 --> 00:14:44,730
并将答案发送给backup

343
00:14:44,730 --> 00:14:46,830
backup不执行该指令

344
00:14:46,830 --> 00:14:48,900
但是在执行该指令的地方

345
00:14:48,900 --> 00:14:50,120
但是在执行该指令的地方

346
00:14:50,120 --> 00:14:52,740
它会听从primary

347
00:14:52,740 --> 00:14:54,090
告诉它正确的答案是什么

348
00:14:54,090 --> 00:14:56,670
只是伪造了答案给软件

349
00:14:56,670 --> 00:15:00,810
我将讨论VMware方案如何做到这一点

350
00:15:00,810 --> 00:15:04,550
我将讨论VMware方案如何做到这一点

351
00:15:04,550 --> 00:15:06,690
有趣的是

352
00:15:06,690 --> 00:15:09,810
今天的论文都是关于复制状态机的

353
00:15:09,810 --> 00:15:12,150
你可能已经注意到

354
00:15:12,150 --> 00:15:13,680
今天的论文仅涉及单处理器

355
00:15:13,680 --> 00:15:15,330
而且还不清楚如何将其扩展到多核机器

356
00:15:15,330 --> 00:15:18,680
而且还不清楚如何将其扩展到多核机器

357
00:15:18,680 --> 00:15:21,810
在多核机器中

358
00:15:21,810 --> 00:15:23,550
两个核的指令的交织是不确定的

359
00:15:23,550 --> 00:15:24,750
两个核的指令的交织是不确定的

360
00:15:24,750 --> 00:15:26,610
两个核的指令的交织是不确定的

361
00:15:26,610 --> 00:15:27,720
因此，我们不再在多核计算机上出现这种情况

362
00:15:27,720 --> 00:15:29,670
因为如果让主数据库和备份计算机执行，

363
00:15:29,670 --> 00:15:31,200
其他条件都相同，

364
00:15:31,200 --> 00:15:32,970
那么它们将是相同的

365
00:15:32,970 --> 00:15:34,670
那么它们将是相同的

366
00:15:34,670 --> 00:15:37,530
因为它们不会在多核计算机上执行

367
00:15:37,530 --> 00:15:39,600
VMware之后推出了一个可能完全不同的新复制系统

368
00:15:39,600 --> 00:15:42,240
VMware之后推出了一个可能完全不同的新复制系统

369
00:15:42,240 --> 00:15:44,070
该系统可以在多核上运行

370
00:15:44,070 --> 00:15:46,890
在我看来，新系统使用状态转移而不是复制状态机

371
00:15:46,890 --> 00:15:49,530
在我看来，新系统使用状态转移而不是复制状态机

372
00:15:49,530 --> 00:15:50,940
因为面对多核和并行性，状态转移更加健壮

373
00:15:50,940 --> 00:15:53,190
因为面对多核和并行性，状态转移更加健壮

374
00:15:53,190 --> 00:15:56,340
因为面对多核和并行性，状态转移更加健壮

375
00:15:56,340 --> 00:15:58,380
如果您使用机器并将内存发送过来

376
00:15:58,380 --> 00:16:00,690
内存映像只是机器的状态而已

377
00:16:00,690 --> 00:16:02,250
内存映像只是机器的状态而已

378
00:16:02,250 --> 00:16:04,470
并行性并不影响

379
00:16:04,470 --> 00:16:06,600
并行性并不影响

380
00:16:06,600 --> 00:16:08,280
而复制状态机方案确实存在并行性问题

381
00:16:08,280 --> 00:16:12,780
而复制状态机方案确实存在并行性问题

382
00:16:12,780 --> 00:16:15,000
另一方面，我猜想这种新的多核方案会更昂贵

383
00:16:15,000 --> 00:16:20,930
另一方面，我猜想这种新的多核方案会更昂贵

384
00:16:21,200 --> 00:16:24,660
好的，如果我们要构建一个复制状态机方案

385
00:16:24,660 --> 00:16:26,250
好的，如果我们要构建一个复制状态机方案

386
00:16:26,250 --> 00:16:31,200
我们有很多问题要回答

387
00:16:31,200 --> 00:16:32,430
我们需要决定要在什么级别上复制状态

388
00:16:32,430 --> 00:16:36,360
我们需要决定要在什么级别上复制状态

389
00:16:36,360 --> 00:16:44,430
我们所说的状态是什么

390
00:16:44,430 --> 00:16:47,670
我们必须担心primary和backup之间紧密同步的程度

391
00:16:47,670 --> 00:16:49,710
我们必须担心primary和backup之间紧密同步的程度

392
00:16:49,710 --> 00:16:51,810
因为primary可能领先backup执行一些

393
00:16:51,810 --> 00:16:53,400
因为primary可能领先backup执行一些

394
00:16:53,400 --> 00:16:55,110
毕竟，是primary看到输入

395
00:16:55,110 --> 00:16:57,570
因此备份几乎必须滞后于

396
00:16:57,570 --> 00:17:00,360
因此备份几乎必须滞后于

397
00:17:00,360 --> 00:17:01,950
这意味着有可能primary出现故障

398
00:17:01,950 --> 00:17:04,500
这意味着有可能primary出现故障

399
00:17:04,500 --> 00:17:08,849
且backup没能完全追上primary

400
00:17:08,849 --> 00:17:11,760
使backup与primary完全同步执行实际上是昂贵的

401
00:17:11,760 --> 00:17:12,959
使backup与primary完全同步执行实际上是昂贵的

402
00:17:12,959 --> 00:17:14,550
因为需要很多时间

403
00:17:14,550 --> 00:17:16,319
因此，很多设计

404
00:17:16,319 --> 00:17:19,470
人们担心的是同步有多紧密

405
00:17:19,470 --> 00:17:27,810
如果primary发生故障

406
00:17:27,810 --> 00:17:29,760
或者您实际上知道backup是否也失败

407
00:17:29,960 --> 00:17:31,590
但是如果primary发生故障则更令人兴奋

408
00:17:31,590 --> 00:17:33,210
必须有一些切换方案

409
00:17:33,210 --> 00:17:34,650
客户端必须知道

410
00:17:34,650 --> 00:17:37,830
哦，天哪，我现在不应该与服务器一上的旧primary通信

411
00:17:37,830 --> 00:17:39,780
哦，天哪，我现在不应该与服务器一上的旧primary通信

412
00:17:39,780 --> 00:17:44,520
我现在应该与服务器二上的backup服务器通信

413
00:17:44,520 --> 00:17:47,970
我现在应该与服务器二上的backup服务器通信

414
00:17:47,970 --> 00:17:50,280
所有客户端都必须以某种方式解决此问题

415
00:17:50,280 --> 00:17:53,340
切换几乎可以肯定

416
00:17:53,340 --> 00:17:55,860
几乎不可能设计一个

417
00:17:55,860 --> 00:17:58,560
不会出现任何异常现象的切入系统

418
00:17:58,560 --> 00:18:00,960
不会出现任何异常现象的切入系统

419
00:18:00,960 --> 00:18:03,000
在这种理想的世界中

420
00:18:03,000 --> 00:18:05,070
如果primary失败，没有人注意到

421
00:18:05,070 --> 00:18:07,080
没有client注意到

422
00:18:07,080 --> 00:18:10,920
这基本上是无法实现的

423
00:18:10,920 --> 00:18:15,120
所以在切入过程中会出现异常

424
00:18:15,120 --> 00:18:16,500
我们必须找出一种应对它们的方法

425
00:18:16,500 --> 00:18:19,560
我们必须找出一种应对它们的方法

426
00:18:19,560 --> 00:18:21,750
如果我们的复制之一失败了

427
00:18:21,750 --> 00:18:23,790
我们真的需要一个新的复制

428
00:18:23,790 --> 00:18:26,820
如果我们有两个复制，其中一个失败

429
00:18:26,820 --> 00:18:29,010
我们只是靠借来的时间生活

430
00:18:29,010 --> 00:18:31,710
因为第二个复制可能在某个时候失败

431
00:18:31,710 --> 00:18:33,990
因此，我们绝对需要使新复制尽快上线

432
00:18:33,990 --> 00:18:36,240
因此，我们绝对需要使新复制尽快上线

433
00:18:36,240 --> 00:18:41,250
那可能很昂贵

434
00:18:41,250 --> 00:18:44,610
状态很大

435
00:18:44,610 --> 00:18:45,690
但是我们喜欢复制状态机的原因是

436
00:18:45,690 --> 00:18:47,190
因为我们认为状态转移会很昂贵

437
00:18:47,190 --> 00:18:49,320
因为我们认为状态转移会很昂贵

438
00:18:49,320 --> 00:18:51,450
但复制状态机中的两个复制仍需要具有完整状态

439
00:18:51,450 --> 00:18:53,040
但复制状态机中的两个复制仍需要具有完整状态

440
00:18:53,040 --> 00:18:55,230
我们只是有一种便宜的方法来使它们保持同步

441
00:18:55,230 --> 00:18:57,210
如果我们需要创建新复制的话

442
00:18:57,210 --> 00:18:59,700
实际上我们别无选择

443
00:18:59,700 --> 00:19:01,410
只能进行状态转移以创建新的复制

444
00:19:01,410 --> 00:19:03,090
新复制需要具有状态的完整状态

445
00:19:03,090 --> 00:19:06,090
新复制需要具有状态的完整状态

446
00:19:06,090 --> 00:19:08,100
因此创建新复制将非常昂贵

447
00:19:08,100 --> 00:19:15,300
人们通常会花费很多

448
00:19:15,300 --> 00:19:16,530
实际上人们花很多时间担心所有这些问题

449
00:19:16,530 --> 00:19:18,750
实际上人们花很多时间担心所有这些问题

450
00:19:18,750 --> 00:19:20,490
我们在查看其他复制状态机方案时会再次看到它们

451
00:19:20,490 --> 00:19:22,980
我们在查看其他复制状态机方案时会再次看到它们

452
00:19:22,980 --> 00:19:29,460
所以关于什么状态要复制的话题

453
00:19:29,460 --> 00:19:33,720
今天的论文对这个问题有一个非常有趣的答案

454
00:19:33,720 --> 00:19:35,880
今天的论文对这个问题有一个非常有趣的答案

455
00:19:35,880 --> 00:19:38,160
它复制了机器的完整状态

456
00:19:38,160 --> 00:19:42,060
即所有内存和所有机器寄存器

457
00:19:42,060 --> 00:19:45,030
即所有内存和所有机器寄存器

458
00:19:45,030 --> 00:19:48,780
是一个非常详细的复制方案

459
00:19:48,780 --> 00:19:51,120
primary和backup，即使是最底层，也完全一样

460
00:19:51,120 --> 00:19:52,620
primary和backup，即使是最底层，也完全一样

461
00:19:52,620 --> 00:19:55,560
对于复制方案而言，这是非常罕见的

462
00:19:55,560 --> 00:19:56,670
对于复制方案而言，这是非常罕见的

463
00:19:56,670 --> 00:19:58,680
比如说GFS

464
00:19:58,680 --> 00:20:01,200
GFS当然

465
00:20:01,200 --> 00:20:03,630
不会复制（具体到每个bit）。你知道，GFS有

466
00:20:03,630 --> 00:20:05,700
复制方案，但他不是复制

467
00:20:05,700 --> 00:20:08,220
内存中的每一个bit

468
00:20:08,220 --> 00:20:10,170
在primary和backup之间。

469
00:20:10,170 --> 00:20:12,180
他们的复制更多是在应用层面

470
00:20:12,180 --> 00:20:14,910
(例如)块的表。

471
00:20:14,910 --> 00:20:16,950
我曾经概括过（GFS），正如你所知

472
00:20:16,950 --> 00:20:18,630
块和块id

473
00:20:18,630 --> 00:20:20,370
是被复制的东西（在GFS中）。他不会

474
00:20:20,370 --> 00:20:22,290
复制除此以外的任何东西，

475
00:20:22,290 --> 00:20:24,570
不是尝试花费巨大的代价

476
00:20:24,570 --> 00:20:26,430
去复制这些机器上面所有除此之外的东西。

477
00:20:26,430 --> 00:20:28,440
只要这些机器拥有同样的

478
00:20:28,440 --> 00:20:31,410
应用可见的chunk的集合

479
00:20:31,410 --> 00:20:37,410
我们就认为可以了。因此，

480
00:20:37,410 --> 00:20:40,530
大多数复制方案都采用与GFS相似的方案

481
00:20:40,530 --> 00:20:42,750
实际上，几乎除了这篇论文

482
00:20:42,750 --> 00:20:46,800
以及一些类似的系统之外

483
00:20:46,800 --> 00:20:48,750
的所有方案

484
00:20:48,750 --> 00:20:50,220
他们几乎都使用了

485
00:20:50,220 --> 00:20:53,730
应用级别的复制

486
00:20:53,730 --> 00:20:56,940
因为这样可以更有效率

487
00:20:56,940 --> 00:20:58,560
因为我们不必费力的

488
00:20:58,560 --> 00:21:00,960
去确保，例如，

489
00:21:00,960 --> 00:21:02,790
在主和副本服务运行时

490
00:21:02,790 --> 00:21:04,980
中断发生在完全相同的时间点

491
00:21:04,980 --> 00:21:07,260
GFS完全不用担心这点

492
00:21:07,260 --> 00:21:09,420
但是这篇论文必须要确保这点

493
00:21:09,420 --> 00:21:11,340
因为它在很低的级别进行复制

494
00:21:11,340 --> 00:21:14,520
因此大多数人

495
00:21:14,520 --> 00:21:16,560
使用特定于应用程序的复制来构建高效的系统

496
00:21:16,560 --> 00:21:18,840
这样做的后果是

497
00:21:18,840 --> 00:21:20,880
必须将复制方案

498
00:21:20,880 --> 00:21:21,900
内置到应用程序中

499
00:21:21,900 --> 00:21:23,580
例如，如果你需要获取

500
00:21:23,580 --> 00:21:26,790
应用程序级别的业务流程

501
00:21:26,790 --> 00:21:28,950
你就需要

502
00:21:28,950 --> 00:21:31,010
让应用程序参与其中

503
00:21:31,010 --> 00:21:33,720
因为有些通用的复制方案

504
00:21:33,720 --> 00:21:34,320
例如今天的论文

505
00:21:34,320 --> 00:21:37,440
并不能理解

506
00:21:37,440 --> 00:21:41,120
哪些东西需要被复制的语义

507
00:21:41,240 --> 00:21:44,520
因此大多数方案是针对于特定应用的

508
00:21:44,520 --> 00:21:47,340
例如GFS以及我们将要在这个主题下阅读的

509
00:21:47,340 --> 00:21:49,310
所有其他论文

510
00:21:49,310 --> 00:21:52,320
今天的论文的不同之处在于

511
00:21:52,320 --> 00:21:54,420
它是在机器级别进行复制的

512
00:21:54,420 --> 00:21:55,890
因此它不关心在其上

513
00:21:55,890 --> 00:21:57,870
运行了什么软件

514
00:21:57,870 --> 00:22:00,450
它复制低级别的

515
00:22:00,450 --> 00:22:01,920
内存以及寄存器

516
00:22:01,920 --> 00:22:03,600
你可以其上运行任何软件

517
00:22:03,600 --> 00:22:05,250
只要它可以在

518
00:22:05,250 --> 00:22:06,870
这种复制方案支持的微处理器上运行

519
00:22:06,870 --> 00:22:08,730
这种复制方案

520
00:22:08,730 --> 00:22:10,399
可以适应任何软件

521
00:22:10,399 --> 00:22:14,080
缺点是

522
00:22:14,080 --> 00:22:16,399
效率不一定高

523
00:22:16,399 --> 00:22:18,559
优点是你可以使用任何现有的软件

524
00:22:18,559 --> 00:22:20,000
甚至你没有源代码

525
00:22:20,000 --> 00:22:21,889
或者不知道它是如何工作的

526
00:22:21,889 --> 00:22:26,029
在一定的限制下

527
00:22:26,029 --> 00:22:27,440
你就可以

528
00:22:27,440 --> 00:22:29,299
在VMware的复制方案下运行它

529
00:22:29,299 --> 00:22:33,940
它可以正常工作，像魔法一样

530
00:22:33,940 --> 00:22:36,889
且对于任意软件都可以进行容错

531
00:22:36,889 --> 00:22:44,260
现在

532
00:22:44,260 --> 00:22:51,230
我们来讨论VMware FT

533
00:22:51,230 --> 00:22:53,029
首先，VMware是一家虚拟机公司

534
00:22:53,029 --> 00:22:56,960
他们的很多业务

535
00:22:56,960 --> 00:22:58,340
都是销售虚拟机技术

536
00:22:58,340 --> 00:23:00,320
虚拟机

537
00:23:00,320 --> 00:23:04,279
指的是

538
00:23:04,279 --> 00:23:07,269
你买一台电脑

539
00:23:07,269 --> 00:23:09,289
在硬件上不是启动

540
00:23:09,289 --> 00:23:12,289
像Linux这样的操作系统

541
00:23:12,289 --> 00:23:16,190
你在硬件上

542
00:23:16,190 --> 00:23:18,169
启动虚拟机监视器

543
00:23:18,169 --> 00:23:19,669
虚拟机监视器就会

544
00:23:19,669 --> 00:23:24,429
在此硬件上

545
00:23:24,429 --> 00:23:27,110
模拟多台虚拟的电脑

546
00:23:27,110 --> 00:23:28,820
因此虚拟机监视器可能会启动

547
00:23:28,820 --> 00:23:31,220

548
00:23:31,220 --> 00:23:34,580
或者多个Linux实例

549
00:23:34,580 --> 00:23:37,149
或者一个Windows实例

550
00:23:37,149 --> 00:23:40,399
这台计算机上的

551
00:23:40,399 --> 00:23:42,260
虚拟机监视器可以运行

552
00:23:42,260 --> 00:23:45,470
许多不同的操作系统

553
00:23:45,470 --> 00:23:49,399
它们每个

554
00:23:49,399 --> 00:23:51,549
包含某种操作系统内核

555
00:23:51,549 --> 00:23:55,909
以及应用程序

556
00:23:55,909 --> 00:23:58,700
所以这是他们开始使用的技术

557
00:23:58,700 --> 00:24:00,409
原因是

558
00:24:00,409 --> 00:24:03,049
事实证明

559
00:24:03,049 --> 00:24:04,760
在硬件和操作系统之间

560
00:24:04,760 --> 00:24:06,320
进行这种级别的间接干预

561
00:24:06,320 --> 00:24:08,419
非常方便

562
00:24:08,419 --> 00:24:10,039
非常方便的原因有很多

563
00:24:10,039 --> 00:24:11,899
这意味着我们可以购买一台计算机

564
00:24:11,899 --> 00:24:14,059
并在其上运行许多不同的操作系统

565
00:24:14,059 --> 00:24:16,130
如果我们运行

566
00:24:16,130 --> 00:24:18,139
大量的小型服务

567
00:24:18,139 --> 00:24:19,730
比起使用大量的计算机

568
00:24:19,730 --> 00:24:21,679
每台运行一个服务

569
00:24:21,679 --> 00:24:23,660
你可以只购买一台计算机

570
00:24:23,660 --> 00:24:25,850
在基于虚拟机上的操作系统中运行每个服务

571
00:24:25,850 --> 00:24:28,250
这就是他们的出发点

572
00:24:28,250 --> 00:24:29,300
他们已经构建了这项功能

573
00:24:29,300 --> 00:24:31,430
和许多其他复杂的东西

574
00:24:31,430 --> 00:24:35,000
在最开始设计VMware FT时

575
00:24:35,000 --> 00:24:38,690
所以这就是虚拟机

576
00:24:38,690 --> 00:24:43,070
论文要做的是

577
00:24:43,070 --> 00:24:46,910
要搭建一台机器

578
00:24:46,910 --> 00:24:51,620
或者说他们需要两台物理机

579
00:24:51,620 --> 00:24:54,940
因为在同一台物理计算机上

580
00:24:54,940 --> 00:24:57,680
的不同虚拟机中

581
00:24:57,680 --> 00:24:59,720
运行主和副本软件

582
00:24:59,720 --> 00:25:01,400
毫无意义

583
00:25:01,400 --> 00:25:03,500
因为我们正在努力应对硬件故障

584
00:25:03,500 --> 00:25:06,710
因此，你有两台计算机分别运行其虚拟机监视器

585
00:25:06,710 --> 00:25:08,900
因此，你有两台计算机分别运行其虚拟机监视器

586
00:25:08,900 --> 00:25:15,590
而主虚拟机将在一台计算机上运行

587
00:25:15,590 --> 00:25:16,970
而副本虚拟机将在另一台上运行

588
00:25:16,970 --> 00:25:18,950
在其中一台计算机上有一个guest操作系统...

589
00:25:18,950 --> 00:25:23,750
在其中一台计算机上有一个guest操作系统..

590
00:25:23,750 --> 00:25:25,040
它可能正在运行许多虚拟机

591
00:25:25,040 --> 00:25:26,930
我们只在乎其中的一个（虚拟机）

592
00:25:26,930 --> 00:25:28,670
它会运行多个guest操作系统

593
00:25:28,670 --> 00:25:32,330
以及服务应用程序

594
00:25:32,330 --> 00:25:35,300
也许是数据库服务，MapReduce主数据库或其他东西

595
00:25:35,300 --> 00:25:37,790
我们称这个为主虚拟机

596
00:25:37,790 --> 00:25:40,250
这里有第二台计算机

597
00:25:40,250 --> 00:25:43,490
其运行相同的虚拟机监视器

598
00:25:43,490 --> 00:25:47,600
也有运行副本服务的相同的虚拟机

599
00:25:47,600 --> 00:25:49,580
也有运行副本服务的相同的虚拟机

600
00:25:49,580 --> 00:25:50,960
因此，无论是何种操作系统，我们都具有完全相同的东西

601
00:25:50,960 --> 00:25:55,250
因此，无论是何种操作系统，我们都具有完全相同的东西

602
00:25:55,250 --> 00:25:58,250
虚拟机为这些guest操作系统、主和副本服务器

603
00:25:58,250 --> 00:26:00,170
虚拟机为这些guest操作系统、主和副本服务器

604
00:26:00,170 --> 00:26:02,270
提供一定范围的内存空间

605
00:26:02,270 --> 00:26:04,760
并且这两个内存镜像是完全相同的

606
00:26:04,760 --> 00:26:07,190
或其目标是使它们在主和副本虚拟机中完全相同

607
00:26:07,190 --> 00:26:09,740
我们有两台物理计算机

608
00:26:09,740 --> 00:26:13,070
每台都在运行

609
00:26:13,070 --> 00:26:15,680
guest虚拟机

610
00:26:15,680 --> 00:26:17,630
该虚拟机上带有我们关心的服务的副本

611
00:26:17,630 --> 00:26:22,640
我们假设有一个网络

612
00:26:22,640 --> 00:26:25,240
连接了这两台机器

613
00:26:25,240 --> 00:26:27,530
此外，在此局域网上还有一些客户端

614
00:26:27,530 --> 00:26:29,480
此外，在此局域网上还有一些客户端

615
00:26:29,480 --> 00:26:30,950
事实上，它们不一定是是客户端

616
00:26:30,950 --> 00:26:33,160
它们可能是其他计算机

617
00:26:33,160 --> 00:26:35,750
复制服务需要与之通信

618
00:26:35,750 --> 00:26:37,470
其中一些是

619
00:26:37,470 --> 00:26:39,270
来发送请求的客户端

620
00:26:39,270 --> 00:26:44,820
这篇论文中的复制服务

621
00:26:44,820 --> 00:26:47,100
实际上并不使用本地磁盘

622
00:26:47,100 --> 00:26:49,530
而是假设

623
00:26:49,530 --> 00:26:53,370
与某种磁盘服务器进行通信

624
00:26:53,370 --> 00:26:55,309
尽管从本篇论文中

625
00:26:55,309 --> 00:26:59,760
很难意识到这一点

626
00:26:59,760 --> 00:27:01,710
该方案实际上

627
00:27:01,710 --> 00:27:04,140
并没有特殊对待这种服务器

628
00:27:04,140 --> 00:27:07,289
它只是数据包的另一个外部来源

629
00:27:07,289 --> 00:27:09,929
只是复制状态机可能会将数据包发送到的地方

630
00:27:09,929 --> 00:27:12,000
这与其他客户端没有太大不同

631
00:27:12,000 --> 00:27:17,370
因此，基本方案是

632
00:27:17,370 --> 00:27:20,370
我们假设

633
00:27:20,370 --> 00:27:24,120
这两个副本、两个虚拟机

634
00:27:24,120 --> 00:27:27,870
或者说主和副本虚拟机，都是精确的副本

635
00:27:27,870 --> 00:27:30,150
某个客户端，例如数据库客户端

636
00:27:30,150 --> 00:27:31,559
复制服务器的某个客户端

637
00:27:31,559 --> 00:27:33,600
向主虚拟机发送请求

638
00:27:33,600 --> 00:27:37,080
而这实际上是

639
00:27:37,080 --> 00:27:38,909
以网络数据包的形式发送的

640
00:27:38,909 --> 00:27:40,590
就是我们刚刚讨论的

641
00:27:40,590 --> 00:27:41,220
它生成一个中断

642
00:27:41,220 --> 00:27:43,140
该中断进入

643
00:27:43,140 --> 00:27:45,270
第一个实例的

644
00:27:45,270 --> 00:27:47,789
虚拟机监视器

645
00:27:47,789 --> 00:27:50,010
虚拟机监视器发现

646
00:27:50,010 --> 00:27:54,059
复制服务的输入到来了

647
00:27:54,059 --> 00:27:55,679
因此，虚拟机监视器会做两件事

648
00:27:55,679 --> 00:27:58,429
第一件事

649
00:27:58,429 --> 00:28:01,799
它模拟网络数据包到达中断

650
00:28:01,799 --> 00:28:04,110
传递给主guest操作系统

651
00:28:04,110 --> 00:28:07,470
以此将其传递给

652
00:28:07,470 --> 00:28:09,600
应用程序的主副本

653
00:28:09,600 --> 00:28:11,760
第二件事，虚拟机监视器知道

654
00:28:11,760 --> 00:28:13,679
这是复制虚拟机的输入

655
00:28:13,679 --> 00:28:15,780
因此，它通过网络

656
00:28:15,780 --> 00:28:19,710
将数据包副本

657
00:28:19,710 --> 00:28:23,010
发送给副本虚拟机监视器

658
00:28:23,010 --> 00:28:26,280
所以它（副本虚拟机监视器）也得到了数据包，副本虚拟机监视器

659
00:28:26,280 --> 00:28:28,470
知道它是

660
00:28:28,470 --> 00:28:30,030
此复制状态机的数据包

661
00:28:30,030 --> 00:28:34,530
它在副本虚拟机中也会构造

662
00:28:34,530 --> 00:28:36,150
网络数据包到达中断

663
00:28:36,150 --> 00:28:39,090
并传送数据包

664
00:28:39,090 --> 00:28:40,799
所以现在主和副本虚拟机都有了数据包的一份副本

665
00:28:40,799 --> 00:28:42,780
得到相同的输入

666
00:28:42,780 --> 00:28:44,059
其中有一些细节

667
00:28:44,059 --> 00:28:48,059
被以相同的方式处理

668
00:28:48,059 --> 00:28:50,299
并保持同步

669
00:28:50,750 --> 00:28:52,100
当然，服务可能

670
00:28:52,100 --> 00:28:55,420
会在主虚拟机上回复客户

671
00:28:55,420 --> 00:28:58,030
服务将生成一个回复数据包

672
00:28:58,030 --> 00:29:02,330
将其发送到虚拟机监视器

673
00:29:02,330 --> 00:29:06,230
所模拟的NIC上

674
00:29:06,230 --> 00:29:07,550
然后，虚拟机监视器将会

675
00:29:07,550 --> 00:29:09,050
在主计算机上输出该数据包

676
00:29:09,050 --> 00:29:11,270
他们将真正地发送回复给客户端

677
00:29:11,270 --> 00:29:13,930
在网络上

678
00:29:13,930 --> 00:29:16,340
由于副本在运行

679
00:29:16,340 --> 00:29:17,810
完全相同的指令序列

680
00:29:17,810 --> 00:29:20,360
它也会生成一个回复数据包返回给客户端

681
00:29:20,360 --> 00:29:23,270
发送该回复数据包

682
00:29:23,270 --> 00:29:27,230
到其模拟的NIC上

683
00:29:27,230 --> 00:29:28,550
虚拟机监视器模拟了该网卡

684
00:29:28,550 --> 00:29:31,010
虚拟机监视器模拟了该网卡

685
00:29:31,010 --> 00:29:32,480
虚拟机监视器知道这是副本虚拟机

686
00:29:32,480 --> 00:29:34,430
虚拟机监视器知道这是副本虚拟机

687
00:29:34,430 --> 00:29:35,990
而它只允许主虚拟机生成输出

688
00:29:35,990 --> 00:29:39,050
因此，虚拟机监视器会丢弃回复数据包

689
00:29:39,050 --> 00:29:42,140
所以他们两个都看到了输入，而只有主虚拟机产生了输出

690
00:29:42,140 --> 00:29:44,240
所以他们两个都看到了输入，而只有主虚拟机产生了输出

691
00:29:44,240 --> 00:29:53,510
就术语而言，这篇论文将这种输入事件流

692
00:29:53,510 --> 00:29:59,690
就术语而言，这篇论文将这种输入事件流

693
00:29:59,690 --> 00:30:01,400
以及之后要讨论的其他事件流

694
00:30:01,400 --> 00:30:04,310
称为日志记录通道

695
00:30:04,310 --> 00:30:06,890
这些通道应该都处于同一个网络中

696
00:30:06,890 --> 00:30:10,550
这些通道应该都处于同一个网络中

697
00:30:10,550 --> 00:30:12,050
而将这种从主到备的事件流称为日志通道中的事件

698
00:30:12,050 --> 00:30:16,450
而这种将从主到备的事件流称为日志通道中的事件

699
00:30:22,240 --> 00:30:24,740
容错的关键在于

700
00:30:24,740 --> 00:30:29,030
当主机宕机的时候

701
00:30:29,030 --> 00:30:31,490
备机将如何感知到它的宕机

702
00:30:31,490 --> 00:30:34,040
备机将如何感知到它的宕机

703
00:30:34,040 --> 00:30:37,310
备机会感知到无法从日志通道获取到任何内容

704
00:30:37,310 --> 00:30:42,110
备机会感知到无法从日志通道获取到任何内容

705
00:30:42,110 --> 00:30:45,500
并且我们知道实际上备机每秒钟会期望获得很多数据

706
00:30:45,500 --> 00:30:47,210
并且我们知道实际上备机每秒钟会期望获得很多数据

707
00:30:47,210 --> 00:30:49,760
原因在于每个主机都有一个周期性的定时器中断来生成日志

708
00:30:49,760 --> 00:30:52,370
原因在于每个主机都有一个周期性的定时器中断来生成日志

709
00:30:52,370 --> 00:30:55,310
原因在于每个主机都有一个周期性的定时器中断来生成日志

710
00:30:55,310 --> 00:30:57,290
这样会使得每次中断都产生一条日志进入备机

711
00:30:57,290 --> 00:30:59,510
这样会使得每次中断都产生一条日志进入备机

712
00:30:59,510 --> 00:31:01,130
这些中断大概每秒触发100次

713
00:31:01,130 --> 00:31:02,420
这些中断大概每秒触发100次

714
00:31:02,420 --> 00:31:04,280
因此备机肯定期望

715
00:31:04,280 --> 00:31:07,400
从日志通道收到很多消息

716
00:31:07,400 --> 00:31:09,110
如果主机挂了

717
00:31:09,110 --> 00:31:11,510
或翻车了

718
00:31:11,510 --> 00:31:12,980
然后虚拟机监视器会说 我去

719
00:31:12,980 --> 00:31:14,330
你知道吗我已经有大约1秒钟没从日志通道收到消息了

720
00:31:14,330 --> 00:31:15,890
你知道吗我已经有大约1秒钟没从日志通道收到消息了

721
00:31:15,890 --> 00:31:19,480
不管主机挂了或发生了啥

722
00:31:19,480 --> 00:31:25,310
在这种情况下

723
00:31:25,310 --> 00:31:28,700
当备机收不到任何主机发来的日志时

724
00:31:28,700 --> 00:31:31,280
这篇论文的方式是

725
00:31:31,280 --> 00:31:33,320
激活备机

726
00:31:33,320 --> 00:31:35,780
这意味着它

727
00:31:35,780 --> 00:31:42,920
不再在日志通道上等待主机的日志

728
00:31:42,920 --> 00:31:46,850
不再在日志通道上等待主机的日志

729
00:31:46,850 --> 00:31:49,160
相反虚拟机监视器

730
00:31:49,160 --> 00:31:51,790
会让备机自动执行

731
00:31:51,790 --> 00:31:54,590
而无需等待来自主机的输入事件

732
00:31:54,590 --> 00:31:59,000
而无需等待来自主机的输入事件

733
00:31:59,000 --> 00:32:00,680
虚拟机监视器会让网络中的

734
00:32:00,680 --> 00:32:02,510
客户端请求

735
00:32:02,510 --> 00:32:05,000
发给备机而非主机

736
00:32:05,000 --> 00:32:09,770
虚拟机监视器会停止丢弃备机

737
00:32:09,770 --> 00:32:11,150
(这里备机成了主机)

738
00:32:11,150 --> 00:32:13,940
停止丢弃备机虚拟机产生的输出

739
00:32:13,940 --> 00:32:15,770
所以现在这台备机

740
00:32:15,770 --> 00:32:18,170
就能直接接收输入

741
00:32:18,170 --> 00:32:20,270
并且也有很多输出

742
00:32:20,270 --> 00:32:22,520
现在备机完全接管了主机的工作

743
00:32:22,520 --> 00:32:25,280
你也知道这让人没啥兴趣

744
00:32:25,280 --> 00:32:26,330
但为了让它正常工作

745
00:32:26,330 --> 00:32:29,390
如果备机挂了

746
00:32:29,390 --> 00:32:31,130
主机一样必须使用类似的流程舍弃备机

747
00:32:31,130 --> 00:32:34,550
停止向备机发送事件

748
00:32:34,550 --> 00:32:37,100
这更像单节点服务器而非副本服务器

749
00:32:37,100 --> 00:32:39,080
因此如果其中一个挂了则另一个会被激活

750
00:32:39,080 --> 00:32:41,090
因此如果其中一个挂了则另一个会被激活

751
00:32:41,090 --> 00:32:43,460
就像你知道的

752
00:32:43,460 --> 00:32:46,390
它会停止产生网络流量

753
00:32:51,220 --> 00:32:57,230
这取决于我们依赖的网络技术是什么

754
00:32:57,230 --> 00:33:01,550
这取决于我们依赖的网络技术是什么

755
00:33:01,550 --> 00:33:04,940
 我觉得在这篇论文中

756
00:33:04,940 --> 00:33:07,910
一种可能性是互联网上的

757
00:33:07,910 --> 00:33:09,530
每一台物理机

758
00:33:09,530 --> 00:33:15,430
或每一个物理网卡都有一个48位的唯一ID

759
00:33:16,720 --> 00:33:21,320
我想说的是 事实上

760
00:33:21,320 --> 00:33:22,910
不是每台物理机都有一个唯一的ID

761
00:33:22,910 --> 00:33:25,400
不是每台物理机都有一个唯一的ID

762
00:33:25,400 --> 00:33:30,710
而是每台虚拟机都有一个唯一的ID

763
00:33:30,710 --> 00:33:36,430
当备机接管后 实际上它会将主机的

764
00:33:36,430 --> 00:33:39,320
以太网ID声明为自己的

765
00:33:39,320 --> 00:33:41,090
并通知所有人我才是这个ID的拥有者

766
00:33:41,090 --> 00:33:42,620
然后网络上的其他人

767
00:33:42,620 --> 00:33:46,010
开始向我们发送数据包

768
00:33:46,010 --> 00:34:02,690
这是我的解释

769
00:34:02,690 --> 00:34:04,370
设计者相信他们已经识别出了所有的数据包来源

770
00:34:04,370 --> 00:34:07,700
并且对于每一个包主机都会进行操作

771
00:34:07,700 --> 00:34:10,159
你知道的

772
00:34:10,159 --> 00:34:12,139
执行随机数生成指令

773
00:34:12,139 --> 00:34:14,360
或在某个时间点进行中断

774
00:34:14,360 --> 00:34:17,360
备机不会做的

775
00:34:17,360 --> 00:34:19,639
但备机上的虚拟机监视器会监测到

776
00:34:19,639 --> 00:34:22,429
所有这类指令并进行拦截

777
00:34:22,429 --> 00:34:24,560
而且什么也不会做

778
00:34:24,560 --> 00:34:26,270
然后备机会等待日志通道中的一个事件

779
00:34:26,270 --> 00:34:28,610
这个指令

780
00:34:28,610 --> 00:34:30,980
随机数生成指令

781
00:34:30,980 --> 00:34:33,700
是在主机上产生的

782
00:34:35,080 --> 00:34:37,420
啥？

783
00:34:37,420 --> 00:34:42,130
是的 是的

784
00:34:42,670 --> 00:34:46,639
这篇论文在疯狂暗示英特尔

785
00:34:46,639 --> 00:34:50,840
在他们的微处理器上增加新特性

786
00:34:50,840 --> 00:34:54,650
来完全支持这项功能

787
00:34:54,650 --> 00:35:03,370
但他们也没说清楚到底是啥

788
00:35:04,180 --> 00:35:08,090
 好了 在这个话题中目前为止你所知道的假设是

789
00:35:08,090 --> 00:35:09,320
只要备机能收到客户端发来的数据包

790
00:35:09,320 --> 00:35:16,010
只要备机能收到客户端发来的数据包

791
00:35:16,010 --> 00:35:17,450
就会执行和主机相同的处理方式

792
00:35:17,450 --> 00:35:21,020
就会执行和主机相同的处理方式

793
00:35:21,020 --> 00:35:25,310
这实际上掩饰了一些重要的细节

794
00:35:25,310 --> 00:35:30,050
这实际上掩饰了一些重要的细节

795
00:35:30,050 --> 00:35:31,190
其中一个问题就像这两个人所说的

796
00:35:31,190 --> 00:35:33,710
有些情况是不确定的

797
00:35:33,710 --> 00:35:36,020
计算机中发生的每件事都应该是确定性的函数

798
00:35:36,020 --> 00:35:37,430
计算机中发生的每件事都应该是确定性的函数

799
00:35:37,430 --> 00:35:39,440
哪怕是内存里的内容也是一个确定性函数

800
00:35:39,440 --> 00:35:41,330
哪怕是内存里的内容也是一个确定性函数

801
00:35:41,330 --> 00:35:44,420
它通常是一种串行执行的代码

802
00:35:44,420 --> 00:35:46,280
但肯定不可能老是这样

803
00:35:46,280 --> 00:35:49,430
所以需要担心的是

804
00:35:49,430 --> 00:35:51,290
当前的状态可能不是一个严格的函数

805
00:35:51,290 --> 00:35:53,270
当前的状态可能不是一个严格的函数

806
00:35:53,270 --> 00:35:54,920
如果在主机和备机中没有仔细考虑

807
00:35:54,920 --> 00:35:56,960
那么情况可能会有所不同

808
00:35:56,960 --> 00:35:58,760
这里有很多可能发生的某种不确定性事件

809
00:35:58,760 --> 00:36:04,040
这里有很多可能发生的某种不确定性事件

810
00:36:04,040 --> 00:36:05,540
所以设计者们不得不坐下来想办法

811
00:36:05,540 --> 00:36:10,570
让它们全都正常工作

812
00:36:10,570 --> 00:36:12,350
接下来就是他们讨论出来的东西

813
00:36:12,350 --> 00:36:16,520
其中一种来自外部源的输入

814
00:36:16,520 --> 00:36:18,860
比如客户端

815
00:36:18,860 --> 00:36:20,420
我们也不知道客户端输入什么时候会来

816
00:36:20,420 --> 00:36:21,890
很多情况下客户端请求并不是那么严格

817
00:36:21,890 --> 00:36:24,170
很多情况下客户端请求并不是那么严格

818
00:36:24,170 --> 00:36:25,520
我们也不知道服务的状态是不是一个确定性函数

819
00:36:25,520 --> 00:36:27,080
我们也不知道服务的状态是不是一个确定性函数

820
00:36:27,080 --> 00:36:31,090
因为它不可知

821
00:36:31,090 --> 00:36:34,550
所以实际上这个系统真正致力于

822
00:36:34,550 --> 00:36:37,550
服务只在网络上通讯的环境

823
00:36:37,550 --> 00:36:39,830
服务只在网络上通讯的环境

824
00:36:39,830 --> 00:36:41,630
所以这个系统基本上支持

825
00:36:41,630 --> 00:36:44,060
基于网络数据包收发的输入输出操作

826
00:36:44,060 --> 00:36:46,240
基于网络数据包收发的输入输出操作

827
00:36:46,240 --> 00:36:48,620
所以我们讲的到达

828
00:36:48,620 --> 00:36:50,060
实际意思是数据包的到达

829
00:36:50,060 --> 00:36:50,540
实际意思是数据包的到达

830
00:36:50,540 --> 00:36:53,810
并且数据包除了包括

831
00:36:53,810 --> 00:36:56,990
发送给我们的数据

832
00:36:56,990 --> 00:37:01,820
还有一个中断

833
00:37:01,820 --> 00:37:05,570
用来发送数据包已抵达的信号量

834
00:37:05,570 --> 00:37:08,090
所以这很重要

835
00:37:08,090 --> 00:37:10,870
当数据包收到后

836
00:37:11,050 --> 00:37:16,250
通常由NIC通过DMA

837
00:37:16,250 --> 00:37:20,720
将包内数据写入内存

838
00:37:20,720 --> 00:37:22,070
并发起一个操作系统可感知的中断

839
00:37:22,070 --> 00:37:23,420
这个中断会在指令流中的某个位置触发

840
00:37:23,420 --> 00:37:26,210
这个中断会在指令流中的某个位置触发

841
00:37:26,210 --> 00:37:29,000
所以这两个指令流必须在主备中一模一样

842
00:37:29,000 --> 00:37:30,860
所以这两个指令流必须在主备中一模一样

843
00:37:30,860 --> 00:37:33,050
否则执行起来会有分歧

844
00:37:33,050 --> 00:37:35,540
所以真正的问题是

845
00:37:35,540 --> 00:37:38,090
当中断精确发生在哪条指令上时

846
00:37:38,090 --> 00:37:40,190
当中断精确发生在哪条指令上时

847
00:37:40,190 --> 00:37:42,500
备机和主机最好全都一样

848
00:37:42,500 --> 00:37:44,420
备机和主机最好全都一样

849
00:37:44,420 --> 00:37:46,400
否则他们的执行逻辑不同状态也不同

850
00:37:46,400 --> 00:37:49,040
因此我们关心的是包数据

851
00:37:49,040 --> 00:37:50,900
和中断发生的时机

852
00:37:50,900 --> 00:37:54,290
和中断发生的时机

853
00:37:54,290 --> 00:37:56,830
并且有两个人已经提到了

854
00:37:56,830 --> 00:38:04,580
有一些指令在不同的机器上的表现不同

855
00:38:04,580 --> 00:38:06,920
有一些指令在不同的机器上的表现不同

856
00:38:06,920 --> 00:38:09,590
或依赖不同

857
00:38:09,590 --> 00:38:11,300
例如生成随机数指令

858
00:38:11,300 --> 00:38:13,250
还有调用获取时间的指令

859
00:38:13,250 --> 00:38:15,260
生成唯一ID的指令

860
00:38:15,260 --> 00:38:16,640
都会产生不同的结果

861
00:38:16,640 --> 00:38:21,410
另一个产生非确定性因素的原因是

862
00:38:21,410 --> 00:38:22,850
另一个产生非确定性因素的原因是

863
00:38:22,850 --> 00:38:27,440
论文不是基于多核并行（实现）的

864
00:38:27,440 --> 00:38:33,320
这是个适用于单核而非多核的系统

865
00:38:33,320 --> 00:38:34,910
这是个适用于单核而非多核的系统

866
00:38:34,910 --> 00:38:36,920
原因在于如果使用多核环境

867
00:38:36,920 --> 00:38:40,340
那么服务肯定运行在多核之上

868
00:38:40,340 --> 00:38:41,780
那么服务肯定运行在多核之上

869
00:38:41,780 --> 00:38:45,050
服务的指令在不同的核上交错执行

870
00:38:45,050 --> 00:38:45,890
服务的指令在不同的核上交错执行

871
00:38:45,890 --> 00:38:48,140
其执行顺序是不可预测的

872
00:38:48,140 --> 00:38:50,810
所以当我们在备机上运行相同的代码

873
00:38:50,810 --> 00:38:52,910
所以当我们在备机上运行相同的代码

874
00:38:52,910 --> 00:38:54,890
如果它是运行在多核之上的并行代码

875
00:38:54,890 --> 00:38:56,900
如果它是运行在多核之上的并行代码

876
00:38:56,900 --> 00:38:58,520
则硬件会以不同的方式在两个核上交错执行这些指令

877
00:38:58,520 --> 00:39:00,790
则硬件会以不同的方式在两个核上交错执行这些指令

878
00:39:00,790 --> 00:39:03,450
这会导致产生不同的结果

879
00:39:03,450 --> 00:39:05,910
这会导致产生不同的结果

880
00:39:05,910 --> 00:39:08,850
因为可以假设这种情况 两个核共同执行一段代码

881
00:39:08,850 --> 00:39:10,500
在某些情况下会同时请求对数据进行加锁

882
00:39:10,500 --> 00:39:13,050
在某些情况下会同时请求对数据进行加锁

883
00:39:13,050 --> 00:39:15,060
在主机上核1可能比核2优先获得锁

884
00:39:15,060 --> 00:39:17,160
而在备机上可能由于微小的时间差异

885
00:39:17,160 --> 00:39:19,140
使得核2先获得锁

886
00:39:19,140 --> 00:39:21,480
你懂的 这样会导致执行结果完全不一样

887
00:39:21,480 --> 00:39:23,610
你懂的 这样会导致执行结果完全不一样

888
00:39:23,610 --> 00:39:25,230
就像不同的线程获得锁

889
00:39:25,230 --> 00:39:26,960
会导致执行结果不同一样

890
00:39:26,960 --> 00:39:30,060
因此多核是不确定性因素里最严峻的挑战

891
00:39:30,060 --> 00:39:32,400
因此多核是不确定性因素里最严峻的挑战

892
00:39:32,400 --> 00:39:36,750
只是在这篇论文中完全被屏蔽了而已

893
00:39:36,750 --> 00:39:39,210
实际上到现在为止我所讲的技术

894
00:39:39,210 --> 00:40:00,000
貌似不是那么好使

895
00:40:00,000 --> 00:40:01,980
不能使用多核并行

896
00:40:01,980 --> 00:40:04,830
而硬件几乎可以肯定是多核并行的

897
00:40:04,830 --> 00:40:06,960
而硬件几乎可以肯定是多核并行的

898
00:40:06,960 --> 00:40:09,240
但那是虚拟机monitor下面的硬件

899
00:40:09,240 --> 00:40:11,640
但那是虚拟机monitor下面的硬件

900
00:40:11,640 --> 00:40:13,830
虚拟机monitor提供给guest操作系统的

901
00:40:13,830 --> 00:40:15,480
虚拟机monitor提供给guest操作系统的

902
00:40:15,480 --> 00:40:18,480
运行primary和backup的虚拟机

903
00:40:18,480 --> 00:40:21,000
运行primary和backup的虚拟机

904
00:40:21,000 --> 00:40:25,080
是单核机器（在这篇论文中）

905
00:40:25,080 --> 00:40:26,790
我猜他们没有一个简单的方法

906
00:40:26,790 --> 00:40:31,550
可以使这种设计应用于多核虚拟机

907
00:40:31,550 --> 00:40:34,880
可以使这种设计应用于多核虚拟机

908
00:40:39,960 --> 00:40:43,690
好的，这些是

909
00:40:43,690 --> 00:40:44,950
经过logging channel的这些事件

910
00:40:44,950 --> 00:40:49,779
日志记录的格式

911
00:40:49,779 --> 00:40:55,660
他们没有说清楚

912
00:40:55,660 --> 00:40:57,160
但我猜想日志条目中要有三样东西

913
00:40:57,160 --> 00:40:58,269
但我猜想日志条目中要有三样东西

914
00:40:58,269 --> 00:41:01,240
（一是）事件发生时的指令号

915
00:41:01,240 --> 00:41:02,710
（一是）事件发生时的指令号

916
00:41:02,710 --> 00:41:04,420
因为如果您要传送中断或输入，或别的

917
00:41:04,420 --> 00:41:06,249
因为如果您要传送中断或输入，或别的

918
00:41:06,249 --> 00:41:09,160
最好将其传送到primary和backup中完全相同的位置

919
00:41:09,160 --> 00:41:10,569
所以我们需要知道

920
00:41:10,569 --> 00:41:11,799
指令序号

921
00:41:11,799 --> 00:41:14,170
指令序号的意思是

922
00:41:14,170 --> 00:41:15,910
自机器启动以来的指令数量

923
00:41:15,910 --> 00:41:18,279
而不是指令地址

924
00:41:18,279 --> 00:41:20,650
例如，执行机器启动以来第40亿零79条指令

925
00:41:20,650 --> 00:41:23,499
例如，执行机器启动以来第40亿零79条指令

926
00:41:23,499 --> 00:41:24,609
所以日志条目将包含指令序号

927
00:41:24,609 --> 00:41:31,210
对于中断和输入

928
00:41:31,210 --> 00:41:34,059
它将是中断在primary发生时的指令序号

929
00:41:34,059 --> 00:41:35,769
它将是中断在primary发生时的指令序号

930
00:41:35,769 --> 00:41:39,369
对于一个怪异指令 比如获取一天中的时间

931
00:41:39,369 --> 00:41:41,140
这个序号是

932
00:41:41,140 --> 00:41:43,329
获取时间的指令的指令序号

933
00:41:43,329 --> 00:41:44,980
获取时间的指令的指令序号

934
00:41:44,980 --> 00:41:46,960
或者无论什么指令在primary上执行的序号

935
00:41:46,960 --> 00:41:49,269
这样backup就知道在哪里让此事件发生

936
00:41:49,269 --> 00:41:52,450
这样backup就知道在哪里让此事件发生

937
00:41:52,450 --> 00:41:54,819
好的，（日志条目）会有type

938
00:41:54,819 --> 00:41:58,089
网络输入，或者怪异指令

939
00:41:58,089 --> 00:42:00,220
然后（日志条目）会有data

940
00:42:00,220 --> 00:42:03,369
如果是有数据包到达，

941
00:42:03,369 --> 00:42:05,170
data会是包里的数据

942
00:42:05,170 --> 00:42:06,430
对于怪异指令，data将是这些怪异指令

943
00:42:06,430 --> 00:42:08,140
在primary上执行后的结果

944
00:42:08,140 --> 00:42:10,450
在primary上执行后的结果

945
00:42:10,450 --> 00:42:13,299
这样备份虚拟机就可以伪造指令

946
00:42:13,299 --> 00:42:15,549
然后提供相同的结果

947
00:42:15,549 --> 00:42:17,910
然后提供相同的结果

948
00:42:22,109 --> 00:42:27,520
好的

949
00:42:27,520 --> 00:42:34,960
这两个操作系统，guest操作系统

950
00:42:34,960 --> 00:42:38,680
假定要求硬件

951
00:42:38,680 --> 00:42:40,240
这里是仿真的硬件，虚拟机

952
00:42:40,240 --> 00:42:42,310
其计时器每秒滴答一百次

953
00:42:42,310 --> 00:42:44,680
其计时器每秒滴答一百次

954
00:42:44,680 --> 00:42:47,859
并产生中断给操作系统

955
00:42:47,859 --> 00:42:49,540
这就是操作系统通过

956
00:42:49,540 --> 00:42:51,220
计数计时器中断来跟踪其时间的方式

957
00:42:51,220 --> 00:42:54,700
因此

958
00:42:54,700 --> 00:42:56,500
因此计时器必须

959
00:42:56,500 --> 00:42:58,270
在primary，backup中的完全相同的位置产生中断

960
00:42:58,270 --> 00:43:00,609
否则他们不会执行相同的，并且分歧

961
00:43:00,609 --> 00:43:04,089
否则他们不会执行相同的，并且分歧

962
00:43:04,089 --> 00:43:06,810
实际情况是

963
00:43:06,810 --> 00:43:10,720
在运行FT虚拟机monitor的物理机上有一个计时器

964
00:43:10,720 --> 00:43:14,140
在运行FT虚拟机monitor的物理机上有一个计时器

965
00:43:14,140 --> 00:43:16,060
物理机器上的计时器计时并发出中断

966
00:43:16,060 --> 00:43:18,250
物理机上的计时器计时并发出中断

967
00:43:18,250 --> 00:43:19,780
将计时器中断传递给primary上的虚拟机monitor

968
00:43:19,780 --> 00:43:23,560
将计时器中断传递给primary上的虚拟机monitor

969
00:43:23,560 --> 00:43:24,820
虚拟机monitor在适当的时候停止primary的执行

970
00:43:24,820 --> 00:43:29,859
虚拟机monitor在适当的时候停止primary的执行

971
00:43:29,859 --> 00:43:31,930
记下自启动以来的指令序号

972
00:43:31,930 --> 00:43:34,180
记下自启动以来的指令序号

973
00:43:34,180 --> 00:43:37,320
记下自启动以来的指令序号

974
00:43:37,320 --> 00:43:39,790
然后以该指令编号将伪造的模拟和中断

975
00:43:39,790 --> 00:43:41,830
然后以该指令编号将伪造的模拟和中断

976
00:43:41,830 --> 00:43:43,240
提供给primary中的guest操作系统

977
00:43:43,240 --> 00:43:44,530
提供给primary中的guest操作系统

978
00:43:44,530 --> 00:43:46,570
你仿真的计时器硬件刚刚滴答了

979
00:43:46,570 --> 00:43:47,080
有中断

980
00:43:47,080 --> 00:43:49,300
然后

981
00:43:49,300 --> 00:43:51,400
然后primary虚拟机monitor

982
00:43:51,400 --> 00:43:52,599
将中断发生的指令号发送给backup

983
00:43:52,599 --> 00:43:54,810
将中断发生的指令号发送给backup

984
00:43:54,810 --> 00:43:59,260
backup当然

985
00:43:59,260 --> 00:44:00,520
其虚拟机monitor

986
00:44:00,520 --> 00:44:02,440
也从其物理计时器获取计时器中断

987
00:44:02,440 --> 00:44:04,660
并没有给提供

988
00:44:04,660 --> 00:44:06,910
没有把真的物理计时器中断传递给backup操作系统

989
00:44:06,910 --> 00:44:10,000
它忽略了它们

990
00:44:10,000 --> 00:44:13,450
当primary计时器中断的日志条目到达此处

991
00:44:13,450 --> 00:44:15,700
当primary计时器中断的日志条目到达此处

992
00:44:15,700 --> 00:44:18,730
当primary计时器中断的日志条目到达此处

993
00:44:18,730 --> 00:44:20,500
然后backup虚拟机monitor将与CPU配合

994
00:44:20,500 --> 00:44:22,210
这需要特殊的CPU支持

995
00:44:22,210 --> 00:44:28,119
这需要特殊的CPU支持

996
00:44:28,119 --> 00:44:30,700
以使物理机在与primary相同的指令序号处中断

997
00:44:30,700 --> 00:44:32,630
以使物理机在与primary相同的指令序号处中断

998
00:44:32,630 --> 00:44:34,130
以使物理机在与primary相同的指令序号处中断

999
00:44:34,130 --> 00:44:36,950
此时，虚拟机monitor再次从guest操作系统取回控制

1000
00:44:36,950 --> 00:44:38,540
此时，虚拟机monitor再次从guest操作系统取回控制

1001
00:44:38,540 --> 00:44:41,510
然后用伪造的计时器中断

1002
00:44:41,510 --> 00:44:43,970
交给backup操作系统

1003
00:44:43,970 --> 00:44:46,190
现在的指令号与主指令上的指令号完全相同

1004
00:44:46,190 --> 00:44:47,930
现在的指令号与主指令上的指令号完全相同

1005
00:44:47,930 --> 00:45:17,060
是的，这个观察是

1006
00:45:17,060 --> 00:45:18,740
这依赖于CPU中有一些特殊的硬件

1007
00:45:18,740 --> 00:45:20,930
这依赖于CPU中有一些特殊的硬件

1008
00:45:20,930 --> 00:45:24,440
因此虚拟机monitor可以告诉硬件，CPU

1009
00:45:24,440 --> 00:45:26,930
请从现在开始的第一千条指令处中断

1010
00:45:26,930 --> 00:45:29,930
然后是虚拟机monitor

1011
00:45:29,930 --> 00:45:32,990
它会在与primary相同的指令序号处中断

1012
00:45:32,990 --> 00:45:34,070
它会在与primary相同的中断序号处发生中断

1013
00:45:34,070 --> 00:45:35,720
它会在与primary相同的中断序号处发生中断

1014
00:45:35,720 --> 00:45:38,570
然后虚拟机monitor告诉CPU

1015
00:45:38,570 --> 00:45:40,700
恢复backup的执行

1016
00:45:40,700 --> 00:45:42,560
恰好在一千条指令之后

1017
00:45:42,560 --> 00:45:44,720
CPU会强制将中断虚拟机monitor

1018
00:45:44,720 --> 00:45:46,460
CPU会强制将中断虚拟机monitor

1019
00:45:46,460 --> 00:45:48,530
这是特殊的硬件

1020
00:45:48,530 --> 00:45:51,740
但是所有英特尔芯片上有，因此它不是

1021
00:45:51,740 --> 00:45:53,930
那么特别

1022
00:45:53,930 --> 00:45:56,960
放在15年前，它还挺新鲜的，现在完全是常规操作

1023
00:45:56,960 --> 00:45:59,510
而且

1024
00:45:59,510 --> 00:46:01,550
它还有很多其他用途，例如

1025
00:46:01,550 --> 00:46:02,930
如果您想进行性能分析

1026
00:46:02,930 --> 00:46:04,940
您想做CPU时间性能分析

1027
00:46:04,940 --> 00:46:07,550
执行CPU时间分析的一种方法

1028
00:46:07,550 --> 00:46:09,290
是让微处理器每千条指令中断一次

1029
00:46:09,290 --> 00:46:11,420
是让微处理器每千条指令中断一次

1030
00:46:11,420 --> 00:46:13,190
这里用的是相同的硬件

1031
00:46:13,190 --> 00:46:15,470
是和让微处理器每千条指令产生一个中断的相同的硬件

1032
00:46:15,470 --> 00:46:17,180
是和让微处理器每千条指令产生一个中断的相同的硬件

1033
00:46:17,180 --> 00:46:18,860
是和让微处理器每千条指令产生一个中断的相同的硬件

1034
00:46:18,860 --> 00:46:21,920
所以这是你的CPU中非常自然的小工具

1035
00:46:21,920 --> 00:46:25,630
所以这是你的CPU中非常自然的小工具

1036
00:46:31,430 --> 00:46:39,170
好的，是的

1037
00:46:54,270 --> 00:46:56,070
如果backup领先primary怎么办

1038
00:46:56,070 --> 00:46:59,760
我们知道

1039
00:46:59,760 --> 00:47:02,820
primary即将在第一百万条指令处中断

1040
00:47:02,820 --> 00:47:04,680
primary即将在第一百万条指令处中断

1041
00:47:04,680 --> 00:47:08,970
但是备份已经执行了第一百万零一条指令

1042
00:47:08,970 --> 00:47:11,760
但是备份已经执行了第一百万零一条指令

1043
00:47:11,760 --> 00:47:14,010
但是备份已经执行了第一百万零一条指令

1044
00:47:14,010 --> 00:47:16,530
如果我们允许这种情况发生

1045
00:47:16,530 --> 00:47:19,440
那么传递中断将为时已晚

1046
00:47:19,440 --> 00:47:21,240
如果我们允许backup领先primary执行

1047
00:47:21,240 --> 00:47:23,730
就来不及将中断放在

1048
00:47:23,730 --> 00:47:26,040
primary指令流和backup指令流的相同位置

1049
00:47:26,040 --> 00:47:27,510
primary指令流和backup指令流的相同位置

1050
00:47:27,510 --> 00:47:29,310
primary指令流和backup指令流的相同位置

1051
00:47:29,310 --> 00:47:31,560
所以我们不能让这种情况发生

1052
00:47:31,560 --> 00:47:33,660
我们不能让backup在执行中领先于primary

1053
00:47:33,660 --> 00:47:37,860
而VMware FT实现这一亩地的方式

1054
00:47:37,860 --> 00:47:45,450
就是backup虚拟机monitor

1055
00:47:45,450 --> 00:47:46,680
实际上维护一个缓冲区

1056
00:47:46,680 --> 00:47:49,680
存放来自primary的等待执行的事件

1057
00:47:49,680 --> 00:47:53,400
存放来自primary的等待执行的事件

1058
00:47:53,400 --> 00:47:56,460
它不会让backup执行

1059
00:47:56,460 --> 00:47:58,920
除非该缓冲区中至少有一个事件

1060
00:47:58,920 --> 00:48:01,500
如果该缓冲区中有一个事件

1061
00:48:01,500 --> 00:48:02,910
那么它将根据指令编号，知道强制停止backup执行的位置

1062
00:48:02,910 --> 00:48:07,410
那么它将根据指令编号，知道强制停止backup执行的位置

1063
00:48:07,410 --> 00:48:10,890
那么它将根据指令编号，知道强制停止backup执行的位置

1064
00:48:10,890 --> 00:48:14,760
因此，任何时候当backup在执行时

1065
00:48:14,760 --> 00:48:17,420
CPU总是已经被告知下一个停止的时间点

1066
00:48:17,420 --> 00:48:19,710
即下一个停止的指令序号

1067
00:48:19,710 --> 00:48:21,720
即下一个停止的指令序号

1068
00:48:21,720 --> 00:48:24,320
只有在buffer中有事件，告诉其下一步停止的地方时

1069
00:48:24,320 --> 00:48:26,700
backup才会执行

1070
00:48:26,700 --> 00:48:30,450
所以这意味着它会在primary之后

1071
00:48:30,450 --> 00:48:31,800
因为backup甚至不能开始执行，直到primary

1072
00:48:31,800 --> 00:48:33,570
因为backup甚至不能开始执行，直到primary

1073
00:48:33,570 --> 00:48:35,790
产生了第一个事件，并且该事件已经到达backup

1074
00:48:35,790 --> 00:48:37,470
产生了第一个事件，并且该事件已经到达backup

1075
00:48:37,470 --> 00:48:39,180
因此backup总是落后primary一个事件

1076
00:48:39,180 --> 00:48:41,700
落后primary至少一个事件

1077
00:48:41,700 --> 00:48:43,140
落后primary至少一个事件

1078
00:48:43,140 --> 00:48:44,730
如果由于某种原因而变慢

1079
00:48:44,730 --> 00:48:45,780
可能是该物理机器上正在运行其他内容

1080
00:48:45,780 --> 00:48:47,760
可能是该物理机器上正在运行其他内容

1081
00:48:47,760 --> 00:48:50,880
那么backup可能落后primary多个事件

1082
00:48:50,880 --> 00:48:53,360
那么backup可能落后primary多个事件

1083
00:48:58,349 --> 00:49:03,099
对于到达特定数据包的情况，通常会有一点复杂

1084
00:49:03,099 --> 00:49:05,520
对于到达特定数据包的情况，通常会有一点复杂

1085
00:49:05,520 --> 00:49:16,539
通常地，当一个

1086
00:49:16,539 --> 00:49:17,950
数据包从网络接口卡到达

1087
00:49:17,950 --> 00:49:19,299
如果我们没有运行虚拟机

1088
00:49:19,299 --> 00:49:22,210
网络接口卡会

1089
00:49:22,210 --> 00:49:24,670
通过DMA方式将数据包内容传到它所在计算机的内存中

1090
00:49:24,670 --> 00:49:27,730
通过DMA方式将数据包内容传到它所在计算机的内存中

1091
00:49:27,730 --> 00:49:30,490
当数据从网络接口卡到达时

1092
00:49:30,490 --> 00:49:33,069
当数据从网络接口卡到达时

1093
00:49:33,069 --> 00:49:34,839
你可能没有编写过这样的软件

1094
00:49:34,839 --> 00:49:38,200
但有可能，计算机上运行的操作系统

1095
00:49:38,200 --> 00:49:39,490
但可能是计算机上运行的操作系统

1096
00:49:39,490 --> 00:49:41,799
可能会看到包中的数据

1097
00:49:41,799 --> 00:49:44,230
当数据被从网络接口卡DMA或拷贝到内存时

1098
00:49:44,230 --> 00:49:46,299
当数据被从网络接口卡DMA或拷贝到内存时

1099
00:49:46,299 --> 00:49:49,779
我们不知道运行的是什么操作系统

1100
00:49:49,779 --> 00:49:51,010
这个系统（VMM）被设计以支持任何操作系统

1101
00:49:51,010 --> 00:49:52,150
这个系统（VMM）被设计以支持任何操作系统

1102
00:49:52,150 --> 00:49:53,950
可能有一个操作系统

1103
00:49:53,950 --> 00:49:56,039
可能有一个操作系统

1104
00:49:56,039 --> 00:49:58,779
当它们被复制到内存中时，观察到内存中到达的数据包

1105
00:49:58,779 --> 00:50:01,200
当它们被复制到内存中时，观察到内存中到达的数据包

1106
00:50:01,300 --> 00:50:02,470
所以我们不能让这种情况发生

1107
00:50:02,500 --> 00:50:06,030
如果在主节点用的是这种方式

1108
00:50:07,130 --> 00:50:08,450
它就会观察到

1109
00:50:08,630 --> 00:50:14,850
如果我们允许网卡直接将接收到的包DMA到主节点内存

1110
00:50:15,460 --> 00:50:22,900
我们没办法精确控制网卡将数据复制到内存的时间点

1111
00:50:23,130 --> 00:50:32,150
所以我们也不知道 什么时候主节点观察到网络包中的数据

1112
00:50:32,580 --> 00:50:41,720
这就意味着网卡复制包进虚拟机监视器的虚拟内存

1113
00:50:41,950 --> 00:50:46,760
然后打断虚拟机监视器告诉它有抵达的包

1114
00:50:47,040 --> 00:50:51,130
这时虚拟机监视器就会中断主节点

1115
00:50:51,270 --> 00:50:53,850
记住当前位置的指令号

1116
00:50:54,100 --> 00:51:01,210
在主节点中断的时候 复制整个包到主节点的内存

1117
00:51:01,920 --> 00:51:05,740
然后模拟主节点的网卡中断

1118
00:51:06,600 --> 00:51:12,510
然后发送包和中断位置的指令号到副节点

1119
00:51:12,660 --> 00:51:16,150
副节点也会中断

1120
00:51:16,250 --> 00:51:19,480
副节点也会在同样的指令号位置中断

1121
00:51:19,540 --> 00:51:24,720
复制整个包到副节点的内存 同样副节点中断没有注意包的抵达过程

1122
00:51:24,770 --> 00:51:28,200
然后模拟副节点在同样指令号位置中断

1123
00:51:28,390 --> 00:51:35,530
这就是论文中描述的回弹缓冲机制

1124
00:51:56,010 --> 00:52:04,920
会产生记录通道流量的指令都是不寻常的指令 很少见

1125
00:52:05,270 --> 00:52:11,810
一般是在主节点和副节点执行结果会不同的指令

1126
00:52:11,980 --> 00:52:15,300
例如获取当前时间 获取当前处理器数量

1127
00:52:15,340 --> 00:52:17,780
或者获取已执行的指令数量

1128
00:52:18,250 --> 00:52:20,640
这些相对来说都是很少见的

1129
00:52:20,890 --> 00:52:23,620
或者说像生成随机数

1130
00:52:23,670 --> 00:52:27,490
让硬件生成用于加密的随机数之类的

1131
00:52:27,760 --> 00:52:29,590
这些都不是日常的指令

1132
00:52:29,930 --> 00:52:34,450
大多数指令例如相加的指令会在主副节点有相同的结果

1133
00:52:50,900 --> 00:52:56,350
没错 每个网络包都被直接打包转发没有修改

1134
00:52:56,630 --> 00:53:00,900
由两边的TCP/IP栈进行解析

1135
00:53:01,980 --> 00:53:09,390
所以我认为99.99%的记录通道流量都是来自于接收到的包

1136
00:53:09,670 --> 00:53:15,070
只有少部分是因为会产生不确定结果的指令造成

1137
00:53:16,560 --> 00:53:22,920
所以我们可以猜到在有客户端连接的服务器上 流量大概是什么样子的

1138
00:53:22,990 --> 00:53:25,320
基本就是各个客户端发的包

1139
00:53:26,590 --> 00:53:30,920
所以我们就能估算出记录通道需要有怎样的性能

1140
00:53:40,690 --> 00:53:43,270
输出是如何工作的也值得讲一下

1141
00:53:44,010 --> 00:53:49,190
在这个系统中 输出就是指发送数据包

1142
00:53:49,770 --> 00:53:55,820
客户端发送请求的网络包 服务端响应网络包

1143
00:53:55,870 --> 00:53:57,700
没有其他形式的输出了

1144
00:53:59,290 --> 00:54:04,840
主节点和副节点计算他们要发送的数据包

1145
00:54:04,960 --> 00:54:08,870
在主节点上真正进行发送

1146
00:54:09,000 --> 00:54:11,710
副节点的包则被简单地丢弃掉

1147
00:54:15,520 --> 00:54:18,310
真实的情况会稍微复杂一点

1148
00:54:19,540 --> 00:54:25,840
假设我们在跑的是一个简单的数据库服务器

1149
00:54:26,030 --> 00:54:30,730
服务器支持客户端进行计数器自增（Increment)操作

1150
00:54:30,850 --> 00:54:37,910
客户端发送自增的请求 服务端对计数器进行加操作 返回操作后的值

1151
00:54:39,570 --> 00:54:42,490
假设在主节点一切都正常

1152
00:54:42,580 --> 00:54:49,140
主副节点现在都存有计数器值10在内存中

1153
00:54:51,000 --> 00:54:55,190
本地网络的客户端发送自增请求到主节点

1154
00:54:56,290 --> 00:55:04,510
这个网络包被发到主节点

1155
00:55:04,630 --> 00:55:08,230
然后被主节点的程序执行

1156
00:55:08,260 --> 00:55:11,610
比如说现在是10 我要将他变为11

1157
00:55:11,900 --> 00:55:17,590
然后产生回复告诉客户端结果11

1158
00:55:19,180 --> 00:55:27,110
这个请求也会被发送到副本上 将10改为11

1159
00:55:27,330 --> 00:55:31,100
然后同样产生一个回复 并被丢弃掉 理论上是这样

1160
00:55:31,570 --> 00:55:39,180
然而你也要想一下如果在不恰当的时间服务出现失败会怎么样

1161
00:55:39,440 --> 00:55:42,730
上这门课的期间你要一直这样问自己

1162
00:55:43,570 --> 00:55:47,580
何时出现失败是最坏的情况 这种情况下会发生什么

1163
00:55:53,640 --> 00:55:59,420
假设主节点确实生成了返回给客户端的回复

1164
00:55:59,870 --> 00:56:05,810
但是主节点在发送完回复之后就宕机了

1165
00:56:05,970 --> 00:56:12,630
更糟的是 网络向来不保证数据包能传递到接收方

1166
00:56:12,960 --> 00:56:20,520
再假设记录通道也在主节点宕机的时候失效了

1167
00:56:20,820 --> 00:56:25,370
那么现在的状态就是 客户端收到回复11

1168
00:56:26,470 --> 00:56:30,970
但是副节点没有收到转发来的客户端请求 所以计数器仍然是10

1169
00:56:32,570 --> 00:56:38,090
现在因为察觉到主节点宕机 副节点接管服务

1170
00:56:38,500 --> 00:56:42,360
那这个或者其他客户端发送自增请求到原来的副节点

1171
00:56:42,460 --> 00:56:47,570
当收到请求的时候这个接管工作的副节点开始处理

1172
00:56:48,000 --> 00:56:50,170
将计数器从10自增为11

1173
00:56:51,850 --> 00:56:56,240
然后值11就会第二次作为回复出现

1174
00:56:57,210 --> 00:56:59,010
回复给原来的客户端或者不同的客户端

1175
00:56:59,550 --> 00:57:06,110
客户端如果比较会发现这是同样的回复 这本不应该发生

1176
00:57:06,570 --> 00:57:11,380
因为我们需要支撑的程序在没改动的情况下

1177
00:57:11,390 --> 00:57:14,380
并不能处理这些副节点上不寻常的问题

1178
00:57:14,620 --> 00:57:17,540
意思是我们不能对它进行修改

1179
00:57:17,550 --> 00:57:19,060
比如说我们可以

1180
00:57:19,080 --> 00:57:21,300
把客户端改成能处理

1181
00:57:21,380 --> 00:57:24,650
副节点容错性带来的问题

1182
00:57:24,810 --> 00:57:26,210
但是实际上我们没有这种选择

1183
00:57:26,550 --> 00:57:30,490
因为这个系统只有在我们不需要客户端进行改动的情况下才有意义

1184
00:57:32,370 --> 00:57:34,930
所以这是个灾难

1185
00:57:35,920 --> 00:57:37,240
我们不能让它发生

1186
00:57:39,730 --> 00:57:44,320
有人记得论文上是怎么样防止它发生的吗？

1187
00:57:45,780 --> 00:57:49,150
输出规则 对的

1188
00:57:55,140 --> 00:57:58,920
没错解决的方案就是控制输出规则

1189
00:58:03,090 --> 00:58:07,240
方案就是阻止输出

1190
00:58:07,740 --> 00:58:10,850
在主节点上不允许生成任何输出

1191
00:58:10,870 --> 00:58:13,480
比如我们现在说的这个计数器输出

1192
00:58:13,800 --> 00:58:22,330
直到副节点确认收到了所有的记录

1193
00:58:22,740 --> 00:58:28,260
所以整个流程正确的顺序是 回到主节点宕机之前

1194
00:58:30,980 --> 00:58:32,600
回到计数器还是10的时候

1195
00:58:32,610 --> 00:58:35,960
正确的顺序是 在这个输出规则下

1196
00:58:39,000 --> 00:58:40,160
当输入到来时

1197
00:58:40,410 --> 00:58:48,540
虚拟机监视器发送输入的副本到副节点

1198
00:58:49,320 --> 00:58:53,780
这个输入的日志信息

1199
00:58:54,170 --> 00:58:57,590
在主节点产生输出前发到副节点

1200
00:59:01,400 --> 00:59:06,530
发送之后这个日志就在去往副节点的网络中

1201
00:59:08,360 --> 00:59:09,470
这个日志有可能丢失

1202
00:59:11,460 --> 00:59:17,450
虚拟机监视器同样传递请求到主节点 生成输出

1203
00:59:17,620 --> 00:59:24,620
所以现在主节点生成结果 计数器值变为11

1204
00:59:24,630 --> 00:59:27,250
然后产生一个11的回复

1205
00:59:27,370 --> 00:59:30,770
但是虚拟机监视器说等一下 现在还不允许生成输出

1206
00:59:30,850 --> 00:59:33,470
直到之前的日志记录都被副节点确认

1207
00:59:33,900 --> 00:59:37,600
这是最近的一条日志消息

1208
00:59:37,880 --> 00:59:40,300
所以输出都被虚拟机监视器截停

1209
00:59:40,490 --> 00:59:45,320
直到这条包含客户端输入的日志

1210
00:59:45,570 --> 00:59:49,570
被虚拟机监视器投递和缓冲

1211
00:59:49,610 --> 00:59:51,350
但是不一定马上会执行

1212
00:59:51,900 --> 00:59:55,760
可能需要等待副节点执行到指令流中对应的位置

1213
00:59:56,000 --> 01:00:01,370
到这里虚拟机监视器就会发送一个ACK包说自己收到输入

1214
01:00:01,790 --> 01:00:03,350
当确认消息抵达时

1215
01:00:04,780 --> 01:00:09,350
虚拟机监视器才会将包发送到网络中

1216
01:00:11,010 --> 01:00:14,270
所以这个方案就是 若客户端可以收到回复

1217
01:00:14,480 --> 01:00:19,140
那么副节点肯定也收到过请求 并且至少已经存到缓冲区

1218
01:00:21,750 --> 01:00:23,800
因此我们不在会有以下的异常

1219
01:00:23,830 --> 01:00:28,390
客户端已经收到了回复 然后因为有故障发生

1220
01:00:28,450 --> 01:00:31,430
副节点完全没有接到过相关内容

1221
01:00:33,770 --> 01:00:38,500
比如说有些情况消息可能会中途丢失

1222
01:00:39,750 --> 01:00:44,040
日志记录丢失后主节点宕机

1223
01:00:44,470 --> 01:00:47,670
因为消息没投递成功 所以副节点也没有确认

1224
01:00:47,740 --> 01:00:49,310
如果主节点宕机

1225
01:00:50,180 --> 01:00:52,860
日志记录随主节点宕机丢失

1226
01:00:52,890 --> 01:00:57,230
它肯定在虚拟机监视器发送输出包之前丢失

1227
01:00:57,280 --> 01:01:00,750
客户端不可能提前收到回复

1228
01:01:02,340 --> 01:01:05,690
它们也不会识别出异常发生

1229
01:01:09,470 --> 01:01:11,230
所以我们需要有输出规则进行限制

1230
01:01:27,540 --> 01:01:28,450

1231
01:01:29,620 --> 01:01:35,190
我不了解 论文没有谈到虚拟机监视器的实现

1232
01:01:35,390 --> 01:01:36,920
这是非常底层的知识

1233
01:01:37,840 --> 01:01:40,960
像划分内存空间 计算页表

1234
01:01:41,070 --> 01:01:44,330
与设备驱动交互 拦截指令

1235
01:01:44,380 --> 01:01:48,340
搞明白Guest用户执行的命令等

1236
01:01:48,540 --> 01:01:53,960
所以这是一些底层的东西 一般用C或C++编写的

1237
01:01:54,010 --> 01:01:55,010
但我并不了解

1238
01:01:58,540 --> 01:02:02,730
回到这里 主节点需要延迟回复

1239
01:02:03,330 --> 01:02:08,060
先等副节点确认已经收到最新消息

1240
01:02:08,540 --> 01:02:14,690
这是几乎所有主备复制模式性能的一道坎

1241
01:02:15,080 --> 01:02:20,230
这种同步等待让主节点不会领先于副节点太多

1242
01:02:20,300 --> 01:02:22,930
因为如果主节点在领先的情况下出现故障

1243
01:02:23,130 --> 01:02:25,980
副节点就会出现数据延迟

1244
01:02:26,050 --> 01:02:28,340
副节点的进度和客户端会不一致

1245
01:02:28,400 --> 01:02:31,250
所以每种主备系统都有这样的问题

1246
01:02:31,310 --> 01:02:34,980
某个时间主节点必须等待副节点

1247
01:02:35,370 --> 01:02:37,280
这是对性能实打实的限制

1248
01:02:37,350 --> 01:02:40,120
即使机器是在相邻机架上

1249
01:02:40,250 --> 01:02:43,790
主节点发送消息和接收确认

1250
01:02:43,870 --> 01:02:47,370
仍然需要等上0.5毫秒

1251
01:02:47,440 --> 01:02:51,930
如果说像避免像地震 大范围断电等问题

1252
01:02:52,060 --> 01:02:54,590
主副节点必须位于不同的城市

1253
01:02:54,640 --> 01:02:56,930
那延迟大概会增加到5毫秒

1254
01:02:56,970 --> 01:03:01,840
如果我们主副节点在不同城市进行复制

1255
01:03:01,900 --> 01:03:04,340
每一个发送的包

1256
01:03:04,440 --> 01:03:10,250
都需要等上5毫秒让日志记录到达副节点上

1257
01:03:10,320 --> 01:03:13,290
然后响应确认 最后才能发送回复给客户端

1258
01:03:13,370 --> 01:03:17,370
对于一些可靠性要求低的服务 可能并不成问题

1259
01:03:18,560 --> 01:03:21,830
但是对于一些数据库服务

1260
01:03:21,870 --> 01:03:25,570
比如需要每秒处理百万请求

1261
01:03:25,620 --> 01:03:28,560
那将会对性能有极大的影响

1262
01:03:29,980 --> 01:03:33,960
这也时在条件允许的情况下

1263
01:03:34,050 --> 01:03:38,010
人们会使用一些不同的主副复制模式

1264
01:03:38,080 --> 01:03:41,750
比如说在更高层次操作 并且需要解析操作内容

1265
01:03:41,810 --> 01:03:44,330
然后不需要每个包都等待确认

1266
01:03:44,410 --> 01:03:48,880
比如只在进行高层次操作时才等待

1267
01:03:48,950 --> 01:03:51,610
只读操作完全不需要等待

1268
01:03:51,680 --> 01:03:53,260
只需要等待写操作同步或者其他一些操作

1269
01:03:53,440 --> 01:03:57,370
但你需要在应用层上实现这些区分

1270
01:04:04,250 --> 01:04:05,090
你说的都是对的

1271
01:04:05,480 --> 01:04:08,420
虚拟机监视器不需要阻止主节点执行命令

1272
01:04:08,480 --> 01:04:10,120
只需要阻止输出就好

1273
01:04:10,570 --> 01:04:13,780
这可能可以做得更好

1274
01:04:13,850 --> 01:04:16,860
但至少这样在一个服务中

1275
01:04:16,910 --> 01:04:21,490
可以在几微秒内响应客户端

1276
01:04:21,740 --> 01:04:25,750
如果我们要先等待处于另一个城市的副节点响应

1277
01:04:25,870 --> 01:04:30,910
那可能会让10微秒变成10毫秒

1278
01:04:35,900 --> 01:04:40,570
如果你有大量客户端并发请求

1279
01:04:40,620 --> 01:04:44,870
虽然可能在高延迟下完成大量处理

1280
01:04:44,940 --> 01:04:49,260
但是你需要非常巧妙的设计才能做到

1281
01:05:02,080 --> 01:05:03,180
这是个很好的想法

1282
01:05:03,230 --> 01:05:06,010
但是如果你将消息记录到主节点内存中

1283
01:05:06,070 --> 01:05:08,510
在主节点宕机时日志就会丢失

1284
01:05:08,560 --> 01:05:12,310
通常认为服务器失效就意味着

1285
01:05:12,830 --> 01:05:16,660
服务器内存中的内容都会丢失

1286
01:05:16,830 --> 01:05:19,690
或者即使你不会如此

1287
01:05:20,030 --> 01:05:24,110
比如说失效是因为主节点电源被意外拔掉

1288
01:05:24,180 --> 01:05:28,520
但你有备用电源之类

1289
01:05:29,730 --> 01:05:30,780
你也做不到

1290
01:05:31,290 --> 01:05:32,550
副节点也做不到如此

1291
01:05:33,130 --> 01:05:38,840
实际上系统在副节点的内存中记录了输出

1292
01:05:39,460 --> 01:05:44,270
为了保证可靠记录 你必须遵守输出规则 等待确认

1293
01:05:44,370 --> 01:05:48,800
所以这是个正确的想法 但是不能使用主节点内存来做

1294
01:05:59,070 --> 01:05:59,670
再说一遍?

1295
01:06:05,170 --> 01:06:06,540
这个想法很棒

1296
01:06:06,610 --> 01:06:12,480
他问的是 能否输入由主节点接收 输出由副节点发送

1297
01:06:12,970 --> 01:06:15,160
我完全没有想过

1298
01:06:15,940 --> 01:06:16,930
这或许可以

1299
01:06:18,390 --> 01:06:19,860
我不确定 这很有意思

1300
01:06:29,280 --> 01:06:30,390

1301
01:06:45,100 --> 01:06:49,370
还有一个可能出现的情况

1302
01:06:53,850 --> 01:06:59,230
主节点在输出已经发送出去之后宕机

1303
01:06:59,490 --> 01:07:01,650
客户端已经收到回复

1304
01:07:01,990 --> 01:07:03,540
然后主节点宕机

1305
01:07:04,370 --> 01:07:08,920
副节点的输入还在事件缓冲中

1306
01:07:09,130 --> 01:07:12,820
在副节点的虚拟机监视器种

1307
01:07:12,880 --> 01:07:15,660
还没有投递到真正的服务副本

1308
01:07:16,820 --> 01:07:20,710
副节点要顶替宕机的主节点

1309
01:07:20,790 --> 01:07:27,460
它首先要消费所有未处理的记录

1310
01:07:27,520 --> 01:07:29,720
以赶上主节点的进度

1311
01:07:29,770 --> 01:07:31,930
否则主副节点进度就会不一致

1312
01:07:32,060 --> 01:07:36,260
副节点在接管服务之前要先消费完记录

1313
01:07:36,530 --> 01:07:41,290
最后一条记录是客户端的请求

1314
01:07:41,780 --> 01:07:46,950
副节点会在它之后开始接管服务

1315
01:07:48,330 --> 01:07:50,970
在传递客户端请求的中断之后

1316
01:07:51,360 --> 01:07:56,330
这意味着副节点计数器自增到11

1317
01:07:56,410 --> 01:07:59,600
然后生成一个输出包 因为这时候它接管服务

1318
01:08:00,960 --> 01:08:05,830
所以生成输出 客户端会受到两个11回复

1319
01:08:08,980 --> 01:08:16,110
如果真的发生这种情况的话是不对的

1320
01:08:16,320 --> 01:08:20,640
如果是单服务器的话这不应该发生

1321
01:08:21,660 --> 01:08:25,000
好消息则是

1322
01:08:25,490 --> 01:08:29,490
如果服务间是使用TCP通信

1323
01:08:29,610 --> 01:08:32,850
请求和响应都是通过TCP通道传输

1324
01:08:33,310 --> 01:08:35,180
当副节点接管时

1325
01:08:35,650 --> 01:08:40,140
副节点的状态和主节点一致 知道所有TCP连接

1326
01:08:40,210 --> 01:08:42,510
还有所有的序列号

1327
01:08:43,080 --> 01:08:44,860
当它产生这个包时

1328
01:08:46,220 --> 01:08:51,110
它会产生和原来的包一样的序列号

1329
01:08:51,280 --> 01:08:54,980
客户端的TCP栈会认为这是个重复的包

1330
01:08:55,240 --> 01:08:58,070
在TCP层就会将它丢弃掉

1331
01:08:58,330 --> 01:09:00,990
而在用户层软件中永远不会看到重复包

1332
01:09:01,950 --> 01:09:04,520
所以这个系统中

1333
01:09:08,050 --> 01:09:10,830
你可以认为问题被意外解决了或者被巧妙处理了

1334
01:09:11,060 --> 01:09:15,400
但事实上对于所有能够进行切换的复制系统

1335
01:09:15,630 --> 01:09:18,390
也就是大部分的复制系统

1336
01:09:18,840 --> 01:09:22,410
很难将他们设计成

1337
01:09:22,470 --> 01:09:26,380
保证切换时不会有重复输出

1338
01:09:28,910 --> 01:09:31,430
你可以在两边都引发报错

1339
01:09:31,550 --> 01:09:34,210
然后在两边都不生成输出

1340
01:09:34,310 --> 01:09:36,900
但是这种做法很糟糕

1341
01:09:36,980 --> 01:09:39,640
或者你可以允许切换时有两次输出

1342
01:09:40,410 --> 01:09:44,460
总之没有办法可以保证只有一次输出

1343
01:09:44,530 --> 01:09:48,530
两边都引发报错或者允许可能的重复输出

1344
01:09:49,240 --> 01:09:53,650
某种程度上说 所有复制模式的客户端

1345
01:09:53,730 --> 01:09:56,200
都需要重复包的检测机制

1346
01:09:56,500 --> 01:09:59,610
在这里我们使用TCP 不然的话也需要其他实现

1347
01:09:59,620 --> 01:10:03,010

1348
01:10:04,450 --> 01:10:05,600

1349
01:10:06,530 --> 01:10:08,450

1350
01:10:08,550 --> 01:10:14,470

1351
01:10:15,450 --> 01:10:18,060

1352
01:10:18,160 --> 01:10:18,690

1353
01:10:45,590 --> 01:10:46,790

1354
01:10:46,940 --> 01:10:48,180

1355
01:10:48,510 --> 01:10:51,140

1356
01:10:51,230 --> 01:10:53,350

1357
01:10:53,420 --> 01:10:57,950

1358
01:10:58,040 --> 01:11:00,210

1359
01:11:00,610 --> 01:11:02,400

1360
01:11:02,530 --> 01:11:03,630

1361
01:11:04,060 --> 01:11:09,450

1362
01:11:09,700 --> 01:11:13,620

1363
01:11:13,660 --> 01:11:17,550

1364
01:11:17,810 --> 01:11:24,330

1365
01:11:24,360 --> 01:11:24,980

1366
01:11:25,050 --> 01:11:29,050

1367
01:11:29,080 --> 01:11:32,300

1368
01:11:32,890 --> 01:11:39,100

1369
01:11:39,610 --> 01:11:41,960

1370
01:11:42,000 --> 01:11:44,170

1371
01:11:44,490 --> 01:11:46,270

1372
01:11:46,320 --> 01:11:50,690

1373
01:11:51,340 --> 01:11:52,740

1374
01:11:52,820 --> 01:11:55,130

1375
01:11:55,720 --> 01:11:58,320

1376
01:11:58,350 --> 01:11:59,350

1377
01:11:59,460 --> 01:12:01,790

1378
01:12:01,840 --> 01:12:03,490

1379
01:12:03,600 --> 01:12:08,010

1380
01:12:08,030 --> 01:12:10,960

1381
01:12:13,070 --> 01:12:15,880

1382
01:12:16,860 --> 01:12:18,940

1383
01:12:20,460 --> 01:12:21,010

1384
01:12:36,860 --> 01:12:41,610

1385
01:12:41,700 --> 01:12:45,320

1386
01:12:45,850 --> 01:12:48,890

1387
01:12:49,250 --> 01:12:51,450

1388
01:12:59,660 --> 01:13:02,140

1389
01:13:02,690 --> 01:13:04,090

1390
01:13:04,790 --> 01:13:09,360

1391
01:13:13,080 --> 01:13:16,900

1392
01:13:17,790 --> 01:13:20,190

1393
01:13:20,550 --> 01:13:22,600

1394
01:13:22,680 --> 01:13:25,660

1395
01:13:27,850 --> 01:13:31,360

1396
01:13:31,400 --> 01:13:34,710

1397
01:13:34,770 --> 01:13:37,480

1398
01:13:37,540 --> 01:13:39,550

1399
01:13:39,870 --> 01:13:40,840

1400
01:13:40,910 --> 01:13:44,140

1401
01:13:44,210 --> 01:13:52,160

1402
01:13:53,140 --> 01:13:54,210

1403
01:13:54,840 --> 01:13:56,900

1404
01:13:56,960 --> 01:13:58,540

1405
01:13:59,470 --> 01:14:02,800

1406
01:14:02,830 --> 01:14:05,100

1407
01:14:05,170 --> 01:14:09,280

1408
01:14:09,330 --> 01:14:12,780

1409
01:14:13,220 --> 01:14:20,060

1410
01:14:20,500 --> 01:14:22,300

1411
01:14:23,350 --> 01:14:25,510

1412
01:14:25,590 --> 01:14:26,510

1413
01:14:29,690 --> 01:14:35,170

1414
01:14:36,190 --> 01:14:39,720

1415
01:14:40,770 --> 01:14:41,900

1416
01:14:42,470 --> 01:14:43,680

1417
01:14:43,760 --> 01:14:47,180

1418
01:14:47,220 --> 01:14:51,190

1419
01:14:51,240 --> 01:14:53,580

1420
01:14:55,480 --> 01:14:57,360

1421
01:14:57,410 --> 01:14:59,330

1422
01:15:01,080 --> 01:15:04,600

1423
01:15:04,680 --> 01:15:06,140

1424
01:15:06,190 --> 01:15:08,130

1425
01:15:08,510 --> 01:15:09,920

1426
01:15:10,000 --> 01:15:13,150

1427
01:15:13,500 --> 01:15:17,070

1428
01:15:17,130 --> 01:15:18,200

1429
01:15:18,460 --> 01:15:22,000

1430
01:15:22,070 --> 01:15:24,040

1431
01:15:24,150 --> 01:15:27,000

1432
01:15:27,280 --> 01:15:31,660

1433
01:15:34,170 --> 01:15:36,440

1434
01:15:37,520 --> 01:15:43,180

1435
01:15:43,530 --> 01:15:46,640

1436
01:15:47,450 --> 01:15:48,150

1437
01:15:52,290 --> 01:15:55,200

1438
01:15:55,730 --> 01:15:56,850

1439
01:15:57,500 --> 01:15:59,810

1440
01:16:00,480 --> 01:16:03,960

1441
01:16:04,050 --> 01:16:05,270

1442
01:16:05,420 --> 01:16:08,070

1443
01:16:14,020 --> 01:16:15,880

1444
01:16:15,950 --> 01:16:19,210

1445
01:16:19,270 --> 01:16:21,230

1446
01:16:21,310 --> 01:16:23,890

1447
01:16:23,950 --> 01:16:29,330

1448
01:16:29,430 --> 01:16:30,690

1449
01:16:30,780 --> 01:16:35,400

1450
01:16:35,470 --> 01:16:36,930

1451
01:16:37,040 --> 01:16:40,860

1452
01:16:40,910 --> 01:16:43,870

1453
01:16:43,950 --> 01:16:45,770

1454
01:16:45,810 --> 01:16:48,600

1455
01:16:48,720 --> 01:16:51,690

1456
01:16:52,210 --> 01:16:54,750

1457
01:16:55,220 --> 01:16:56,760

1458
01:16:58,470 --> 01:17:01,790

1459
01:17:01,830 --> 01:17:05,420

1460
01:17:07,920 --> 01:17:09,640

1461
01:17:15,020 --> 01:17:16,070

1462
01:17:17,280 --> 01:17:21,310

1463
01:17:22,330 --> 01:17:24,590

1464
01:17:24,790 --> 01:17:26,540

1465
01:17:26,660 --> 01:17:29,960

1466
01:17:30,010 --> 01:17:31,670

1467
01:17:32,290 --> 01:17:35,020

1468
01:17:35,080 --> 01:17:40,190

1469
01:17:41,610 --> 01:17:44,980

1470
01:17:45,580 --> 01:17:48,130

1471
01:17:48,650 --> 01:17:51,140

1472
01:17:51,200 --> 01:17:56,080

1473
01:17:56,470 --> 01:17:58,510

1474
01:17:58,850 --> 01:18:00,650

1475
01:18:01,250 --> 01:18:02,850

1476
01:18:03,500 --> 01:18:04,370

1477
01:18:04,460 --> 01:18:06,020

1478
01:18:06,100 --> 01:18:08,120

1479
01:18:08,210 --> 01:18:12,650

1480
01:18:13,360 --> 01:18:15,350

1481
01:18:15,400 --> 01:18:17,400

1482
01:18:17,460 --> 01:18:19,910

1483
01:18:21,280 --> 01:18:24,460

1484
01:18:25,000 --> 01:18:27,500

1485
01:18:28,550 --> 01:18:32,490

1486
01:18:35,310 --> 01:18:36,420

1487
01:18:37,260 --> 01:18:38,380

1488
01:18:38,790 --> 01:18:41,720

1489
01:18:42,100 --> 01:18:46,290

1490
01:18:46,470 --> 01:18:49,480

1491
01:18:49,540 --> 01:18:54,240

1492
01:18:54,430 --> 01:18:57,180

1493
01:18:57,580 --> 01:19:00,730

1494
01:19:00,760 --> 01:19:02,410

1495
01:19:02,930 --> 01:19:07,370

1496
01:19:07,430 --> 01:19:11,480

1497
01:19:11,840 --> 01:19:13,670

