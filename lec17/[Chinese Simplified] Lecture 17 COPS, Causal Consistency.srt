1
00:00:02,689 --> 00:00:09,319
好吧，大家好，

2
00:00:10,849 --> 00:00:14,900
今天开始吧，主题是因果一致性

3
00:00:14,900 --> 00:00:20,910
，然后使用COPS系统

4
00:00:20,910 --> 00:00:23,310
我们每天的COPS论文

5
00:00:23,310 --> 00:00:26,099
是因果一致性的案例研究，所以

6
00:00:26,099 --> 00:00:30,570
设置实际上很熟悉我们

7
00:00:30,570 --> 00:00:35,850
再次谈论

8
00:00:35,850 --> 00:00:39,469
具有 多个数据中心中的数据，

9
00:00:39,469 --> 00:00:42,120
他们想要复制

10
00:00:42,120 --> 00:00:43,770
每个数据中心的所有数据，他们的

11
00:00:43,770 --> 00:00:45,750
数据中心必须保持副本

12
00:00:45,750 --> 00:00:50,700
靠近用户，并且可能是为了

13
00:00:50,700 --> 00:00:55,020
容错，所以像往常一样，我们可能

14
00:00:55,020 --> 00:00:59,600
会有三个数据 中心

15
00:01:02,630 --> 00:01:04,340
，你知道，因为我们正在构建大型

16
00:01:04,340 --> 00:01:05,690
系统，我们将分片数据

17
00:01:05,690 --> 00:01:07,280
，每个数据中心都将

18
00:01:07,280 --> 00:01:09,380
拥有多个服务器

19
00:01:09,380 --> 00:01:12,710
 

20
00:01:12,710 --> 00:01:14,570
 

21
00:01:14,570 --> 00:01:29,300
已经看过这个并且你知道

22
00:01:29,300 --> 00:01:31,520
人们的通常目标你知道

23
00:01:31,520 --> 00:01:33,470
有许多不同的设计

24
00:01:33,470 --> 00:01:34,820
来完成这项工作但你知道你

25
00:01:34,820 --> 00:01:37,190
真的喜欢阅读肯定喜欢

26
00:01:37,190 --> 00:01:39,080
阅读快因为这些 Web

27
00:01:39,080 --> 00:01:43,060
工作负载往往以阅读为主，

28
00:01:43,060 --> 00:01:45,680
并且您知道自己想要工作权，并且

29
00:01:45,680 --> 00:01:47,479
希望我们尽可能

30
00:01:47,479 --> 00:01:52,640
保持一致性，因此快速

31
00:01:52,640 --> 00:01:53,780
原因很有趣，因为

32
00:01:53,780 --> 00:01:55,970
客户端通常是 Web 浏览器

33
00:01:55,970 --> 00:01:59,270
，因此 Web 将 是一组

34
00:01:59,270 --> 00:02:03,020
网络浏览器，它们都将

35
00:02:03,020 --> 00:02:04,369
客户端称为存储系统，但它们

36
00:02:04,369 --> 00:02:07,039
实际上是与用户浏览器对话的网络浏览

37
00:02:07,039 --> 00:02:09,139
器，因此典型的安排

38
00:02:09,139 --> 00:02:11,800
是这些发生在本地的原因，

39
00:02:11,800 --> 00:02:14,420
并且权限可能稍微

40
00:02:14,420 --> 00:02:18,470
复杂一些，因此一个系统可以 适合这种

41
00:02:18,470 --> 00:02:22,790
模式的是扳手，你记得

42
00:02:22,790 --> 00:02:24,890
扳手和扳手权限涉及

43
00:02:24,890 --> 00:02:27,560
Paxos，它运行在所有数据

44
00:02:27,560 --> 00:02:29,800
中心，所以如果你在 paxos 中写入，

45
00:02:29,800 --> 00:02:33,290
可能数据中心的客户端需要

46
00:02:33,290 --> 00:02:35,959
写入，通信涉及

47
00:02:35,959 --> 00:02:39,350
实际需要可能需要税收

48
00:02:39,350 --> 00:02:41,300
在其中一台服务器上运行

49
00:02:41,300 --> 00:02:43,430
以与至少大多数其他

50
00:02:43,430 --> 00:02:45,319
副本数据中心通信，因此权限

51
00:02:45,319 --> 00:02:49,620
往往有点慢，但

52
00:02:49,620 --> 00:02:52,500
在附加方面是一致的 Savannah 支持

53
00:02:52,500 --> 00:02:54,319
两阶段提交，因此我们有事务

54
00:02:54,319 --> 00:02:57,450
并且读取速度要快得多，

55
00:02:57,450 --> 00:03:01,019
因为微风使用

56
00:03:01,019 --> 00:03:04,709
了本文所描述的真实时间方案，并且实际上

57
00:03:04,709 --> 00:03:07,560
只在本地咨询过我们还阅读了

58
00:03:07,560 --> 00:03:09,959
Facebook 的 memcache 新论文，这是本文的

59
00:03:09,959 --> 00:03:13,829
另一个设计 演示模式

60
00:03:13,829 --> 00:03:15,269
Facebook memcache 关键文件 有一个

61
00:03:15,269 --> 00:03:18,720
主站点包含

62
00:03:18,720 --> 00:03:21,060
我的续集数据库的主集，所以如果客户

63
00:03:21,060 --> 00:03:23,640
想要做一个权利，我想

64
00:03:23,640 --> 00:03:25,140
这个数据中心 3 的主端确实将所有权利发送

65
00:03:25,140 --> 00:03:27,750
到数据中心 3，然后是数据

66
00:03:27,750 --> 00:03:30,540
中心 3 向其他数据中心发送新信息或

67
00:03:30,540 --> 00:03:32,129
验证，

68
00:03:32,129 --> 00:03:33,750
因此实际上有点贵

69
00:03:33,750 --> 00:03:38,810
，另一方面与扳手不同，

70
00:03:38,810 --> 00:03:41,220
所有读取都是本地的，当客户端

71
00:03:41,220 --> 00:03:42,540
需要做一个珠子时，它可以咨询

72
00:03:42,540 --> 00:03:44,579
memcache 密钥服务器 本地数据

73
00:03:44,579 --> 00:03:49,920
中心和 memcachedb 先生，

74
00:03:49,920 --> 00:03:51,840
速度快得令人眼花缭乱，人们

75
00:03:51,840 --> 00:03:53,730
向他们报告单个 memcache

76
00:03:53,730 --> 00:03:56,519
服务器每秒保存一百万次读取，

77
00:03:56,519 --> 00:03:59,430
这非常快 因此，

78
00:03:59,430 --> 00:04:02,700
Facebook memcache D 方案再次需要

79
00:04:02,700 --> 00:04:04,079
涉及跨数据通信中心以

80
00:04:04,079 --> 00:04:06,450
获得权利，但读取

81
00:04:06,450 --> 00:04:09,930
是本地的，所以今天

82
00:04:09,930 --> 00:04:11,220
的问题和COPS论文回答的问题

83
00:04:11,220 --> 00:04:12,750
是，我们是否可以拥有一个

84
00:04:12,750 --> 00:04:16,880
允许纯粹在本地追求权利的系统，

85
00:04:16,880 --> 00:04:19,260
并且 从客户端的

86
00:04:19,260 --> 00:04:21,060
角度来看，客户端可以

87
00:04:21,060 --> 00:04:22,680
在正确的情况下与之交谈，他们可以

88
00:04:22,680 --> 00:04:26,729
在自己的数据中心中发送正确的本地副本

89
00:04:26,729 --> 00:04:28,800
以及

90
00:04:28,800 --> 00:04:31,050
仅对本地副本进行一些读取，而

91
00:04:31,050 --> 00:04:33,330
不必等待其他数据中心 永远

92
00:04:33,330 --> 00:04:34,770
不必与其他数据中心交谈或

93
00:04:34,770 --> 00:04:38,039
等待其他数据中心执行权限，

94
00:04:38,039 --> 00:04:40,830
所以我们真正想要的是一个

95
00:04:40,830 --> 00:04:47,780
可以具有本地读取和本地

96
00:04:48,440 --> 00:04:50,940
权限的系统，这是最大的目标，

97
00:04:50,940 --> 00:04:53,580
真正的性能目标，这将

98
00:04:53,580 --> 00:04:55,170
有助于提高 当然因为现在

99
00:04:55,170 --> 00:04:59,040
不像扳手和Facebook论文我们有

100
00:04:59,040 --> 00:05:00,690
一个纯粹的本地权限

101
00:05:00,690 --> 00:05:04,200
从客户的角度来看要快得多嗯，

102
00:05:04,200 --> 00:05:05,700
 

103
00:05:05,700 --> 00:05:08,160
如果权限的话，它也可能有助于容错鲁棒性 可以在本地完成，

104
00:05:08,160 --> 00:05:09,540
那么我们不必担心

105
00:05:09,540 --> 00:05:10,980
其他数据中心是否已启动，或者

106
00:05:10,980 --> 00:05:12,060
我们是否可以快速与他们交谈，

107
00:05:12,060 --> 00:05:15,090
因为客户不需要

108
00:05:15,090 --> 00:05:18,810
等待他们，所以我们将寻找

109
00:05:18,810 --> 00:05:20,790
具有此功能的系统 这种水平的

110
00:05:20,790 --> 00:05:25,500
性能，最后我们

111
00:05:25,500 --> 00:05:27,810
会让你知道一致性模型因为

112
00:05:27,810 --> 00:05:28,470
 

113
00:05:28,470 --> 00:05:29,880
如果你

114
00:05:29,880 --> 00:05:31,980
最初只对本地副本执行权限，我们会担心一致性你

115
00:05:31,980 --> 00:05:33,690
知道其他数据中心的副本数据怎么样，

116
00:05:33,690 --> 00:05:36,030
所以我们 肯定会担心

117
00:05:36,030 --> 00:05:36,840
一致性，

118
00:05:36,840 --> 00:05:38,850
但至少本次讲座的态度

119
00:05:38,850 --> 00:05:40,260
是，一旦我们弄清楚如何获得良好的性能，我们就会让

120
00:05:40,260 --> 00:05:42,450
一致性跟踪

121
00:05:42,450 --> 00:05:44,640
你所知道的

122
00:05:44,640 --> 00:05:46,710
性能，

123
00:05:46,710 --> 00:05:48,450
然后再弄清楚如何定义

124
00:05:48,450 --> 00:05:51,210
一致性考虑它是否

125
00:05:51,210 --> 00:05:54,330
足够好，所以这就是总体

126
00:05:54,330 --> 00:05:56,790
策略我实际上要谈论

127
00:05:56,790 --> 00:06:02,040
两个稻草人设计，有点好，但

128
00:06:02,040 --> 00:06:05,700
不是很好的设计，然后

129
00:06:05,700 --> 00:06:08,160
我们才真正谈论COPS如何 s 工作，所以

130
00:06:08,160 --> 00:06:12,800
首先我想谈谈一个最简单的

131
00:06:12,800 --> 00:06:16,770
设计，它

132
00:06:16,770 --> 00:06:19,140
遵循我能想到的这种本地评级策略 我会称

133
00:06:19,140 --> 00:06:27,560
这个稻草人 1 所以在稻草中，

134
00:06:27,560 --> 00:06:33,680
我们将拥有三个数据中心

135
00:06:34,669 --> 00:06:37,350
，让我们假设 数据以

136
00:06:37,350 --> 00:06:41,490
两种方式在每个数据中心绘制，因此他

137
00:06:41,490 --> 00:06:43,560
可能来自 ATM，密钥来自

138
00:06:43,560 --> 00:06:45,300
大使馆，在每个数据中心以相同的方式分片

139
00:06:45,300 --> 00:06:55,100
，客户端将

140
00:06:55,100 --> 00:06:59,370
在本地读取，如果客户端写入，

141
00:06:59,370 --> 00:07:01,680
假设客户端需要写入密钥

142
00:07:01,680 --> 00:07:03,660
以 M 开头的客户端

143
00:07:03,660 --> 00:07:08,610
将向分片服务器发送密钥 M 的写入

144
00:07:08,610 --> 00:07:10,610
 

145
00:07:10,610 --> 00:07:13,290
负责的本地分片服务器 他以 M 开头 分片

146
00:07:13,290 --> 00:07:15,840
服务器将

147
00:07:15,840 --> 00:07:17,490
立即向客户端返回回复说哦，是的，

148
00:07:17,490 --> 00:07:22,200
我做对了，但是在 此外，每台

149
00:07:22,200 --> 00:07:26,360
服务器将维护

150
00:07:26,360 --> 00:07:29,010
一个已发送给它的未完成权限队列，

151
00:07:29,010 --> 00:07:30,660
最近获得了

152
00:07:30,660 --> 00:07:32,190
需要发送到其他数据中心的客户端，并且

153
00:07:32,190 --> 00:07:34,229
它将在后台将这些权限异步流式传输

154
00:07:34,229 --> 00:07:38,100
到相应的

155
00:07:38,100 --> 00:07:40,320
服务器 另一个数据中心，所以

156
00:07:40,320 --> 00:07:42,960
在向客户端申请后，我们的分片

157
00:07:42,960 --> 00:07:45,810
服务器

158
00:07:45,810 --> 00:07:48,960
将向每个其他数据设置发送客户端权限的副本

159
00:07:48,960 --> 00:07:52,169
，您知道这些权限

160
00:07:52,169 --> 00:07:53,250
通过网络可能需要

161
00:07:53,250 --> 00:07:55,229
很长时间，最终它们会

162
00:07:55,229 --> 00:07:57,120
到达 在目标数据集中，其他

163
00:07:57,120 --> 00:07:58,950
数据中心和这些分片

164
00:07:58,950 --> 00:08:00,930
服务器中的每一个都会将权限应用于其

165
00:08:00,930 --> 00:08:07,340
本地数据表，因此这是一种

166
00:08:07,340 --> 00:08:10,560
具有非常好的性能的设计，

167
00:08:10,560 --> 00:08:12,750
原因权限全部在本地完成可能

168
00:08:12,750 --> 00:08:13,979
永远不会有两个客户端永远不会 必须

169
00:08:13,979 --> 00:08:16,100
等待有很多并行性，

170
00:08:16,100 --> 00:08:18,990
因为您知道 a 的分片服务器，

171
00:08:18,990 --> 00:08:20,750
 

172
00:08:20,750 --> 00:08:22,710
如果 a 的分片

173
00:08:22,710 --> 00:08:24,270
服务器正确，您知道它必须

174
00:08:24,270 --> 00:08:27,120
将其数据推送到相应的分

175
00:08:27,120 --> 00:08:28,470
片服务器和其他数据中心 但是

176
00:08:28,470 --> 00:08:30,300
它可以

177
00:08:30,300 --> 00:08:33,150
独立于其他分片服务

178
00:08:33,150 --> 00:08:34,799
推送进行这些推送，因此

179
00:08:34,799 --> 00:08:36,450
 

180
00:08:36,450 --> 00:08:41,429
如果您稍微考虑一下，在服务和

181
00:08:41,429 --> 00:08:44,580
推送写入方面都存在并行性 设计本质上也

182
00:08:44,580 --> 00:08:48,250
有效地支持读取，并且读取

183
00:08:48,250 --> 00:08:50,290
实际上永远不会对

184
00:08:50,290 --> 00:08:52,150
本地数据中心产生任何影响尽管权利会

185
00:08:52,150 --> 00:08:53,680
在您执行权利时做一些工作，但您

186
00:08:53,680 --> 00:08:54,820
知道客户端不必等待

187
00:08:54,820 --> 00:08:57,010
它，但是分片服务器然后 必须

188
00:08:57,010 --> 00:08:59,320
将权限推送给其他数据中心

189
00:08:59,320 --> 00:09:01,810
，您知道这意味着

190
00:09:01,810 --> 00:09:03,220
其他数据中心的新数据

191
00:09:03,220 --> 00:09:06,490
会非常快速地进行，因此读取所需的工作量比

192
00:09:06,490 --> 00:09:09,040
权限少，如果您更担心速率性能，这适用于读取

193
00:09:09,040 --> 00:09:12,640
繁重的工作量

194
00:09:12,640 --> 00:09:14,470
可以想象

195
00:09:14,470 --> 00:09:16,420
其他设计，例如，您

196
00:09:16,420 --> 00:09:18,220
可以想象读取实际上

197
00:09:18,220 --> 00:09:19,810
必须咨询多个数据中心

198
00:09:19,810 --> 00:09:22,360
并且权限纯粹是本地的设计，因此您

199
00:09:22,360 --> 00:09:23,830
可以想象一个方案，当

200
00:09:23,830 --> 00:09:25,690
您进行读取时，您实际上从每个其他数据中心读取数据

201
00:09:25,690 --> 00:09:28,030
 

202
00:09:28,030 --> 00:09:30,970
从其他每个数据中心获取您想要的密钥的当前副本的日期

203
00:09:30,970 --> 00:09:32,350
并

204
00:09:32,350 --> 00:09:34,990
选择可能是最新的一个，然后

205
00:09:34,990 --> 00:09:37,390
权利非常便宜并且品种很

206
00:09:37,390 --> 00:09:38,430
昂贵 ve 或者您可以想象

207
00:09:38,430 --> 00:09:41,070
这两种策略的组合

208
00:09:41,070 --> 00:09:44,860
某种仲裁重叠方案，或者

209
00:09:44,860 --> 00:09:46,810
您编写多数并

210
00:09:46,810 --> 00:09:48,490
在仅大多数数据

211
00:09:48,490 --> 00:09:49,870
中心写入多数并满足大多数数据

212
00:09:49,870 --> 00:09:53,440
中心并依赖重叠，

213
00:09:53,440 --> 00:09:56,380
实际上有

214
00:09:56,380 --> 00:10:00,040
人们在商业上使用的真实实时系统在

215
00:10:00,040 --> 00:10:02,560
遵循这种设计的真实网站中使用，所以

216
00:10:02,560 --> 00:10:04,120
如果你对这种真实

217
00:10:04,120 --> 00:10:06,580
世界的版本感兴趣，你可以查找

218
00:10:06,580 --> 00:10:11,230
亚马逊的发电机系统或开源

219
00:10:11,230 --> 00:10:11,730
 

220
00:10:11,730 --> 00:10:14,410
Kassandra 系统，

221
00:10:14,410 --> 00:10:17,660
那里比 当

222
00:10:17,660 --> 00:10:19,760
我在这里勾画出但它们

223
00:10:19,760 --> 00:10:23,540
遵循相同的基本模式时，因此这种方案的通常名称

224
00:10:23,540 --> 00:10:26,960
是最终

225
00:10:26,960 --> 00:10:31,370
一致性，其原因是

226
00:10:31,370 --> 00:10:40,910
，至少在最初，如果你

227
00:10:40,910 --> 00:10:43,760
写其他读卡器和其他数据

228
00:10:43,760 --> 00:10:46,360
中心，则不能保证 EC 或正确，

229
00:10:46,360 --> 00:10:48,890
但他们总有一天会因为您

230
00:10:48,890 --> 00:10:50,180
推出权利，所以他们

231
00:10:50,180 --> 00:10:53,180
最终会看到您的数据，因此无法

232
00:10:53,180 --> 00:10:56,120
保证订单，例如，如果

233
00:10:56,120 --> 00:10:58,790
我是客户并且我写 他

234
00:10:58,790 --> 00:11:00,020
从他们开始，然后我写了一个

235
00:11:00,020 --> 00:11:03,980
以a

236
00:11:03,980 --> 00:11:07,100
 

237
00:11:07,100 --> 00:11:09,440
 

238
00:11:09,440 --> 00:11:12,560
 

239
00:11:12,560 --> 00:11:14,240
开头的密钥 广域网上的速度或

240
00:11:14,240 --> 00:11:15,830
不同的路线

241
00:11:15,830 --> 00:11:17,750
，也许我写了，也许

242
00:11:17,750 --> 00:11:19,880
客户先写了 em，然后写了 a，但

243
00:11:19,880 --> 00:11:22,640
也许如果他们先到达 a，

244
00:11:22,640 --> 00:11:24,260
然后更新 am，也许我

245
00:11:24,260 --> 00:11:26,900
在另一个数据中心以相反的顺序到达，

246
00:11:26,900 --> 00:11:28,850
如此不同

247
00:11:28,850 --> 00:11:32,030
客户会以不同的顺序观察更新，

248
00:11:32,030 --> 00:11:36,470
所以你知道没有顺序可以

249
00:11:36,470 --> 00:11:39,040
保证

250
00:11:40,230 --> 00:11:43,600
这种感觉最终的意义

251
00:11:43,600 --> 00:11:46,209
最终的一致性是，如果事情

252
00:11:46,209 --> 00:11:49,360
稳定下来，人们停止写作，并且

253
00:11:49,360 --> 00:11:51,880
所有这些写消息最终

254
00:11:51,880 --> 00:11:53,230
到达他们的目的地，

255
00:11:53,230 --> 00:11:56,800
那么我' 最终，一个

256
00:11:56,800 --> 00:11:59,560
最终一致的系统应该

257
00:11:59,560 --> 00:12:03,370
最终在所有副本中存储相同的值

258
00:12:03,370 --> 00:12:11,230
 

259
00:12:11,230 --> 00:12:12,880
，这就是

260
00:12:12,880 --> 00:12:14,920
如果你等待它最终一致的感觉 为了尘埃落定，

261
00:12:14,920 --> 00:12:16,870
你最终会得到

262
00:12:16,870 --> 00:12:18,269
每个人都有相同的数据，

263
00:12:18,269 --> 00:12:20,889
这是一个非常弱的规范，是一个非常

264
00:12:20,889 --> 00:12:24,670
弱的规范，但你知道，因为它是一个

265
00:12:24,670 --> 00:12:26,620
松散的规范，所以在实施中有很大的自由度

266
00:12:26,620 --> 00:12:28,630
和很多

267
00:12:28,630 --> 00:12:30,250
机会 获得良好的性能，

268
00:12:30,250 --> 00:12:31,899
因为系统基本上

269
00:12:31,899 --> 00:12:34,449
不需要您立即执行任何操作

270
00:12:34,449 --> 00:12:38,079
或遵守任何排序规则它

271
00:12:38,079 --> 00:12:40,029
与

272
00:12:40,029 --> 00:12:43,420
我们迄今为止再次看到的大多数一致性方案完全不同，因为我

273
00:12:43,420 --> 00:12:45,240
提到它用于部署的系统

274
00:12:45,240 --> 00:12:48,550
最终一致性是但是

275
00:12:48,550 --> 00:12:50,319
对于应用程序程序员来说这可能是相当棘手的，

276
00:12:50,319 --> 00:12:53,139
所以让我勾勒出一个

277
00:12:53,139 --> 00:12:54,910
你可能想要在网络

278
00:12:54,910 --> 00:12:58,630
和网站上做的事情的例子，你

279
00:12:58,630 --> 00:13:04,149
必须非常小心

280
00:13:04,149 --> 00:13:09,880
如果这是一个最终一致性应用程序

281
00:13:09,880 --> 00:13:13,569
示例，你可能会感到惊讶 我们正在建立一个

282
00:13:13,569 --> 00:13:16,269
存储照片的网站，每个用户都有一组

283
00:13:16,269 --> 00:13:19,959
你知道的照片照片，因为

284
00:13:19,959 --> 00:13:21,519
你知道具有

285
00:13:21,519 --> 00:13:26,170
某种唯一 ID 的键值对是关键，每个 用户

286
00:13:26,170 --> 00:13:29,980
有一个维护他们的公共照片列表的列表

287
00:13:29,980 --> 00:13:31,689
，他们允许其他

288
00:13:31,689 --> 00:13:34,120
人看到所以假设我拍了

289
00:13:34,120 --> 00:13:37,899
一张照片，我想将它插入到

290
00:13:37,899 --> 00:13:40,720
这个系统中，或者你知道我

291
00:13:40,720 --> 00:13:43,329
与网络服务器联系并且网络服务器运行的

292
00:13:43,329 --> 00:13:45,850
代码是 将我的照片

293
00:13:45,850 --> 00:13:47,589
插入存储系统，然后将

294
00:13:47,589 --> 00:13:50,620
我的照片的引用添加到我的照片列表中，

295
00:13:50,620 --> 00:13:51,540
这样可能会

296
00:13:51,540 --> 00:13:54,149
运行，也许会发生这种情况，我们会说它

297
00:13:54,149 --> 00:13:57,240
发生在客户端 c1 上，这是

298
00:13:57,240 --> 00:14:00,779
我正在与之交谈的 Web 服务器，也许但是

299
00:14:00,779 --> 00:14:03,899
代码 看起来有一个代码调用

300
00:14:03,899 --> 00:14:07,550
我的照片的 put 操作

301
00:14:07,550 --> 00:14:09,290
，它真的应该对你很感兴趣

302
00:14:09,290 --> 00:14:13,190
 

303
00:14:13,190 --> 00:14:15,500
 

304
00:14:15,500 --> 00:14:19,910
 

305
00:14:19,910 --> 00:14:22,770
我的列表是

306
00:14:22,770 --> 00:14:25,980
正确的，这就是我的客户代码

307
00:14:25,980 --> 00:14:28,020
看起来像其他人正在

308
00:14:28,020 --> 00:14:30,630
松散地查看我的照片会看起来获取

309
00:14:30,630 --> 00:14:34,080
我的照片列表的副本，然后

310
00:14:34,080 --> 00:14:35,310
他们会查看列表中的照片，

311
00:14:35,310 --> 00:14:39,120
因此客户可能会调用

312
00:14:39,120 --> 00:14:44,100
get 对于我的清单 然后查看

313
00:14:44,100 --> 00:14:48,570
列表，然后调用 get on that

314
00:14:48,570 --> 00:14:50,430
photo 也许他们看到了我刚刚

315
00:14:50,430 --> 00:14:51,209
上传到列表中的照片

316
00:14:51,209 --> 00:14:53,279
，他们会得到它，因为

317
00:14:53,279 --> 00:14:57,089
你知道那张照片的密钥是的，所以

318
00:14:57,089 --> 00:14:59,450
这就像完全简单的代码

319
00:14:59,450 --> 00:15:02,910
看起来它应该可以工作，但在

320
00:15:02,910 --> 00:15:05,730
最终一致的系统中它

321
00:15:05,730 --> 00:15:07,589
不一定会工作，

322
00:15:07,589 --> 00:15:10,500
问题是这两个放置

323
00:15:10,500 --> 00:15:12,899
即使客户以如此

324
00:15:12,899 --> 00:15:15,089
明显的顺序执行它们首先插入照片

325
00:15:15,089 --> 00:15:17,670
然后添加对该照片的引用 我

326
00:15:17,670 --> 00:15:20,190
的照片列表事实是，在这种

327
00:15:20,190 --> 00:15:22,380
情况下，我

328
00:15:22,380 --> 00:15:25,680
概述的第二次放置的早期一致方案可能会

329
00:15:25,680 --> 00:15:29,570
在第一次放置之前到达其他数据中心，

330
00:15:29,570 --> 00:15:31,920
因此如果另一个客户

331
00:15:31,920 --> 00:15:34,770
在不同的数据中心读取数据，可能会看到

332
00:15:34,770 --> 00:15:37,560
我的新列表的更新列表 照片在其中，但是

333
00:15:37,560 --> 00:15:40,500
当另一个客户和另一个数据

334
00:15:40,500 --> 00:15:42,540
中心去获取列表中的照片时，

335
00:15:42,540 --> 00:15:44,490
这张照片可能还不存在，

336
00:15:44,490 --> 00:15:47,550
因为第一个权利可能还没有

337
00:15:47,550 --> 00:15:50,670
到达客户的妻子

338
00:15:50,670 --> 00:15:56,160
Tuesda 是的，如果这只是

339
00:15:56,160 --> 00:15:57,870
在最终一致的系统中的例行事件，

340
00:15:57,870 --> 00:16:01,800
如果我们没有

341
00:16:01,800 --> 00:16:05,399
想到任何更聪明

342
00:16:05,399 --> 00:16:07,529
的行为，这种行为看起来

343
00:16:07,529 --> 00:16:09,390
就像代码在某种

344
00:16:09,390 --> 00:16:11,399
直观层面上无法工作，但是当 你实际上

345
00:16:11,399 --> 00:16:13,050
去阅读系统的规范，

346
00:16:13,050 --> 00:16:15,300
也就是说不能保证你意识到

347
00:16:15,300 --> 00:16:18,810
啊，你知道这一点，这个

348
00:16:18,810 --> 00:16:20,820
看起来正确的代码可能完全不这样做我

349
00:16:20,820 --> 00:16:23,100
认为它会这样做这些通常

350
00:16:23,100 --> 00:16:27,890
被称为异常，

351
00:16:29,490 --> 00:16:31,480
你知道方法 想一想

352
00:16:31,480 --> 00:16:33,399
，这种行为并不一定是您

353
00:16:33,399 --> 00:16:35,230
知道您在列表中看到了第三个列表，

354
00:16:35,230 --> 00:16:37,360
但照片不存在，但这不是

355
00:16:37,360 --> 00:16:39,040
错误，也不是不正确，因为

356
00:16:39,040 --> 00:16:41,050
毕竟系统从未

357
00:16:41,050 --> 00:16:43,750
保证这种食物

358
00:16:43,750 --> 00:16:46,389
会这样做 实际上在这里生成照片，

359
00:16:46,389 --> 00:16:50,050
所以并不是说它不正确，

360
00:16:50,050 --> 00:16:52,630
只是它比您希望的要弱，

361
00:16:52,630 --> 00:16:55,959
因此仍然可以对

362
00:16:55,959 --> 00:16:58,180
这样的系统进行编程，并且人们一直都在这样做

363
00:16:58,180 --> 00:17:00,610
，并且有很多

364
00:17:00,610 --> 00:17:03,699
您可以使用的技巧 例如，您知道

365
00:17:03,699 --> 00:17:05,380
防御性程序员可能会观察到

366
00:17:05,380 --> 00:17:07,750
程序员可能会编写代码

367
00:17:07,750 --> 00:17:09,189
，如果您说的话我的

368
00:17:09,189 --> 00:17:11,049
意思是列出它可能还不存在

369
00:17:11,049 --> 00:17:13,150
，因此如果您在列表中看到对照片的引用，

370
00:17:13,150 --> 00:17:14,799
您会得到一个 不存在的照片，

371
00:17:14,799 --> 00:17:17,770
您只需重试，稍等片刻，

372
00:17:17,770 --> 00:17:19,799
然后重试，因为

373
00:17:19,799 --> 00:17:22,179
很快照片可能会出现，

374
00:17:22,179 --> 00:17:24,309
如果没有，我们将跳过它并且不将其

375
00:17:24,309 --> 00:17:27,010
显示给用户，因此完全

376
00:17:27,010 --> 00:17:31,120
有可能 这种风格的程序，但

377
00:17:31,120 --> 00:17:33,580
我们绝对希望

378
00:17:33,580 --> 00:17:35,470
存储系统的行为比这更直观

379
00:17:35,470 --> 00:17:37,030
，这将使

380
00:17:37,030 --> 00:17:40,809
程序员的谎言生活更容易我们

381
00:17:40,809 --> 00:17:42,580
可以想象异常更少的系统

382
00:17:42,580 --> 00:17:46,650
然后是非常简单的

383
00:17:46,650 --> 00:17:50,260
最终一致的系统在

384
00:17:50,260 --> 00:17:54,309
我继续之前可以 谈论如何

385
00:17:54,309 --> 00:17:56,140
使一致性更好一点

386
00:17:56,140 --> 00:17:59,230
我想讨论一些我

387
00:17:59,230 --> 00:18:01,030
遗漏的关于当前最终

388
00:18:01,030 --> 00:18:02,860
一致性系统的重要

389
00:18:02,860 --> 00:18:07,830
内容 权利是最新的，因此

390
00:18:07,830 --> 00:18:12,309
对于某些数据，如果数据可能

391
00:18:12,309 --> 00:18:15,610
由不止一个方写入

392
00:18:15,610 --> 00:18:20,080
，我们可能必须

393
00:18:20,080 --> 00:18:22,360
决定哪个数据项更新，因此

394
00:18:22,360 --> 00:18:27,320
假设我们有一些密钥或调用 OK

395
00:18:27,320 --> 00:18:32,420
以及您知道的权利 客户端

396
00:18:32,420 --> 00:18:35,120
启动 K 的速率，因此当客户端写入

397
00:18:35,120 --> 00:18:36,950
一个值另一个客户端写入

398
00:18:36,950 --> 00:18:42,350
值 2 时，我们需要建立一个系统，

399
00:18:42,350 --> 00:18:46,040
以便所有三个数据中心

400
00:18:46,040 --> 00:18:50,570
就密钥 K 的最终值达成一致，

401
00:18:50,570 --> 00:18:51,770
因为毕​​竟我们至少

402
00:18:51,770 --> 00:18:53,240
当尘埃落定时保证最终的一致性

403
00:18:53,240 --> 00:18:55,610
所有数据中心都

404
00:18:55,610 --> 00:18:58,520
具有相同的数据，因此您知道数据中心

405
00:18:58,520 --> 00:19:01,130
3 将获得这两个权利，

406
00:19:01,130 --> 00:19:02,510
它会选择其中一个

407
00:19:02,510 --> 00:19:06,110
作为 K 的最终值，当然 um datacenter

408
00:19:06,110 --> 00:19:08,090
- 看到相同 权利是正确的，它看到了

409
00:19:08,090 --> 00:19:13,460
自己的权利，所以他们都看到这

410
00:19:13,460 --> 00:19:14,810
对坏了，他们

411
00:19:14,810 --> 00:19:18,470
都最好做出同样的决定，

412
00:19:18,470 --> 00:19:20,780
不管哪个是最终价值，以及

413
00:19:20,780 --> 00:19:22,970
他们到达的顺序是正确的，因为

414
00:19:22,970 --> 00:19:26,150
我们不知道 是的 您知道数据中心

415
00:19:26,150 --> 00:19:28,040
三可能会观察到这些以一个顺序到达，

416
00:19:28,040 --> 00:19:29,810
而其他一些数据中心可能会

417
00:19:29,810 --> 00:19:31,730
观察到它们以不同

418
00:19:31,730 --> 00:19:33,920
 

419
00:19:33,920 --> 00:19:35,390
 

420
00:19:35,390 --> 00:19:38,240
的顺序到达 决定

421
00:19:38,240 --> 00:19:42,170
 

422
00:19:42,170 --> 00:19:46,550
密钥的最终最新值是什么，所以我们需要一些

423
00:19:46,550 --> 00:19:50,600
版本号的概念，

424
00:19:50,600 --> 00:19:52,340
而签署版本号的最直接方法

425
00:19:52,340 --> 00:19:58,180
是使用挂钟时间，

426
00:19:58,180 --> 00:20:01,520
所以为什么不挂钟时间和想法

427
00:20:01,520 --> 00:20:04,310
是当客户端生成一个

428
00:20:04,310 --> 00:20:07,490
放置它或

429
00:20:07,490 --> 00:20:09,620
本地图表服务器与之交谈的分片服务器

430
00:20:09,620 --> 00:20:12,250
时，它会查看当前时间哦，你知道它

431
00:20:12,250 --> 00:20:15,320
现在是 125，它会

432
00:20:15,320 --> 00:20:17,740
将该时间作为版本号关联

433
00:20:17,740 --> 00:20:20,120
起来 它的密钥版本，然后我们将

434
00:20:20,120 --> 00:20:25,060
注释这些写入消息，

435
00:20:25,060 --> 00:20:28,580
这些实际上都将时间戳存储

436
00:20:28,580 --> 00:20:30,470
在数据库中，并用时间注释这些

437
00:20:30,470 --> 00:20:33,140
在数据中心之间发送的写入消息，

438
00:20:33,140 --> 00:20:35,360
因此您知道这可能是

439
00:20:35,360 --> 00:20:37,970
在 102 处写入的，并且 该权利发生

440
00:20:37,970 --> 00:20:40,390
在 103

441
00:20:41,049 --> 00:20:47,409
，因此如果 102 写入者或

442
00:20:47,409 --> 00:20:49,269
假设三个权利中的一个首先到达，

443
00:20:49,269 --> 00:20:51,279
那么数据中心三将把

444
00:20:51,279 --> 00:20:56,139
这个密钥和时间戳一二三放入其数据库

445
00:20:56,139 --> 00:20:56,909
 

446
00:20:56,909 --> 00:21:00,070
，当 102 的权利到达时，

447
00:21:00,070 --> 00:21:01,350
标准中心会说 哦，实际上

448
00:21:01,350 --> 00:21:04,269
这是一项较旧的权利，我将

449
00:21:04,269 --> 00:21:05,889
忽略此权利，因为它具有较低的

450
00:21:05,889 --> 00:21:08,019
时间戳和我已经拥有的时间步长

451
00:21:08,019 --> 00:21:09,460
，当然，如果它们到达

452
00:21:09,460 --> 00:21:11,919
并且另一个命令执行了一个句子，

453
00:21:11,919 --> 00:21:13,389
我们实际上会短暂地存储该权利，

454
00:21:13,389 --> 00:21:16,239
直到 正确的更高的

455
00:21:16,239 --> 00:21:17,499
时间戳到达，但随后它会

456
00:21:17,499 --> 00:21:19,389
 

457
00:21:19,389 --> 00:21:22,840
 

458
00:21:22,840 --> 00:21:24,609
 

459
00:21:24,609 --> 00:21:26,950
 

460
00:21:26,950 --> 00:21:29,289
 

461
00:21:29,289 --> 00:21:32,759
取代它 最高编号的

462
00:21:32,759 --> 00:21:39,600
值没问题，所以这几乎可以工作，

463
00:21:39,600 --> 00:21:42,159
有两个有两个小问题

464
00:21:42,159 --> 00:21:47,889
，一个是两个数据中心

465
00:21:47,889 --> 00:21:49,359
如果同时写入，

466
00:21:49,359 --> 00:21:51,009
实际上可能会分配 这个小时间戳

467
00:21:51,009 --> 00:21:54,249
这相对容易解决，

468
00:21:54,249 --> 00:21:57,190
通常完成的方式是

469
00:21:57,190 --> 00:22:00,190
时间戳实际上是时间对或

470
00:22:00,190 --> 00:22:02,080
其他任何东西，高位基本上是

471
00:22:02,080 --> 00:22:04,960
某种标识符，

472
00:22:04,960 --> 00:22:06,399
实际上几乎可以是任何东西，只要

473
00:22:06,399 --> 00:22:08,440
它是唯一的某种 标识符，

474
00:22:08,440 --> 00:22:11,769
例如数据中心名称或 ID 或

475
00:22:11,769 --> 00:22:18,220
低位中的某些内容，只是为了使

476
00:22:18,220 --> 00:22:19,600
来自不同数据中心或

477
00:22:19,600 --> 00:22:22,239
不同服务器的所有管道标志成为您想要的，

478
00:22:22,239 --> 00:22:23,889
然后如果两个权限

479
00:22:23,889 --> 00:22:26,230
同时来自不同数据中心

480
00:22:26,230 --> 00:22:28,330
的两个权限将拥有 不同的低位，

481
00:22:28,330 --> 00:22:30,009
这些小位将用于

482
00:22:30,009 --> 00:22:33,549
区分两个右边的哪个

483
00:22:33,549 --> 00:22:36,340
是较低的时间戳，因此

484
00:22:36,340 --> 00:22:40,090
应该让给另一个具有

485
00:22:40,090 --> 00:22:44,739
较高的好的，所以我们将

486
00:22:44,739 --> 00:22:46,090
在底部的位和纸上贴上某种 ID

487
00:22:46,090 --> 00:22:47,440
实际上谈论这样

488
00:22:47,440 --> 00:22:50,499
做很常见另一个问题是

489
00:22:50,499 --> 00:22:53,859
如果所有数据中心在时间上完全同步，这个系统就可以正常工作

490
00:22:53,859 --> 00:22:56,009
 

491
00:22:56,009 --> 00:22:58,450
，这

492
00:22:58,450 --> 00:23:00,340
是一个sp  anner 论文强调了

493
00:23:00,340 --> 00:23:02,769
很长的篇幅，所以如果

494
00:23:02,769 --> 00:23:04,799
所有数据中心都同意所有服务器上的时钟

495
00:23:04,799 --> 00:23:08,470
并且这将是好的，

496
00:23:08,470 --> 00:23:11,200
但如果时钟关闭几秒钟

497
00:23:11,200 --> 00:23:13,029
甚至几分钟，那么我们

498
00:23:13,029 --> 00:23:16,899
这里就有一个严重的问题 如此

499
00:23:16,899 --> 00:23:23,409
重要的问题是，

500
00:23:23,409 --> 00:23:26,710
您知道的较早出现的权利

501
00:23:26,710 --> 00:23:28,419
应该被较晚的权利覆盖，

502
00:23:28,419 --> 00:23:30,879
因此可能是实时较早出现的权利

503
00:23:30,879 --> 00:23:33,279
是因为时钟

504
00:23:33,279 --> 00:23:35,710
被分配了高时间戳，

505
00:23:35,710 --> 00:23:38,440
因此不会被以下权利取代

506
00:23:38,440 --> 00:23:43,480
来得晚了，现在我们从来没有

507
00:23:43,480 --> 00:23:45,580
对这个 ID 的最终

508
00:23:45,580 --> 00:23:49,359
一致性做出任何保证，我们也从来没有

509
00:23:49,359 --> 00:23:51,720
说过我们会在以后的时间里

510
00:23:51,720 --> 00:23:58,409
正确地赢得客户，但

511
00:23:58,409 --> 00:24:02,889
我们不希望已经足够弱的

512
00:24:02,889 --> 00:24:04,840
一致性，我们不 不想让它

513
00:24:04,840 --> 00:24:06,539
有不必要的

514
00:24:06,539 --> 00:24:09,519
奇怪行为，比如用户真的很

515
00:24:09,519 --> 00:24:11,320
清楚他们吃了一些东西，然后他们

516
00:24:11,320 --> 00:24:14,499
稍后更新似乎没有

517
00:24:14,499 --> 00:24:16,929
生效，因为早期的更新被

518
00:24:16,929 --> 00:24:19,169
分配了 tw  o 次认为它太大

519
00:24:19,169 --> 00:24:23,830
了另外如果某些服务器时钟

520
00:24:23,830 --> 00:24:26,169
太高而且不对你知道如果

521
00:24:26,169 --> 00:24:29,019
它是核心小组说快一分钟那么它将

522
00:24:29,019 --> 00:24:37,389
是一整分钟当没有其他人时我们

523
00:24:37,389 --> 00:24:38,830
必须等待所有的服务想法

524
00:24:38,830 --> 00:24:41,649
 

525
00:24:41,649 --> 00:24:43,269
在其他人

526
00:24:43,269 --> 00:24:46,419
写关于热量的文章之前赶上一分钟快速服务器时钟以解决该问题解决该

527
00:24:46,419 --> 00:24:51,309
问题的一种方法是

528
00:24:51,309 --> 00:24:54,549
这个称为 Lamport 时钟的想法该

529
00:24:54,549 --> 00:24:57,310
论文谈到了这一点，

530
00:24:57,310 --> 00:24:59,440
尽管该论文并没有真正说明

531
00:24:59,440 --> 00:25:00,880
原因 他们使用灯或时钟我

532
00:25:00,880 --> 00:25:02,890
猜这至少部分是

533
00:25:02,890 --> 00:25:05,410
因为我只是不介意

534
00:25:05,410 --> 00:25:08,770
Flambeau时钟是Wade分配

535
00:25:08,770 --> 00:25:12,100
的与实时相关的时间戳，

536
00:25:12,100 --> 00:25:14,560
但希望在某些

537
00:25:14,560 --> 00:25:16,090
具有时钟的服务器上会出现问题 运行

538
00:25:16,090 --> 00:25:22,360
速度太快，所以每台服务器都保留一个

539
00:25:22,360 --> 00:25:26,800
称为 T max 的值，这是

540
00:25:26,800 --> 00:25:28,570
它似乎与其他任何地方相距甚远的最高版本号，

541
00:25:28,570 --> 00:25:31,980
 

542
00:25:34,390 --> 00:25:36,470
所以如果其他人正在生成

543
00:25:36,470 --> 00:25:37,909
您提前知道的时间戳，那么

544
00:25:37,909 --> 00:25:40,039
您知道另一个 se  rvers 会

545
00:25:40,039 --> 00:25:41,600
看到这个时间戳，他们的团队轴将

546
00:25:41,600 --> 00:25:46,190
提前反映实时，然后

547
00:25:46,190 --> 00:25:48,500
当服务器需要将版本号的时间戳分配

548
00:25:48,500 --> 00:25:52,850
给新的 put

549
00:25:52,850 --> 00:25:56,500
时，它将采用

550
00:25:56,500 --> 00:26:03,350
这个团队 ax 的最大值加一的方式 并且挂钟

551
00:26:03,350 --> 00:26:05,380
 

552
00:26:05,850 --> 00:26:10,019
是实时的，这意味着新

553
00:26:10,019 --> 00:26:13,350
版本号，所以这是

554
00:26:13,350 --> 00:26:16,470
我们需要伴随

555
00:26:16,470 --> 00:26:18,379
文丘里一致系统中的值的版本号，

556
00:26:18,379 --> 00:26:20,909
所以每个新版本号都

557
00:26:20,909 --> 00:26:22,649
将高于看到的最高版本

558
00:26:22,649 --> 00:26:26,070
号 比

559
00:26:26,070 --> 00:26:28,859
上一个 Rite 的数据高得多，例如

560
00:26:28,859 --> 00:26:31,559
我们正在更新的数据，并且至少与实时一样高

561
00:26:31,559 --> 00:26:35,369
，所以如果没有人的时钟

562
00:26:35,369 --> 00:26:37,200
提前，这个 Tmax 加一

563
00:26:37,200 --> 00:26:38,999
实际上可能比实时

564
00:26:38,999 --> 00:26:41,460
和时间戳工具小

565
00:26:41,460 --> 00:26:43,979
如果某个服务器有一个太快的疯狂时钟，则实时结束，

566
00:26:43,979 --> 00:26:46,169
那么这将导致所有其他

567
00:26:46,169 --> 00:26:48,779
服务器所有它更新的服务器都

568
00:26:48,779 --> 00:26:51,809
提前了团队轴，以便当他们

569
00:26:51,809 --> 00:26:53,700
分配的新版本号高于

570
00:26:53,700 --> 00:26:56,879
w 的版本号时 讨厌的女士们

571
00:26:56,879 --> 00:26:58,919
评价他们从服务器上看到的

572
00:26:58,919 --> 00:27:03,869
时钟太快了，这就是

573
00:27:03,869 --> 00:27:08,720
兰伯特时钟，这就是论文

574
00:27:08,720 --> 00:27:11,220
分配版本号的方式，

575
00:27:11,220 --> 00:27:16,229
在分布式系统中一直出现，所以

576
00:27:16,229 --> 00:27:18,359
我想提出另一个关于

577
00:27:18,359 --> 00:27:25,229
我们最终一致的系统的问题

578
00:27:25,229 --> 00:27:27,899
是如何处理

579
00:27:27,899 --> 00:27:32,639
同一密钥的并发速率的问题实际上更

580
00:27:32,639 --> 00:27:35,879
糟糕的是并发

581
00:27:35,879 --> 00:27:38,609
速率可能携带的可能性可能都携带

582
00:27:38,609 --> 00:27:40,700
应该保留的重要信息，

583
00:27:40,700 --> 00:27:49,799
因此对于考试来说，两者的客户都

584
00:27:49,799 --> 00:27:51,299
做了这两个你知道不同的

585
00:27:51,299 --> 00:27:54,479
客户 客户一和客户-他们

586
00:27:54,479 --> 00:27:59,960
都发出了相同的密钥

587
00:28:04,370 --> 00:28:09,870
，这两个都让我们将其发送到

588
00:28:09,870 --> 00:28:14,190
数据中心3问题是

589
00:28:14,190 --> 00:28:16,500
数据中心3如何处理

590
00:28:16,500 --> 00:28:24,059
此处的信息和此处的信息这是一个

591
00:28:24,059 --> 00:28:25,380
真正的难题实际上没有 一个很好的

592
00:28:25,380 --> 00:28:26,429
 

593
00:28:26,429 --> 00:28:28,679
答案，论文使用的是最后一个

594
00:28:28,679 --> 00:28:30,570
Raider 获胜的数据中心 3，他

595
00:28:30,570 --> 00:28:32,580
将查看此处签名的版本号

596
00:28:32,580 --> 00:28:33,870
和版本号 er 被

597
00:28:33,870 --> 00:28:35,929
分配在这里，其中一个将

598
00:28:35,929 --> 00:28:39,600
在时间稍晚一点的数据中心 ID 上稍高

599
00:28:39,600 --> 00:28:41,700
一点，或者更高一点，或者我是

600
00:28:41,700 --> 00:28:44,400
一个数据中心 3，您将简单地

601
00:28:44,400 --> 00:28:47,490
丢弃时间戳较低

602
00:28:47,490 --> 00:28:49,350
的数据并接受具有较高

603
00:28:49,350 --> 00:28:51,750
裤子的数据 stampin 就是这样，所以它

604
00:28:51,750 --> 00:28:58,700
使用了最后一个 Raider 获胜策略

605
00:28:58,700 --> 00:29:03,860
，它的优点是它是

606
00:29:03,860 --> 00:29:05,730
确定性的，每个人都会

607
00:29:05,730 --> 00:29:13,890
得到相同的答案，你可以想出一些

608
00:29:13,890 --> 00:29:17,070
例子，其中是人，所以你

609
00:29:17,070 --> 00:29:18,270
知道例如假设这些

610
00:29:18,270 --> 00:29:20,880
put 试图做什么 是增加一个

611
00:29:20,880 --> 00:29:24,900
计数器，所以这些客户都

612
00:29:24,900 --> 00:29:27,809
在计数器附近看到值 10 他们都有

613
00:29:27,809 --> 00:29:30,720
一个，也许我们已经把 11 正确，但是

614
00:29:30,720 --> 00:29:32,130
你知道我们真正想要做的是

615
00:29:32,130 --> 00:29:33,870
让他们都增加计数器

616
00:29:33,870 --> 00:29:35,070
并让它有值 12

617
00:29:35,070 --> 00:29:37,950
所以在那种情况下，上一次 Raider 获胜并

618
00:29:37,950 --> 00:29:39,600
没有那么好，我们真正

619
00:29:39,600 --> 00:29:41,100
想要的是数据中心 3

620
00:29:41,100 --> 00:29:43,350
将这个增量组合起来，

621
00:29:43,350 --> 00:29:46,140
这个增量最终得到 12 的值，

622
00:29:46,140 --> 00:29:53,929
所以你知道这些系统 ms 确实

623
00:29:53,929 --> 00:29:58,159
通常足够强大，可以做到这一点，但

624
00:29:58,159 --> 00:30:01,200
我们更希望我们真正

625
00:30:01,200 --> 00:30:05,360
想要的是更复杂的冲突

626
00:30:05,360 --> 00:30:08,360
解决方案

627
00:30:08,860 --> 00:30:10,440
 

628
00:30:10,440 --> 00:30:13,649
，我们看到的其他系统认为

629
00:30:13,649 --> 00:30:15,870
这是支持真实事务的最强大的系统，

630
00:30:15,870 --> 00:30:20,820
而不是而

631
00:30:20,820 --> 00:30:22,019
不是 刚刚放入 get 它实际上

632
00:30:22,019 --> 00:30:24,379
具有执行原子

633
00:30:24,379 --> 00:30:27,870
事务增量增量的增量运算符，增量

634
00:30:27,870 --> 00:30:30,269
并没有丢失，这

635
00:30:30,269 --> 00:30:32,279
可能是解决冲突更新的最强大方法的一种事务，

636
00:30:32,279 --> 00:30:35,759
 

637
00:30:35,759 --> 00:30:38,250
我们还看到了

638
00:30:38,250 --> 00:30:39,539
一些支持迷你概念的系统

639
00:30:39,539 --> 00:30:43,080
交易，其中至少在

640
00:30:43,080 --> 00:30:44,850
一条数据上，您可以进行原子

641
00:30:44,850 --> 00:30:48,080
操作，例如原子增量或

642
00:30:48,080 --> 00:30:52,559
原子测试和设置，您还可以想象

643
00:30:52,559 --> 00:30:55,679
想要拥有一个

644
00:30:55,679 --> 00:30:57,720
确实来解决自定义冲突的系统，因此

645
00:30:57,720 --> 00:30:59,399
公开我们保留

646
00:30:59,399 --> 00:31:01,320
在这里的这个值 是一个购物车，你知道里面有

647
00:31:01,320 --> 00:31:04,379
一堆物品，我们的用户可能

648
00:31:04,379 --> 00:31:05,730
因为他们正在运行你知道

649
00:31:05,730 --> 00:31:06,960
风浏览器中的两个窗口

650
00:31:06,960 --> 00:31:08,669
添加了 t

651
00:31:08,669 --> 00:31:11,250
从两个不同的网络服务器向他们的购物车添加两个不同的项目

652
00:31:11,250 --> 00:31:11,730
 

653
00:31:11,730 --> 00:31:14,399
我们希望这两个冲突的

654
00:31:14,399 --> 00:31:16,590
写入同一个购物车来解决

655
00:31:16,590 --> 00:31:19,980
可能通过将两个

656
00:31:19,980 --> 00:31:21,509
购物车和球的集合结合而不是

657
00:31:21,509 --> 00:31:24,240
扔掉一个并接受

658
00:31:24,240 --> 00:31:29,330
另一个我' 我提出了

659
00:31:30,210 --> 00:31:33,930
令人满意的解决方案，确实该论文

660
00:31:33,930 --> 00:31:35,250
并没有真正提出很多

661
00:31:35,250 --> 00:31:38,790
解决方案，这只是每周

662
00:31:38,790 --> 00:31:43,590
一致系统的一个缺点，很容易

663
00:31:43,590 --> 00:31:45,740
陷入您可能对您希望拥有

664
00:31:45,740 --> 00:31:47,730
的相同数据的权利冲突的情况

665
00:31:47,730 --> 00:31:50,090
复杂

666
00:31:50,090 --> 00:31:52,680
的应用程序特定的解决

667
00:31:52,680 --> 00:31:55,830
方案，但它通常非常困难，

668
00:31:55,830 --> 00:31:58,260
就像人们必须忍受的刺

669
00:31:58,260 --> 00:32:04,020
 

670
00:32:04,020 --> 00:32:05,610
一样，这有助于最终的

671
00:32:05,610 --> 00:32:07,770
一致性，我的稻草人在这里

672
00:32:07,770 --> 00:32:10,350
为和为 P 与 纸舞

673
00:32:10,350 --> 00:32:12,360
和几段它

674
00:32:12,360 --> 00:32:13,560
可以用来做得更好

675
00:32:13,560 --> 00:32:15,930
他们并没有真正探索这一点，因为

676
00:32:15,930 --> 00:32:21,090
很难回到最终的

677
00:32:21,090 --> 00:32:26,670
一致性 如果你还记得我的稻草人系统

678
00:32:26,670 --> 00:32:32,280
，即使

679
00:32:32,280 --> 00:32:36,170
非常简单这个非常简单的场景也有一个真正的问题我

680
00:32:36,170 --> 00:32:38,880
知道我们确实放了一张照片并放了一个照片

681
00:32:38,880 --> 00:32:40,770
列表，然后其他人处于

682
00:32:40,770 --> 00:32:42,900
不同的位置，它会读取新的 this 但是

683
00:32:42,900 --> 00:32:44,520
当他们读到 照片他们发现

684
00:32:44,520 --> 00:32:47,100
那里什么都没有所以我们能不能做得更好

685
00:32:47,100 --> 00:32:49,700
 

686
00:32:49,700 --> 00:32:52,800
 

687
00:32:52,800 --> 00:32:59,040
 

688
00:32:59,040 --> 00:33:03,290
 

689
00:33:03,290 --> 00:33:05,640
 

690
00:33:05,640 --> 00:33:08,790
更接近论文，所以这也是稻草人

691
00:33:08,790 --> 00:33:11,030
 

692
00:33:12,300 --> 00:33:14,269
，

693
00:33:14,269 --> 00:33:19,129
在这个方案中，我将提出一个新的

694
00:33:19,129 --> 00:33:21,200
操作员，不仅是 put 和 get，而且还有一个

695
00:33:21,200 --> 00:33:24,580
客户可以使用

696
00:33:24,580 --> 00:33:29,299
的 sink 操作员，sink 操作员将是

697
00:33:29,299 --> 00:33:34,339
密钥和版本号

698
00:33:34,339 --> 00:33:36,259
当客户端调用它时，sink 会做什么是 sink

699
00:33:36,259 --> 00:33:40,159
等待，直到密钥 K 的所有数据中心副本

700
00:33:40,159 --> 00:33:44,269
至少是

701
00:33:44,269 --> 00:33:47,690
指定版本号的最新版本，所以这是

702
00:33:47,690 --> 00:33:50,179
一种强制命令客户可以说的方式，

703
00:33:50,179 --> 00:33:51,379
我也会等待 每个人都

704
00:33:51,379 --> 00:33:54,499
知道这个价值 而且我只想

705
00:33:54,499 --> 00:33:56,719
在每个人都

706
00:33:56,719 --> 00:33:58,700
知道中心知道这个值之后，为了让

707
00:33:58,700 --> 00:34:02,169
客户知道

708
00:34:02,169 --> 00:34:06,799
要通过接收器的版本号，我们将

709
00:34:06,799 --> 00:34:08,659
稍微更改 put 调用，以便您说 put key

710
00:34:08,659 --> 00:34:14,869
value 并 put 返回

711
00:34:14,869 --> 00:34:21,260
这个更新的 K 的版本号，你可以称之为

712
00:34:21,260 --> 00:34:23,449
这个接收器要求演戏是

713
00:34:23,449 --> 00:34:28,129
一种障碍进攻，我们可以

714
00:34:28,129 --> 00:34:34,659
称之为最终的一致性加上

715
00:34:36,069 --> 00:34:41,169
障碍，请参阅呼叫障碍

716
00:34:46,400 --> 00:34:48,260
我稍后将讨论如何对用户

717
00:34:48,260 --> 00:34:49,850
但是请记住，这件事

718
00:34:49,850 --> 00:34:51,380
调用可能会很慢，因为它

719
00:34:51,380 --> 00:34:54,949
的自然实施是

720
00:34:54,949 --> 00:34:56,960
它实际上会出去并与

721
00:34:56,960 --> 00:34:58,610
所有其他数据中心进行对话并询问他们

722
00:34:58,610 --> 00:35:01,820
您是否知道您的密钥支付版本

723
00:35:01,820 --> 00:35:03,950
至少您知道 这个版本号

724
00:35:03,950 --> 00:35:06,350
，然后必须等待数据

725
00:35:06,350 --> 00:35:07,730
中心响应，如果他们中的任何一个

726
00:35:07,730 --> 00:35:10,130
说不，它就必须读取该数据

727
00:35:10,130 --> 00:35:13,270
是的，那么你现在如何再次将这个

728
00:35:13,270 --> 00:35:16,670
很好地用于我们的照片列表，

729
00:35:16,670 --> 00:35:19,940
也许是你的客户 pdating

730
00:35:19,940 --> 00:35:22,520
照片 它会调用 put 来

731
00:35:22,520 --> 00:35:23,690
插入照片 它会得到一个版本

732
00:35:23,690 --> 00:35:31,640
号 现在你知道程序员现在

733
00:35:31,640 --> 00:35:36,920
必须在这里

734
00:35:36,920 --> 00:35:39,350
更新照片但你知道如果

735
00:35:39,350 --> 00:35:40,760
你知道的其他一些数据中心没有看到

736
00:35:40,760 --> 00:35:43,010
我的 photo 然而，然后程序员

737
00:35:43,010 --> 00:35:48,590
会说同步，你要下沉

738
00:35:48,590 --> 00:35:51,920
照片等待所有数据中心拥有

739
00:35:51,920 --> 00:35:53,480
 

740
00:35:53,480 --> 00:35:56,630
put 返回的版本号，只有在同步返回之后，

741
00:35:56,630 --> 00:36:00,440
客户端才会调用 put update 更新

742
00:36:00,440 --> 00:36:03,770
照片列表和 现在，如果客户二来

743
00:36:03,770 --> 00:36:05,210
了，我必须阅读照片列表，

744
00:36:05,210 --> 00:36:07,040
然后要在照片中，你知道谁

745
00:36:07,040 --> 00:36:09,800
知道客户二会

746
00:36:09,800 --> 00:36:15,580
获取照片列表让我们说时间

747
00:36:15,580 --> 00:36:18,560
对他们来说是一样的，它

748
00:36:18,560 --> 00:36:20,810
会在 照片列表，如果它

749
00:36:20,810 --> 00:36:23,120
在该列表中看到照片，它会

750
00:36:23,120 --> 00:36:25,760
在照片的本地数据中心再次让你知道

751
00:36:25,760 --> 00:36:29,330
，现在

752
00:36:29,330 --> 00:36:32,630
如果客户在

753
00:36:32,630 --> 00:36:36,260
不同的数据中心看到照片，我们实际上处于更好的情况 在

754
00:36:36,260 --> 00:36:43,880
这个列表中，这意味着 客户

755
00:36:43,880 --> 00:36:45,770
希望已经在此列表中调用了 put，

756
00:36:45,770 --> 00:36:48,290
因为

757
00:36:48,290 --> 00:36:50,300
如果客户希望

758
00:36:50,300 --> 00:36:51,770
已经在此列表中调用了 put，那么正是这个 put 添加了列表的镜头，这

759
00:36:51,770 --> 00:36:54,290
意味着现在考虑

760
00:36:54,290 --> 00:36:56,210
到此代码的正常工作方式的客户端已经调用了

761
00:36:56,210 --> 00:36:58,580
sink 并且 sink 没有 直到

762
00:36:58,580 --> 00:37:01,460
照片出现在所有数据中心才返回

763
00:37:01,460 --> 00:37:03,500
，这意味着客户端 2 可以，客户端 2 的

764
00:37:03,500 --> 00:37:06,080
程序员可以

765
00:37:06,080 --> 00:37:09,200
很好地依赖列表中的照片，这意味着

766
00:37:09,200 --> 00:37:11,240
无论谁将镜头添加到

767
00:37:11,240 --> 00:37:16,160
列表中，他们的同步都已完成，而且

768
00:37:16,160 --> 00:37:17,360
事实上 完成的事情意味着

769
00:37:17,360 --> 00:37:18,680
照片无处不在，

770
00:37:18,680 --> 00:37:21,020
因此我们可以依靠这个获取照片

771
00:37:21,020 --> 00:37:28,270
实际上返回照片，所以

772
00:37:28,270 --> 00:37:32,830
这很有效，而且它实际上相当

773
00:37:32,830 --> 00:37:37,100
实用，它确实需要

774
00:37:37,100 --> 00:37:38,690
程序的一部分或

775
00:37:38,690 --> 00:37:40,520
你认识的程序员必须考虑的相当仔细的考虑 啊哈，

776
00:37:40,520 --> 00:37:43,790
我需要一个水槽，我需要把水槽

777
00:37:43,790 --> 00:37:45,770
放好，

778
00:37:45,770 --> 00:37:48,290
以便读者

779
00:37:48,290 --> 00:37:50,330
更快地为读者解决问题，但读者仍然需要

780
00:37:50,330 --> 00:37:52,280
思考哦，哟 你知道我至少要

781
00:37:52,280 --> 00:37:56,570
测试程序员必须

782
00:37:56,570 --> 00:37:58,400
知道检查它是否

783
00:37:58,400 --> 00:37:59,780
程序员做了一个get列表然后我

784
00:37:59,780 --> 00:38:01,730
从那个列表中得到照片你

785
00:38:01,730 --> 00:38:03,580
知道验证代码确实

786
00:38:03,580 --> 00:38:05,900
修改了名为sink的列表 在

787
00:38:05,900 --> 00:38:08,390
为列表添加一些东西之前

788
00:38:08,390 --> 00:38:11,020
 

789
00:38:11,190 --> 00:38:13,410
，这完全是关于接收器的，因为

790
00:38:13,410 --> 00:38:15,090
所有关于执行顺序的原因

791
00:38:15,090 --> 00:38:17,790
确保这在读者发生之前完全完成，

792
00:38:17,790 --> 00:38:22,830
以便接收器

793
00:38:22,830 --> 00:38:24,600
和某种明确地强制作者的顺序

794
00:38:24,600 --> 00:38:26,580
读者也 必须考虑

795
00:38:26,580 --> 00:38:28,980
顺序 在这个例子中顺序实际上是很明显的，

796
00:38:28,980 --> 00:38:31,590
但如果

797
00:38:31,590 --> 00:38:34,140
作者确实放了一个 put 然后 sink 然后

798
00:38:34,140 --> 00:38:36,390
put 第二个东西，那么几乎总是

799
00:38:36,390 --> 00:38:38,280
读者需要阅读第二个东西

800
00:38:38,280 --> 00:38:41,580
然后阅读第一个东西 因为

801
00:38:41,580 --> 00:38:43,560
保证你从

802
00:38:43,560 --> 00:38:46,110
这个接收器方案中摆脱出来，所以这些障碍是，

803
00:38:46,110 --> 00:38:49,320
如果读者看到第二条

804
00:38:49,320 --> 00:38:51,780
数据，那么他们保证也会

805
00:38:51,780 --> 00:38:53,610
看到第一条数据，这

806
00:38:53,610 --> 00:38:55,140
意味着读 r 有点需要先成为第二

807
00:38:55,140 --> 00:38:57,480
条数据，然后

808
00:38:57,480 --> 00:39:03,330
是第一个数据，所以

809
00:39:03,330 --> 00:39:05,040
有一个关于容错的问题，

810
00:39:05,040 --> 00:39:07,080
主要是如果一个数据中心出现故障

811
00:39:07,080 --> 00:39:09,420
，这意味着接收器阻塞，直到

812
00:39:09,420 --> 00:39:10,590
其他数据中心带来

813
00:39:10,590 --> 00:39:12,870
这是绝对正确的所以你

814
00:39:12,870 --> 00:39:16,680
完全正确这是一个这不是一个

815
00:39:16,680 --> 00:39:19,050
伟大的计划好吧这是一个

816
00:39:19,050 --> 00:39:21,450
稻草人这个水槽

817
00:39:21,450 --> 00:39:24,630
叫COPS会阻止这种方式实际上

818
00:39:24,630 --> 00:39:26,760
人们

819
00:39:26,760 --> 00:39:30,060
使用的那种版本 在现实世界中，为了避免这个

820
00:39:30,060 --> 00:39:31,920
问题，您是否知道无论数据

821
00:39:31,920 --> 00:39:33,240
中心停机会不会导致接收器

822
00:39:33,240 --> 00:39:37,080
永远阻塞，这会导致两者都实际

823
00:39:37,080 --> 00:39:41,480
咨询数据中心的法定人数，

824
00:39:41,480 --> 00:39:45,450
这样接收器只会等待您知道

825
00:39:45,450 --> 00:39:48,930
说大多数数据 中心

826
00:39:48,930 --> 00:39:50,580
承认他们拥有最新

827
00:39:50,580 --> 00:39:52,410
版本的照片，并且它

828
00:39:52,410 --> 00:39:55,260
实际上必须咨询

829
00:39:55,260 --> 00:39:58,560
大多数重叠的数据中心才能

830
00:39:58,560 --> 00:40:01,590
获取数据，因此事情并不是真正的

831
00:40:01,590 --> 00:40:03,840
真实版本 也许

832
00:40:03,840 --> 00:40:08,520
不像我可能再次暗示的那样乐观 aasaiya

833
00:40:08,520 --> 00:40:14,050
以这种方式工作的系统是

834
00:40:14,050 --> 00:40:16,440
你感兴趣的是发电机

835
00:40:16,440 --> 00:40:21,720
和 Cassandra，他们使用 quorums 来

836
00:40:21,720 --> 00:40:28,140
避免墙上的谈话流行好吧，所以

837
00:40:28,140 --> 00:40:30,900
这是一个简单的设计并且有

838
00:40:30,900 --> 00:40:32,910
不错的 语义即使它很慢，

839
00:40:32,910 --> 00:40:34,740
并且正如您所观察到的那样，它的容错性不是很好，

840
00:40:34,740 --> 00:40:36,540
但读取性能非常

841
00:40:36,540 --> 00:40:38,780
出色，因为

842
00:40:38,780 --> 00:40:41,819
至少如果我们如果仲裁

843
00:40:41,819 --> 00:40:45,569
设置是读取一个写入全部并且

844
00:40:45,569 --> 00:40:47,190
写入性能不是很好，那么读取仍然是本地的，但是

845
00:40:47,190 --> 00:40:49,680
如果 您写得不多，或者如果

846
00:40:49,680 --> 00:40:52,020
您不介意等待很长时间，

847
00:40:52,020 --> 00:40:53,369
您可能可以说服

848
00:40:53,369 --> 00:40:55,849
自己速率性能

849
00:40:55,849 --> 00:40:58,829
不是灾难的原因是，毕竟

850
00:40:58,829 --> 00:41:01,230
Facebook memcache D 论文必须

851
00:41:01,230 --> 00:41:02,910
通过主要发送所有权利 数据

852
00:41:02,910 --> 00:41:04,470
中心所以是的，你知道 Facebook 运行

853
00:41:04,470 --> 00:41:07,050
多个数据中心，客户

854
00:41:07,050 --> 00:41:08,760
与所有数据中心交谈，但费率必须

855
00:41:08,760 --> 00:41:11,430
全部发送到我

856
00:41:11,430 --> 00:41:13,490
在一个主要数据中心的后续数据库，

857
00:41:13,490 --> 00:41:15,839
同样跨度 r 写入必须

858
00:41:15,839 --> 00:41:18,119
等待大多数副本站点

859
00:41:18,119 --> 00:41:19,530
在

860
00:41:19,530 --> 00:41:21,630
客户端考虑继续之前

861
00:41:21,630 --> 00:41:23,280
确认权限，因此客户端可能

862
00:41:23,280 --> 00:41:25,859
不规则权限可能必须等待与

863
00:41:25,859 --> 00:41:27,359
其他数据中心对话才能允许

864
00:41:27,359 --> 00:41:30,540
读取 快一点

865
00:41:30,540 --> 00:41:35,000
在实践中似乎并不令人发指，妈妈我

866
00:41:35,000 --> 00:41:38,040
仍然知道你可能希望

867
00:41:38,040 --> 00:41:39,630
拥有一个比这更好的系统，

868
00:41:39,630 --> 00:41:42,900
以某种方式具有同步的语义，

869
00:41:42,900 --> 00:41:46,020
这种同步或同步正在迫使这种放置

870
00:41:46,020 --> 00:41:48,270
在每个人看来肯定会发生

871
00:41:48,270 --> 00:41:49,770
在第二次放之前，您可能希望

872
00:41:49,770 --> 00:41:54,329
拥有它并且没有成本，因此我们

873
00:41:54,329 --> 00:41:56,970
将对系统感兴趣，这

874
00:41:56,970 --> 00:41:58,440
开始接近COPS

875
00:41:58,440 --> 00:42:00,720
对系统感兴趣的系统，而

876
00:42:00,720 --> 00:42:02,790
不是强迫客户

877
00:42:02,790 --> 00:42:04,829
在这一点上等待 我们以某种方式只是将

878
00:42:04,829 --> 00:42:06,780
订单编码为一条信息，

879
00:42:06,780 --> 00:42:08,970
我们将告诉读者或

880
00:42:08,970 --> 00:42:16,010
告诉其他数据中心，然后简单地

881
00:42:16,010 --> 00:42:21,040
执行论文中提到的

882
00:42:21,040 --> 00:42:24,710
不可扩展的实现 这是在

883
00:42:24,710 --> 00:42:27,050
每个数据中心，所以这是每个数据中心的日志记录

884
00:42:27,050 --> 00:42:31,490
方法，而不是

885
00:42:31,490 --> 00:42:34,550
让不同的分片服务器与

886
00:42:34,550 --> 00:42:36,140
其他数据

887
00:42:36,140 --> 00:42:42,440
服务器中的对应部分独立地进行对话，而不是在

888
00:42:42,440 --> 00:42:43,700
中心每天都有一个

889
00:42:43,700 --> 00:42:47,120
指定的日志服务器 它负责

890
00:42:47,120 --> 00:42:49,700
将写入发送

891
00:42:49,700 --> 00:42:52,400
到另一个数据中心的通信，这意味着如果

892
00:42:52,400 --> 00:42:56,300
客户端做对了，它会放入其

893
00:42:56,300 --> 00:42:59,000
本地分片，这就是该分片的图表，

894
00:42:59,000 --> 00:43:00,680
而不是仅仅将

895
00:43:00,680 --> 00:43:02,090
数据单独发送到其他数据

896
00:43:02,090 --> 00:43:07,010
中心 将与他的本地日志

897
00:43:07,010 --> 00:43:11,900
服务器对话并将权限附加到

898
00:43:11,900 --> 00:43:13,280
该数据中心正在

899
00:43:13,280 --> 00:43:15,110
累积的一个日志，然后如果客户端

900
00:43:15,110 --> 00:43:18,650
说写入不同的密钥，也许

901
00:43:18,650 --> 00:43:22,300
我们在这里写入密钥 a 和密钥 B

902
00:43:22,300 --> 00:43:25,520
而不是再次而不是 这个分片

903
00:43:25,520 --> 00:43:27,350
服务器会独立发送密钥 B 的权限，

904
00:43:27,350 --> 00:43:31,010
它会告诉

905
00:43:31,010 --> 00:43:34,220
本地日志服务器将权限附加

906
00:43:34,220 --> 00:43:37,280
到日志，然后日志服务器将

907
00:43:37,280 --> 00:43:40,250
其日志发送到其他数据中心 按

908
00:43:40,250 --> 00:43:45,080
日志顺序，这样所有数据中心都可以

909
00:43:45,080 --> 00:43:46,910
保证看到第一的权利

910
00:43:46,910 --> 00:43:49,400
，他们会希望将这个速率

911
00:43:49,400 --> 00:43:52,430
处理为第一，然后所有数据中心

912
00:43:52,430 --> 00:43:53,630
都会看到我们的 B 权利，这

913
00:43:53,630 --> 00:43:54,920
意味着如果客户做了 获得

914
00:43:54,920 --> 00:43:57,950
第一个的权利，然后成为正确的

915
00:43:57,950 --> 00:43:59,630
写入将按该顺序显示，并

916
00:43:59,630 --> 00:44:01,640
在其日志 a 和 B 中，它们将被发送

917
00:44:01,640 --> 00:44:04,160
到第一个的权利，然后

918
00:44:04,160 --> 00:44:06,200
是对每个 t 数据的权利 中心

919
00:44:06,200 --> 00:44:08,060
，它们实际上可能必须被

920
00:44:08,060 --> 00:44:11,870
发送到一种单一的日志接收

921
00:44:11,870 --> 00:44:15,410
服务器，该服务器在

922
00:44:15,410 --> 00:44:19,550
它们按日志顺序到达时一次播放一个速率，所以

923
00:44:19,550 --> 00:44:20,990
如果

924
00:44:20,990 --> 00:44:23,810
论文批评

925
00:44:23,810 --> 00:44:26,270
它实际上恢复了

926
00:44:26,270 --> 00:44:29,240
我们的一些性能，这就是日志策略 想要，因为现在

927
00:44:29,240 --> 00:44:31,550
我们不再是客户端，我们现在消除了

928
00:44:31,550 --> 00:44:33,380
接收器，客户端可以返回到

929
00:44:33,380 --> 00:44:38,860
当前的 a 放置，然后放置 B，一旦数据位于本地日志服务器的日志中，它们的

930
00:44:38,860 --> 00:44:41,450
客户端放置就可以返回

931
00:44:41,450 --> 00:44:43,760
 

932
00:44:43,760 --> 00:44:46,670
所以现在客户的 put 和 get

933
00:44:46,670 --> 00:44:48,860
现在又很快了，

934
00:44:48,860 --> 00:44:51,620
但是 我们基本上通过

935
00:44:51,620 --> 00:44:54,470
 

936
00:44:54,470 --> 00:44:56,480
条目和日志的序列号来保留顺序，而

937
00:44:56,480 --> 00:44:59,630
不是让客户端等待，所以这

938
00:44:59,630 --> 00:45:01,640
很好，我们得到了你现在知道的顺序，我们正在

939
00:45:01,640 --> 00:45:05,810
强制有序写入，我们正在

940
00:45:05,810 --> 00:45:08,180
导致权利 在另一个数据中心按顺序显示，

941
00:45:08,180 --> 00:45:09,530
以便阅读

942
00:45:09,530 --> 00:45:11,720
客户端将按顺序看到它们，因此

943
00:45:11,720 --> 00:45:13,610
我们的示例应用程序实际上可能会

944
00:45:13,610 --> 00:45:16,990
使用这种方案来解决它们。

945
00:45:17,770 --> 00:45:20,720
论文指出的

946
00:45:20,720 --> 00:45:24,170
关于这种解决方案的缺点是

947
00:45:24,170 --> 00:45:26,690
日志服务器现在 所有权限都必须

948
00:45:26,690 --> 00:45:29,420
通过这台日志服务器，因此，如果我们

949
00:45:29,420 --> 00:45:31,250
有一个大型数据库，可能有

950
00:45:31,250 --> 00:45:34,700
数百台服务器至少服务

951
00:45:34,700 --> 00:45:37,010
于相当高的工作负载，那么

952
00:45:37,010 --> 00:45:39,200
正确的工作负载所有权限都必须

953
00:45:39,200 --> 00:45:42,080
通过这台日志服务器，可能所有

954
00:45:42,080 --> 00:45:45,170
权限必须通过

955
00:45:45,170 --> 00:45:47,960
远端的单个接收日志服务器

956
00:45:47,960 --> 00:45:50,900
和单个日志服务器

957
00:45:50,900 --> 00:45:52,340
 

958
00:45:52,340 --> 00:45:54,410
 

959
00:45:54,410 --> 00:45:57,980
播放 足以处理所有这些

960
00:45:57,980 --> 00:46:01,880
费率，因此COPS不遵循这种

961
00:46:01,880 --> 00:46:06,760
方法将订单

962
00:46:06,760 --> 00:46:10,870
限制传达给其他数据中心，

963
00:46:10,870 --> 00:46:15,440
好吧，所以我们希望构建一个

964
00:46:15,440 --> 00:46:17,120
至少可以从客户的

965
00:46:17,120 --> 00:46:18,770
角度处理费率并在本地读取的系统

966
00:46:18,770 --> 00:46:20,600
，我们没有 不想等待

967
00:46:20,600 --> 00:46:22,550
你不想让客户等待

968
00:46:22,550 --> 00:46:25,610
以获得订单我们想要一个转发我们喜欢

969
00:46:25,610 --> 00:46:28,040
这些速率是

970
00:46:28,040 --> 00:46:31,490
异步转发的事实但我们

971
00:46:31,490 --> 00:46:36,050
想消除中央日志服务器

972
00:46:36,050 --> 00:46:37,850
所以我们想以某种方式 将

973
00:46:37,850 --> 00:46:39,290
订单信息传送到其他数据中心，

974
00:46:39,290 --> 00:46:41,440
而不必通过单个日志汇集我们所有的费率

975
00:46:41,440 --> 00:46:45,590
，好吧，现在

976
00:46:45,590 --> 00:46:48,560
这让我们了解了COPS

977
00:46:48,560 --> 00:46:51,700
实际上在做

978
00:46:51,700 --> 00:46:54,410
 

979
00:46:54,410 --> 00:46:56,390
什么 谈论的是非 GTE

980
00:46:56,390 --> 00:47:00,740
版本的 cops 没有 get

981
00:47:00,740 --> 00:47:09,380
transactions 的 cops ok 所以 cops 是这里的基本

982
00:47:09,380 --> 00:47:11,600
策略是，当 cops 客户端

983
00:47:11,600 --> 00:47:14,630
在本地读写时，他们会积累

984
00:47:14,630 --> 00:47:16,130
有关顺序的信息

985
00:47:16,130 --> 00:47:19,130
他们正在做的事情

986
00:47:19,130 --> 00:47:21,050
比日志记录方案更细粒度

987
00:47:21,050 --> 00:47:24,220
，只要客户没有引用，信息就会被发送到

988
00:47:24,220 --> 00:47:26,750
远程数据中心，

989
00:47:26,750 --> 00:47:29,060
所以我们有这个

990
00:47:29,060 --> 00:47:34,580
客户上下文的概念，因为客户

991
00:47:34,580 --> 00:47:36,590
确实得到了一些 put 你知道可能是一个

992
00:47:36,590 --> 00:47:42,070
客户端作为 X 的获取，然后我得到它 Y

993
00:47:42,070 --> 00:47:48,430
，然后是 Z 的某个值

994
00:47:49,569 --> 00:47:55,009
，客户端

995
00:47:55,009 --> 00:47:57,499
使用的实现 Budhan get 的库的上下文

996
00:47:57,499 --> 00:47:59,239
将在此上下文

997
00:47:59,239 --> 00:48:01,789
信息中累积作为 放置沙子

998
00:48:01,789 --> 00:48:05,089
会发生，所以如果客户没有得到，

999
00:48:05,089 --> 00:48:07,069
并且在版本 2 中产生了一些值，

1000
00:48:07,069 --> 00:48:11,239
我只是将其保存为

1001
00:48:11,239 --> 00:48:13,249
示例，可能 get 返回 x 的当前

1002
00:48:13,249 --> 00:48:14,539
值和当前值 House

1003
00:48:14,539 --> 00:48:20,179
版本 2，也许是 Y 返回将在上下文中累积

1004
00:48:20,179 --> 00:48:22,549
的版本的当前值

1005
00:48:22,549 --> 00:48:25,459
 

1006
00:48:25,459 --> 00:48:32,359
是该客户端已读取 X 并获得

1007
00:48:32,359 --> 00:48:37,119
版本 2，然后在获取之后为什么

1008
00:48:37,119 --> 00:48:39,920
COPS客户端库将添加到

1009
00:48:39,920 --> 00:48:43,099
上下文中，这样不仅仅是我们已经 阅读

1010
00:48:43,099 --> 00:48:44,599
X 并获得 vers  ion 2 但现在

1011
00:48:44,599 --> 00:48:47,739
我们已经读取了 Y 并获得了版本 4，

1012
00:48:47,739 --> 00:48:53,089
当客户端执行 put 时

1013
00:48:53,089 --> 00:48:57,009
，发送到本地分

1014
00:48:57,009 --> 00:49:02,869
片服务器的信息不仅是 put 键

1015
00:49:02,869 --> 00:49:06,589
，如果值是，还有这些

1016
00:49:06,589 --> 00:49:08,749
依赖关系，所以我们要去 告诉

1017
00:49:08,749 --> 00:49:12,589
Z 的本地分片服务器，该

1018
00:49:12,589 --> 00:49:15,049
客户端在执行

1019
00:49:15,049 --> 00:49:19,189
put X 并获得版本 2 和 Y 并获得

1020
00:49:19,189 --> 00:49:21,819
版本 4 之前已经读取，

1021
00:49:23,220 --> 00:49:26,110
并且您知道这里发生了什么

1022
00:49:26,110 --> 00:49:28,540
是我们告诉客户端在哪里

1023
00:49:28,540 --> 00:49:30,790
表达此排序信息

1024
00:49:30,790 --> 00:49:34,600
现在把这个放到 Z 上，客户在做脚之前

1025
00:49:34,600 --> 00:49:37,210
似乎是 X 版本 2 和 Y 版本 4

1026
00:49:37,210 --> 00:49:39,040
，所以

1027
00:49:39,040 --> 00:49:41,800
阅读这个版本的 Z 的任何其他人也

1028
00:49:41,800 --> 00:49:44,140
最好看到带有 Beasties 版本的 X&Y

1029
00:49:44,140 --> 00:49:48,670
，同样，如果客户

1030
00:49:48,670 --> 00:49:54,450
然后做了一个 put 别的东西说

1031
00:49:54,960 --> 00:49:57,010
Q 将发送到本地分

1032
00:49:57,010 --> 00:50:01,630
片服务器的不仅仅是 Q 和这个，

1033
00:50:01,630 --> 00:50:05,260
而且这个客户端

1034
00:50:05,260 --> 00:50:08,020
之前已经做了一些获取输入的事实，所以让我们

1035
00:50:08,020 --> 00:50:12,880
假设这个 put 产生版本​​ 3 你

1036
00:50:12,880 --> 00:50:14,950
知道本地分片服务器说 高的

1037
00:50:14,950 --> 00:50:16,960
将版本 3 分配给 Z 的新值

1038
00:50:16,960 --> 00:50:19,390
，然后当我们开始执行

1039
00:50:19,390 --> 00:50:21,280
Q 的退出时，将伴随着

1040
00:50:21,280 --> 00:50:22,990
依赖信息，即

1041
00:50:22,990 --> 00:50:25,630
这个 put 出现在 Q 的这个 put 之后出现

1042
00:50:25,630 --> 00:50:29,020
在创建 Z 版本 3 的 Z 的 put 之后

1043
00:50:29,020 --> 00:50:33,070
至少从概念上讲

1044
00:50:33,070 --> 00:50:36,750
，上下文的其余部分也

1045
00:50:38,079 --> 00:50:40,640
应该被传递，尽管

1046
00:50:40,640 --> 00:50:46,670
我们会看到由于各种原因，COPS

1047
00:50:46,670 --> 00:50:49,369
可以优化掉这些信息，

1048
00:50:49,369 --> 00:50:51,980
如果有一个程序 put 只发送

1049
00:50:51,980 --> 00:50:56,750
该点的版本信息，

1050
00:50:56,750 --> 00:50:58,010
所以问题是它对

1051
00:50:58,010 --> 00:51:03,200
要订购的上下文我不相信，所以

1052
00:51:03,200 --> 00:51:09,109
我认为我认为

1053
00:51:09,109 --> 00:51:10,849
将上下文或至少

1054
00:51:10,849 --> 00:51:15,770
在 put 中发送的信息视为

1055
00:51:15,770 --> 00:51:20,809
至少四个

1056
00:51:20,809 --> 00:51:25,819
非交易COPS的一大包依赖项就足够了，所以

1057
00:51:25,819 --> 00:51:27,559
客户 是社区这个上下文并且

1058
00:51:27,559 --> 00:51:29,300
基本上发送每个 put

1059
00:51:29,300 --> 00:51:34,040
的上下文，上下文正在编码这个订单

1060
00:51:34,040 --> 00:51:36,829
信息，在我之前的

1061
00:51:36,829 --> 00:51:39,980
稻草人稻草人 2 有点被

1062
00:51:39,980 --> 00:51:41,359
水槽强迫而不是做 我们不是

1063
00:51:41,359 --> 00:51:43,549
在等待伴随这些

1064
00:51:43,549 --> 00:51:47,089
put 哦，这个 put 需要出现在这些

1065
00:51:47,089 --> 00:51:48,950
先前的值之后，并且这个 put 需要

1066
00:51:48,950 --> 00:51:56,119
出现在这些先前的值之后，COPS

1067
00:51:56,119 --> 00:51:58,940
称这些关系，这个 put

1068
00:51:58,940 --> 00:52:00,890
需要出现在这些先前

1069
00:52:00,890 --> 00:52:04,270
的依赖

1070
00:52:05,900 --> 00:52:12,010
和依赖值之后，并且 它写成

1071
00:52:12,010 --> 00:52:14,779
假设这只脚产生 Z 版本

1072
00:52:14,779 --> 00:52:20,539
3 我们将它表达为真的有

1073
00:52:20,539 --> 00:52:23,720
两个实际上两个依赖关系 这里一个

1074
00:52:23,720 --> 00:52:28,849
是 X 版本 2 在 Z

1075
00:52:28,849 --> 00:52:32,799
版本 3 之前，另一个是 Y

1076
00:52:32,799 --> 00:52:38,020
版本 4 在 Z 版本

1077
00:52:38,020 --> 00:52:42,859
3 之前，这些就是 只是定义

1078
00:52:42,859 --> 00:52:46,069
或符号，该文件用来讨论

1079
00:52:46,069 --> 00:52:50,779
 

1080
00:52:50,779 --> 00:52:53,619
COPS需要强制执行的这些单独的订单信息，

1081
00:52:53,619 --> 00:52:58,339
那么这是什么，

1082
00:52:58,339 --> 00:52:59,869
这是传递

1083
00:52:59,869 --> 00:53:02,000
给本地分片服务器的依赖信息是什么这

1084
00:53:02,000 --> 00:53:08,450
实际上导致COPS做得很好

1085
00:53:08,450 --> 00:53:12,289
当它从本地客户端接收到一个 put 时首先吃掉COPS分片服务器

1086
00:53:12,289 --> 00:53:15,020
它分配新的

1087
00:53:15,020 --> 00:53:18,710
版本号然后它存储你的新

1088
00:53:18,710 --> 00:53:21,200
值 知道它为 Z 存储这个新

1089
00:53:21,200 --> 00:53:22,910
值以及

1090
00:53:22,910 --> 00:53:30,559
它分配的长版本号的版本号

1091
00:53:30,559 --> 00:53:33,260
，然后它将整个混乱发送到

1092
00:53:33,260 --> 00:53:35,420
每个其他数据中心，因此至少

1093
00:53:35,420 --> 00:53:38,599
一些非 GT COPS本地分片服务器

1094
00:53:38,599 --> 00:53:42,170
只记住键值 并且最新

1095
00:53:42,170 --> 00:53:43,369
版本号实际上并不

1096
00:53:43,369 --> 00:53:45,170
记得依赖关系，只是通过网络将它们转发

1097
00:53:45,170 --> 00:53:46,609
到其他数据

1098
00:53:46,609 --> 00:53:53,079
中心，所以现在的位置是

1099
00:53:53,079 --> 00:53:57,319
，假设我们有一个客户端生成

1100
00:53:57,319 --> 00:54:03,380
了一个 Z 并且它被

1101
00:54:03,380 --> 00:54:08,900
分配了一些值版本号 v3，它有

1102
00:54:08,900 --> 00:54:11,859
这些依赖

1103
00:54:13,090 --> 00:54:19,960
XV 2 + 一个 YB 4 对，这是

1104
00:54:19,960 --> 00:54:22,630
从数据中心 1 发送到另一个

1105
00:54:22,630 --> 00:54:25,870
数据中心，所以我们有一个数据中心 2 和

1106
00:54:25,870 --> 00:54:29,020
数据中心 3 现在都收到了这个，

1107
00:54:29,020 --> 00:54:31,210
实际上这个信息是从

1108
00:54:31,210 --> 00:54:34,360
碎片服务器发送的 对于 ze，所以有很多分

1109
00:54:34,360 --> 00:54:37,720
片服务器，但只有 Z

1110
00:54:37,720 --> 00:54:40,530
的分片参与其中，

1111
00:54:40,530 --> 00:54:43,570
所以这里数据中心 3 的衬衫

1112
00:54:43,570 --> 00:54:49,960
是给 Z 的，它将接收

1113
00:54:49,960 --> 00:54:54,960
客户端发送的这个 put 短服务器转发

1114
00:54:56,070 --> 00:55:00,160
它 简短的服务器带有

1115
00:55:00,160 --> 00:55:02,200
您在 Z B 3 之前知道 X V 2 和 Y 之前知道的依赖信息，

1116
00:55:02,200 --> 00:55:04,510
 

1117
00:55:04,510 --> 00:55:06,910
但这实际上意味着在操作上

1118
00:55:06,910 --> 00:55:10,270
，这个新版本的 Z 不能

1119
00:55:10,270 --> 00:55:14,620
透露给客户端，直到它的

1120
00:55:14,620 --> 00:55:17,260
依赖这些版本的 x 和 y

1121
00:55:17,260 --> 00:55:22,180
具有 已经向

1122
00:55:22,180 --> 00:55:24,640
数据中心 3 中的客户端显示，这意味着分片

1123
00:55:24,640 --> 00:55:27,070
服务器 visi 必须持有此权限

1124
00:55:27,070 --> 00:55:30,010
必须延迟将此权限应用于 Z，

1125
00:55:30,010 --> 00:55:33,370
直到它知道这两个依赖项

1126
00:55:33,370 --> 00:55:35,410
在本地数据中心中可见，

1127
00:55:35,410 --> 00:55:38,920
这意味着 Z 必须关闭

1128
00:55:38,920 --> 00:55:40,960
假设你知道我们有这些

1129
00:55:40,960 --> 00:55:43,180
用于 X 的分片服务器，而短裤是给 Y

1130
00:55:43,180 --> 00:55:45,550
Z 实际上必须向

1131
00:55:45,550 --> 00:55:47,320
X 的分片服务器

1132
00:55:47,320 --> 00:55:49,420
和 Y 的分片服务器发送一条消息，说你知道

1133
00:55:49,420 --> 00:55:52,330
a 当前版本的版本号是多少

1134
00:55:52,330 --> 00:55:55,150
x 和 y 的编号，并且必须

1135
00:55:55,150 --> 00:55:58,030
等待结果，如果这两个分片

1136
00:55:58,030 --> 00:55:59,620
服务器都说哦，您知道他们为 Y 提供的

1137
00:55:59,620 --> 00:56:01,450
版本号为 2 或更高或 4

1138
00:56:01,450 --> 00:56:03,850
或更高，则 Z 可以继续

1139
00:56:03,850 --> 00:56:09,420
申请放入其本地表 数据

1140
00:56:09,420 --> 00:56:13,840
但是你知道这两个分片

1141
00:56:13,840 --> 00:56:16,390
服务器可能没有收到

1142
00:56:16,390 --> 00:56:17,620
对应于 Y 的外向性版本 2 的更新，

1143
00:56:17,620 --> 00:56:20,260
并且 KC 必须

1144
00:56:20,260 --> 00:56:22,150
坚持这个更新分片

1145
00:56:22,150 --> 00:56:23,890
服务器他必须坚持这个更新并

1146
00:56:23,890 --> 00:56:25,540
 

1147
00:56:25,540 --> 00:56:27,310
告诉 指示的 X 或 Y 版本

1148
00:56:27,310 --> 00:56:29,680
实际上已经到达并安装在

1149
00:56:29,680 --> 00:56:32,020
这两个短服务器上，因此现在可能会有

1150
00:56:32,020 --> 00:56:35,080
一些延迟，只有

1151
00:56:35,080 --> 00:56:37,510
在数据中心 3 上可见这些依赖关系

1152
00:56:37,510 --> 00:56:40,240
之后，a4z 的分片才能继续

1153
00:56:40,240 --> 00:56:43,320
并为 Z 写入更新的稳定版

1154
00:56:43,320 --> 00:56:52,570
版本 3 可以，这

1155
00:56:52,570 --> 00:56:54,640
当然意味着，如果客户端

1156
00:56:54,640 --> 00:56:56,920
数据中心 3 读取 Z 并看到

1157
00:56:56,920 --> 00:56:59,170
版本 3，那么因为他已经等待

1158
00:56:59,170 --> 00:57:01,870
，这意味着如果该客户端然后读取 X

1159
00:57:01,870 --> 00:57:04,210
或 Y，则可以保证至少看到

1160
00:57:04,210 --> 00:57:06,520
版本 X 的 2 和 Y 的至少版本 2

1161
00:57:06,520 --> 00:57:10,420
因为他没有透露分片或

1162
00:57:10,420 --> 00:57:13,780
没有透露 Z 直到

1163
00:57:13,780 --> 00:57:19,210
确定依赖项是可见的

1164
00:57:19,210 --> 00:57:20,860
 

1165
00:57:20,860 --> 00:57:22,870
 

1166
00:57:22,870 --> 00:57:24,820
使用 Z 分片进行分区永远阻塞

1167
00:57:24,820 --> 00:57:29,260
是的，嗯，语义要求 Z

1168
00:57:29,260 --> 00:57:34,720
分片永远阻塞，这绝对是

1169
00:57:34,720 --> 00:57:36,400
正确的，所以你知道这里肯定有一个

1170
00:57:36,400 --> 00:57:40,870
假设，他们

1171
00:57:40,870 --> 00:57:42,850
知道两种可能结果好的方法，

1172
00:57:42,850 --> 00:57:45,430
一种是有人修理 网络

1173
00:57:45,430 --> 00:57:48,130
或修复任何损坏的东西，x 和

1174
00:57:48,130 --> 00:57:50,740
y 最终会得到他们的更新，这

1175
00:57:50,740 --> 00:57:52,420
是解决这个问题的一种方法，然后 z

1176
00:57:52,420 --> 00:57:53,470
最终将能够应用更新

1177
00:57:53,470 --> 00:57:57,640
可能需要等待很长时间 另

1178
00:57:57,640 --> 00:57:59,050
一种可能性是数据中心可能

1179
00:57:59,050 --> 00:58:00,430
完全 摧毁了

1180
00:58:00,430 --> 00:58:02,710
你的意思是建筑物被烧毁了，所以

1181
00:58:02,710 --> 00:58:04,500
我们根本不必担心这个，

1182
00:58:04,500 --> 00:58:07,780
但它确实指出了一个问题，这是

1183
00:58:07,780 --> 00:58:13,680
对因果一致性的真正批评，

1184
00:58:13,680 --> 00:58:18,850
那就是这些延迟实际上可能

1185
00:58:18,850 --> 00:58:21,370
非常糟糕，因为你可以想象哦，

1186
00:58:21,370 --> 00:58:23,230
你知道 Z 正在

1187
00:58:23,230 --> 00:58:25,030
等待 X 的正确值到达你知道即使

1188
00:58:25,030 --> 00:58:26,590
没有失败也没有任何东西

1189
00:58:26,590 --> 00:58:29,710
烧毁即使只是缓慢也会

1190
00:58:29,710 --> 00:58:31,840
令人恼火 Z 伙计你必须等待

1191
00:58:31,840 --> 00:58:34,570
X 出现 l 可能是 X

1192
00:58:34,570 --> 00:58:38,110
已经出现并到达了

1193
00:58:38,110 --> 00:58:38,980
这个图表，

1194
00:58:38,980 --> 00:58:41,290
但它本身可能依赖于

1195
00:58:41,290 --> 00:58:43,630
密钥 a，所以这个图表服务器

1196
00:58:43,630 --> 00:58:45,970
在 a 的更新到来之前无法安装它，

1197
00:58:45,970 --> 00:58:49,240
因为 X 这个放的 X 依赖

1198
00:58:49,240 --> 00:58:52,570
于一些 键 a 和 Z 仍然需要

1199
00:58:52,570 --> 00:58:54,339
等待，因为 Z 等待的

1200
00:58:54,339 --> 00:58:57,160
是这个版本的 X 对

1201
00:58:57,160 --> 00:58:59,500
客户端可见，因此必须安装

1202
00:58:59,500 --> 00:59:00,940
它，所以如果 X 的更新已经

1203
00:59:00,940 --> 00:59:02,920
到达，但它本身正在等待

1204
00:59:02,920 --> 00:59:05,440
其他版本 依赖然后我们可能会得到这些

1205
00:59:05,440 --> 00:59:09,880
级联依赖 等待，在现实

1206
00:59:09,880 --> 00:59:11,859
生活中，实际上这些你知道这些

1207
00:59:11,859 --> 00:59:15,310
可能会发生，这

1208
00:59:15,310 --> 00:59:19,599
是人们提出的问题之一，

1209
00:59:19,599 --> 00:59:21,460
你知道

1210
00:59:21,460 --> 00:59:24,730
当你试图说服他们时，反对调用是一致性，这是

1211
00:59:24,730 --> 00:59:27,070
一个好主意 级联

1212
00:59:27,070 --> 00:59:30,910
延迟的问题，所以这太糟糕了，虽然在

1213
00:59:30,910 --> 00:59:33,760
那个说明上确实，

1214
00:59:33,760 --> 00:59:37,240
COPS论文的作者对 P 有后续

1215
00:59:37,240 --> 00:59:38,440
实际上是一些有趣的

1216
00:59:38,440 --> 00:59:41,589
后续论文，但其中一个对此有

1217
00:59:41,589 --> 00:59:43,930
一些缓解 级联

1218
00:59:43,930 --> 00:59:47,650
重量问题 好的，所以对于一个照片

1219
00:59:47,650 --> 00:59:50,589
示例，这是这个COPS

1220
00:59:50,589 --> 00:59:51,970
方案将实际解决我们的照片

1221
00:59:51,970 --> 00:59:53,950
示例的方案，原因是你知道

1222
00:59:53,950 --> 00:59:55,359
我们正在谈论的这个 put

1223
00:59:55,359 --> 00:59:58,359
是依赖项将拥有的照片列表的 put

1224
00:59:58,359 --> 01:00:00,359
及其 依赖列表

1225
01:00:00,359 --> 01:00:05,020
是照片的插入，这

1226
01:00:05,020 --> 01:00:06,339
意味着当照片 Willis 的 put

1227
01:00:06,339 --> 01:00:10,300
到达远程站点时，远程

1228
01:00:10,300 --> 01:00:11,950
chard 服务器本质上将

1229
01:00:11,950 --> 01:00:13,990
等待照片被插入并

1230
01:00:13,990 --> 01:00:16,480
可见，然后再更新照片列表，

1231
01:00:16,480 --> 01:00:19,359
因此任何客户端 在

1232
01:00:19,359 --> 01:00:22,089
能够看到更新照片列表的新照片的远程站点中，

1233
01:00:22,089 --> 01:00:25,810
保证也能够

1234
01:00:25,810 --> 01:00:28,720
看到照片，因此这个COPS方案

1235
01:00:28,720 --> 01:00:33,780
修复了照片和照片列表示例，

1236
01:00:33,990 --> 01:00:39,700
这个COPS正在实施

1237
01:00:39,700 --> 01:00:45,060
的方案通常被称为 因果一致性

1238
01:00:52,270 --> 01:00:56,510
所以有一个问题是

1239
01:00:56,510 --> 01:00:58,310
程序员要指定依赖关系

1240
01:00:58,310 --> 01:01:01,040
不是事实证明尽管

1241
01:01:01,040 --> 01:01:04,760
上下文信息

1242
01:01:04,760 --> 01:01:08,810
在此处累积的上下文信息c  ops 客户端

1243
01:01:08,810 --> 01:01:11,090
库可以自动累积它，

1244
01:01:11,090 --> 01:01:15,320
所以程序只需要获取和放置

1245
01:01:15,320 --> 01:01:23,000
，甚至可能不需要查看版本

1246
01:01:23,000 --> 01:01:25,220
号，所以我们只是

1247
01:01:25,220 --> 01:01:28,910
获取输入的简单程序，并且 cops

1248
01:01:28,910 --> 01:01:30,470
库在内部维护这些上下文

1249
01:01:30,470 --> 01:01:32,870
并将这些额外信息添加到 put

1250
01:01:32,870 --> 01:01:38,690
我们的 pcs 这样程序员就可以

1251
01:01:38,690 --> 01:01:41,750
得到一些 put 并且系统会

1252
01:01:41,750 --> 01:01:43,640
自动跟踪依赖

1253
01:01:43,640 --> 01:01:47,740
信息，所以这非常方便

1254
01:01:47,740 --> 01:01:51,920
 

1255
01:01:51,920 --> 01:01:53,330
 

1256
01:01:53,330 --> 01:01:57,740
 

1257
01:01:57,740 --> 01:02:00,500
足以使照片示例

1258
01:02:00,500 --> 01:02:02,750
代码正确运行以使其

1259
01:02:02,750 --> 01:02:04,450
具有预期结果而不是

1260
01:02:04,450 --> 01:02:08,540
异常结果，并且至少可以

1261
01:02:08,540 --> 01:02:10,670
说它是相当有效的，因为

1262
01:02:10,670 --> 01:02:12,590
您不知道客户永远

1263
01:02:12,590 --> 01:02:14,300
不必等待权利完成

1264
01:02:14,300 --> 01:02:16,220
没有这个接收器 业务和

1265
01:02:16,220 --> 01:02:19,280
通信大多是

1266
01:02:19,280 --> 01:02:20,840
独立的，没有中央日志服务器，所以

1267
01:02:20,840 --> 01:02:22,790
可以说这都是相当

1268
01:02:22,790 --> 01:02:26,950
高性能的 e 并且具有相当好的

1269
01:02:26,950 --> 01:02:31,580
语义 相当好的一致性，

1270
01:02:31,580 --> 01:02:36,380
所以这个设计

1271
01:02:36,380 --> 01:02:38,270
产生的一致性通常被称为因果

1272
01:02:38,270 --> 01:02:42,890
一致性，它实际上是一个

1273
01:02:42,890 --> 01:02:45,890
比这篇论文更古老的想法，在这篇论文之前

1274
01:02:45,890 --> 01:02:48,710
有很多调用所以一致性方案

1275
01:02:48,710 --> 01:02:50,510
确实有很多

1276
01:02:50,510 --> 01:02:53,300
后续 - 在工作上，所以这是一个治疗想法

1277
01:02:53,300 --> 01:02:55,300
，人们非常喜欢

1278
01:02:55,300 --> 01:02:58,670
因果一致性是

1279
01:02:58,670 --> 01:03:02,000
什么意思，在这里我提出我

1280
01:03:02,000 --> 01:03:03,620
认为论文中图二的副本，

1281
01:03:03,620 --> 01:03:05,119
 

1282
01:03:05,119 --> 01:03:07,760
定义所说的

1283
01:03:07,760 --> 01:03:10,869
那种是客户行为引起的

1284
01:03:10,869 --> 01:03:15,380
依赖关系，所以有两种诱导依赖关系的方式，

1285
01:03:15,380 --> 01:03:17,660
一种是如果

1286
01:03:17,660 --> 01:03:21,349
给定的客户端有一个 put 然后我

1287
01:03:21,349 --> 01:03:24,200
得到它是否得到然后是 PUD 或一个 put

1288
01:03:24,200 --> 01:03:28,730
然后是一个 put 然后我们说

1289
01:03:28,730 --> 01:03:31,430
put 取决于先前的 put 或 get

1290
01:03:31,430 --> 01:03:34,640
所以在这种情况下，为什么如果两个

1291
01:03:34,640 --> 01:03:37,220
依赖于一个的 X 的放置，那么这是

1292
01:03:37,220 --> 01:03:41,150
一种形式的依赖另一种形式的

1293
01:03:41,150 --> 01:03:43,579
依赖如果是，如果一个客户端

1294
01:03:43,579 --> 01:03:46,430
从存储系统中释放一个值，那么

1295
01:03:46,430 --> 01:03:49,130
我们 是的，第二个

1296
01:03:49,130 --> 01:03:51,920
客户端发出的 get 取决于

1297
01:03:51,920 --> 01:03:53,570
实际插入

1298
01:03:53,570 --> 01:03:55,849
来自前一个客户端的值的相应 put，

1299
01:03:55,849 --> 01:03:59,630
此外，我们说依赖

1300
01:03:59,630 --> 01:04:03,920
关系是可传递的，因此您

1301
01:04:03,920 --> 01:04:06,770
知道这个 put 依赖于 get this

1302
01:04:06,770 --> 01:04:09,619
get by client two depends 根据

1303
01:04:09,619 --> 01:04:11,630
客户一的 put 和传递性，

1304
01:04:11,630 --> 01:04:15,920
我们可以得出结论，客户

1305
01:04:15,920 --> 01:04:18,220
二的 get 取决于客户的礼物

1306
01:04:18,220 --> 01:04:21,020
，这意味着

1307
01:04:21,020 --> 01:04:23,980
例如客户三的最后一次 put 取决于

1308
01:04:23,980 --> 01:04:31,550
所有这些先前的操作，所以

1309
01:04:31,550 --> 01:04:35,380
这是一个定义 因果依赖

1310
01:04:35,380 --> 01:04:38,900
，然后一个因果一致的系统

1311
01:04:38,900 --> 01:04:45,440
说，如果通过

1312
01:04:45,440 --> 01:04:46,910
依赖的定义，我刚刚概述

1313
01:04:46,910 --> 01:04:51,890
了 a 依赖于 B 抱歉 B 依赖于 a

1314
01:04:51,890 --> 01:04:56,089
并且客户端读取 B 然后客户端

1315
01:04:56,089 --> 01:04:59,089
随后也必须看到依赖关系，

1316
01:04:59,089 --> 01:05:03,920
所以如果客户端看到 通过依赖项

1317
01:05:03,920 --> 01:05:05,270
排序的两个有序操作中的第二个，

1318
01:05:05,270 --> 01:05:07,430
然后客户端

1319
01:05:07,430 --> 01:05:09,770
也保证

1320
01:05:09,770 --> 01:05:13,760
能够看到 ev 该

1321
01:05:13,760 --> 01:05:16,780
操作所依赖的一切

1322
01:05:17,099 --> 01:05:19,270
你都知道，这就是定义，从

1323
01:05:19,270 --> 01:05:21,430
某种意义上说，它是你知道的，从某种意义上说，它

1324
01:05:21,430 --> 01:05:25,060
直接源自系统实际所做的事情，

1325
01:05:25,060 --> 01:05:29,050
所以当

1326
01:05:29,050 --> 01:05:32,260
更新与因果相关时，这非常好，也就是说，

1327
01:05:32,260 --> 01:05:35,440
如果你知道这些客户，并且在

1328
01:05:35,440 --> 01:05:36,580
某种意义上 他们在

1329
01:05:36,580 --> 01:05:37,930
通过存储系统间接地互相交谈

1330
01:05:37,930 --> 01:05:39,970
，所以客户是我有点

1331
01:05:39,970 --> 01:05:42,160
像你知道的，如果我们有人

1332
01:05:42,160 --> 01:05:45,490
读取这个值并且 c5 看到 5 并

1333
01:05:45,490 --> 01:05:46,630
检查你知道的代码，他们可以

1334
01:05:46,630 --> 01:05:48,880
得出结论，真的是你 知道

1335
01:05:48,880 --> 01:05:51,599
这一点，从某种意义上说，这个 put

1336
01:05:51,599 --> 01:05:55,150
肯定是在

1337
01:05:55,150 --> 01:05:56,950
最后一个 put 之前出现的，所以如果你看到 slash 但你

1338
01:05:56,950 --> 01:05:58,869
真的天哪，你真的应该

1339
01:05:58,869 --> 01:06:00,580
看到这个第一个 put 所以从这个意义上说，

1340
01:06:00,580 --> 01:06:02,619
因果一致性给了你这个

1341
01:06:02,619 --> 01:06:08,140
程序员一种排序

1342
01:06:08,140 --> 01:06:13,150
行为良好的签证允许他们看到

1343
01:06:13,150 --> 01:06:14,740
来自存储

1344
01:06:14,740 --> 01:06:18,310
系统的行为良好的值 关于

1345
01:06:18,310 --> 01:06:20,349
因果一致性的另一个好处是，当它

1346
01:06:20,349 --> 01:06:23,140
更新时，当 th 中有两个值时 e系统

1347
01:06:23,140 --> 01:06:25,089
不是两个更新没有因果

1348
01:06:25,089 --> 01:06:28,900
关系因果一致性系统

1349
01:06:28,900 --> 01:06:31,450
你知道COPS存储系统没有

1350
01:06:31,450 --> 01:06:33,310
义务维护

1351
01:06:33,310 --> 01:06:35,859
没有因果关系的更新之间的顺序

1352
01:06:35,859 --> 01:06:41,200
例如如果我的意思是这

1353
01:06:41,200 --> 01:06:43,359
对性能有好处例如如果我们

1354
01:06:43,359 --> 01:06:46,300
有你 知道客户一做 X

1355
01:06:46,300 --> 01:06:49,480
，然后我把 Z

1356
01:06:49,480 --> 01:06:53,220
 

1357
01:06:53,220 --> 01:06:55,480
 

1358
01:06:55,480 --> 01:06:58,290
 

1359
01:06:58,290 --> 01:07:00,339
 

1360
01:07:00,339 --> 01:07:02,200
以及

1361
01:07:02,200 --> 01:07:04,900
客户一号的任何行动，

1362
01:07:04,900 --> 01:07:09,820
因此允许COPS完全独立地为客户的

1363
01:07:09,820 --> 01:07:11,980
put 完成与 Y 的 put 相关的所有工作，而

1364
01:07:11,980 --> 01:07:14,440
 

1365
01:07:14,440 --> 01:07:16,060
最终的结果是它已经完成

1366
01:07:16,060 --> 01:07:19,440
并且 Y 的 put 完全是

1367
01:07:19,440 --> 01:07:22,240
发生在服务器上，

1368
01:07:22,240 --> 01:07:24,770
为什么这两个 put

1369
01:07:24,770 --> 01:07:29,360
只涉及

1370
01:07:29,360 --> 01:07:31,070
X 和 Z 所在的分片的

1371
01:07:31,070 --> 01:07:35,180
 

1372
01:07:35,180 --> 01:07:37,220
服务器，因为 Z 的远程服务器可能需要一些交互 可能必须等待这个

1373
01:07:37,220 --> 01:07:39,410
put 到达，但他们不必

1374
01:07:39,410 --> 01:07:41,870
与负责 Y 的服务器交谈，

1375
01:07:41,870 --> 01:07:44,990
所以如果这是

1376
01:07:44,990 --> 01:07:47,540
因果一致性允许良好的意义上允许

1377
01:07:47,540 --> 01:07:51,320
并行性和良好的性能，你

1378
01:07:51,320 --> 01:07:54,530
知道这是不同的 来自可能

1379
01:07:54,530 --> 01:07:55,940
来自线性化系统（如 Anna

1380
01:07:55,940 --> 01:07:57,320
线性化系统）的实际

1381
01:07:57,320 --> 01:07:59,750
放置 Y 是在实时放置 X 之后的事实

1382
01:07:59,750 --> 01:08:01,760
实际上

1383
01:08:01,760 --> 01:08:04,670
对线性化存储系统提出了一些要求，但是

1384
01:08:04,670 --> 01:08:06,970
对于因果一致性，这里没有这样的要求

1385
01:08:06,970 --> 01:08:09,530
，因此您可能

1386
01:08:09,530 --> 01:08:11,030
能够构建 因果一致性

1387
01:08:11,030 --> 01:08:13,460
因果一致性系统，

1388
01:08:13,460 --> 01:08:18,380
比线性化系统快

1389
01:08:18,380 --> 01:08:20,390
 

1390
01:08:20,390 --> 01:08:22,640
 

1391
01:08:22,640 --> 01:08:26,120
 

1392
01:08:26,120 --> 01:08:28,490
 

1393
01:08:28,490 --> 01:08:33,529
t 我

1394
01:08:33,529 --> 01:08:36,500
解释了电气问题的答案，

1395
01:08:36,500 --> 01:08:45,800
如果客户确实得到了 X 我的

1396
01:08:45,800 --> 01:08:49,640
意思是看看它的上下文是否得到了

1397
01:08:49,640 --> 01:08:53,330
X，然后把 t  o Y 然后

1398
01:08:53,330 --> 01:08:58,760
在上下文中退出到 Z 最初是 X

1399
01:08:58,760 --> 01:09:02,060
版本，当我们

1400
01:09:02,060 --> 01:09:03,859
客户端从服务器的 puts 开始时，它

1401
01:09:03,859 --> 01:09:06,470
会包含这个上下文，

1402
01:09:06,470 --> 01:09:08,839
但是在实际系统中

1403
01:09:08,839 --> 01:09:13,630
，在放置上下文之后有这个优化

1404
01:09:13,630 --> 01:09:20,410
被简单地替换

1405
01:09:20,410 --> 01:09:22,640
为 put 的版本号和

1406
01:09:22,640 --> 01:09:24,620
上下文中的任何先前内容，例如

1407
01:09:24,620 --> 01:09:26,870
有关 X 的信息是

1408
01:09:26,870 --> 01:09:28,670
来自客户端上下文的竞争，

1409
01:09:28,670 --> 01:09:30,859
因此它仅包括在 put 之后，

1410
01:09:30,859 --> 01:09:33,529
上下文只是替换为

1411
01:09:33,529 --> 01:09:37,040
从 put 返回的数字 所以

1412
01:09:37,040 --> 01:09:38,799
这不是返回你知道

1413
01:09:38,799 --> 01:09:44,270
版本 7 的原因以及为什么

1414
01:09:44,270 --> 01:09:47,390
这是正确的并且不会丢失

1415
01:09:47,390 --> 01:09:49,520
非交易

1416
01:09:49,520 --> 01:09:57,650
COPS的任何信息的原因是，当这个 put 被

1417
01:09:57,650 --> 01:10:01,490
发送到所有远程站点时，put

1418
01:10:01,490 --> 01:10:04,070
伴随依赖列表中的 X 版本，

1419
01:10:04,070 --> 01:10:06,080
因此直到所有数据中心都不会应用这个 put，

1420
01:10:06,080 --> 01:10:10,640
 

1421
01:10:10,640 --> 01:10:13,880
直到这个 X 也被应用，

1422
01:10:13,880 --> 01:10:16,400
所以如果客户端然后这样做，

1423
01:10:16,400 --> 01:10:18,710
那么这个 put 变成被发送

1424
01:10:18,710 --> 01:10:20,990
到其他数据中心实际上是一个

1425
01:10:20,990 --> 01:10:24,530
带有 Z 和一些值的 put 并且依赖

1426
01:10:24,530 --> 01:10:27,050
关系只是 Y 版本 7 所有其他

1427
01:10:27,050 --> 01:10:29,350
数据中心将等待

1428
01:10:29,350 --> 01:10:32,330
他们在应用 Z 之前检查

1429
01:10:32,330 --> 01:10:34,520
他们将检查 Y 版本 7

1430
01:10:34,520 --> 01:10:36,740
已在他们的数据中心应用，

1431
01:10:36,740 --> 01:10:39,110
我们知道 Y 版本 7

1432
01:10:39,110 --> 01:10:41,780
不会应用在他们的数据中心，直到 X

1433
01:10:41,780 --> 01:10:43,310
版本在该数据中心提供任何东西，

1434
01:10:43,310 --> 01:10:44,360
所以这里有一种

1435
01:10:44,360 --> 01:10:48,310
级联延迟，这

1436
01:10:48,310 --> 01:10:50,630
告诉其他数据中心

1437
01:10:50,630 --> 01:10:53,300
等待安装 Y 版本 7

1438
01:10:53,300 --> 01:10:55,760
意味着他们也必须已经在

1439
01:10:55,760 --> 01:10:59,240
等待 Y 版本 7 所依赖的任何内容

1440
01:10:59,240 --> 01:11:01,910
，因此我们不需要

1441
01:11:01,910 --> 01:11:06,170
同时包含 X 版本、X 版本和

1442
01:11:06,170 --> 01:11:08,810
此依赖项列表，因为这些数据

1443
01:11:08,810 --> 01:11:10,400
中心将 已经在等待

1444
01:11:10,400 --> 01:11:12,560
那个版本的 X 所以

1445
01:11:12,560 --> 01:11:15,890
问题的答案是没有COPS打电话给

1446
01:11:15,890 --> 01:11:18,560
非事务性COPS不需要

1447
01:11:18,560 --> 01:11:20,390
任何东西 不需要

1448
01:11:20,390 --> 01:11:23,030
在完成后记住上下文中的获取

1449
01:11:23,030 --> 01:11:25,270
p

1450
01:11:27,269 --> 01:11:32,079
好吧，关于这个方案的最后一点要注意的

1451
01:11:32,079 --> 01:11:36,999
是，COPS只看到

1452
01:11:36,999 --> 01:11:39,820
某些关系，它只知道

1453
01:11:39,820 --> 01:11:45,820
某些因果关系，

1454
01:11:45,820 --> 01:11:48,519
只有你知道，COPS知道，如果

1455
01:11:48,519 --> 01:11:50,320
一个客户端线程执行一个 put，然后

1456
01:11:50,320 --> 01:11:53,320
另一个 put 客户端你知道 COPS记录，

1457
01:11:53,320 --> 01:11:55,989
所以第二次放取决于

1458
01:11:55,989 --> 01:11:58,590
第一本书此外，COPS

1459
01:11:58,590 --> 01:12:01,210
知道哦，客户对

1460
01:12:01,210 --> 01:12:05,590
某个值的读取取决于

1461
01:12:05,590 --> 01:12:07,630
我是创建该值的人

1462
01:12:07,630 --> 01:12:09,130
，因此取决于任何

1463
01:12:09,130 --> 01:12:11,050
那个 依赖，所以你知道COPS在这里

1464
01:12:11,050 --> 01:12:13,269
直接意识到这些依赖关系

1465
01:12:13,269 --> 01:12:18,969
，但是通常

1466
01:12:18,969 --> 01:12:21,969
情况下，更大意义上的因果关系

1467
01:12:21,969 --> 01:12:24,730
是通过

1468
01:12:24,730 --> 01:12:29,559
COPS不知道的渠道传达的，例如，你

1469
01:12:29,559 --> 01:12:34,840
知道客户是否做了 X 然后

1470
01:12:34,840 --> 01:12:38,050
你知道谁在控制

1471
01:12:38,050 --> 01:12:41,650
客户的人在电话上打电话给客户，

1472
01:12:41,650 --> 01:12:44,139
或者你知道电子邮件或

1473
01:12:44,139 --> 01:12:45,579
其他内容，看你知道我刚刚

1474
01:12:45,579 --> 01:12:47,019
用一些新信息更新了数据库

1475
01:12:47,019 --> 01:12:48,550
关于你为什么不去看看

1476
01:12:48,550 --> 01:12:52,090
它，然后你的客户知道

1477
01:12:52,090 --> 01:12:57,519
它在更大的意义上是 X 的

1478
01:12:57,519 --> 01:13:00,500
因果关系吗？你知道

1479
01:13:00,500 --> 01:13:01,910
建议客户真的应该

1480
01:13:01,910 --> 01:13:04,160
看到更新的 X，因为客户

1481
01:13:04,160 --> 01:13:07,070
从电话到新的 呼叫 X 已

1482
01:13:07,070 --> 01:13:11,360
更新，因此如果COPS

1483
01:13:11,360 --> 01:13:12,740
知道电话呼叫，

1484
01:13:12,740 --> 01:13:19,550
它实际上会包括

1485
01:13:19,550 --> 01:13:27,170
 

1486
01:13:27,170 --> 01:13:28,840
 

1487
01:13:28,840 --> 01:13:31,340
 

1488
01:13:31,340 --> 01:13:33,380
在这里打电话，我在

1489
01:13:33,380 --> 01:13:36,740
这里接到电话，如果这个 get

1490
01:13:36,740 --> 01:13:39,590
看到了 put COPS会知道足够的知识来

1491
01:13:39,590 --> 01:13:41,680
安排这个 get 会看到那个 put

1492
01:13:41,680 --> 01:13:44,780
但是因为COPS完全不知道

1493
01:13:44,780 --> 01:13:47,150
这个电话，所以没有理由

1494
01:13:47,150 --> 01:13:48,740
期望这个 get 实际上会

1495
01:13:48,740 --> 01:13:55,240
产生看跌值，因此 cops 是一种

1496
01:13:55,240 --> 01:13:57,920
强制因果一致性，但仅

1497
01:13:57,920 --> 01:14:00,680
对于来源

1498
01:14:00,680 --> 01:14:04,730
是 cops 直接意识到的因果关系，

1499
01:14:04,730 --> 01:14:08,360
这意味着 cops 是

1500
01:14:08,360 --> 01:14:10,630
因果一致性的某种消除

1501
01:14:10,630 --> 01:14:13,160
 

1502
01:14:13,160 --> 01:14:17,210
如果

1503
01:14:17,210 --> 01:14:19,010
您将因果关系的概念限制在

1504
01:14:19,010 --> 01:14:21,620
COPS可以在更大的意义上看到的范围内，那么它

1505
01:14:21,620 --> 01:14:23,300
 

1506
01:14:23,300 --> 01:14:24,860
 

1507
01:14:24,860 --> 01:14:27,500
只会消除

1508
01:14:27,500 --> 01:14:29,750
异常行为 更新了，但他们没有

1509
01:14:29,750 --> 01:14:31,370
看到更新的值，这是因为

1510
01:14:31,370 --> 01:14:32,990
他们的信念是由

1511
01:14:32,990 --> 01:14:41,290
COPS不知道的事情引起的，

1512
01:14:41,290 --> 01:14:46,040
另一个我

1513
01:14:46,040 --> 01:14:51,140
不会谈论的潜在问题是，请记住

1514
01:14:51,140 --> 01:14:52,640
带有照片列表的照片示例

1515
01:14:52,640 --> 01:14:55,520
 

1516
01:14:55,520 --> 01:14:57,580
添加照片的特定

1517
01:14:57,580 --> 01:14:59,780
顺序以及查看照片的特定不同顺序

1518
01:14:59,780 --> 01:15:02,930
使系统具有因果

1519
01:15:02,930 --> 01:15:04,550
一致性，因为我们肯定依赖

1520
01:15:04,550 --> 01:15:08,750
于读者

1521
01:15:08,750 --> 01:15:10,910
阅读照片列表然后阅读

1522
01:15:10,910 --> 01:15:13,310
照片的顺序是

1523
01:15:13,310 --> 01:15:14,030
照片引用

1524
01:15:14,030 --> 01:15:16,250
joana 照片列表的事实意味着照片的

1525
01:15:16,250 --> 01:15:19,190
读取将成功，但是在

1526
01:15:19,190 --> 01:15:22,670
某些情况下 没有

1527
01:15:22,670 --> 01:15:25,970
一个阅读顺序或

1528
01:15:25,970 --> 01:15:30,440
阅读或写作顺序的组合会导致

1529
01:15:30,440 --> 01:15:32,990
我们想要的那种行为，

1530
01:15:32,990 --> 01:15:34,850
但这会导致交易

1531
01:15:34,850 --> 01:15:36,800
，我没有足够的时间来

1532
01:15:36,800 --> 01:15:38,660
解释，但至少我想

1533
01:15:38,660 --> 01:15:42,560
提一下问题 论文设置如此

1534
01:15:42,560 --> 01:15:47,050
假设我们有我们的照片列表并且

1535
01:15:47,050 --> 01:15:50,210
它受到访问控制列表

1536
01:15:50,210 --> 01:15:52,100
和访问控制的保护这

1537
01:15:52,100 --> 01:15:55,240
基本上是允许

1538
01:15:55,240 --> 01:15:57,500
查看我列表中照片的用户名列表

1539
01:15:57,500 --> 01:16:01,480
这是否意味着实现这些的软件

1540
01:16:01,630 --> 01:16:04,250
具有访问

1541
01:16:04,250 --> 01:16:07,490
控制的照片列表这需要您

1542
01:16:07,490 --> 01:16:09,170
知道阅读列表然后阅读

1543
01:16:09,170 --> 01:16:11,540
访问控制列表并查看

1544
01:16:11,540 --> 01:16:13,280
尝试进行读取的用户是否在访问

1545
01:16:13,280 --> 01:16:17,060
控制列表中，但是

1546
01:16:17,060 --> 01:16:19,580
获取访问控制列表的顺序和

1547
01:16:19,580 --> 01:16:22,580
照片列表很有效，所以如果

1548
01:16:22,580 --> 01:16:24,320
客户端代码首先获取访问

1549
01:16:24,320 --> 01:16:29,150
控制列表，然后获取照片列表，

1550
01:16:29,150 --> 01:16:32,420
那么排序实际上并不

1551
01:16:32,420 --> 01:16:36,860
总是那么好，因为假设我的

1552
01:16:36,860 --> 01:16:38,630
客户 Reesie 访问控制列表并

1553
01:16:38,630 --> 01:16:40,880
看到我在列表中，但是就

1554
01:16:40,880 --> 01:16:44,060
在这里，这张照片的所有者将

1555
01:16:44,060 --> 01:16:47,510
我从访问控制列表中删除，

1556
01:16:47,510 --> 01:16:50,030
并插入一张我

1557
01:16:50,030 --> 01:16:51,760
不应该在列表列表中看到的新照片，

1558
01:16:51,760 --> 01:16:56,740
所以 c2 确实 你知道

1559
01:16:56,740 --> 01:16:59,660
访问控制端口是删除我，

1560
01:16:59,660 --> 01:17:01,880
然后放入照片列表以添加

1561
01:17:01,880 --> 01:17:05,840
我不允许看到的照片然后我的客户

1562
01:17:05,840 --> 01:17:07,790
得到第二个它看到

1563
01:17:07,790 --> 01:17:09,770
这个列表你可能会看到这个列表

1564
01:17:09,770 --> 01:17:11,510
现在是更新列表，其中包含

1565
01:17:11,510 --> 01:17:12,800
我不允许查看的照片，但我的

1566
01:17:12,800 --> 01:17:14,180
客户认为啊哈我在访问

1567
01:17:14,180 --> 01:17:15,710
控制列表中，因为它正在阅读旧

1568
01:17:15,710 --> 01:17:17,980
 

1569
01:17:18,510 --> 01:17:20,490
照片，这是这张照片，所以我可以

1570
01:17:20,490 --> 01:17:23,490
看到你 在那种情况下，您

1571
01:17:23,490 --> 01:17:26,040
知道我们得到了一种不一致的情况，我们知道这

1572
01:17:26,040 --> 01:17:29,250
是

1573
01:17:29,250 --> 01:17:32,040
新列表和旧访问控制列表的一种不一致的组合，

1574
01:17:32,040 --> 01:17:34,590
但实际上除了

1575
01:17:34,590 --> 01:17:38,190
因果一致性之外

1576
01:17:38,190 --> 01:17:40,650
什么都没有 好吧，

1577
01:17:40,650 --> 01:17:42,300
您将看到至少

1578
01:17:42,300 --> 01:17:46,380
与 depe 一样新的数据 ndencies 每次

1579
01:17:46,380 --> 01:17:51,390
你这样做时，事实上如果你知道，

1580
01:17:51,390 --> 01:17:52,680
如果你认为它通过了论文指出的那样

1581
01:17:52,680 --> 01:17:54,590
，

1582
01:17:54,590 --> 01:17:58,050
阅读客户端首先阅读

1583
01:17:58,050 --> 01:18:01,050
照片列表然后阅读访问控制也是不正确的，

1584
01:18:01,050 --> 01:18:05,510
因为在这之间偷偷摸摸

1585
01:18:05,510 --> 01:18:08,220
虽然这可能有一个我读过的这个

1586
01:18:08,220 --> 01:18:09,480
可能有一张我不允许看到的照片

1587
01:18:09,480 --> 01:18:11,460
，当时可能访问

1588
01:18:11,460 --> 01:18:14,160
控制不包括我，但

1589
01:18:14,160 --> 01:18:15,930
此时列表的所有者可能会

1590
01:18:15,930 --> 01:18:18,240
删除私人照片添加我

1591
01:18:18,240 --> 01:18:20,220
访问控制列表，然后我可能会

1592
01:18:20,220 --> 01:18:22,230
在列表中看到我自己，所以如果我们

1593
01:18:22,230 --> 01:18:23,520
按照这个顺序执行它也是不对的，

1594
01:18:23,520 --> 01:18:28,110
因为我们可能会看到我们可能会得到一个旧

1595
01:18:28,110 --> 01:18:31,640
列表和一个新的访问控制列表，所以

1596
01:18:31,640 --> 01:18:34,890
因果一致性就像我已经 到目前为止所描述的它还

1597
01:18:34,890 --> 01:18:36,270
不足以

1598
01:18:36,270 --> 01:18:37,890
处理这种情况，你知道我们需要

1599
01:18:37,890 --> 01:18:39,900
一些能够通过更新之前或之后的任何一种来获得

1600
01:18:39,900 --> 01:18:42,720
相互一致的列表和访问

1601
01:18:42,720 --> 01:18:45,390
控制列表的概念，

1602
01:18:45,390 --> 01:18:48,500
 

1603
01:18:48,500 --> 01:18:52,320
并且 cops GT 实际上提供了一个 方式o  f

1604
01:18:52,320 --> 01:18:55,830
通过基本上同时执行 Gatz 来做到这一点，

1605
01:18:55,830 --> 01:18:57,410
 

1606
01:18:57,410 --> 01:19:02,700
但是当 cops GT 没有得到时，它会将完整的依赖集发送

1607
01:19:02,700 --> 01:19:04,410
回客户端

1608
01:19:04,410 --> 01:19:07,320
，这意味着

1609
01:19:07,320 --> 01:19:08,910
提交的客户端能够

1610
01:19:08,910 --> 01:19:10,680
实际检查这两个依赖项的

1611
01:19:10,680 --> 01:19:14,880
依赖关系 返回值并看到啊哈，

1612
01:19:14,880 --> 01:19:16,800
您知道列表的依赖项

1613
01:19:16,800 --> 01:19:20,520
是这些版本的一个版本，抱歉

1614
01:19:20,520 --> 01:19:23,970
，可能存在

1615
01:19:23,970 --> 01:19:25,650
访问控制列表的依赖项列表，我

1616
01:19:25,650 --> 01:19:28,230
提到它取决于更远的 this 版本

1617
01:19:28,230 --> 01:19:30,510
 

1618
01:19:30,510 --> 01:19:31,920
Lists the begone 的版本

1619
01:19:31,920 --> 01:19:34,140
，在这种情况下，COPS GT 可以

1620
01:19:34,140 --> 01:19:41,940
获取数据，一个问题

1621
01:19:41,940 --> 01:19:45,800
是它是否与执行威胁有关，

1622
01:19:45,800 --> 01:19:50,880
是的，所以它们的因果

1623
01:19:50,880 --> 01:19:52,590
一致性确实不是，它

1624
01:19:52,590 --> 01:19:55,800
与挂钟时间无关，所以它没有

1625
01:19:55,800 --> 01:19:58,130
挂钟时间的概念

1626
01:19:58,130 --> 01:20:00,810
只有它遵守的唯一一种顺序形式，

1627
01:20:00,810 --> 01:20:03,510
甚至

1628
01:20:03,510 --> 01:20:05,699
与步行时间有点相关，或者如果

1629
01:20:05,699 --> 01:20:07,500
一个线程先做一件事，然后再做另一件事，

1630
01:20:07,500 --> 01:20:08,699
 

1631
01:20:08,699 --> 01:20:12,120
那么 因果一致性确实认为

1632
01:20:12,120 --> 01:20:13,590
这三个操作是按

1633
01:20:13,590 --> 01:20:15,690
顺序排列的，但这是因为一个客户端线程

1634
01:20:15,690 --> 01:20:18,210
做了这些事情的顺序，而不是

1635
01:20:18,210 --> 01:20:19,880
因为存在实时

1636
01:20:19,880 --> 01:20:24,780
关系，所以在这里总结一下

1637
01:20:24,780 --> 01:20:26,880
，将其放入一种更大的

1638
01:20:26,880 --> 01:20:32,580
世界上下文中 因果一致性

1639
01:20:32,580 --> 01:20:37,440
一直是一个非常有前途的

1640
01:20:37,440 --> 01:20:39,090
研究领域，并且已经存在了很

1641
01:20:39,090 --> 01:20:41,699
长时间，因为它似乎确实可以

1642
01:20:41,699 --> 01:20:43,920
为您提供足够好的一致性，

1643
01:20:43,920 --> 01:20:47,100
但也提供了更多

1644
01:20:47,100 --> 01:20:49,590
机会和线性化能力以

1645
01:20:49,590 --> 01:20:52,949
获得高性能，但是它没有

1646
01:20:52,949 --> 01:20:54,570
在现实世界中实际上并没有得到太大的牵引力，

1647
01:20:54,570 --> 01:20:55,290
 

1648
01:20:55,290 --> 01:20:58,410
人们使用最终一致性系统

1649
01:20:58,410 --> 01:21:00,360
，他们使用强一致性系统，

1650
01:21:00,360 --> 01:21:02,790
但是很少看到已部署的

1651
01:21:02,790 --> 01:21:04,830
系统和因果一致性，并且

1652
01:21:04,830 --> 01:21:06,810
有很多潜在的

1653
01:21:06,810 --> 01:21:09,510
原因，你知道这总是

1654
01:21:09,510 --> 01:21:11,520
很难 准确说明为什么人们

1655
01:21:11,520 --> 01:21:15,330
在现实世界的系统中使用或不使用某些技术，

1656
01:21:15,330 --> 01:21:19,920
原因之一是跟踪可能很

1657
01:21:19,920 --> 01:21:24,030
尴尬 现实世界中的每个客户端因果关系，

1658
01:21:24,030 --> 01:21:25,890
用户和浏览器

1659
01:21:25,890 --> 01:21:27,660
可能会在不同时间联系不同的 Web 服务器

1660
01:21:27,660 --> 01:21:31,020
，这意味着

1661
01:21:31,020 --> 01:21:32,790
单个 Web 服务器不足以

1662
01:21:32,790 --> 01:21:36,300
保持用户上下文，我们需要某种方法将

1663
01:21:36,300 --> 01:21:38,280
单个用户的上下文拼接在一起，

1664
01:21:38,280 --> 01:21:40,650
因为他们

1665
01:21:40,650 --> 01:21:43,240
在同一个网站上访问不同的网络服务器，这很

1666
01:21:43,240 --> 01:21:45,100
 

1667
01:21:45,100 --> 01:21:48,880
 

1668
01:21:48,880 --> 01:21:50,680
 

1669
01:21:50,680 --> 01:21:52,660
 

1670
01:21:52,660 --> 01:21:55,960
痛苦 没有

1671
01:21:55,960 --> 01:21:57,970
提供铁定的因果关系，只有

1672
01:21:57,970 --> 01:22:00,810
某种特定类型的因果关系，这

1673
01:22:00,810 --> 01:22:05,910
很好地限制了它的吸引力，

1674
01:22:05,910 --> 01:22:09,190
另一个是你知道最终

1675
01:22:09,190 --> 01:22:11,560
和因果一致的系统

1676
01:22:11,560 --> 01:22:13,270
只能提供最有限的

1677
01:22:13,270 --> 01:22:16,570
交易和人员概念 更多我

1678
01:22:16,570 --> 01:22:19,540
认为随着时间的推移，我

1679
01:22:19,540 --> 01:22:21,760
希望他们的存储系统有

1680
01:22:21,760 --> 01:22:25,420
交易

1681
01:22:25,420 --> 01:22:27,640
 

1682
01:22:27,640 --> 01:22:30,190
未决

1683
01:22:30,190 --> 01:22:33,120
信息可能非常重要，

1684
01:22:33,120 --> 01:22:35,980
您知道我无法

1685
01:22:35,980 --> 01:22:38,560
在论文的性能部分检测到这一点，

1686
01:22:38,560 --> 01:22:40,030
但

1687
01:22:40,030 --> 01:22:41,530
事实是必须存储和推送大量信息

1688
01:22:41,530 --> 01:22:44,110
，您知道您

1689
01:22:44,110 --> 01:22:46,450
是否希望 对于至少 Facebook 从 memcache 中获得的每秒数百万次

1690
01:22:46,450 --> 01:22:47,800
操作级别的

1691
01:22:47,800 --> 01:22:50,080
性能

1692
01:22:50,080 --> 01:22:52,930
D 使用因果一致性

1693
01:22:52,930 --> 01:22:54,370
所必须支付的那种开销

1694
01:22:54,370 --> 01:22:57,250
可能

1695
01:22:57,250 --> 01:22:59,380
对性能非常重要，

1696
01:22:59,380 --> 01:23:02,080
所以这就是为什么我 m

1697
01:23:02,080 --> 01:23:03,970
因果一致性目前可能还没有

1698
01:23:03,970 --> 01:23:08,350
流行起来，尽管也许

1699
01:23:08,350 --> 01:23:12,520
有一天它会好起来的，这就是我要说的全部内容

1700
01:23:12,520 --> 01:23:14,860
，实际上，从下一节课开始，

1701
01:23:14,860 --> 01:23:16,420
我们

1702
01:23:16,420 --> 01:23:20,350
将从存储和

1703
01:23:20,350 --> 01:23:24,220
涉及区块链的三个讲座的序列中切换，所以

1704
01:23:24,220 --> 01:23:26,790
我会 周四见你

1705
01:23:27,490 --> 01:23:29,550
 

