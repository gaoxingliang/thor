1
00:00:00,900 --> 00:00:04,120
今天我要讨论

2
00:00:04,120 --> 00:00:16,359
这个鸡蛋花的论文这是一篇相当古老的

3
00:00:16,359 --> 00:00:18,400
分布式文件系统论文，

4
00:00:18,400 --> 00:00:21,099
之所以阅读它，是因为它

5
00:00:21,099 --> 00:00:23,439
有很多有趣和优秀的设计

6
00:00:23,439 --> 00:00:25,829
，与缓存一致性、

7
00:00:25,829 --> 00:00:28,839
分布式事务和分布式

8
00:00:28,839 --> 00:00:31,029
崩溃有关 恢复以及

9
00:00:31,029 --> 00:00:33,420
它们之间的交互，所以

10
00:00:33,420 --> 00:00:35,500
这些才是我们要尝试梳理的真正背后的想法

11
00:00:35,500 --> 00:00:38,140
，

12
00:00:38,140 --> 00:00:42,699
所以这些真的是我们的很多

13
00:00:42,699 --> 00:00:47,530
缓存连贯性真的是

14
00:00:47,530 --> 00:00:50,679
如果我有缓存的东西的想法

15
00:00:50,679 --> 00:00:52,899
但是，如果您在我

16
00:00:52,899 --> 00:00:54,370
有缓存的情况下修改它，您知道会

17
00:00:54,370 --> 00:00:56,410
发生一些事情，因此我可以看到您的

18
00:00:56,410 --> 00:00:58,809
修改，我们

19
00:00:58,809 --> 00:01:04,420
还将其内部需要的操作分

20
00:01:04,420 --> 00:01:06,910
发给文件系统，以便

21
00:01:06,910 --> 00:01:09,130
能够对文件系统数据结构进行复杂的更新

22
00:01:09,130 --> 00:01:14,560
和 因为文件

23
00:01:14,560 --> 00:01:16,600
系统本质上是分散在

24
00:01:16,600 --> 00:01:19,270
一堆服务器中的，所以

25
00:01:19,270 --> 00:01:20,920
能够从崩溃中恢复是至关重要的，而这些

26
00:01:20,920 --> 00:01:30,130
服务器的整体设计 朋友

27
00:01:30,130 --> 00:01:34,300
pammi 它是一个网络文件系统 它

28
00:01:34,300 --> 00:01:37,840
旨在查看现有

29
00:01:37,840 --> 00:01:39,400
应用程序 它旨在

30
00:01:39,400 --> 00:01:41,050
与现有应用程序一起工作，例如

31
00:01:41,050 --> 00:01:43,270
UNIX 程序 我们

32
00:01:43,270 --> 00:01:47,620
在人们的工作站上运行的普通 UNIX 程序

33
00:01:47,620 --> 00:01:51,310
很像 Athena 的 AFS 让您可以访问您的

34
00:01:51,310 --> 00:01:53,500
Athena 主目录和各种

35
00:01:53,500 --> 00:01:56,470
项目 来自任何 Athena

36
00:01:56,470 --> 00:01:58,690
工作站的目录，因此总体

37
00:01:58,690 --> 00:02:00,550
情况是，您有一群

38
00:02:00,550 --> 00:02:06,010
用户，报纸世界中的每个用户都

39
00:02:06,010 --> 00:02:07,300
坐在工作站前

40
00:02:07,300 --> 00:02:09,369
 

41
00:02:09,369 --> 00:02:10,810
 

42
00:02:10,810 --> 00:02:12,430
并在鼠标和

43
00:02:12,430 --> 00:02:14,020
Windows 系统中显示，所以每个人

44
00:02:14,020 --> 00:02:14,490
 

45
00:02:14,490 --> 00:02:17,370
都坐在计算机工作站的

46
00:02:17,370 --> 00:02:19,260
 

47
00:02:19,260 --> 00:02:24,720
 

48
00:02:24,720 --> 00:02:27,600
 

49
00:02:27,600 --> 00:02:30,510
 

50
00:02:30,510 --> 00:02:32,930
前面 您知道

51
00:02:32,930 --> 00:02:36,810
本文中发生的几乎所有事情都

52
00:02:36,810 --> 00:02:40,440
在每个工作站的鸡蛋花软件中进行，

53
00:02:40,440 --> 00:02:42,840
所以也许他们正坐在 在

54
00:02:42,840 --> 00:02:44,490
工作站前面，他们可能

55
00:02:44,490 --> 00:02:47,040
正在运行普通程序，例如

56
00:02:47,040 --> 00:02:48,540
正在读取和写入文件的文本编辑器，

57
00:02:48,540 --> 00:02:50,520
并且当他们完成编辑

58
00:02:50,520 --> 00:02:51,540
源文件时，他们通过编译器运行它

59
00:02:51,540 --> 00:02:53,490
 

60
00:02:53,490 --> 00:02:57,570
 

61
00:02:57,570 --> 00:02:59,940
内核有一个

62
00:02:59,940 --> 00:03:08,040
鸡蛋花模块，它

63
00:03:08,040 --> 00:03:10,470
在所有这些工作站内部实现文件系统，

64
00:03:10,470 --> 00:03:15,690
相互复制，然后

65
00:03:15,690 --> 00:03:18,000
文件系统数据结构的真实存储，

66
00:03:18,000 --> 00:03:19,980
比如文件

67
00:03:19,980 --> 00:03:22,110
内容，还有节点和

68
00:03:22,110 --> 00:03:24,120
目录，alissa 文件和每个

69
00:03:24,120 --> 00:03:26,760
目录和 关于

70
00:03:26,760 --> 00:03:28,710
我所知道的信息和哪些块是免费的所有信息

71
00:03:28,710 --> 00:03:32,970
都存储在一个名为花瓣的共享虚拟磁盘

72
00:03:32,970 --> 00:03:37,560
表面中

73
00:03:37,560 --> 00:03:38,970
 

74
00:03:38,970 --> 00:03:40,650
 

75
00:03:40,650 --> 00:03:42,240
 

76
00:03:42,240 --> 00:03:45,090
 

77
00:03:45,090 --> 00:03:46,710
things 复制数据，所以你

78
00:03:46,710 --> 00:03:48,510
可以想象踏板服务器

79
00:03:48,510 --> 00:03:55,470
成对出现，一个崩溃 s 我们仍然可以

80
00:03:55,470 --> 00:03:58,020
获取我们的数据，因此当鸡蛋花

81
00:03:58,020 --> 00:04:00,390
需要读取或写入时，您知道读取

82
00:04:00,390 --> 00:04:02,370
目录或其他内容，它会

83
00:04:02,370 --> 00:04:04,260
向正确的踏板服务器发送远程过程调用，

84
00:04:04,260 --> 00:04:06,360
以便说明这是

85
00:04:06,360 --> 00:04:08,280
我需要您知道的块，请阅读 对我来说，

86
00:04:08,280 --> 00:04:10,650
请归还那个块，并且在

87
00:04:10,650 --> 00:04:13,980
大多数情况下，花瓣就像一个磁盘

88
00:04:13,980 --> 00:04:16,108
驱动器，您可以将其

89
00:04:16,108 --> 00:04:22,260
视为一种共享的共享磁盘驱动器，所有

90
00:04:22,260 --> 00:04:25,800
这些鸡蛋花膝盖都与之交谈，从我们的角度来看，它

91
00:04:25,800 --> 00:04:28,700
被称为虚拟磁盘

92
00:04:31,830 --> 00:04:34,000
对于本次讨论的大部分内容，

93
00:04:34,000 --> 00:04:35,440
我们只是想像

94
00:04:35,440 --> 00:04:37,690
踏板只是一个磁盘驱动器

95
00:04:37,690 --> 00:04:39,580
，所有这些 Handy 的朋友都在网络上使用

96
00:04:39,580 --> 00:04:41,919
它，所以它让你

97
00:04:41,919 --> 00:04:44,950
通过给它一个块

98
00:04:44,950 --> 00:04:46,690
号或地址来读取和写入它 在磁盘上，

99
00:04:46,690 --> 00:04:47,919
似乎我

100
00:04:47,919 --> 00:04:56,880
想像普通硬盘驱动器一样读取该块，

101
00:04:56,880 --> 00:05:00,730
所以该文件的预期

102
00:05:00,730 --> 00:05:02,820
用途因此作者预期的用途

103
00:05:02,820 --> 00:05:05,590
实际上是设计中相当重要的驱动程序

104
00:05:05,590 --> 00:05:08,200
他们想要的是

105
00:05:08,200 --> 00:05:10,690
支持他们的 他们自己的活动和

106
00:05:10,690 --> 00:05:12,730
他们是一个研究实验室的成员，这个

107
00:05:12,730 --> 00:05:16,600
研究实验室可能有 50 人

108
00:05:16,600 --> 00:05:18,940
，他们习惯于

109
00:05:18,940 --> 00:05:20,890
共享基础设施，例如

110
00:05:20,890 --> 00:05:24,550
使用

111
00:05:24,550 --> 00:05:27,070
以前的网络文件系统共享时间共享机器或工作站

112
00:05:27,070 --> 00:05:29,020
，以便在合作的研究人员小组之间共享文件，

113
00:05:29,020 --> 00:05:31,000
所以 他们都想要

114
00:05:31,000 --> 00:05:32,800
他们想要一个文件系统，他们

115
00:05:32,800 --> 00:05:33,970
可以用它来存储他们自己的主

116
00:05:33,970 --> 00:05:37,270
目录以及存储共享的

117
00:05:37,270 --> 00:05:39,550
项目文件，这意味着如果

118
00:05:39,550 --> 00:05:41,260
我编辑一个文件，我真的会喜欢其他

119
00:05:41,260 --> 00:05:43,270
人我的工作和其他人 与我一起

120
00:05:43,270 --> 00:05:45,190
工作的人能够阅读我刚刚编辑的文件，

121
00:05:45,190 --> 00:05:47,320
所以我们想要那种

122
00:05:47,320 --> 00:05:51,190
共享，此外，如果我

123
00:05:51,190 --> 00:05:52,780
可以坐在任何工作站我的

124
00:05:52,780 --> 00:05:54,910
工作站你的工作站

125
00:05:54,910 --> 00:05:57,550
图书馆的公共工作站仍然

126
00:05:57,550 --> 00:05:59,440
可以 我所有主目录的文件

127
00:05:59,440 --> 00:06:01,240
我的环境中需要的一切，

128
00:06:01,240 --> 00:06:03,340
所以他们对一个相对较小的组织中

129
00:06:03,340 --> 00:06:07,000
的人类用户的共享文件系统非常感兴趣

130
00:06:07,000 --> 00:06:11,380
 

131
00:06:11,380 --> 00:06:12,820
足以让每个人都信任所有

132
00:06:12,820 --> 00:06:14,740
的人所有的计算机，所以实际上

133
00:06:14,740 --> 00:06:16,810
该设计在安全性方面基本上没有什么可

134
00:06:16,810 --> 00:06:19,660
说的，而且确实可以说

135
00:06:19,660 --> 00:06:21,820
在像

136
00:06:21,820 --> 00:06:23,830
雅典娜这样你不能真正信任

137
00:06:23,830 --> 00:06:26,410
用户或工作站的环境中不起作用，所以它真的

138
00:06:26,410 --> 00:06:29,950
非常非常 现在为他们的

139
00:06:29,950 --> 00:06:34,450
环境设计就性能而言

140
00:06:34,450 --> 00:06:36,130
他们的环境也很重要你

141
00:06:36,130 --> 00:06:37,630
知道事实证明大多数

142
00:06:37,630 --> 00:06:39,039
人使用计算机的方式是租用

143
00:06:39,039 --> 00:06:40,569
他们坐在前面的工作站

144
00:06:40,569 --> 00:06:41,919
是他们主要读写

145
00:06:41,919 --> 00:06:44,679
自己的文件，他们可能会阅读一些 共享

146
00:06:44,679 --> 00:06:48,009
文件你知道程序或一些项目

147
00:06:48,009 --> 00:06:50,289
文件或其他东西，但大多数时候

148
00:06:50,289 --> 00:06:51,909
我正在读写我的文件，而

149
00:06:51,909 --> 00:06:53,770
你正在你的工作站上读写你的文件

150
00:06:53,770 --> 00:06:55,569
，你

151
00:06:55,569 --> 00:06:57,189
知道我们正在积极共享文件确实是个例外

152
00:06:57,189 --> 00:06:59,319
因此，

153
00:06:59,319 --> 00:07:01,629
 

154
00:07:01,629 --> 00:07:04,659
即使

155
00:07:04,659 --> 00:07:06,099
文件的真实副本正式存储在这个

156
00:07:06,099 --> 00:07:08,289
共享磁盘中，以一种或另一种方式也很有意义 如果我们可以

157
00:07:08,289 --> 00:07:11,499
进行某种缓存，那么在

158
00:07:11,499 --> 00:07:12,999
我登录并使用我的文件一段时间后，

159
00:07:12,999 --> 00:07:15,610
它们会在本地缓存在这里，这样就

160
00:07:15,610 --> 00:07:17,379
可以得到它们，如果我们必须从中获取它们，你知道

161
00:07:17,379 --> 00:07:20,169
微秒而不是毫秒

162
00:07:20,169 --> 00:07:22,059
文件

163
00:07:22,059 --> 00:07:27,639
服务器还可以，所以法国比利牛斯山脉支持

164
00:07:27,639 --> 00:07:29,619
这种缓存，而且它

165
00:07:29,619 --> 00:07:33,849
支持右后缓存，不仅

166
00:07:33,849 --> 00:07:38,349
在每个工作站和

167
00:07:38,349 --> 00:07:40,479
每个素馨花服务器中都

168
00:07:40,479 --> 00:07:46,269
缓存，我们还有右后缓存，这意味着如果我

169
00:07:46,269 --> 00:07:49,149
想修改某些东西，如果我修改 一个

170
00:07:49,149 --> 00:07:51,159
文件，甚至在一个目录中创建一个文件，

171
00:07:51,159 --> 00:07:53,409
或者删除一个文件，或者基本上

172
00:07:53,409 --> 00:07:55,869
做任何其他操作，只要没有

173
00:07:55,869 --> 00:07:57,939
其他人没有其他工作站需要看到

174
00:07:57,939 --> 00:07:59,039
它，

175
00:07:59,039 --> 00:08:01,659
赤素馨使用回写缓存

176
00:08:01,659 --> 00:08:05,110
，这意味着我的写入只保留

177
00:08:05,110 --> 00:08:07,240
在本地 缓存，如果我至少最初创建一个文件，

178
00:08:07,240 --> 00:08:09,430
 

179
00:08:09,430 --> 00:08:11,740
关于新创建文件的信息说一个新

180
00:08:11,740 --> 00:08:13,990
分配的具有初始化

181
00:08:13,990 --> 00:08:16,809
内容的 inode，并且您知道添加

182
00:08:16,809 --> 00:08:19,449
到新名称的新条目对我的态度 主

183
00:08:19,449 --> 00:08:21,219
目录所有这些修改

184
00:08:21,219 --> 00:08:23,439
最初都只是在缓存中完成，

185
00:08:23,439 --> 00:08:25,389
因此

186
00:08:25,389 --> 00:08:27,789
可以非常快速地完成创建文件之类的操作，它们只

187
00:08:27,789 --> 00:08:30,300
需要修改这

188
00:08:30,300 --> 00:08:32,620
台机器的磁盘缓存中的本地内存，并且它们通常不会被

189
00:08:32,620 --> 00:08:34,630
写回兜售，直到

190
00:08:34,630 --> 00:08:37,299
后来 至少最初我们可以

191
00:08:37,299 --> 00:08:39,519
对文件

192
00:08:39,519 --> 00:08:41,708
系统进行各种修改，至少对我自己的目录我

193
00:08:41,708 --> 00:08:44,889
自己的文件完全在本地进行，这

194
00:08:44,889 --> 00:08:47,139
对性能非常有帮助，

195
00:08:47,139 --> 00:08:48,639
就像你知道一千个

196
00:08:48,639 --> 00:08:50,319
差异的因素能够

197
00:08:50,319 --> 00:08:52,149
在本地内存中修改某些东西与 现在

198
00:08:52,149 --> 00:08:54,430
必须发送远程过程调用来发送

199
00:08:54,430 --> 00:08:59,470
服务器

200
00:08:59,470 --> 00:09:03,870
，它对这里的架构具有极其决定性的一个严重后果

201
00:09:03,870 --> 00:09:06,130
是，这

202
00:09:06,130 --> 00:09:09,399
意味着文件系统的逻辑

203
00:09:09,399 --> 00:09:11,860
必须在每个工作站中，以便我的

204
00:09:11,860 --> 00:09:13,240
工作站能够实现

205
00:09:13,240 --> 00:09:15,700
诸如创建文件之类的事情只是

206
00:09:15,700 --> 00:09:17,560
在其本地缓存之外进行操作，这意味着该文件的所有

207
00:09:17,560 --> 00:09:20,740
逻辑所有智能

208
00:09:20,740 --> 00:09:22,180
系统必须位于我的

209
00:09:22,180 --> 00:09:24,070
工作站中，并且在他们的设计中

210
00:09:24,070 --> 00:09:26,110
基本上与

211
00:09:26,110 --> 00:09:28,720
踏板共享存储系统

212
00:09:28,720 --> 00:09:31,330
有关，对文件系统或

213
00:09:31,330 --> 00:09:34,450
文件或目录一无所知 所有这些逻辑

214
00:09:34,450 --> 00:09:35,800
从某种意义上说，这是一个非常

215
00:09:35,800 --> 00:09:38,920
简单的简单系统

216
00:09:38,920 --> 00:09:41,350
复杂性在每个客户的素馨花

217
00:09:41,350 --> 00:09:46,089
中，所以这是一种非常

218
00:09:46,089 --> 00:09:49,029
分散的方案，其中一个

219
00:09:49,029 --> 00:09:50,770
原因是 - 因为这是你

220
00:09:50,770 --> 00:09:53,800
真正需要的，或者这些是

221
00:09:53,800 --> 00:09:56,339
他们可以想到的设计，允许他们

222
00:09:56,339 --> 00:09:58,360
纯粹在本地进行修改 每个

223
00:09:58,360 --> 00:10:00,610
工作站它确实都有很好的

224
00:10:00,610 --> 00:10:03,459
副作用，尽管我是因为大部分

225
00:10:03,459 --> 00:10:05,470
复杂性和大部分 CPU 时间

226
00:10:05,470 --> 00:10:07,839
都花在这里，这意味着

227
00:10:07,839 --> 00:10:09,970
当您在向系统添加用户时添加工作站时，

228
00:10:09,970 --> 00:10:13,630
您会自动获得更多 CPU

229
00:10:13,630 --> 00:10:16,870
容量 运行那些新用户的文件

230
00:10:16,870 --> 00:10:18,850
系统操作，因为大多数文件

231
00:10:18,850 --> 00:10:21,550
系统操作只发生

232
00:10:21,550 --> 00:10:23,050
在工作站本地，大部分 CPU

233
00:10:23,050 --> 00:10:25,690
时间都花在这里，所以 sy 当您添加工作站时，stem 确实

234
00:10:25,690 --> 00:10:27,490
具有一定程度的自然

235
00:10:27,490 --> 00:10:30,550
扩展可扩展性，每个

236
00:10:30,550 --> 00:10:32,020
新工作站都会增加

237
00:10:32,020 --> 00:10:33,459
新用户的负载，但

238
00:10:33,459 --> 00:10:35,920
运行该用户

239
00:10:35,920 --> 00:10:38,260
文件系统操作的可用 CPU 时间也更多一些，当然在某些

240
00:10:38,260 --> 00:10:40,779
时候您是 中央存储系统的gas会用完，

241
00:10:40,779 --> 00:10:44,800
 

242
00:10:44,800 --> 00:10:46,120
然后你知道你可能需要添加更多的

243
00:10:46,120 --> 00:10:52,980
存储服务器，

244
00:10:54,830 --> 00:10:59,339
好吧，所以我们有系统

245
00:10:59,339 --> 00:11:01,320
在这里进行严重的缓存，并且

246
00:11:01,320 --> 00:11:05,339
在缓存中进行修改，

247
00:11:05,339 --> 00:11:06,750
实际上这些立即 对于

248
00:11:06,750 --> 00:11:09,660
设计中的一些严重挑战，

249
00:11:09,660 --> 00:11:11,670
设计主要是关于解决

250
00:11:11,670 --> 00:11:15,510
我即将提出的挑战，这些

251
00:11:15,510 --> 00:11:20,339
挑战主要

252
00:11:20,339 --> 00:11:26,130
来自缓存和这种

253
00:11:26,130 --> 00:11:28,380
分散式架构，其中

254
00:11:28,380 --> 00:11:30,660
大部分智能都位于

255
00:11:30,660 --> 00:11:43,220
客户端中，所以 第一个挑战是

256
00:11:45,500 --> 00:11:49,170
假设工作站创建一个文件

257
00:11:49,170 --> 00:11:55,890
，你知道也许一个文件说 /a 一个新

258
00:11:55,890 --> 00:11:59,490
文件 /a 最初它只是

259
00:11:59,490 --> 00:12:01,380
在它的位置创建这个 l 缓存，以便您

260
00:12:01,380 --> 00:12:03,029
首先知道它可能需要从petal nom获取

261
00:12:03,029 --> 00:12:05,010
斜线目录的当前内容，

262
00:12:05,010 --> 00:12:06,930
但是当它创建一个

263
00:12:06,930 --> 00:12:10,110
文件时只是修改其缓存副本并且

264
00:12:10,110 --> 00:12:11,250
不会立即将其发送回

265
00:12:11,250 --> 00:12:14,459
peddle，那么这里就有一个直接的问题

266
00:12:14,459 --> 00:12:17,250
假设工作站 2 上的用户

267
00:12:17,250 --> 00:12:19,709
试图获取目录斜线的目录列表，

268
00:12:19,709 --> 00:12:21,930
我们真的希望

269
00:12:21,930 --> 00:12:24,720
能够让该用户正确地看到新

270
00:12:24,720 --> 00:12:27,720
创建的文件，这就是用户

271
00:12:27,720 --> 00:12:29,339
所期望的，如果你知道，用户会非常

272
00:12:29,339 --> 00:12:31,980
困惑 楼下的人

273
00:12:31,980 --> 00:12:33,420
创建了一个文件并说哦，

274
00:12:33,420 --> 00:12:34,410
你知道我把所有这些有趣的

275
00:12:34,410 --> 00:12:36,360
信息都放在了这个新文件中 /a

276
00:12:36,360 --> 00:12:37,860
你为什么不去阅读它然后我尝试

277
00:12:37,860 --> 00:12:41,040
阅读它，它完全不存在所以我们

278
00:12:41,040 --> 00:12:43,470
绝对想要 非常强的一致性

279
00:12:43,470 --> 00:12:45,000
如果楼下的人说他们

280
00:12:45,000 --> 00:12:46,470
在文件系统中做了一些事情，我

281
00:12:46,470 --> 00:12:49,200
应该能够看到它，如果我

282
00:12:49,200 --> 00:12:51,720
在一个工作站上编辑文件，然后可能

283
00:12:51,720 --> 00:12:54,330
在另一台计算机上的计算机上编译它，

284
00:12:54,330 --> 00:12:56,850
我想要 C 编译器查看

285
00:12:56,850 --> 00:12:58,500
我刚刚对我的文件所做的修改

286
00:12:58,500 --> 00:13:01,079
，这意味着文件系统必须

287
00:13:01,079 --> 00:13:05,540
做一些事情来确保读者甚至可以看到

288
00:13:05,540 --> 00:13:09,810
最新的权限，所以我们

289
00:13:09,810 --> 00:13:11,279
一直在谈论这个，因为我们一直

290
00:13:11,279 --> 00:13:13,319
称之为你知道强强

291
00:13:13,319 --> 00:13:15,740
之前的一致性和线性化能力

292
00:13:15,740 --> 00:13:18,779
，这基本上是我们在

293
00:13:18,779 --> 00:13:20,850
缓存上下文中想要的，尽管

294
00:13:20,850 --> 00:13:22,980
这里的问题不一定是关于存储

295
00:13:22,980 --> 00:13:24,480
服务器，而是关于

296
00:13:24,480 --> 00:13:26,370
这里有一个修改

297
00:13:26,370 --> 00:13:28,860
需要在其他地方看到的事实，现在

298
00:13:28,860 --> 00:13:30,870
为了历史 通常

299
00:13:30,870 --> 00:13:38,790
称为缓存一致性的原因，它

300
00:13:38,790 --> 00:13:41,879
是缓存系统的属性，

301
00:13:41,879 --> 00:13:43,649
即使我缓存了旧版本的某些东西，

302
00:13:43,649 --> 00:13:46,470
如果其他人在

303
00:13:46,470 --> 00:13:48,269
他们的缓存中修改了它，那么我的缓存将

304
00:13:48,269 --> 00:13:50,790
自动反映他们的

305
00:13:50,790 --> 00:13:53,550
修改，所以我们希望这个缓存

306
00:13:53,550 --> 00:13:58,350
一致性属性是另一个问题 你

307
00:13:58,350 --> 00:14:01,889
拥有的是你知道所有

308
00:14:01,889 --> 00:14:03,870
的文件和目录都是共享的，我们

309
00:14:03,870 --> 00:14:05,879
很容易遇到两个不同的情况

310
00:14:05,879 --> 00:14:09,059
t 个工作站同时修改

311
00:14:09,059 --> 00:14:11,220
同一个目录，所以

312
00:14:11,220 --> 00:14:14,250
再次假设他们工作站上的用户

313
00:14:14,250 --> 00:14:16,019
想要创建一个文件

314
00:14:16,019 --> 00:14:18,209
/a，它是目录中的一个新文件

315
00:14:18,209 --> 00:14:20,189
 

316
00:14:20,189 --> 00:14:24,029
两人想要

317
00:14:24,029 --> 00:14:27,209
创建一个名为 slash B 的新文件，所以在

318
00:14:27,209 --> 00:14:29,250
某种程度上你知道他们正在创建

319
00:14:29,250 --> 00:14:32,100
不同的文件，好吧 a 和 B 但他们

320
00:14:32,100 --> 00:14:33,540
都需要修改根目录

321
00:14:33,540 --> 00:14:35,399
以向根目录添加一个新名称

322
00:14:35,399 --> 00:14:38,040
，所以问题是偶数 如果他们

323
00:14:38,040 --> 00:14:40,920
同时执行此操作，您知道将

324
00:14:40,920 --> 00:14:42,870
不同名称文件的创建归档，但

325
00:14:42,870 --> 00:14:44,339
在来自不同工作站的同一目录中，

326
00:14:44,339 --> 00:14:46,290
系统将能够

327
00:14:46,290 --> 00:14:51,029
整理这些

328
00:14:51,029 --> 00:14:52,889
对同一目录的并发修改并得出一些

329
00:14:52,889 --> 00:14:54,240
合理的结果，当然还有

330
00:14:54,240 --> 00:14:56,519
我们的合理结果 想要的是 a

331
00:14:56,519 --> 00:14:58,949
和 B 最终都存在我们不希望

332
00:14:58,949 --> 00:15:01,889
最终出现一些你知道的情况，

333
00:15:01,889 --> 00:15:04,230
其中只有一个最终存在，

334
00:15:04,230 --> 00:15:06,329
因为第二个修改

335
00:15:06,329 --> 00:15:10,259
覆盖并排序 of 取代了

336
00:15:10,259 --> 00:15:13,160
第一个修改

337
00:15:15,440 --> 00:15:19,860
，所以这又是它有很多

338
00:15:19,860 --> 00:15:21,150
不同的名称，但我们将其称为 de

339
00:15:21,150 --> 00:15:26,010
Missa T 我们希望诸如

340
00:15:26,010 --> 00:15:28,770
创建文件之类的操作以引导文件的行为就

341
00:15:28,770 --> 00:15:31,520
好像它们只是瞬时

342
00:15:31,520 --> 00:15:34,620
瞬时的一样，并且

343
00:15:34,620 --> 00:15:37,040
因此，永远不要干扰

344
00:15:37,040 --> 00:15:39,930
 

345
00:15:39,930 --> 00:15:41,460
其他

346
00:15:41,460 --> 00:15:43,470
工作站在类似时间发生

347
00:15:43,470 --> 00:15:46,080
 

348
00:15:46,080 --> 00:15:47,670
 

349
00:15:47,670 --> 00:15:50,760
的操作 状态我们希望它们

350
00:15:50,760 --> 00:15:54,770
看起来好像它们

351
00:15:54,770 --> 00:16:00,630
在我们遇到的最后一个问题上瞬间发生是假设

352
00:16:00,630 --> 00:16:04,230
你知道我的工作站被修改了

353
00:16:04,230 --> 00:16:05,550
很多东西，也许它的

354
00:16:05,550 --> 00:16:07,589
修改是或者它的许多

355
00:16:07,589 --> 00:16:10,260
修改只在本地缓存中完成，

356
00:16:10,260 --> 00:16:12,420
因为这个权利

357
00:16:12,420 --> 00:16:16,170
如果我的站点

358
00:16:16,170 --> 00:16:18,450
在修改了本地缓存中的某些内容后崩溃了，则返回缓存，

359
00:16:18,450 --> 00:16:20,400
并且可能将一些但不是所有

360
00:16:20,400 --> 00:16:22,170
的修改反射回存储

361
00:16:22,170 --> 00:16:27,300
踏板，其他工作站仍在

362
00:16:27,300 --> 00:16:29,520
执行，并且 他们仍然需要

363
00:16:29,520 --> 00:16:32,010
能够理解文件系统，

364
00:16:32,010 --> 00:16:34,290
所以我的工作站在

365
00:16:34,290 --> 00:16:35,700
我处于某些事情的中间时崩溃了，

366
00:16:35,700 --> 00:16:38,310
最好不要破坏整个文件系统

367
00:16:38,310 --> 00:16:39,990
，甚至是它的任何部分，

368
00:16:39,990 --> 00:16:45,330
这意味着我们 需要的

369
00:16:45,330 --> 00:16:49,290
是单个服务器的崩溃恢复我们

370
00:16:49,290 --> 00:16:51,080
将无法让我的工作站崩溃

371
00:16:51,080 --> 00:16:53,850
而不干扰

372
00:16:53,850 --> 00:16:55,500
使用同一共享

373
00:16:55,500 --> 00:16:57,270
系统的其他人的活动即使他们查看

374
00:16:57,270 --> 00:16:58,650
我的文件中的目录他们应该看到一些

375
00:16:58,650 --> 00:17:00,510
明智的东西也许它不会 包括

376
00:17:00,510 --> 00:17:02,839
我做的最后一件事，但他们应该看到

377
00:17:02,839 --> 00:17:06,150
一致的文件系统而不是 rekt

378
00:17:06,150 --> 00:17:08,250
文件系统数据结构，所以我们希望

379
00:17:08,250 --> 00:17:10,910
崩溃恢复

380
00:17:13,859 --> 00:17:16,390
一如既往地

381
00:17:16,390 --> 00:17:18,760
使用更复杂的分布式系统，因为我们

382
00:17:18,760 --> 00:17:20,560
很容易遇到只有

383
00:17:20,560 --> 00:17:22,900
一个服务器的情况 崩溃，但其他人

384
00:17:22,900 --> 00:17:27,220
正在运行，并再次为所有这些

385
00:17:27,220 --> 00:17:30,160
事情为所有这三个挑战

386
00:17:30,160 --> 00:17:32,170
他们真正面临挑战我们在这个

387
00:17:32,170 --> 00:17:34,300
讨论中他们的挑战是如何

388
00:17:34,300 --> 00:17:36,300
自由 gipani 的工作原理以及

389
00:17:36,300 --> 00:17:38,190
 

390
00:17:38,190 --> 00:17:40,810
工作站内的这些鸡蛋花软件是如何工作的

391
00:17:40,810 --> 00:17:42,130
，所以当我谈论崩溃时，我

392
00:17:42,130 --> 00:17:43,480
指的是工作站崩溃

393
00:17:43,480 --> 00:17:46,630
，它是鸡蛋花，你知道踏板

394
00:17:46,630 --> 00:17:50,080
虚拟磁盘有许多

395
00:17:50,080 --> 00:17:51,850
与之相关的类似问题，但实际上并

396
00:17:51,850 --> 00:17:55,470
没有 今天的重点是它在踏板中内置了

397
00:17:55,470 --> 00:17:59,230
一套完全独立的 R'lyeh

398
00:17:59,230 --> 00:18:02,590
容错机制，

399
00:18:02,590 --> 00:18:04,720
它实际上很像

400
00:18:04,720 --> 00:18:06,670
我们之前讨论过的链式复制类型的系统，

401
00:18:06,670 --> 00:18:12,460
好的，所以我将

402
00:18:12,460 --> 00:18:15,270
依次讨论这些挑战中的每一个

403
00:18:15,270 --> 00:18:20,010
第一个挑战是缓存一致性

404
00:18:22,050 --> 00:18:29,620
，这里的游戏是同时获得

405
00:18:29,620 --> 00:18:32,680
线性化能力的好处，

406
00:18:32,680 --> 00:18:35,170
即当我阅读时，当我查看

407
00:18:35,170 --> 00:18:36,850
文件系统中的任何内容时，我总是看到新的

408
00:18:36,850 --> 00:18:38,710
数据，我总是看到最新的数据，

409
00:18:38,710 --> 00:18:42,210
所以我们都得到了线性化 能力和

410
00:18:42,210 --> 00:18:45,370
缓存不是缓存 那是很好的缓存，

411
00:18:45,370 --> 00:18:48,100
因为我们可以获得性能，所以不知何故，

412
00:18:48,100 --> 00:18:50,230
我们知道我们需要获得这

413
00:18:50,230 --> 00:18:56,470
两者的好处以及人们实现的那种好处

414
00:18:56,470 --> 00:18:59,010
 

415
00:18:59,010 --> 00:19:01,120
使用所谓的缓存一致性

416
00:19:01,120 --> 00:19:02,860
协议的缓存一致性，事实证明，这些

417
00:19:02,860 --> 00:19:04,510
协议在许多

418
00:19:04,510 --> 00:19:06,220
不同的情况下被大量使用，不仅是

419
00:19:06,220 --> 00:19:08,770
分布式文件系统，而且还包括

420
00:19:08,770 --> 00:19:12,550
 

421
00:19:12,550 --> 00:19:14,880
多核中的缓存，多核处理器中的每核缓存

422
00:19:14,880 --> 00:19:17,560
也使用 缓存一致性协议

423
00:19:17,560 --> 00:19:20,620
与我将为鸡蛋花描述的协议没有什么不同，

424
00:19:20,620 --> 00:19:23,350
 

425
00:19:23,350 --> 00:19:23,700
 

426
00:19:23,700 --> 00:19:29,100
所以事实证明，鸡蛋花 x 的缓存

427
00:19:29,100 --> 00:19:32,130
一致性是由它使用锁驱动的

428
00:19:32,130 --> 00:19:34,679
，我们稍后会看到锁在

429
00:19:34,679 --> 00:19:37,169
两者中出现 实际上对于原子性和

430
00:19:37,169 --> 00:19:39,480
崩溃恢复，但

431
00:19:39,480 --> 00:19:41,130
我现在要讨论的锁的特殊用途

432
00:19:41,130 --> 00:19:43,200
是使用块来驱动缓存一致性，

433
00:19:43,200 --> 00:19:45,149
以帮助工作站确保

434
00:19:45,149 --> 00:19:46,919
即使它们正在缓存数据，它们也在

435
00:19:46,919 --> 00:19:51,029
缓存最新数据

436
00:19:51,029 --> 00:19:52,950
除了鸡蛋花服务器、工作站

437
00:19:52,950 --> 00:19:55,889
和踏板服务器之外

438
00:19:55,889 --> 00:19:59,789
，鸡蛋花系统中还有第三种服务器，

439
00:19:59,789 --> 00:20:02,730
还有锁服务器，所以我们

440
00:20:02,730 --> 00:20:04,559
只是假装有 ne lock

441
00:20:04,559 --> 00:20:06,870
server 虽然你可以将

442
00:20:06,870 --> 00:20:10,049
锁分片到多个服务器上，所以这里有一个

443
00:20:10,049 --> 00:20:16,470
lock server 它是一个独立的，你知道

444
00:20:16,470 --> 00:20:17,909
它在逻辑上至少是一个独立的

445
00:20:17,909 --> 00:20:19,500
计算机，尽管我认为它们在

446
00:20:19,500 --> 00:20:21,269
与踏板服务器相同的硬件上运行它们，

447
00:20:21,269 --> 00:20:24,659
但它基本上只有一张

448
00:20:24,659 --> 00:20:29,669
桌子 命名锁和锁的

449
00:20:29,669 --> 00:20:32,070
命名我们认为它们

450
00:20:32,070 --> 00:20:34,679
是以文件名命名的，尽管

451
00:20:34,679 --> 00:20:37,139
实际上它们是以 I 数字命名的，所以

452
00:20:37,139 --> 00:20:43,620
我们对每个文件都有一个潜在的锁

453
00:20:43,620 --> 00:20:48,630
，每个锁可能

454
00:20:48,630 --> 00:20:51,539
由 这个讨论的一些所有者

455
00:20:51,539 --> 00:20:54,240
我只是假设我将把

456
00:20:54,240 --> 00:20:56,130
它描述为好像锁是独占锁，

457
00:20:56,130 --> 00:20:58,769
尽管实际上鸡蛋花有一个更

458
00:20:58,769 --> 00:21:01,049
复杂的锁方案，

459
00:21:01,049 --> 00:21:03,899
允许一个作者或多个读者

460
00:21:03,899 --> 00:21:08,279
，例如文件 X 可能有 最近

461
00:21:08,279 --> 00:21:10,529
被工作站 1 使用，并且

462
00:21:10,529 --> 00:21:15,029
工作站 1 上有一个锁，可能

463
00:21:15,029 --> 00:21:17,519
文件 Y 最近被工作站 2 使用，

464
00:21:17,519 --> 00:21:20,039
并且工作站 2 有一个锁

465
00:21:20,039 --> 00:21:21,510
，锁定服务器将记住关闭或

466
00:21:21,510 --> 00:21:22,200
每个 fi

467
00:21:22,200 --> 00:21:24,299
如果有人可能没有人

468
00:21:24,299 --> 00:21:28,260
对该文件进行操作，那么谁拥有锁，然后在每个

469
00:21:28,260 --> 00:21:29,870
工作站中，

470
00:21:29,870 --> 00:21:33,779
每个工作站都跟踪

471
00:21:33,779 --> 00:21:36,090
它持有的锁，这与它紧密相关

472
00:21:36,090 --> 00:21:37,110
 

473
00:21:37,110 --> 00:21:38,999
我也在跟踪缓存数据，

474
00:21:38,999 --> 00:21:42,440
因此在每个工作站的鸡蛋花

475
00:21:42,440 --> 00:21:49,549
模块中 还有一个锁表，

476
00:21:52,999 --> 00:21:55,889
记录哪个文件需要更多的会话来

477
00:21:55,889 --> 00:21:59,989
锁定它有什么样的锁以及

478
00:21:59,989 --> 00:22:03,210
该文件的缓存内容，

479
00:22:03,210 --> 00:22:04,710
因此可能是一大堆

480
00:22:04,710 --> 00:22:07,289
数据块或目录内容

481
00:22:07,289 --> 00:22:10,320
，例如，有很多 这里的内容

482
00:22:10,320 --> 00:22:14,460
，所以琳达鸡蛋花服务器决定

483
00:22:14,460 --> 00:22:17,100
哦，它需要读取它需要使用

484
00:22:17,100 --> 00:22:19,320
目录斜杠或查看文件 a 或

485
00:22:19,320 --> 00:22:22,679
查看 inode 它首先被要求

486
00:22:22,679 --> 00:22:24,389
锁定服务器锁定

487
00:22:24,389 --> 00:22:26,999
它将要使用的任何内容，然后它 要求花瓣

488
00:22:26,999 --> 00:22:30,149
获取该文件或

489
00:22:30,149 --> 00:22:32,369
目录或其需要读取的任何内容的数据

490
00:22:32,369 --> 00:22:34,409
，然后工作站

491
00:22:34,409 --> 00:22:36,539
记住哦，您知道我有

492
00:22:36,539 --> 00:22:41,609
文件 X 的副本，其内容是文件 X 的

493
00:22:41,609 --> 00:22:46,590
内容 缓存，事实

494
00:22:46,590 --> 00:22:48,600
证明工作站可以

495
00:22:48,600 --> 00:22:51,960
在至少两种不同的模式下锁定

496
00:22:51,960 --> 00:22:54,659
工作站可以主动读取或

497
00:22:54,659 --> 00:22:56,970
写入的任何文件或目录

498
00:22:56,970 --> 00:22:59,129
现在

499
00:22:59,129 --> 00:23:01,799
处于文件创建操作或删除或

500
00:23:01,799 --> 00:23:05,399
重命名或其他操作的中间 所以在这种情况下，我会

501
00:23:05,399 --> 00:23:09,379
说锁由

502
00:23:09,379 --> 00:23:12,769
工作站持有并且很忙，它也可能是

503
00:23:12,769 --> 00:23:16,049
在工作站完成一些

504
00:23:16,049 --> 00:23:17,999
操作（如创建文件或

505
00:23:17,999 --> 00:23:18,779
读取

506
00:23:18,779 --> 00:23:20,639
您知道的文件然后在完成后立即释放锁）

507
00:23:20,639 --> 00:23:22,139
之后 使用该系统调用，

508
00:23:22,139 --> 00:23:24,149
 

509
00:23:24,149 --> 00:23:25,859
只要系统调用工作站上的任何系统调用（例如重命名、读取或写入或创建）

510
00:23:25,859 --> 00:23:27,659
 

511
00:23:27,659 --> 00:23:31,980
，至少在内部它不会

512
00:23:31,980 --> 00:23:34,289
主动使用该文件，但

513
00:23:34,289 --> 00:23:36,119
它会在锁定服务器的范围内放弃锁定

514
00:23:36,119 --> 00:23:37,739
担心工作站将持有

515
00:23:37,739 --> 00:23:39,809
锁，但工作站说明

516
00:23:39,809 --> 00:23:42,899
它自己使用它不再主动使用

517
00:23:42,899 --> 00:23:45,269
该锁以及调用

518
00:23:45,269 --> 00:23:49,170
锁仍然由工作站持有

519
00:23:49,170 --> 00:23:54,430
我只是 工作站并没有

520
00:23:54,430 --> 00:23:57,130
真正使用它，这很快就会很重要

521
00:23:57,130 --> 00:24:01,360
，所以我认为

522
00:24:01,360 --> 00:24:02,920
如果我们假设

523
00:24:02,920 --> 00:24:05,050
这是工作站之一，这两个设置一致，锁服务器

524
00:24:05,050 --> 00:24:07,420
知道哦，x和y的锁存在并且

525
00:24:07,420 --> 00:24:08,620
它们是 两者都由工作站持有一个

526
00:24:08,620 --> 00:24:11,470
工作站

527
00:24:11,470 --> 00:24:13,090
在其表中具有相同的信息它知道它

528
00:24:13,090 --> 00:24:15,790
持有这两个块，此外

529
00:24:15,790 --> 00:24:18,010
它还记得内容

530
00:24:18,010 --> 00:24:20,440
是为两个锁所覆盖的目录的文件管理器缓存的

531
00:24:20,440 --> 00:24:26,560
 

532
00:24:26,560 --> 00:24:28,990
这里有许多规则

533
00:24:28,990 --> 00:24:32,680
鸡蛋花遵循这导致它以

534
00:24:32,680 --> 00:24:35,110
一种提供缓存一致性的方式使用锁，

535
00:24:35,110 --> 00:24:36,850
然后确定没有人打算

536
00:24:36,850 --> 00:24:38,860
使用缓存中的陈旧数据，

537
00:24:38,860 --> 00:24:45,840
所以这些基本上

538
00:24:46,110 --> 00:24:48,310
是与

539
00:24:48,310 --> 00:24:53,470
锁和缓存数据结合使用的规则，所以这里真正

540
00:24:53,470 --> 00:24:58,240
最重要的不变量是 除非

541
00:24:58,240 --> 00:25:00,610
工作站还持有与该数据关联的锁，否则不允许任何工作站缓存数据以

542
00:25:00,610 --> 00:25:02,470
保存任何缓存数据

543
00:25:02,470 --> 00:25:05,440
，

544
00:25:05,440 --> 00:25:13,480
因此基本上没有锁 w 就没有缓存数据

545
00:25:13,480 --> 00:25:17,740
如果没有保护该数据的锁，

546
00:25:17,740 --> 00:25:21,520
并且在操作上这

547
00:25:21,520 --> 00:25:25,150
意味着工作站在使用数据之前，

548
00:25:25,150 --> 00:25:27,370
它首先

549
00:25:27,370 --> 00:25:29,590
从锁服务器获取数据的锁，并且在

550
00:25:29,590 --> 00:25:32,350
工作站获得锁之后，工作站才

551
00:25:32,350 --> 00:25:34,600
从花瓣读取数据

552
00:25:34,600 --> 00:25:40,060
并放置 并将其放入缓存中，

553
00:25:40,060 --> 00:25:41,830
因此顺序是您可以获取锁

554
00:25:41,830 --> 00:25:47,160
，然后从花瓣中读取

555
00:25:50,470 --> 00:25:53,630
 

556
00:25:53,630 --> 00:25:55,220
 

557
00:25:55,220 --> 00:25:56,480
 

558
00:25:56,480 --> 00:25:58,040
获得锁，然后严格地

559
00:25:58,040 --> 00:26:02,300
从花瓣中读取，如果你

560
00:26:02,300 --> 00:26:05,960
释放了锁，那么规则是

561
00:26:05,960 --> 00:26:08,000
，在释放锁之前，

562
00:26:08,000 --> 00:26:10,100
如果你在释放锁之前修改了缓存中的锁数据，你首先必须写，

563
00:26:10,100 --> 00:26:13,340
 

564
00:26:13,340 --> 00:26:15,440
你必须写 返回数据

565
00:26:15,440 --> 00:26:18,200
以将数据修改回花瓣，然后

566
00:26:18,200 --> 00:26:20,240
仅当花瓣为“是”时，我才获得数据，

567
00:26:20,240 --> 00:26:22,070
然后您必须释放将

568
00:26:22,070 --> 00:26:23,840
锁返回给

569
00:26:23,840 --> 00:26:27,130
锁服务器的锁，因此顺序始终是

570
00:26:27,130 --> 00:26:31,930
您首先写入缓存 约会 花瓣

571
00:26:31,930 --> 00:26:37,840
存储系统，然后释放锁

572
00:26:40,690 --> 00:26:43,760
并擦除条目 哎呀

573
00:26:43,760 --> 00:26:45,410
 

574
00:26:45,410 --> 00:26:47,600
，从该

575
00:26:47,600 --> 00:26:52,160
工作站锁定表中删除条目和猫以及缓存数据这

576
00:26:52,160 --> 00:26:55,250
导致

577
00:26:55,250 --> 00:26:57,950
锁定服务器之间以及工作站与锁定服务器之间的协议

578
00:26:57,950 --> 00:27:01,940
组成 四种

579
00:27:01,940 --> 00:27:04,070
不同类型的消息，这是

580
00:27:04,070 --> 00:27:11,720
一致性协议，这些只是

581
00:27:11,720 --> 00:27:13,190
网络，您可以将它们视为

582
00:27:13,190 --> 00:27:14,540
本质上的一种单向网络

583
00:27:14,540 --> 00:27:20,860
消息有

584
00:27:20,860 --> 00:27:25,000
从工作站到锁定服务器的

585
00:27:25,000 --> 00:27:27,590
请求消息请求消息说哦，嘿，锁定服务器

586
00:27:27,590 --> 00:27:30,950
我会 如果锁

587
00:27:30,950 --> 00:27:34,460
服务器愿意给你锁

588
00:27:34,460 --> 00:27:35,960
，当然如果其他人持有

589
00:27:35,960 --> 00:27:37,610
这个锁，如果锁服务器不能立即给

590
00:27:37,610 --> 00:27:39,200
你锁，但是如果锁

591
00:27:39,200 --> 00:27:41,360
变得空闲，锁服务器会

592
00:27:41,360 --> 00:27:46,970
响应，我们有一个 如果您请求锁定服务器的锁定并且其他人持有锁定权，则授予消息然后

593
00:27:46,970 --> 00:27:49,400
锁定服务器返回到工作站以

594
00:27:49,400 --> 00:27:51,980
响应较早的请求

595
00:27:51,980 --> 00:27:53,900
 

596
00:27:53,900 --> 00:27:55,610
 

597
00:27:55,610 --> 00:27:58,010
现在其他工作站必须首先

598
00:27:58,010 --> 00:27:59,450
放弃锁，我们不能让两个

599
00:27:59,450 --> 00:28:02,180
人拥有同一个锁，所以

600
00:28:02,180 --> 00:28:03,440
我们如何才能

601
00:28:03,440 --> 00:28:07,250
让锁正常工作我在这里说的是，

602
00:28:07,250 --> 00:28:08,690
当一个锁站是你知道

603
00:28:08,690 --> 00:28:09,889
它什么时候 实际使用锁并

604
00:28:09,889 --> 00:28:11,779
主动读取或写入

605
00:28:11,779 --> 00:28:13,519
具有锁的东西并将其标记为忙

606
00:28:13,519 --> 00:28:15,710
但是工作站

607
00:28:15,710 --> 00:28:18,289
通常在使用完锁后不会放弃锁，

608
00:28:18,289 --> 00:28:21,649
因此如果我创建文件然后

609
00:28:21,649 --> 00:28:24,679
创建系统调用 完成我仍然

610
00:28:24,679 --> 00:28:26,509
拥有那个新文件锁定的文件，并且

611
00:28:26,509 --> 00:28:28,370
还拥有该文件的锁，我的

612
00:28:28,370 --> 00:28:29,570
工作站仍将全部

613
00:28:29,570 --> 00:28:31,549
锁定该文件，它只会处于

614
00:28:31,549 --> 00:28:33,620
空闲状态而不是忙碌状态，但就

615
00:28:33,620 --> 00:28:34,730
锁定服务器而言

616
00:28:34,730 --> 00:28:36,409
好吧，我的工作站仍然有锁

617
00:28:36,409 --> 00:28:38,269
，之所以

618
00:28:38,269 --> 00:28:40,159
懒惰将锁交还给

619
00:28:40,159 --> 00:28:42,320
锁服务器的原因是，如果我

620
00:28:42,320 --> 00:28:43,850
在我的工作站上创建一个名为 Y 的文件，

621
00:28:43,850 --> 00:28:46,159
我几乎肯定

622
00:28:46,159 --> 00:28:48,950
会使用 Y 其他目的，比如

623
00:28:48,950 --> 00:28:51,110
写一些 数据到它或从中读取或

624
00:28:51,110 --> 00:28:53,139
其他东西，因此

625
00:28:53,139 --> 00:28:55,490
对于工作站来说，为工作站

626
00:28:55,490 --> 00:28:58,940
中所有最近

627
00:28:58,940 --> 00:29:00,590
使用的文件累积锁并且不

628
00:29:00,590 --> 00:29:02,899
将它们归还给它们是非常有利的，除非它真的必须这样做

629
00:29:02,899 --> 00:29:05,179
，所以在普通

630
00:29:05,179 --> 00:29:07,070
情况下 我在我的主目录中使用了一堆文件，

631
00:29:07,070 --> 00:29:09,950
而其他任何工作站上的

632
00:29:09,950 --> 00:29:11,960
其他人都没有看过它们，我的

633
00:29:11,960 --> 00:29:14,000
工作站最终会为我的文件累积数十

634
00:29:14,000 --> 00:29:16,279
或数百个处于空闲状态的锁，

635
00:29:16,279 --> 00:29:18,230
但如果其他人确实查看

636
00:29:18,230 --> 00:29:20,840
了我的一个文件 他们需要首先

637
00:29:20,840 --> 00:29:22,340
获得锁，而我必须放弃

638
00:29:22,340 --> 00:29:25,009
锁，因此工作方式是，

639
00:29:25,009 --> 00:29:27,350
如果锁服务器收到锁请求

640
00:29:27,350 --> 00:29:30,080
并且它在锁服务器表 AHA 中看到，则

641
00:29:30,080 --> 00:29:31,879
您知道锁当前由

642
00:29:31,879 --> 00:29:34,460
工作站 1 拥有 锁服务器将向

643
00:29:34,460 --> 00:29:38,539
 

644
00:29:38,539 --> 00:29:40,669
当前拥有该锁的工作站发送撤销消息，

645
00:29:40,669 --> 00:29:42,889
说看你知道其他人

646
00:29:42,889 --> 00:29:47,360
想要它请放弃锁当

647
00:29:47,360 --> 00:29:49,580
工作站收到撤销请求时，

648
00:29:49,580 --> 00:29:54,409
如果锁我 s 空闲然后如果缓存数据

649
00:29:54,409 --> 00:29:56,419
是脏的，工作站将首先

650
00:29:56,419 --> 00:30:00,230
将修改过缓存数据的 cat 脏数据写

651
00:30:00,230 --> 00:30:01,759
回 peddle，

652
00:30:01,759 --> 00:30:04,610
因为规则说

653
00:30:04,610 --> 00:30:06,259
为了永远不缓存没有锁的数据，

654
00:30:06,259 --> 00:30:08,750
我们得到了修改的权利 可以

655
00:30:08,750 --> 00:30:11,419
追溯到 peddle 在释放之前，所以

656
00:30:11,419 --> 00:30:13,159
如果锁空闲将首先写

657
00:30:13,159 --> 00:30:16,519
回数据，如果它被修改回 peddle

658
00:30:16,519 --> 00:30:17,360
，

659
00:30:17,360 --> 00:30:22,250
然后向锁服务器发送一条消息，

660
00:30:22,250 --> 00:30:24,890
说可以我们放弃这个

661
00:30:24,890 --> 00:30:35,809
锁，所以撤销的响应发送到

662
00:30:35,809 --> 00:30:37,940
工作站 是最差的站发送

663
00:30:37,940 --> 00:30:39,200
它当然释放如果最差的

664
00:30:39,200 --> 00:30:40,850
站在它

665
00:30:40,850 --> 00:30:42,620
正在

666
00:30:42,620 --> 00:30:44,630
删除或重命名或

667
00:30:44,630 --> 00:30:49,190
影响锁定文件

668
00:30:49,190 --> 00:30:51,950
的过程中主动使用锁时被撤销，最差的站不会给我们

669
00:30:51,950 --> 00:30:53,720
锁，直到它 它已完成使用，

670
00:30:53,720 --> 00:30:55,010
直到完成该文件系统

671
00:30:55,010 --> 00:30:56,809
操作，无论

672
00:30:56,809 --> 00:30:58,970
使用该文件的系统调用是什么，然后

673
00:30:58,970 --> 00:31:00,830
处于最差站锁定状态的锁定

674
00:31:00,830 --> 00:31:03,500
将转换为空闲，然后 y 您

675
00:31:03,500 --> 00:31:07,190
将能够注意撤销

676
00:31:07,190 --> 00:31:10,010
请求，并且在写信给兜售后，如果

677
00:31:10,010 --> 00:31:12,950
需要释放锁，那么

678
00:31:12,950 --> 00:31:17,650
这就是边缘的一致性协议

679
00:31:17,650 --> 00:31:21,410
，这是对

680
00:31:21,410 --> 00:31:23,059
 

681
00:31:23,059 --> 00:31:24,799
我提到的赤素馨使用的一致性协议的简化

682
00:31:24,799 --> 00:31:26,299
在这一切之前缺少的是

683
00:31:26,299 --> 00:31:28,429
锁可以是写入者

684
00:31:28,429 --> 00:31:31,100
独占或共享用于

685
00:31:31,100 --> 00:31:38,990
只读访问的事实，就像花瓣是

686
00:31:38,990 --> 00:31:41,059
一个块服务器并且

687
00:31:41,059 --> 00:31:44,150
不了解文件系统的任何内容锁

688
00:31:44,150 --> 00:31:47,210
服务器还有这些ID这些是真的

689
00:31:47,210 --> 00:31:49,429
锁标识符和锁

690
00:31:49,429 --> 00:31:51,980
对文件或

691
00:31:51,980 --> 00:31:53,809
目录或文件系统一无所知，它只是有

692
00:31:53,809 --> 00:31:55,760
这些，它只是有这个带有

693
00:31:55,760 --> 00:31:58,790
不透明 ID 的表，谁拥有你知道

694
00:31:58,790 --> 00:32:01,190
名称锁，谁拥有这些锁，

695
00:32:01,190 --> 00:32:03,230
它是鸡蛋花知道啊你

696
00:32:03,230 --> 00:32:05,240
知道我关联的锁是他给了一个

697
00:32:05,240 --> 00:32:08,330
文件有这样那样的标识符

698
00:32:08,330 --> 00:32:11,450
，并且碰巧日本使用unix风格的

699
00:32:11,450 --> 00:32:14,270
I编号或与文件相关联的编号

700
00:32:14,270 --> 00:32:20,390
o  f 为锁命名所以只是

701
00:32:20,390 --> 00:32:25,760
为了使这个一致性协议具体化

702
00:32:25,760 --> 00:32:28,580
并再次说明

703
00:32:28,580 --> 00:32:31,100
花瓣操作

704
00:32:31,100 --> 00:32:33,620
和锁服务器操作之间的关系让

705
00:32:33,620 --> 00:32:35,390
我来看看如果一个

706
00:32:35,390 --> 00:32:37,850
工作站修改了一些文件系统

707
00:32:37,850 --> 00:32:40,360
数据然后在另一个

708
00:32:40,360 --> 00:32:43,130
工作站中查看它会发生什么 所以我们有两个

709
00:32:43,130 --> 00:32:50,840
工作站作为锁定服务器，所以

710
00:32:50,840 --> 00:32:52,910
如果工作站一个想要读取，协议的执行方式是

711
00:32:52,910 --> 00:32:56,299
因为

712
00:32:56,299 --> 00:32:58,970
工作站想要读取然后修改文件

713
00:32:58,970 --> 00:33:02,120
e 所以在它甚至可以

714
00:33:02,120 --> 00:33:06,940
从 peddle 读取关于 Z 的任何内容之前，它必须首先

715
00:33:06,940 --> 00:33:11,510
获取锁 对于 Z 所以它

716
00:33:11,510 --> 00:33:13,520
向锁服务器发送一个获取请求可能

717
00:33:13,520 --> 00:33:15,350
没有人持有锁或锁服务器

718
00:33:15,350 --> 00:33:16,690
从未听说过任何关于它的信息

719
00:33:16,690 --> 00:33:19,250
所以锁为 Z 生成一个新条目

720
00:33:19,250 --> 00:33:21,919
并且它稳定地返回我们的回复说

721
00:33:21,919 --> 00:33:24,429
是的

722
00:33:24,429 --> 00:33:33,200
你拥有锁 C 的授权

723
00:33:33,200 --> 00:33:34,789
此时工作站说它已

724
00:33:34,789 --> 00:33:37,309
锁定文件 Z 无权

725
00:33:37,309 --> 00:33:40,220
从花瓣中读取有关它的信息，所以

726
00:33:40,220 --> 00:33:47,799
此时我们将从花瓣中读取 Z

727
00:33:52,030 --> 00:33:55,159
和 确实，工作站一可以

728
00:33:55,159 --> 00:33:57,620
稍后在其缓存中本地修改它，

729
00:33:57,620 --> 00:33:59,750
也许

730
00:33:59,750 --> 00:34:01,880
坐在工作站二前面的人

731
00:34:01,880 --> 00:34:04,010
也想读取文件 Z，而

732
00:34:04,010 --> 00:34:06,110
工作站二没有

733
00:34:06,110 --> 00:34:07,580
文件 ISA 的锁定是第一件事

734
00:34:07,580 --> 00:34:09,590
它需要做的是向锁服务器发送一条消息

735
00:34:09,590 --> 00:34:12,560
说哦，是的，我想

736
00:34:12,560 --> 00:34:16,609
获得文件 Z 的锁，锁服务器

737
00:34:16,609 --> 00:34:18,710
知道它还不能回复是，因为

738
00:34:18,710 --> 00:34:20,629
其他人拥有锁，即

739
00:34:20,629 --> 00:34:23,239
我的锁服务器发送的工作站之一

740
00:34:23,239 --> 00:34:28,418
作为回应

741
00:34:30,600 --> 00:34:34,000
撤销工作站一个工作站

742
00:34:34,000 --> 00:34:35,710
不允许放弃锁定，直到它将

743
00:34:35,710 --> 00:34:37,810
任何修改的数据写回

744
00:34:37,810 --> 00:34:42,280
踏板，所以它现在将写入模型

745
00:34:42,280 --> 00:34:45,460
任何修改的内容

746
00:34:45,460 --> 00:34:46,449
文件的实际内容总是

747
00:34:46,449 --> 00:34:51,370
修改回踏板

748
00:34:51,370 --> 00:34:54,840
工作站 2 是否允许将

749
00:34:54,840 --> 00:35:02,260
释放发送回锁服务器，锁

750
00:35:02,260 --> 00:35:04,150
服务器必须在

751
00:35:04,150 --> 00:35:05,590
某个表中保存记录，说你知道

752
00:35:05,590 --> 00:35:07,900
有人在等待锁

753
00:35:07,900 --> 00:35:10,390
Z  lder 释放我们

754
00:35:10,390 --> 00:35:14,590
需要回复的版本，所以这个

755
00:35:14,590 --> 00:35:17,140
释放的收据将导致锁服务器

756
00:35:17,140 --> 00:35:19,800
更新它的表并最终将

757
00:35:19,800 --> 00:35:26,500
授权发送回或第二站，

758
00:35:26,500 --> 00:35:28,720
此时我们的第二站终于可以

759
00:35:28,720 --> 00:35:36,580
读取文件，甚至可以踩踏板这是如何

760
00:35:36,580 --> 00:35:39,370
缓存一致性协议的作用是

761
00:35:39,370 --> 00:35:43,620
确保执行读取的每个人都

762
00:35:43,620 --> 00:35:46,960
不会读取数据，

763
00:35:46,960 --> 00:35:49,390
直到之前的任何人都读取数据，直到任何可能

764
00:35:49,390 --> 00:35:52,570
在缓存中私下修改数据的人

765
00:35:52,570 --> 00:35:54,700
首先将数据写回

766
00:35:54,700 --> 00:36:01,060
踏板，所以锁定机制

767
00:36:01,060 --> 00:36:04,300
强制读取以查看最新的权利所以

768
00:36:04,300 --> 00:36:12,540
发生了什么

769
00:36:12,540 --> 00:36:14,770
在这些缓存一致性协议中可能有许多优化

770
00:36:14,770 --> 00:36:16,570
 

771
00:36:16,570 --> 00:36:18,250
我的意思是我实际上已经描述了

772
00:36:18,250 --> 00:36:20,260
一个这种空闲状态

773
00:36:20,260 --> 00:36:22,270
工作站持有他们所持有的锁的事实

774
00:36:22,270 --> 00:36:23,830
现在不使用而不是

775
00:36:23,830 --> 00:36:25,420
立即发布它们，这

776
00:36:25,420 --> 00:36:28,120
已经是对

777
00:36:28,120 --> 00:36:30,730
您能想到的最简单协议的优化，另一个

778
00:36:30,730 --> 00:36:33,790
主要优化是 Frangipani

779
00:36:33,790 --> 00:36:36,700
有一个概念，即共享

780
00:36:36,700 --> 00:36:39,220
、共享读锁和

781
00:36:39,220 --> 00:36:41,470
独占写锁，所以有很多

782
00:36:41,470 --> 00:36:42,880
很多工作站需要

783
00:36:42,880 --> 00:36:44,740
是同一个文件，但没有人在写它，

784
00:36:44,740 --> 00:36:47,710
他们都可以在该文件上锁定一个读锁

785
00:36:47,710 --> 00:36:49,539
，如果有人 确实出现

786
00:36:49,539 --> 00:36:51,400
并尝试写入这个

787
00:36:51,400 --> 00:36:54,759
被广泛缓存的文件，他们首先需要首先

788
00:36:54,759 --> 00:36:57,910
撤销每个人的读锁，以便

789
00:36:57,910 --> 00:36:59,710
每个人都放弃他们的缓存副本，

790
00:36:59,710 --> 00:37:01,930
然后才有权或被允许

791
00:37:01,930 --> 00:37:03,460
写入文件，但现在没关系，因为

792
00:37:03,460 --> 00:37:05,500
没有人有缓存 不再复制，因此

793
00:37:05,500 --> 00:37:08,109
没有人可以在正常写入时读取陈旧数据，

794
00:37:08,109 --> 00:37:13,240
因此这是一个

795
00:37:13,240 --> 00:37:21,609
由锁定协议驱动的缓存一致性故事

796
00:37:21,609 --> 00:37:26,380
，在我们的

797
00:37:26,380 --> 00:37:35,829
列表中是的，是的，这是一个很好的问题

798
00:37:35,829 --> 00:37:42,700
，实际上在

799
00:37:42,700 --> 00:37:44,529
我的方案中存在风险 描述了如果我

800
00:37:44,529 --> 00:37:47,170
在我的工作站上修改了一个文件并且没有其他人

801
00:37:47,170 --> 00:37:50,440
阅读它，因为没有其他人阅读它，

802
00:37:50,440 --> 00:37:53,019
那么修改后文件的唯一副本可能

803
00:37:53,019 --> 00:37:55,569
包含一些宝贵的

804
00:37:55,569 --> 00:37:58,450
信息 我工作站上的 RAM 中的缓存

805
00:37:58,450 --> 00:38:00,849
和我的工作然后它们将

806
00:38:00,849 --> 00:38:03,579
崩溃，你知道我们没有做

807
00:38:03,579 --> 00:38:05,079
任何特别的事情，那么它会

808
00:38:05,079 --> 00:38:07,059
因为数据的唯一副本而崩溃，

809
00:38:07,059 --> 00:38:09,490
并且数据会丢失，所以

810
00:38:09,490 --> 00:38:12,190
为了防止这种情况发生 不管所有

811
00:38:12,190 --> 00:38:15,220
这些工作站每 30 秒写回

812
00:38:15,220 --> 00:38:18,549
缓存中的任何内容

813
00:38:18,549 --> 00:38:21,700
，因此

814
00:38:21,700 --> 00:38:23,799
如果我的工作站意外崩溃，

815
00:38:23,799 --> 00:38:25,539
我可能会失去最后 30 秒的工作时间，

816
00:38:25,539 --> 00:38:27,339
但实际上只是

817
00:38:27,339 --> 00:38:32,279
模仿普通 Linux 或 UNIX

818
00:38:33,150 --> 00:38:36,240
确实可以运行所有这一切，很多故事

819
00:38:36,240 --> 00:38:40,480
都是在分布式文件系统的上下文中

820
00:38:40,480 --> 00:38:43,660
尝试模仿

821
00:38:43,660 --> 00:38:46,119
普通 unix 风格的

822
00:38:46,119 --> 00:38:49,180
工作站所具有的属性，这样用户就不会对

823
00:38:49,180 --> 00:38:51,309
鸡蛋花感到惊讶，它只是

824
00:38:51,309 --> 00:38:53,410
有点像 与它们

825
00:38:53,410 --> 00:38:55,859
已经使用

826
00:38:57,000 --> 00:39:00,910
的方式相同，因此我们的下一个挑战

827
00:39:00,910 --> 00:39:04,390
是如何实现原子性

828
00:39:04,390 --> 00:39:05,890
，即使当我执行复杂

829
00:39:05,890 --> 00:39:07,750
操作（例如创建文件）时，这

830
00:39:07,750 --> 00:39:10,780
毕竟涉及 s 将我知道的新标记

831
00:39:10,780 --> 00:39:14,080
为已分配 初始化

832
00:39:14,080 --> 00:39:15,580
inode 我

833
00:39:15,580 --> 00:39:16,960
知道描述每个文件的一小段数据 可能

834
00:39:16,960 --> 00:39:19,720
为文件分配空间

835
00:39:19,720 --> 00:39:21,400
在目录中为我的新文件添加新名称

836
00:39:21,400 --> 00:39:23,440
有很多步骤需要做很多

837
00:39:23,440 --> 00:39:25,510
事情 更新了我们不希望

838
00:39:25,510 --> 00:39:27,820
任何人看到任何中间

839
00:39:27,820 --> 00:39:30,340
步骤我们希望您认识其他

840
00:39:30,340 --> 00:39:32,260
工作站的人看到文件不

841
00:39:32,260 --> 00:39:34,360
存在或完全存在但

842
00:39:34,360 --> 00:39:40,260
不是在一个原子

843
00:39:41,340 --> 00:39:56,860
多步骤操作之间的东西好吧所以

844
00:39:56,860 --> 00:39:58,840
为了实现这一点 为了使

845
00:39:58,840 --> 00:40:01,240
多步骤操作，如文件创建

846
00:40:01,240 --> 00:40:04,030
或重命名或删除原子就

847
00:40:04,030 --> 00:40:05,860
其他工作站而言，

848
00:40:05,860 --> 00:40:08,380
鸡蛋花有一个实现事务的概念，

849
00:40:08,380 --> 00:40:13,930
它是一个完整

850
00:40:13,930 --> 00:40:15,850
的数据库样式事务系统，

851
00:40:15,850 --> 00:40:20,040
在它内部再次由锁驱动，

852
00:40:20,250 --> 00:40:22,830
此外它 是的，这

853
00:40:22,830 --> 00:40:26,220
实际上是分布式事务系统

854
00:40:26,220 --> 00:40:28,720
，我们将

855
00:40:28,720 --> 00:40:31,060
在后面的课程中看到更多关于分布式事务系统的信息

856
00:40:31,060 --> 00:40:31,570
 

857
00:40:31,570 --> 00:40:34,690
就像一个非常常见的需求

858
00:40:34,690 --> 00:40:39,550
和分布式系统，这里的基本故事

859
00:40:39,550 --> 00:40:43,390
是，鸡蛋花使

860
00:40:43,390 --> 00:40:45,790
其他工作站无法看到我的

861
00:40:45,790 --> 00:40:47,800
修改，直到

862
00:40:47,800 --> 00:40:50,350
通过首先获取

863
00:40:50,350 --> 00:40:52,330
我将要处理的所有数据的所有锁完全完成操作

864
00:40:52,330 --> 00:40:54,640
在我的操作过程中需要读取或写入，

865
00:40:54,640 --> 00:40:57,280
并且在完成完整操作之前不释放任何这些

866
00:40:57,280 --> 00:41:00,970
锁

867
00:41:00,970 --> 00:41:02,620
，当然

868
00:41:02,620 --> 00:41:05,470
遵循一致性规则将

869
00:41:05,470 --> 00:41:08,800
所有修改后的数据写回花瓣，

870
00:41:08,800 --> 00:41:10,330
所以在我执行

871
00:41:10,330 --> 00:41:12,340
重命名之类的操作之前，就像移动文件一样 从一个

872
00:41:12,340 --> 00:41:13,900
目录到另一个目录，这毕竟

873
00:41:13,900 --> 00:41:16,000
会修改两个目录，我不

874
00:41:16,000 --> 00:41:18,970
希望任何人看到文件位于

875
00:41:18,970 --> 00:41:20,980
任一目录或

876
00:41:20,980 --> 00:41:22,330
操作中间的某个东西

877
00:41:22,330 --> 00:41:25,420
，以便执行

878
00:41:25,420 --> 00:41:31,960
此操作 锁定

879
00:41:31,960 --> 00:41:39,190
操作，然后做所有的事情，就像

880
00:41:39,190 --> 00:41:47,830
鸡蛋花一样的所有更新，所以我

881
00:41:47,830 --> 00:41:55,900
写到踏板然后释放，

882
00:41:55,900 --> 00:41:57,430
当然这是简单的按钮，你知道

883
00:41:57,430 --> 00:41:59,170
因为我们已经拥有了锁定

884
00:41:59,170 --> 00:42:00,370
服务器，以驱动

885
00:42:00,370 --> 00:42:04,210
我们购买的缓存一致性协议，你

886
00:42:04,210 --> 00:42:05,740
知道确保我们

887
00:42:05,740 --> 00:42:07,870
在整个操作期间持有所有锁，

888
00:42:07,870 --> 00:42:10,510
我们几乎免费获得这些不可分割的原子

889
00:42:10,510 --> 00:42:18,190
事务，所以这是

890
00:42:18,190 --> 00:42:19,330
一件有趣的事情 知道，

891
00:42:19,330 --> 00:42:20,860
这基本上就是关于

892
00:42:20,860 --> 00:42:23,620
使操作成为原子操作和中转

893
00:42:23,620 --> 00:42:26,800
Pandu 持有所有锁的全部

894
00:42:26,800 --> 00:42:28,270
内容 关于这种锁的使用，一个有趣的事情

895
00:42:28,270 --> 00:42:29,950
是便士使用锁的趋势

896
00:42:29,950 --> 00:42:33,600
- 几乎与缓存一致性相反的目的

897
00:42:33,600 --> 00:42:36,430
鸡蛋花使用

898
00:42:36,430 --> 00:42:38,850
锁来确保

899
00:42:38,850 --> 00:42:41,620
任何想要阅读它们的人都可以立即看到写入，

900
00:42:41,620 --> 00:42:43,780
所以这就是使用

901
00:42:43,780 --> 00:42:46,270
锁基本上是为了确保

902
00:42:46,270 --> 00:42:49,420
人们可以看到写入这种使用

903
00:42:49,420 --> 00:42:51,430
块是为了确保人们

904
00:42:51,430 --> 00:42:53,920
在我完成之前看不到写入

905
00:42:53,920 --> 00:42:57,820
有一个操作，因为我持有所有的

906
00:42:57,820 --> 00:42:59,530
锁，直到所有的权利都

907
00:42:59,530 --> 00:43:01,690
完成了，所以他们在这里通过重用 lo 玩了一个

908
00:43:01,690 --> 00:43:04,630
有趣的把戏

909
00:43:04,630 --> 00:43:06,100
cks 他们无论如何都必须

910
00:43:06,100 --> 00:43:09,160
为事务处理以驱动缓存

911
00:43:09,160 --> 00:43:11,700
一致性，

912
00:43:12,590 --> 00:43:14,750
所以下一个有趣的事情

913
00:43:14,750 --> 00:43:24,950
是崩溃恢复，我们需要应对

914
00:43:24,950 --> 00:43:27,050
这种可能性，最有趣的

915
00:43:27,050 --> 00:43:29,270
可能性是工作站

916
00:43:29,270 --> 00:43:33,410
在持有锁和中间时崩溃

917
00:43:33,410 --> 00:43:35,900
在

918
00:43:35,900 --> 00:43:37,250
重新造林的某种复杂更新中

919
00:43:37,250 --> 00:43:39,350
获得了一堆锁，它正在

920
00:43:39,350 --> 00:43:40,820
写入大量数据以创建或

921
00:43:40,820 --> 00:43:42,740
删除文件，或者某些东西可能已将

922
00:43:42,740 --> 00:43:45,380
其中一些修改写

923
00:43:45,380 --> 00:43:48,620
回踏板，因为它可能很快就会

924
00:43:48,620 --> 00:43:50,480
释放锁 或者已经被

925
00:43:50,480 --> 00:43:52,100
锁服务器要求释放锁，所以它

926
00:43:52,100 --> 00:43:54,320
可能已经完成了一些权利，

927
00:43:54,320 --> 00:43:57,590
以便为其复杂的操作返回踏板，但不是

928
00:43:57,590 --> 00:44:00,230
全部，然后在放弃锁之前崩溃，

929
00:44:00,230 --> 00:44:02,380
所以这

930
00:44:02,380 --> 00:44:07,300
是崩溃恢复的有趣情况，

931
00:44:07,300 --> 00:44:09,830
所以有一个

932
00:44:09,830 --> 00:44:11,420
对于工作站崩溃崩溃的许多事情不能很好地工作

933
00:44:11,420 --> 00:44:30,440
我们希望

934
00:44:30,440 --> 00:44:32,990
不能很好地工作的事情就是

935
00:44:32,990 --> 00:44:35,090
obs  erve 工作站崩溃

936
00:44:35,090 --> 00:44:37,870
并释放其所有锁，因为

937
00:44:37,870 --> 00:44:41,060
如果它完成了诸如创建

938
00:44:41,060 --> 00:44:43,570
新文件之类的操作并将文件

939
00:44:43,570 --> 00:44:47,150
目录条目写入其名称返回到踏板，

940
00:44:47,150 --> 00:44:48,860
但它尚未写入

941
00:44:48,860 --> 00:44:51,500
描述

942
00:44:51,500 --> 00:44:53,840
inode 文件的初始化 inode 可能 仍然充满

943
00:44:53,840 --> 00:44:56,450
垃圾或以前的文件

944
00:44:56,450 --> 00:44:58,700
花瓣中的一些以前的文件信息，

945
00:44:58,700 --> 00:45:00,230
但我们已经编写了目录

946
00:45:00,230 --> 00:45:02,270
条目，因此仅

947
00:45:02,270 --> 00:45:05,060
释放崩溃的文件服务器是不可以的 崩溃的释放

948
00:45:05,060 --> 00:45:11,180
是站锁定 另一件

949
00:45:11,180 --> 00:45:13,400
不好的事情是不 释放崩溃的

950
00:45:13,400 --> 00:45:15,350
工作站锁，你知道这

951
00:45:15,350 --> 00:45:17,690
是正确的，因为你知道它是否

952
00:45:17,690 --> 00:45:20,150
在

953
00:45:20,150 --> 00:45:23,210
写出一些修改的过程

954
00:45:23,210 --> 00:45:24,350
中崩溃了事实上它没有写出所有这些修改

955
00:45:24,350 --> 00:45:26,090
意味着不能释放它的锁

956
00:45:26,090 --> 00:45:28,640
所以 简单地不释放它的锁是

957
00:45:28,640 --> 00:45:31,100
正确的，因为它会对

958
00:45:31,100 --> 00:45:33,830
任何读者隐藏这个部分更新，所以

959
00:45:33,830 --> 00:45:35,740
没有人会因为看到

960
00:45:35,740 --> 00:45:38,240
部分更新的数据结构而感到困惑

961
00:45:38,240 --> 00:45:41,210
另一方面，你知道，如果我们根本不放弃它们，那么

962
00:45:41,210 --> 00:45:42,950
任何你需要使用这些文件的

963
00:45:42,950 --> 00:45:44,480
人都必须永远等待锁

964
00:45:44,480 --> 00:45:47,480
，所以我们

965
00:45:47,480 --> 00:45:48,950
绝对必须放弃锁

966
00:45:48,950 --> 00:45:51,500
以便其他工作站可以使用

967
00:45:51,500 --> 00:45:53,210
系统可以使用这些相同的文件和

968
00:45:53,210 --> 00:45:55,700
目录，但我们必须

969
00:45:55,700 --> 00:45:57,590
对工作站

970
00:45:57,590 --> 00:45:59,900
可能已经完成一些权利但

971
00:45:59,900 --> 00:46:05,360
并非全部用于其操作的事实采取一些措施，因此鸡蛋花

972
00:46:05,360 --> 00:46:10,130
几乎与其他所有

973
00:46:10,130 --> 00:46:12,050
需要实施崩溃可恢复

974
00:46:12,050 --> 00:46:16,540
事务的系统用户一样 直接记录

975
00:46:22,600 --> 00:46:25,820
这是我们

976
00:46:25,820 --> 00:46:29,990
在上一堂课中看到的至少一个实例，

977
00:46:29,990 --> 00:46:33,350
我也使用了直接

978
00:46:33,350 --> 00:46:39,950
记录，所以这个想法是，如果

979
00:46:39,950 --> 00:46:41,420
工作站需要执行

980
00:46:41,420 --> 00:46:43,030
涉及

981
00:46:43,030 --> 00:46:46,430
更新许多数据的复杂操作 在文件系统中的花瓣中

982
00:46:46,430 --> 00:46:48,500
，工作站

983
00:46:48,500 --> 00:46:51,020
在它获得任何花瓣权限之前首先要在

984
00:46:51,020 --> 00:46:57,140
他的登录花瓣中附加一个 la log 条目，

985
00:46:57,140 --> 00:47:00,650
描述完整的

986
00:47:00,650 --> 00:47:03,920
操作集 它即将完成，只有

987
00:47:03,920 --> 00:47:07,130
当描述完整

988
00:47:07,130 --> 00:47:09,980
操作集的日志条目安全地在花瓣

989
00:47:09,980 --> 00:47:11,990
中，现在其他任何人都可以看到它

990
00:47:11,990 --> 00:47:15,140
时，工作站才会开始

991
00:47:15,140 --> 00:47:17,090
将操作的权限发送给

992
00:47:17,090 --> 00:47:20,390
花瓣，所以我们如果它 如果站

993
00:47:20,390 --> 00:47:23,240
甚至可以透露

994
00:47:23,240 --> 00:47:26,060
其操作的权利之一花瓣它必须

995
00:47:26,060 --> 00:47:29,390
已经放置了描述整个操作的日志条目

996
00:47:29,390 --> 00:47:32,300
所有更新必须

997
00:47:32,300 --> 00:47:35,390
已经存在于花瓣中所以这是非常

998
00:47:35,390 --> 00:47:37,640
标准的这只是

999
00:47:37,640 --> 00:47:39,630
前面的描述 记录，

1000
00:47:39,630 --> 00:47:43,989
但是

1001
00:47:43,989 --> 00:47:47,829
鸡蛋花如何实现提前

1002
00:47:47,829 --> 00:47:48,309
记录有几个奇怪的方面记录

1003
00:47:48,309 --> 00:47:51,489
第一个是在大多数

1004
00:47:51,489 --> 00:47:54,630
事务系统中只有一个日志

1005
00:47:54,630 --> 00:47:57,549
，系统中的所有事务

1006
00:47:57,549 --> 00:47:59,170
你知道它们都

1007
00:47:59,170 --> 00:48:02,200
在一个地方的一个日志中，所以 有崩溃

1008
00:48:02,200 --> 00:48:05,499
，有歌剧 不止一个

1009
00:48:05,499 --> 00:48:07,390
操作会影响同一条

1010
00:48:07,390 --> 00:48:10,359
数据 我们拥有针对

1011
00:48:10,359 --> 00:48:11,650
该数据的所有这些操作以及

1012
00:48:11,650 --> 00:48:14,650
罪恶中的所有其他内容 gle 日志序列

1013
00:48:14,650 --> 00:48:16,779
，因此我们知道例如哪个是

1014
00:48:16,779 --> 00:48:20,890
给定 David 片段的最新更新，

1015
00:48:20,890 --> 00:48:22,450
但鸡蛋花并没有这样做

1016
00:48:22,450 --> 00:48:28,150
，它将她的工作站日志作为

1017
00:48:28,150 --> 00:48:30,400
每个工作站的一个日志，并且有

1018
00:48:30,400 --> 00:48:34,930
单独的日志另一个非常有趣的

1019
00:48:34,930 --> 00:48:36,940
事情 关于 frangipane 日志记录

1020
00:48:36,940 --> 00:48:39,519
系统的优势在于，在几乎每个使用日志记录的系统中，LA 工作站日志

1021
00:48:39,519 --> 00:48:42,069
都存储在花瓣中，而不是

1022
00:48:42,069 --> 00:48:44,499
 

1023
00:48:44,499 --> 00:48:46,839
 

1024
00:48:46,839 --> 00:48:48,880
 

1025
00:48:48,880 --> 00:48:50,650
 

1026
00:48:50,650 --> 00:48:54,339
本地磁盘上 非常

1027
00:48:54,339 --> 00:48:56,729
好的理由

1028
00:48:56,729 --> 00:48:59,229
赤素馨工作站

1029
00:48:59,229 --> 00:49:01,479
将他们的日志存储在共享存储中的花瓣中

1030
00:49:01,479 --> 00:49:03,460
每个工作站都有

1031
00:49:03,460 --> 00:49:06,009
自己的半私有日志，但它存储

1032
00:49:06,009 --> 00:49:09,549
在花瓣存储中，如果

1033
00:49:09,549 --> 00:49:11,619
工作站崩溃，它的

1034
00:49:11,619 --> 00:49:14,769
日志可以由其他工作站获取，因此

1035
00:49:14,769 --> 00:49:25,450
日志在 花瓣，这

1036
00:49:25,450 --> 00:49:26,940
 

1037
00:49:26,940 --> 00:49:30,039
就像存储在公共共享存储中其他地方的工作站的单独日志，

1038
00:49:30,039 --> 00:49:31,539
所以就像一个非常

1039
00:49:31,539 --> 00:49:34,839
有趣和联合国大学 sual 安排

1040
00:49:34,839 --> 00:49:37,719
好的，所以我们需要大致

1041
00:49:37,719 --> 00:49:41,579
了解法律中的内容 日志条目中的内容

1042
00:49:50,579 --> 00:49:53,469
，不幸的是，文件

1043
00:49:53,469 --> 00:49:56,430
对日志条目的格式并没有特别明确，

1044
00:49:56,430 --> 00:49:58,869
但我们可以想象，

1045
00:49:58,869 --> 00:50:00,640
论文确实说每个工作站都

1046
00:50:00,640 --> 00:50:04,239
记录 位于一个已知的位置

1047
00:50:04,239 --> 00:50:06,729
，花瓣中已知范围的块号，

1048
00:50:06,729 --> 00:50:09,099
此外，每个工作站都使用

1049
00:50:09,099 --> 00:50:11,170
其日志空间和花瓣，以

1050
00:50:11,170 --> 00:50:13,390
一种循环方式，从头到尾都是正确的日志

1051
00:50:13,390 --> 00:50:15,009
条目

1052
00:50:15,009 --> 00:50:18,670
工作站

1053
00:50:18,670 --> 00:50:21,700
将返回并

1054
00:50:21,700 --> 00:50:23,349
在其日志区域的开头重用其日志空间

1055
00:50:23,349 --> 00:50:25,329
，当然这意味着

1056
00:50:25,329 --> 00:50:26,769
工作站需要能够让您知道

1057
00:50:26,769 --> 00:50:30,940
清理他们的日志，以便

1058
00:50:30,940 --> 00:50:32,979
确保在此之前不需要日志条目

1059
00:50:32,979 --> 00:50:35,589
空间被重用了，我会

1060
00:50:35,589 --> 00:50:39,400
稍微讨论一下，但是每个日志都包含

1061
00:50:39,400 --> 00:50:42,719
一系列日志条目 每个日志条目

1062
00:50:42,719 --> 00:50:47,559
都有一个日志序列号 它只是一个

1063
00:50:47,559 --> 00:50:48,999
递增的数字 每个工作站

1064
00:50:48,999 --> 00:50:53,229
编号它的日志条目 1 2 3 4 5

1065
00:50:53,229 --> 00:50:56,319
造成这种情况的直接原因可能是

1066
00:50:56,319 --> 00:50:58,059
该论文

1067
00:50:58,059 --> 00:51:02,170
提到的唯一原因是，如果工作站崩溃，French

1068
00:51:02,170 --> 00:51:04,839
penny 检测工作站日志结束的方式

1069
00:51:04,839 --> 00:51:06,940
 

1070
00:51:06,940 --> 00:51:10,239
是扫描其日志

1071
00:51:10,239 --> 00:51:14,049
花瓣中的单词，直到 它看到增加的

1072
00:51:14,049 --> 00:51:16,630
序列停止增加，然后它

1073
00:51:16,630 --> 00:51:18,130
知道具有最高

1074
00:51:18,130 --> 00:51:20,769
日志序列号的日志条目必须是

1075
00:51:20,769 --> 00:51:23,140
最后一个条目，因为它需要能够

1076
00:51:23,140 --> 00:51:27,519
检测到日志的结尾 ok 所以我们有

1077
00:51:27,519 --> 00:51:29,170
这个日志序列号，然后 我

1078
00:51:29,170 --> 00:51:31,539
相信每个日志实际上都有一个

1079
00:51:31,539 --> 00:51:32,059
 

1080
00:51:32,059 --> 00:51:35,390
模型描述数组

1081
00:51:35,390 --> 00:51:38,059
 

1082
00:51:38,059 --> 00:51:39,859
 

1083
00:51:39,859 --> 00:51:41,930
 

1084
00:51:41,930 --> 00:51:44,059
 

1085
00:51:44,059 --> 00:51:48,410
 

1086
00:51:48,410 --> 00:51:51,170
数组将有一个

1087
00:51:51,170 --> 00:51:53,989
块号它是花瓣中的一个块号

1088
00:51:53,989 --> 00:52:00,920
有一个版本号，

1089
00:52:00,920 --> 00:52:07,900
我们稍后会得到，然后

1090
00:52:07,900 --> 00:52:12,380
是要写入的数据，所以有

1091
00:52:12,380 --> 00:52:18,019
一堆 需要

1092
00:52:18,019 --> 00:52:19,640
描述可能涉及

1093
00:52:19,640 --> 00:52:23,029
文件系统中的多个数据的操作

1094
00:52:23,029 --> 00:52:25,609
需要注意的一点是，日志仅

1095
00:52:25,609 --> 00:52:29,269
包含有关对

1096
00:52:29,269 --> 00:52:32,569
元数据的更改的信息，即对文件系统

1097
00:52:32,569 --> 00:52:37,069
中的目录和 inode 以及分配位图的

1098
00:52:37,069 --> 00:52:38,719
更改，日志没有'  t 实际上

1099
00:52:38,719 --> 00:52:41,479
包含写入

1100
00:52:41,479 --> 00:52:43,400
文件内容的数据它不包含

1101
00:52:43,400 --> 00:52:45,349
用户的数据它只包含

1102
00:52:45,349 --> 00:52:47,809
足够的信息以使文件

1103
00:52:47,809 --> 00:52:51,019
系统结构在崩溃后可恢复

1104
00:52:51,019 --> 00:52:55,309
例如如果我

1105
00:52:55,309 --> 00:52:58,239
在目录中创建一个名为 F 的文件 这将

1106
00:52:58,239 --> 00:53:01,819
产生一个新的日志条目，其中有两个

1107
00:53:01,819 --> 00:53:04,339
关于修改的小描述

1108
00:53:04,339 --> 00:53:06,289
，一个是关于如何

1109
00:53:06,289 --> 00:53:08,809
初始化新文件 inode 的

1110
00:53:08,809 --> 00:53:11,929
描述，另一个是对要

1111
00:53:11,929 --> 00:53:16,299
放置在新文件

1112
00:53:17,140 --> 00:53:21,259
目录中的新名称的描述 '

1113
00:53:21,259 --> 00:53:22,699
当然不这么说，日志实际上

1114
00:53:22,699 --> 00:53:25,689
是这些日志条目的序列，

1115
00:53:28,630 --> 00:53:32,440
最初是为了能够

1116
00:53:32,440 --> 00:53:34,840
尽可能快地进行修改，

1117
00:53:34,840 --> 00:53:37,520
最初是朋友 日本工作站的

1118
00:53:37,520 --> 00:53:40,880
日志只存储在

1119
00:53:40,880 --> 00:53:43,460
工作站自己的内存中，

1120
00:53:43,460 --> 00:53:46,430
直到它必须被写回兜售

1121
00:53:46,430 --> 00:53:49,610
，这样你就知道写

1122
00:53:49,610 --> 00:53:51,590
任何东西，包括日志条目来兜售

1123
00:53:51,590 --> 00:53:53,330
你知道这需要很长时间，所以我们

1124
00:53:53,330 --> 00:53:55,460
要避免 甚至将日志条目写

1125
00:53:55,460 --> 00:53:58,190
回 peddle 以及将脏数据

1126
00:53:58,190 --> 00:54:00,590
或修改的块写回 peddle 我们

1127
00:54:00,590 --> 00:54:02,330
希望尽可能避免这样做，

1128
00:54:02,330 --> 00:54:07,310
因此

1129
00:54:07,310 --> 00:54:13,010
当工作站从锁定服务器收到撤销消息时会发生什么的真实完整故事

1130
00:54:13,010 --> 00:54:15,740
看到

1131
00:54:15,740 --> 00:54:26,110
它必须放弃某个锁定，所以

1132
00:54:28,720 --> 00:54:31,010
现在这是一样的，你知道这

1133
00:54:31,010 --> 00:54:33,020
是一样的，虽然比较了sporto的

1134
00:54:33,020 --> 00:54:36,650
协议撤销消息，如果

1135
00:54:36,650 --> 00:54:39,710
工作站收到撤销消息，

1136
00:54:39,710 --> 00:54:41,960
它必须采取的一系列步骤是首先

1137
00:54:41,960 --> 00:54:47,300
它很好，这是正确的 它的

1138
00:54:47,300 --> 00:54:48,920
部分日志仅在内存中并且

1139
00:54:48,920 --> 00:54:50,750
尚未写入兜售它

1140
00:54:50,750 --> 00:54:52,430
必须确保日志完整并

1141
00:54:52,430 --> 00:54:54,620
作为第一步踩踏板所以它写

1142
00:54:54,620 --> 00:55:09,020
它很长然后才写

1143
00:55:09,020 --> 00:55:16,040
任何

1144
00:55:16,040 --> 00:55:21,340
被撤销的锁所覆盖的更新块，所以写

1145
00:55:21,340 --> 00:55:24,700
修改块

1146
00:55:28,069 --> 00:55:36,579
只是为了那些被激发的锁，然后

1147
00:55:40,420 --> 00:55:48,499
发送一个释放消息，

1148
00:55:48,499 --> 00:55:50,059
这个排序和这个严格

1149
00:55:50,059 --> 00:55:54,380
禁止的原因是，如果我们

1150
00:55:54,380 --> 00:55:55,819
写这些修改来兜售你 知道他们

1151
00:55:55,819 --> 00:55:58,699
对数据结构的修改

1152
00:55:58,699 --> 00:56:00,469
文件系统数据结构，如果

1153
00:56:00,469 --> 00:56:01,910
我们像往常一样在婴儿新闻框中途崩溃

1154
00:56:01,910 --> 00:56:04,940
，我们要

1155
00:56:04,940 --> 00:56:07,609
确保其他一些工作站

1156
00:56:07,609 --> 00:56:09,199
其他人有足够的信息

1157
00:56:09,199 --> 00:56:12,049
来完成

1158
00:56:12,049 --> 00:56:14,900
修改集

1159
00:56:14,900 --> 00:56:16,130
即使工作站已经

1160
00:56:16,130 --> 00:56:17,809
崩溃并且可能没有完成

1161
00:56:17,809 --> 00:56:20,089
这些权限并首先写入日志，但是仍然可以创建工作站，

1162
00:56:20,089 --> 00:56:22,400
这将是我们能够

1163
00:56:22,400 --> 00:56:24,680
完成它的原因 这些日志记录

1164
00:56:24,680 --> 00:56:26,329
是对这些修改将是什么的完整描述

1165
00:56:26,329 --> 00:56:28,099
所以首先

1166
00:56:28,099 --> 00:56:30,769
我们你知道首先我们把

1167
00:56:30,769 --> 00:56:33,549
完整的日志写到花瓣然后我们的

1168
00:56:33,549 --> 00:56:35,719
工作站可以开始写它

1169
00:56:35,719 --> 00:56:37,609
修改过的块你 知道它可能会

1170
00:56:37,609 --> 00:56:39,319
崩溃，可能不会希望不会崩溃，

1171
00:56:39,319 --> 00:56:41,630
如果它以修改块的形式完成写入，

1172
00:56:41,630 --> 00:56:43,069
那么它可以将释放发送

1173
00:56:43,069 --> 00:56:45,259
回锁定服务器，这样你就知道

1174
00:56:45,259 --> 00:56:46,759
我的工作站是否修改了一堆

1175
00:56:46,759 --> 00:56:48,499
文件，然后其他工作站

1176
00:56:48,499 --> 00:56:50,420
想要读取一个 在这些文件中，这是

1177
00:56:50,420 --> 00:56:52,219
发生锁的顺序，所以曾经

1178
00:56:52,219 --> 00:56:54,949
问我要我的锁，我的

1179
00:56:54,949 --> 00:56:56,930
工作站马上说日志，然后

1180
00:56:56,930 --> 00:56:58,369
马上

1181
00:56:58,369 --> 00:57:01,130
写脏的修改块来

1182
00:57:01,130 --> 00:57:03,229
兜售，然后才释放，

1183
00:57:03,229 --> 00:57:04,670
然后另一个工作站可以获取

1184
00:57:04,670 --> 00:57:06,559
锁并读取 这些块，所以这是

1185
00:57:06,559 --> 00:57:09,289
一种非崩溃，如果

1186
00:57:09,289 --> 00:57:13,430
没有发生崩溃，那

1187
00:57:13,430 --> 00:57:17,930
当然是顺序当然

1188
00:57:17,930 --> 00:57:21,400
只有在发生崩溃时才有趣是

1189
00:57:21,980 --> 00:57:28,390
[音乐]

1190
00:57:35,519 --> 00:57:38,079
好的，所以对于日志，你是绝对

1191
00:57:38,079 --> 00:57:42,969
正确的，它会写入整个日志 是的

1192
00:57:42,969 --> 00:57:44,859
，所以如果我们对特定文件进行撤销，

1193
00:57:44,859 --> 00:57:47,680
工作站将

1194
00:57:47,680 --> 00:57:53,319
写入其整个日志，然后

1195
00:57:53,319 --> 00:57:54,999
只是因为它只放弃

1196
00:57:54,999 --> 00:57:59,650
了 Z 的锁定，它只需要写

1197
00:57:59,650 --> 00:58:01,359
回数据 t 帽子被 Z 覆盖了，所以我必须

1198
00:58:01,359 --> 00:58:03,880
只写整个日志，只写

1199
00:58:03,880 --> 00:58:05,289
我们需要放弃的锁所覆盖的数据

1200
00:58:05,289 --> 00:58:07,329
，然后我们可以

1201
00:58:07,329 --> 00:58:10,059
释放那个锁，所以是的，你知道，如果

1202
00:58:10,059 --> 00:58:11,469
这样写整个日志可能会

1203
00:58:11,469 --> 00:58:13,930
像你一样矫枉过正 原来你

1204
00:58:13,930 --> 00:58:15,910
知道所以这是一个优化，你

1205
00:58:15,910 --> 00:58:18,849
可能会或可能不会

1206
00:58:18,849 --> 00:58:21,609
关心配置文件 Z 的最后一次

1207
00:58:21,609 --> 00:58:22,989
修改是否放弃了这个，但

1208
00:58:22,989 --> 00:58:25,509
我日志中的后续条目没有

1209
00:58:25,509 --> 00:58:27,670
修改该文件，那么我可以只写

1210
00:58:27,670 --> 00:58:30,219
我的内存日志的这个前缀

1211
00:58:30,219 --> 00:58:33,459
回到了花瓣，你知道懒得

1212
00:58:33,459 --> 00:58:36,489
写剩下的，

1213
00:58:36,489 --> 00:58:37,029
有时

1214
00:58:37,029 --> 00:58:41,380
我可能会看到我可能不得不写回日志

1215
00:58:41,380 --> 00:58:42,549
实际上并不清楚我会为我们节省很多

1216
00:58:42,549 --> 00:58:43,779
我们必须写的时间 无论如何，日志会在

1217
00:58:43,779 --> 00:58:47,890
某个时候返回，是的，我认为花瓣

1218
00:58:47,890 --> 00:58:53,739
只是写了整个事情，好吧，所以

1219
00:58:53,739 --> 00:58:56,289
现在我们可以讨论

1220
00:58:56,289 --> 00:58:58,539
当工作站在

1221
00:58:58,539 --> 00:59:01,410
正确持有锁的情况下崩溃时会发生什么，你知道需要

1222
00:59:01,410 --> 00:59:03,910
修改一些东西重命名文件创建一个

1223
00:59:03,910 --> 00:59:05,380
文件无论如何 r 它获得了

1224
00:59:05,380 --> 00:59:07,569
它需要的所有锁 它修改了

1225
00:59:07,569 --> 00:59:13,809
它自己的缓存中的一些东西以反映这些

1226
00:59:13,809 --> 00:59:17,380
操作 可能将一些东西写

1227
00:59:17,380 --> 00:59:19,630
回花瓣，然后可能

1228
00:59:19,630 --> 00:59:21,849
在写入的中途使人崩溃，所以有

1229
00:59:21,849 --> 00:59:24,150
很多点它可能会崩溃，

1230
00:59:24,150 --> 00:59:26,709
因为这是 总是

1231
00:59:26,709 --> 00:59:31,779
序列它总是总是在

1232
00:59:31,779 --> 00:59:33,880
从缓存中写回修改的块之前

1233
00:59:33,880 --> 00:59:34,330
 

1234
00:59:34,330 --> 00:59:36,610
，鸡蛋花总是先写

1235
00:59:36,610 --> 00:59:39,370
它记录的踏板，这意味着

1236
00:59:39,370 --> 00:59:41,830
如果发生崩溃，它要么是在

1237
00:59:41,830 --> 00:59:43,690
最糟糕的电台将我们的日志写回

1238
00:59:43,690 --> 00:59:45,610
踏板时，但在它被写入之前

1239
00:59:45,610 --> 00:59:48,100
修改后的文件或目录'阻塞，

1240
00:59:48,100 --> 00:59:51,220
或者它在写回这些修改的块时崩溃，

1241
00:59:51,220 --> 00:59:53,500
但因此

1242
00:59:53,500 --> 00:59:55,720
肯定是在它被写入

1243
00:59:55,720 --> 00:59:57,730
整个日志之后，所以这是一个非常

1244
00:59:57,730 --> 01:00:00,370
重要的你知道但或者

1245
01:00:00,370 --> 01:00:01,660
崩溃发生在它完全

1246
01:00:01,660 --> 01:00:05,530
完成所有这些之后所以你 知道

1247
01:00:05,530 --> 01:00:06,970
只是因为排序的原因，

1248
01:00:06,970 --> 01:00:08,350
 

1249
01:00:08,350 --> 01:00:10,960
我们让我担心的场景数量有限

1250
01:00:10,960 --> 01:00:15,970
他崩溃了，所以工作站

1251
01:00:15,970 --> 01:00:18,370
崩溃了，它崩溃了，你知道，因为喜欢

1252
01:00:18,370 --> 01:00:19,900
令人兴奋，让我们崩溃，而控股

1253
01:00:19,900 --> 01:00:21,670
锁定发生的第一件事，

1254
01:00:21,670 --> 01:00:23,950
锁定服务器向它发送一个撤销请求

1255
01:00:23,950 --> 01:00:26,620
，而锁定服务器没有得到任何响应

1256
01:00:26,620 --> 01:00:27,760
，这就是开始触发

1257
01:00:27,760 --> 01:00:29,560
任何事情的原因 没有人

1258
01:00:29,560 --> 01:00:31,920
要求锁

1259
01:00:32,010 --> 01:00:34,000
基本上没有人会

1260
01:00:34,000 --> 01:00:35,890
注意到工作站崩溃了所以让我们

1261
01:00:35,890 --> 01:00:37,300
假设其他人想要

1262
01:00:37,300 --> 01:00:40,270
工作站

1263
01:00:40,270 --> 01:00:42,550
在崩溃时拥有的锁之一并且锁定服务结束

1264
01:00:42,550 --> 01:00:44,710
撤销并且它永远不会得到

1265
01:00:44,710 --> 01:00:47,260
释放 经过一定时间后的工作站

1266
01:00:47,260 --> 01:00:49,000
，

1267
01:00:49,000 --> 01:00:52,030
事实证明，鸡蛋花锁

1268
01:00:52,030 --> 01:00:53,680
出于多种原因使用租约，因此您知道

1269
01:00:53,680 --> 01:00:56,650
在最短时间到期后，

1270
01:00:56,650 --> 01:00:58,390
锁定服务器将决定

1271
01:00:58,390 --> 01:01:01,000
工作站一定已经崩溃，

1272
01:01:01,000 --> 01:01:02,560
它将启动恢复以及什么 这

1273
01:01:02,560 --> 01:01:04,000
实际上意味着告诉另一个

1274
01:01:04,000 --> 01:01:06,700
工作站锁定服务器将告诉

1275
01:01:06,700 --> 01:01:08,880
其他一些现场工作站看起来

1276
01:01:08,880 --> 01:01:10,720
工作站看起来 要崩溃，

1277
01:01:10,720 --> 01:01:16,330
请阅读它的日志并重播

1278
01:01:16,330 --> 01:01:18,010
它最近的所有操作，以确保

1279
01:01:18,010 --> 01:01:20,620
它们完成并告诉我你什么时候

1280
01:01:20,620 --> 01:01:22,510
完成，然后锁

1281
01:01:22,510 --> 01:01:29,550
服务器才会释放锁，这样就可以了

1282
01:01:29,550 --> 01:01:32,320
，这就是重点 在此情况

1283
01:01:32,320 --> 01:01:34,480
下，日志在踏板中至关重要，

1284
01:01:34,480 --> 01:01:36,490
因为其他一些工作站

1285
01:01:36,490 --> 01:01:39,340
将检查崩溃工作站登录

1286
01:01:39,340 --> 01:01:41,910
踏板

1287
01:01:42,120 --> 01:01:45,680
没事所以有什么可能性

1288
01:01:45,680 --> 01:01:47,700
是在它写回任何东西之前你可能崩溃的最坏的情况，

1289
01:01:47,700 --> 01:01:49,590
 

1290
01:01:49,590 --> 01:01:51,240
所以 意味着这个

1291
01:01:51,240 --> 01:01:53,100
正在恢复的另一个工作站将查看崩溃

1292
01:01:53,100 --> 01:01:55,800
工作站这个日志，看看它可能

1293
01:01:55,800 --> 01:01:57,690
什么都

1294
01:01:57,690 --> 01:02:00,600
没有，什么也不做，然后释放

1295
01:02:00,600 --> 01:02:02,700
工作站现在持有的锁，最糟糕的是你

1296
01:02:02,700 --> 01:02:04,170
可能已经修改

1297
01:02:04,170 --> 01:02:06,390
了缓存中的各种东西 但如果它没有

1298
01:02:06,390 --> 01:02:09,750
向他的日志区域写入任何内容，那么它

1299
01:02:09,750 --> 01:02:11,190
不可能正确写入

1300
01:02:11,190 --> 01:02:12,900
在这些操作期间修改过的任何块，那么我们

1301
01:02:12,900 --> 01:02:16,260
 

1302
01:02:16,260 --> 01:02:19,230
将丢失最后几个操作

1303
01:02:19,230 --> 01:02:22,230
工作站所做的文件

1304
01:02:22,230 --> 01:02:24,900
系统将与

1305
01:02:24,900 --> 01:02:27,600
崩溃的工作站

1306
01:02:27,600 --> 01:02:30,030
开始修改任何内容之前的时间点保持一致，因为

1307
01:02:30,030 --> 01:02:31,290
显然工作站甚至

1308
01:02:31,290 --> 01:02:33,030
从未达到它正在写入

1309
01:02:33,030 --> 01:02:35,670
日志条目的程度 工作站的下一个可能性

1310
01:02:35,670 --> 01:02:38,180
写了一些

1311
01:02:38,180 --> 01:02:40,770
记录日志区域，在这种情况下，

1312
01:02:40,770 --> 01:02:43,170
恢复工作站

1313
01:02:43,170 --> 01:02:45,900
将从日志的开头向前扫描，直到它

1314
01:02:45,900 --> 01:02:48,120
停止看到日志序列号

1315
01:02:48,120 --> 01:02:51,000
增加，这就是日志必须在哪里的点

1316
01:02:51,000 --> 01:02:53,970
Anton 和恢复

1317
01:02:53,970 --> 01:02:56,400
工作站我们将查看其中的每一个

1318
01:02:56,400 --> 01:02:58,830
更改的描述并基本上

1319
01:02:58,830 --> 01:03:02,160
将更改重新播放回花瓣我会

1320
01:03:02,160 --> 01:03:04,230
说哦，您知道有某些块

1321
01:03:04,230 --> 01:03:06,630
编号，并且花瓣需要向其

1322
01:03:06,630 --> 01:03:08,400
写入某些数据，这

1323
01:03:08,400 --> 01:03:10,410
与崩溃的

1324
01:03:10,410 --> 01:03:15,360
工作站在其自己的本地缓存中所做的修改相同

1325
01:03:15,360 --> 01:03:17,100
所以恢复的工作站我们将只

1326
01:03:17,100 --> 01:03:19,800
考虑其中的每一个并重播

1327
01:03:19,800 --> 01:03:24,330
每个崩溃的工作站日志条目

1328
01:03:24,330 --> 01:03:26,910
回到花瓣，当它

1329
01:03:26,910 --> 01:03:28,320
一直到崩溃的

1330
01:03:28,320 --> 01:03:32,430
工作站日志结束时，它存在于花瓣中，

1331
01:03:32,430 --> 01:03:36,420
它会告诉锁服务器，锁

1332
01:03:36,420 --> 01:03:37,800
服务器将释放崩溃的

1333
01:03:37,800 --> 01:03:42,180
工作站锁，这

1334
01:03:42,180 --> 01:03:46,560
将使踏板更新

1335
01:03:46,560 --> 01:03:50,100
崩溃工作站

1336
01:03:50,100 --> 01:03:51,780
在崩溃之前所做的一些操作的前缀可能不是全部

1337
01:03:51,780 --> 01:03:53,070
，因为它可能没有写出

1338
01:03:53,070 --> 01:03:55,560
所有日志，但恢复

1339
01:03:55,560 --> 01:03:56,310
季节

1340
01:03:56,310 --> 01:03:58,440
不会在日志条目中重播任何内容，

1341
01:03:58,440 --> 01:04:01,800
除非它有完整的日志

1342
01:04:01,800 --> 01:04:05,220
花瓣中的条目，所以你隐含地知道这

1343
01:04:05,220 --> 01:04:06,270
意味着会有某种

1344
01:04:06,270 --> 01:04:08,310
校验和安排或其他东西，所以

1345
01:04:08,310 --> 01:04:11,220
恢复工作站会知道啊哈这个

1346
01:04:11,220 --> 01:04:13,110
日志条目是完整的，而不是像

1347
01:04:13,110 --> 01:04:14,970
部分写的那样非常重要，

1348
01:04:14,970 --> 01:04:17,700
因为这样做的全部意义在于

1349
01:04:17,700 --> 01:04:21,030
确保只有完整的操作

1350
01:04:21,030 --> 01:04:24,210
是可见的，并且永远

1351
01:04:24,210 --> 01:04:26,850
不会是部分操作，因此

1352
01:04:26,850 --> 01:04:30,570
 

1353
01:04:30,570 --> 01:04:32,160
将给定操作或组的所有权限放在

1354
01:04:32,160 --> 01:04:34,880
一起也很重要 l  og，以便在恢复时恢复

1355
01:04:34,880 --> 01:04:38,910
工作站可以执行操作的所有权限，

1356
01:04:38,910 --> 01:04:42,720
或者它们中的任何一个都不会执行一半的操作

1357
01:04:42,720 --> 01:04:48,000
，这就是

1358
01:04:48,000 --> 01:04:50,550
如果在将日志写回花瓣时发生崩溃时会发生的情况

1359
01:04:50,550 --> 01:04:55,500
另一个

1360
01:04:55,500 --> 01:04:57,990
有趣的可能性是

1361
01:04:57,990 --> 01:04:59,820
崩溃工作站在写入日志后崩溃

1362
01:04:59,820 --> 01:05:02,160
，并且在将

1363
01:05:02,160 --> 01:05:04,770
一些块写回自身之后崩溃，然后崩溃

1364
01:05:04,770 --> 01:05:08,220
，然后浏览了一些非常

1365
01:05:08,220 --> 01:05:09,840
重要的细节，我稍后会谈到，

1366
01:05:09,840 --> 01:05:11,280
然后会发生什么再次

1367
01:05:11,280 --> 01:05:12,330
是恢复工作站，当然是

1368
01:05:12,330 --> 01:05:13,650
恢复 工作站并不真正知道

1369
01:05:13,650 --> 01:05:14,910
 

1370
01:05:14,910 --> 01:05:19,530
工作站崩溃的点，它所看到的是哦，

1371
01:05:19,530 --> 01:05:21,690
这里有一些日志条目，

1372
01:05:21,690 --> 01:05:23,220
恢复工作站将再次

1373
01:05:23,220 --> 01:05:29,430
以相同的方式重播日志，或多或少发生的

1374
01:05:29,430 --> 01:05:30,690
事情是，即使

1375
01:05:30,690 --> 01:05:32,870
修改 已经在花瓣中完成了

1376
01:05:32,870 --> 01:05:35,400
我们在这里重播相同的修改学生正在播放相同修改

1377
01:05:35,400 --> 01:05:36,690
的恢复

1378
01:05:36,690 --> 01:05:38,280
它只是

1379
01:05:38,280 --> 01:05:40,650
写入相同的数据 再次出现在同一个地方

1380
01:05:40,650 --> 01:05:43,860
，可能并没有真正改变

1381
01:05:43,860 --> 01:05:46,170
已经完成的写入的值，

1382
01:05:46,170 --> 01:05:48,060
但是如果崩溃

1383
01:05:48,060 --> 01:05:49,410
工作站没有完成它的

1384
01:05:49,410 --> 01:05:50,940
一些权利，那么这些权利中的一些

1385
01:05:50,940 --> 01:05:53,400
不确定哪些会真正改变

1386
01:05:53,400 --> 01:06:00,600
数据以完成操作 好吧

1387
01:06:00,600 --> 01:06:03,020
 

1388
01:06:03,740 --> 01:06:06,560
，这实际上并不是

1389
01:06:06,560 --> 01:06:12,230
完整的故事，今天的问题设置了

1390
01:06:12,230 --> 01:06:14,480
一个特定的场景，

1391
01:06:14,480 --> 01:06:22,160
需要增加一点复杂性，

1392
01:06:22,160 --> 01:06:24,349
特别是

1393
01:06:24,349 --> 01:06:27,920
崩溃的工作站在崩溃之前实际上已经

1394
01:06:27,920 --> 01:06:29,569
完成了整个序列的可能性

1395
01:06:29,569 --> 01:06:31,700
，事实上 释放了

1396
01:06:31,700 --> 01:06:37,640
它的一些锁，或者它不是

1397
01:06:37,640 --> 01:06:40,609
最后一个修改特定数据的工作站的人，

1398
01:06:40,609 --> 01:06:42,530
 

1399
01:06:42,530 --> 01:06:44,720
所以如果我们有一些

1400
01:06:44,720 --> 01:06:50,480
工作站并且它执行说删除

1401
01:06:50,480 --> 01:06:57,200
文件它删除文件说会发生这种情况 一个文件 F 和

1402
01:06:57,200 --> 01:07:03,589
目录 D 然后还有一些其他

1403
01:07:03,589 --> 01:07:07,400
工作站，在此删除之后

1404
01:07:07,400 --> 01:07:09,920
创建一个具有相同名称的新文件，

1405
01:07:09,920 --> 01:07:12,490
但当然它是一个差异 erent 文件现在

1406
01:07:12,490 --> 01:07:15,800
所以工作站 1 我很抱歉

1407
01:07:15,800 --> 01:07:22,490
工作站 2 稍后创建相同的

1408
01:07:22,490 --> 01:07:27,140
文件相同的文件名，然后在

1409
01:07:27,140 --> 01:07:32,750
工作站 1 崩溃之后，所以我们

1410
01:07:32,750 --> 01:07:34,190
需要你对工作站

1411
01:07:34,190 --> 01:07:38,990
的日志进行恢复，所以此时

1412
01:07:38,990 --> 01:07:39,710
你 知道也许有第三个

1413
01:07:39,710 --> 01:07:43,420
工作站在进行恢复，

1414
01:07:45,250 --> 01:07:50,050
所以现在工作站 3 正在

1415
01:07:52,180 --> 01:07:56,660
对工作站日志进行恢复，所以序列

1416
01:07:56,660 --> 01:07:58,250
说工作站 1 删除了一个文件或

1417
01:07:58,250 --> 01:08:00,829
工作站 2 创建了一个文件或工作站 3

1418
01:08:00,829 --> 01:08:04,190
很好地恢复了你知道可能

1419
01:08:04,190 --> 01:08:06,829
是这个删除是 仍然在工作站

1420
01:08:06,829 --> 01:08:09,890
的日志中，所以工作站 2 可能您知道，

1421
01:08:09,890 --> 01:08:11,869
或者工作站 1 崩溃，或者

1422
01:08:11,869 --> 01:08:13,069
工作站 3 将查看其日志

1423
01:08:13,069 --> 01:08:14,670
，该日志将重播

1424
01:08:14,670 --> 01:08:19,158
工作站日志中的所有更新，记录

1425
01:08:19,158 --> 01:08:21,779
此删除可能为此删除的更新

1426
01:08:21,779 --> 01:08:23,488
这个删除的条目可能

1427
01:08:23,488 --> 01:08:25,679
仍然在工作站的日志中，所以

1428
01:08:25,679 --> 01:08:27,380
除非我们做一些聪明的事情，否则

1429
01:08:27,380 --> 01:08:29,819
工作站 3 会删除这个

1430
01:08:29,819 --> 01:08:32,729
文件，你知道，因为这个

1431
01:08:32,729 --> 01:08:34,889
操作从 th 中删除了相关条目

1432
01:08:34,889 --> 01:08:35,790
e目录

1433
01:08:35,790 --> 01:08:40,109
因此实际上删除了这个文件

1434
01:08:40,109 --> 01:08:41,908
，这是

1435
01:08:41,908 --> 01:08:44,279
工作站2之后创建的另一个文件，所以

1436
01:08:44,279 --> 01:08:46,920
这是完全错误的，好吧我们

1437
01:08:46,920 --> 01:08:48,750
想让你知道我们为什么想要

1438
01:08:48,750 --> 01:08:50,460
你知道马站删除了一个

1439
01:08:50,460 --> 01:08:52,859
文件，该文件应该被删除但是一个

1440
01:08:52,859 --> 01:08:55,170
新的 如果她的名字不应该被

1441
01:08:55,170 --> 01:08:56,790
删除只是因为它在重新启动时崩溃了

1442
01:08:56,790 --> 01:08:58,859
因为这个创建发生在

1443
01:08:58,859 --> 01:09:01,969
删除之后好吧所以我们不能只是

1444
01:09:01,969 --> 01:09:05,460
重播工作站的日志而不

1445
01:09:05,460 --> 01:09:09,389
进一步考虑因为它可能

1446
01:09:09,389 --> 01:09:11,130
本质上可能是工作站

1447
01:09:11,130 --> 01:09:13,500
日志中的一个日志条目 可能在

1448
01:09:13,500 --> 01:09:16,109
我们在恢复期间播放时已经过时了一些

1449
01:09:16,109 --> 01:09:17,460
其他工作站可能已经修改了

1450
01:09:17,460 --> 01:09:19,109
相同的数据以及随后的其他方式，

1451
01:09:19,109 --> 01:09:22,198
因此我们不能盲目地

1452
01:09:22,198 --> 01:09:26,880
重播日志条目，所以

1453
01:09:26,880 --> 01:09:29,939
这就是今天的问题和方式

1454
01:09:29,939 --> 01:09:32,939
鸡蛋花解决了这个问题，方法是将

1455
01:09:32,939 --> 01:09:36,259
版本号与

1456
01:09:36,259 --> 01:09:39,359
存储在踏板中的文件系统中的每条数据

1457
01:09:39,359 --> 01:09:42,420
相关联，并将相同的版本

1458
01:09:42,420 --> 01:09:45,868
号与 日志中描述的每一个更新，

1459
01:09:45,868 --> 01:09:49,100
所以每一个日志条目，

1460
01:09:49,100 --> 01:09:53,670
当我刚开始的时候，我没有任何

1461
01:09:53,670 --> 01:09:59,429
你知道的东西，我会在

1462
01:09:59,429 --> 01:10:02,429
踏板中说每一个元数据每个

1463
01:10:02,429 --> 01:10:06,659
索引节点每一个数据，

1464
01:10:06,659 --> 01:10:08,400
就像一个内容的内容

1465
01:10:08,400 --> 01:10:12,320
例如，存储和踏板中的每个数据元数据块

1466
01:10:12,320 --> 01:10:14,580
都有一个版本号，

1467
01:10:14,580 --> 01:10:19,290
当工作站需要修改

1468
01:10:19,290 --> 01:10:21,840
踏板中的一条元数据时，它首先将踏板中的元数据

1469
01:10:21,840 --> 01:10:23,670
读取到其

1470
01:10:23,670 --> 01:10:27,449
内存中，然后查看现有

1471
01:10:27,449 --> 01:10:28,219
版本

1472
01:10:28,219 --> 01:10:30,320
，然后当它 创建

1473
01:10:30,320 --> 01:10:32,420
描述其修改的日志文件，它将

1474
01:10:32,420 --> 01:10:36,289
现有版本号加一

1475
01:10:36,289 --> 01:10:41,599
放入日志条目，然后当它进入时，如果它

1476
01:10:41,599 --> 01:10:43,099
确实有机会写回数据，

1477
01:10:43,099 --> 01:10:45,170
它将使用新

1478
01:10:45,170 --> 01:10:48,619
增加的版本号写回数据，所以如果 over

1479
01:10:48,619 --> 01:10:51,499
station 没有崩溃并且它确实崩溃了，或者如果

1480
01:10:51,499 --> 01:10:52,969
它在崩溃之前确实设法写回了一些数据

1481
01:10:52,969 --> 01:10:55,039
，那么版本

1482
01:10:55,039 --> 01:10:56,960
号已存储在花瓣中以用于受

1483
01:10:56,960 --> 01:10:59,929
影响的元数据，它将至少与

1484
01:10:59,929 --> 01:11:02,630
 

1485
01:11:02,630 --> 01:11:04,280
存储在日志条目中的版本号将

1486
01:11:04,280 --> 01:11:05,599
更高一些其他工作站

1487
01:11:05,599 --> 01:11:09,829
随后修改所以

1488
01:11:09,829 --> 01:11:13,699
这里实际发生的是

1489
01:11:13,699 --> 01:11:17,300
工作站 3 我们将看到的

1490
01:11:17,300 --> 01:11:20,690
是工作站的日志条目删除

1491
01:11:20,690 --> 01:11:23,090
操作将存储一个特定的版本

1492
01:11:23,090 --> 01:11:26,030
号 在与目录修改相关联的日志条目中，

1493
01:11:26,030 --> 01:11:28,849
 

1494
01:11:28,849 --> 01:11:31,940
假设日志条目

1495
01:11:31,940 --> 01:11:33,199
会很好地说明目录的版本号，

1496
01:11:33,199 --> 01:11:35,150
并且

1497
01:11:35,150 --> 01:11:37,460
此日志条目创建的新版本号是版本

1498
01:11:37,460 --> 01:11:40,130
号 3，以便工作站

1499
01:11:40,130 --> 01:11:42,170
2 随后更改

1500
01:11:42,170 --> 01:11:45,619
实际上是在工作站崩溃之前添加文件应用程序

1501
01:11:45,619 --> 01:11:47,539
 

1502
01:11:47,539 --> 01:11:49,599
的目录必须放弃目录中的锁定，

1503
01:11:49,599 --> 01:11:52,219
这可能就是为什么日志条目甚至

1504
01:11:52,219 --> 01:11:55,429
存在于踏板中的原因，因此工作站 1

1505
01:11:55,429 --> 01:11:56,630
必须放弃锁定显然

1506
01:11:56,630 --> 01:11:58,940
工作站 2 得到了 锁定并读取

1507
01:11:58,940 --> 01:12:02,179
目录的当前元数据，

1508
01:12:02,179 --> 01:12:04,489
发现版本号现在是 3

1509
01:12:04,489 --> 01:12:08,269
，当工作站 2 写入时

1510
01:12:08,269 --> 01:12:14,360
data 它会将 peddle 中的版本号

1511
01:12:14,360 --> 01:12:19,940
或目录设置为 4

1512
01:12:19,940 --> 01:12:22,749
ok，这意味着

1513
01:12:22,749 --> 01:12:24,739
 

1514
01:12:24,739 --> 01:12:28,789
当

1515
01:12:28,789 --> 01:12:31,190
最差代理 3 上的恢复软件

1516
01:12:31,190 --> 01:12:34,849
重播工作站的日志时，此删除操作的日志条目现在将包含版本号 3

1517
01:12:34,849 --> 01:12:36,469
首先查看版本号，因此它会

1518
01:12:36,469 --> 01:12:37,909
查看版本号日志条目

1519
01:12:37,909 --> 01:12:40,929
它将读取块从

1520
01:12:40,929 --> 01:12:42,369
查看块中的版本号

1521
01:12:42,369 --> 01:12:44,579
以及踏板中块中的版本号

1522
01:12:44,579 --> 01:12:47,439
是否大于或等于

1523
01:12:47,439 --> 01:12:50,110
日志条目中的版本号

1524
01:12:50,110 --> 01:12:51,610
恢复软件将简单地忽略

1525
01:12:51,610 --> 01:12:54,340
日志条目中的更新并且不这样做

1526
01:12:54,340 --> 01:12:57,729
，因为显然该块已经

1527
01:12:57,729 --> 01:12:59,139
被崩溃工作站写回

1528
01:12:59,139 --> 01:13:01,449
，然后可能随后

1529
01:13:01,449 --> 01:13:05,409
被其他工作站修改，因此

1530
01:13:05,409 --> 01:13:06,999
重放实际上是基于选择性的 在

1531
01:13:06,999 --> 01:13:08,829
这个版本号上重播它是一个

1532
01:13:08,829 --> 01:13:14,369
恢复只写只有

1533
01:13:14,369 --> 01:13:17,170
重播在日志中是正确的，如果该

1534
01:13:17,170 --> 01:13:20,499
权利实际上是新的，那么在日志

1535
01:13:20,499 --> 01:13:22,599
条目中的权利比已经s的数据新

1536
01:13:22,599 --> 01:13:31,539
在兜售中被撕毁，所以

1537
01:13:31,539 --> 01:13:34,650
这里有一个令人恼火的问题，可能是

1538
01:13:34,650 --> 01:13:37,150
工作站 3 正在运行此

1539
01:13:37,150 --> 01:13:39,280
恢复软件，而其他

1540
01:13:39,280 --> 01:13:41,050
工作站仍在

1541
01:13:41,050 --> 01:13:42,729
积极地在文件系统中读写，并且

1542
01:13:42,729 --> 01:13:46,229
有锁并且知道要兜售什么，

1543
01:13:46,229 --> 01:13:50,800
所以当我们进行重播时，它会继续进行 '

1544
01:13:50,800 --> 01:13:52,030
 

1545
01:13:52,030 --> 01:13:54,670
是对恢复一无所知的工作站仍然处于活动状态

1546
01:13:54,670 --> 01:13:57,429
，实际上工作站二可能

1547
01:13:57,429 --> 01:14:00,849
 

1548
01:14:00,849 --> 01:14:03,760
在恢复进行时锁定此目录，因此恢复

1549
01:14:03,760 --> 01:14:05,769
可能正在扫描日志，您

1550
01:14:05,769 --> 01:14:08,409
无需读取或写入此目录

1551
01:14:08,409 --> 01:14:11,650
数据 踏板，而工作站 2

1552
01:14:11,650 --> 01:14:14,499
仍然锁定此数据，问题是

1553
01:14:14,499 --> 01:14:16,179
您如何知道我们如何解决这个问题，

1554
01:14:16,179 --> 01:14:19,510
就像实际上

1555
01:14:19,510 --> 01:14:22,150
结果不起作用的一种可能性是

1556
01:14:22,150 --> 01:14:24,760
恢复软件首先

1557
01:14:24,760 --> 01:14:28,749
获取它需要查看的任何内容的锁定

1558
01:14:28,749 --> 01:14:30,969
在重放日志之前在花瓣中

1559
01:14:30,969 --> 01:14:36,189
，您知道

1560
01:14:36,189 --> 01:14:38,229
这不起作用的一个很好的原因是，它

1561
01:14:38,229 --> 01:14:39,639
可能是我们在

1562
01:14:39,639 --> 01:14:41,800
系统之后运行恢复 tem-wide power failure

1563
01:14:41,800 --> 01:14:43,570
例如，所有关于谁

1564
01:14:43,570 --> 01:14:46,689
拥有什么锁的知识都丢失了，因此我们

1565
01:14:46,689 --> 01:14:49,469
无法编写恢复软件来

1566
01:14:49,469 --> 01:14:52,840
参与锁定

1567
01:14:52,840 --> 01:14:54,199
协议，因为

1568
01:14:54,199 --> 01:14:56,030
您知道所有关于什么被锁定的知识

1569
01:14:56,030 --> 01:14:57,769
我的插槽未锁定可能已经丢失

1570
01:14:57,769 --> 01:14:58,459
在电源故障中

1571
01:14:58,459 --> 01:15:01,940
嗯，但幸运的是，

1572
01:15:01,940 --> 01:15:03,619
恢复软件可以继续

1573
01:15:03,619 --> 01:15:07,280
在踏板中读取或写入块，而不必担心在踏板中

1574
01:15:07,280 --> 01:15:09,559
读取或写入数据

1575
01:15:09,559 --> 01:15:11,360
而完全不用担心

1576
01:15:11,360 --> 01:15:15,260
锁定，原因是如果

1577
01:15:15,260 --> 01:15:16,639
恢复软件 您知道恢复

1578
01:15:16,639 --> 01:15:18,110
软件想要重播此日志条目

1579
01:15:18,110 --> 01:15:20,510
并可能修改

1580
01:15:20,510 --> 01:15:22,039
与此目录关联的数据，它只是继续

1581
01:15:22,039 --> 01:15:23,539
并立即

1582
01:15:23,539 --> 01:15:26,630
从踏板中读取目录

1583
01:15:26,630 --> 01:15:28,969
中的任何内容，实际上只有两种情况，即

1584
01:15:28,969 --> 01:15:30,650
崩溃工作站一个已经放弃 它的

1585
01:15:30,650 --> 01:15:33,860
锁或者它没有如果它没有放弃

1586
01:15:33,860 --> 01:15:35,150
这个锁那么没有其他人可以

1587
01:15:35,150 --> 01:15:36,590
锁定一个目录，所以

1588
01:15:36,590 --> 01:15:39,909
如果它放弃了就没有问题 它的锁，然后

1589
01:15:39,909 --> 01:15:42,559
在我放弃它的锁之前，它

1590
01:15:42,559 --> 01:15:46,699
必须写下它的

1591
01:15:46,699 --> 01:15:50,030
目录数据返回到踏板，这

1592
01:15:50,030 --> 01:15:52,219
意味着存储在踏板中的版本号

1593
01:15:52,219 --> 01:15:53,929
必须至少

1594
01:15:53,929 --> 01:15:56,150
与崩溃的工作站日志条目中的版本号一样高，

1595
01:15:56,150 --> 01:15:58,459
并且 因此，当恢复

1596
01:15:58,459 --> 01:16:00,769
软件将日志条目

1597
01:16:00,769 --> 01:16:02,599
版本号与

1598
01:16:02,599 --> 01:16:04,820
数据和踏板的版本号进行比较时，它会看到日志

1599
01:16:04,820 --> 01:16:07,510
条目版本号没有更高，

1600
01:16:07,510 --> 01:16:11,479
因此我们不会播放日志条目，所以

1601
01:16:11,479 --> 01:16:13,400
是的，恢复软件会

1602
01:16:13,400 --> 01:16:15,139
读取 没有持有锁的块，

1603
01:16:15,139 --> 01:16:18,079
但它不会修改它，因为

1604
01:16:18,079 --> 01:16:19,489
如果锁定被释放，版本

1605
01:16:19,489 --> 01:16:21,650
号将足够高，以

1606
01:16:21,650 --> 01:16:26,510
表明日志条目

1607
01:16:26,510 --> 01:16:28,519
在崩溃的工作站崩溃之前已经进行了某种处理，

1608
01:16:28,519 --> 01:16:31,459
所以没有

1609
01:16:31,459 --> 01:16:41,809
锁定 问题好吧，这就是我已经讨论

1610
01:16:41,809 --> 01:16:43,849
过的那种主要胆量是什么

1611
01:16:43,849 --> 01:16:46,400
踏板取决于Nam它是缓存一致性

1612
01:16:46,400 --> 01:16:49,070
它是分布式事务它是

1613
01:16:49,070 --> 01:16:53,840
分布式崩溃恢复th 其他

1614
01:16:53,840 --> 01:16:55,550
要考虑的事情是论文

1615
01:16:55,550 --> 01:16:57,139
谈到了一些关于性能的内容，

1616
01:16:57,139 --> 01:17:00,949
实际上在 20 多年后

1617
01:17:00,949 --> 01:17:02,900
很难解释性能数据，

1618
01:17:02,900 --> 01:17:04,909
因为他们在非常不同的硬件上标记了他们的性能数据，

1619
01:17:04,909 --> 01:17:06,889
在一个非常

1620
01:17:06,889 --> 01:17:08,150
不同的环境中与

1621
01:17:08,150 --> 01:17:11,179
你今天看到的大致不同的

1622
01:17:11,179 --> 01:17:12,949
性能 他们显示的数字，或者随着

1623
01:17:12,949 --> 01:17:15,140
您添加越来越多的友谊和

1624
01:17:15,140 --> 01:17:19,310
工作站，系统基本上

1625
01:17:19,310 --> 01:17:22,219
不会变慢这是每个新

1626
01:17:22,219 --> 01:17:24,500
工作站，即使它正在积极进行

1627
01:17:24,500 --> 01:17:26,449
文件系统操作也不会

1628
01:17:26,449 --> 01:17:28,429
减慢现有工作站的速度，所以从这个

1629
01:17:28,429 --> 01:17:30,320
意义上说，系统 你知道至少

1630
01:17:30,320 --> 01:17:32,600
对于应用程序状态来说看看

1631
01:17:32,600 --> 01:17:34,730
系统给了他们合理的可扩展性

1632
01:17:34,730 --> 01:17:36,860
他们可以添加更多的工作站而不会

1633
01:17:36,860 --> 01:17:42,679
减慢现有用户的速度

1634
01:17:42,679 --> 01:17:44,890
 

1635
01:17:44,890 --> 01:17:47,600
虽然素馨花充满了非常

1636
01:17:47,600 --> 01:17:49,130
有趣的技术值得

1637
01:17:49,130 --> 01:17:51,650
记住它并没有太大的

1638
01:17:51,650 --> 01:17:55,909
影响 在关于存储系统如何演变的

1639
01:17:55,909 --> 01:17:58,550
部分原因

1640
01:17:58,550 --> 01:18:00,560
是 目标

1641
01:18:00,560 --> 01:18:02,000
环境是小型工作组

1642
01:18:02,000 --> 01:18:04,040
人们坐在办公桌前的工作站前

1643
01:18:04,040 --> 01:18:06,860
并共享文件

1644
01:18:06,860 --> 01:18:09,620
环境良好 它仍然存在于某些

1645
01:18:09,620 --> 01:18:12,140
地方 并不是真正的行动

1646
01:18:12,140 --> 01:18:13,730
在分布式存储中 行动

1647
01:18:13,730 --> 01:18:15,230
真正的行动被转移到排序中 大

1648
01:18:15,230 --> 01:18:19,400
数据中心或大网站的大数据

1649
01:18:19,400 --> 01:18:22,250
计算，你知道在那个世界中，

1650
01:18:22,250 --> 01:18:24,380
首先文件系统

1651
01:18:24,380 --> 01:18:25,909
接口

1652
01:18:25,909 --> 01:18:28,850
与数据库相比并不是很有用，比如人们真的很

1653
01:18:28,850 --> 01:18:31,190
喜欢大网站世界中的交易，

1654
01:18:31,190 --> 01:18:33,620
但他们需要它们来做很小的事情

1655
01:18:33,620 --> 01:18:35,360
数据项 您

1656
01:18:35,360 --> 01:18:39,080
将存储在数据库中

1657
01:18:39,080 --> 01:18:40,340
的数据类型，而不是您

1658
01:18:40,340 --> 01:18:44,929
自然会存储在文件系统中的数据类型，因此您

1659
01:18:44,929 --> 01:18:47,270
知道其中一些技术可能在

1660
01:18:47,270 --> 01:18:49,370
某种程度上您可以在现代系统中看到它的回声，

1661
01:18:49,370 --> 01:18:50,929
但是 它通常采用

1662
01:18:50,929 --> 01:18:53,030
某种数据库的形式，另一种大

1663
01:18:53,030 --> 01:18:56,030
存储类型是

1664
01:18:56,030 --> 01:18:59,030
根据需要存储大文件，用于

1665
01:18:59,030 --> 01:19:01,730
MapReduce 和 GFS 等大数据计算

1666
01:19:01,730 --> 01:19:04,969
是一个你知道的在某种程度上看起来

1667
01:19:04,969 --> 01:19:06,650
像一个文件系统，是

1668
01:19:06,650 --> 01:19:08,800
你想要的 MapReduce 存储系统，

1669
01:19:08,800 --> 01:19:12,530
但对于 GFS 和大数据

1670
01:19:12,530 --> 01:19:15,710
计算 frangipane easy 你知道

1671
01:19:15,710 --> 01:19:19,040
专注于本地缓存和工作站

1672
01:19:19,040 --> 01:19:22,010
，非常关注

1673
01:19:22,010 --> 01:19:24,410
缓存一致性和锁定

1674
01:19:24,410 --> 01:19:27,170
你知道它对

1675
01:19:27,170 --> 01:19:29,890
数据的读取和写入

1676
01:19:29,890 --> 01:19:33,530
都不是很有用

1677
01:19:33,530 --> 01:19:35,990
如果你正在读取 10

1678
01:19:35,990 --> 01:19:38,450
TB 的数据，

1679
01:19:38,450 --> 01:19:41,090
缓存通常是没有用

1680
01:19:41,090 --> 01:19:45,470
 

1681
01:19:45,470 --> 01:19:47,060
的 时间稍纵即逝，它

1682
01:19:47,060 --> 01:19:50,230
在某些情况下仍然有用，但这

1683
01:19:50,230 --> 01:19:52,370
并不是

1684
01:19:52,370 --> 01:19:56,390
人们在设计新系统时真正考虑的

1685
01:19:56,390 --> 01:19:59,500
问题，就是这样

