1
00:00:00,060 --> 00:00:02,370
我想谈谈农场日

2
00:00:02,370 --> 00:00:06,150
和乐观并发控制，这

3
00:00:06,150 --> 00:00:07,710
是

4
00:00:07,710 --> 00:00:10,860
使用我们谈论农场的原因的主要有趣技术

5
00:00:10,860 --> 00:00:14,460
这是

6
00:00:14,460 --> 00:00:16,350
关于事务、复制和

7
00:00:16,350 --> 00:00:19,410
分片系列的最后一篇论文，这仍然是 开放的

8
00:00:19,410 --> 00:00:21,720
研究领域，人们

9
00:00:21,720 --> 00:00:25,800
对性能或可用

10
00:00:25,800 --> 00:00:30,359
的性能与一致性

11
00:00:30,359 --> 00:00:31,470
权衡完全不满意，

12
00:00:31,470 --> 00:00:32,668
他们仍在努力做得更好

13
00:00:32,668 --> 00:00:34,800
，特别是这篇论文

14
00:00:34,800 --> 00:00:36,780
的动机是这些新的巨大性能

15
00:00:36,780 --> 00:00:41,570
潜力 RDMA NIC，

16
00:00:41,570 --> 00:00:43,800
因此您可能想知道，因为我们刚刚

17
00:00:43,800 --> 00:00:44,760
阅读了有关 spanner 的内容

18
00:00:44,760 --> 00:00:48,000
，它们在所有复制之后农场与某些 spanner 有何不同，

19
00:00:48,000 --> 00:00:49,379
并且它们使用

20
00:00:49,379 --> 00:00:51,660
两阶段提交来处理

21
00:00:51,660 --> 00:00:54,020
该级别的事务，它们看起来非常相似，

22
00:00:54,020 --> 00:00:56,850
因为 a 是已部署的系统已

23
00:00:56,850 --> 00:01:00,059
使用 a 很长一段时间以来，它的主要

24
00:01:00,059 --> 00:01:02,640
重点是地理复制，

25
00:01:02,640 --> 00:01:04,559
即能够

26
00:01:04,559 --> 00:01:06,930
在东海岸和西海岸以及不同的地区

27
00:01:06,930 --> 00:01:09,000
复制 ta 中心，并且能够进行

28
00:01:09,000 --> 00:01:11,189
相当有效的事务，这些事务

29
00:01:11,189 --> 00:01:13,799
涉及许多不同地方的数据片段，

30
00:01:13,799 --> 00:01:16,590
以及关于它的最具创新性的

31
00:01:16,590 --> 00:01:18,810
事情，因为为了

32
00:01:18,810 --> 00:01:20,640
尝试解决长距离

33
00:01:20,640 --> 00:01:22,950
执行两阶段提交需要多长时间的问题

34
00:01:22,950 --> 00:01:26,119
是它有一个使用同步时间

35
00:01:26,119 --> 00:01:27,780
的只读事务的特殊优化路径，

36
00:01:27,780 --> 00:01:32,189
 

37
00:01:32,189 --> 00:01:34,520
 

38
00:01:34,520 --> 00:01:36,680
如果你记得的话，你从 spanner 中获得的性能是读/写

39
00:01:36,680 --> 00:01:40,380
事务需要 10 到 100 毫秒，

40
00:01:40,380 --> 00:01:42,509
具体取决于

41
00:01:42,509 --> 00:01:46,170
不同数据中心的距离有多近。 做出

42
00:01:46,170 --> 00:01:49,079
一套非常不同的设计决策

43
00:01:49,079 --> 00:01:50,790
并针对不同类型的工作负载

44
00:01:50,790 --> 00:01:52,710
首先它是一个研究原型，

45
00:01:52,710 --> 00:01:54,540
所以它绝不是

46
00:01:54,540 --> 00:01:57,390
成品，目标是探索

47
00:01:57,390 --> 00:02:00,509
这些新的 RDMA 高速

48
00:02:00,509 --> 00:02:04,259
网络硬件的潜力，所以它真的 仍然

49
00:02:04,259 --> 00:02:08,128
是一个探索性系统，它假设

50
00:02:08,128 --> 00:02:09,619
所有副本都在同一个数据中心，

51
00:02:09,619 --> 00:02:11,340
绝对没有

52
00:02:11,340 --> 00:02:11,880
 

53
00:02:11,880 --> 00:02:13,830
意义 n 即使在不同的

54
00:02:13,830 --> 00:02:15,600
数据中心，更不用说在东海岸

55
00:02:15,600 --> 00:02:18,360
和西海岸，所以它不是试图

56
00:02:18,360 --> 00:02:20,640
解决一个问题，扳手是

57
00:02:20,640 --> 00:02:22,020
关于如果整个数据中心

58
00:02:22,020 --> 00:02:23,790
出现故障会发生什么我可以拿出我的数据

59
00:02:23,790 --> 00:02:25,920
真的这就是它所拥有的程度

60
00:02:25,920 --> 00:02:27,540
容错适用于个别

61
00:02:27,540 --> 00:02:30,900
崩溃，或者可能在

62
00:02:30,900 --> 00:02:33,720
整个数据中心断电并

63
00:02:33,720 --> 00:02:37,560
再次恢复

64
00:02:37,560 --> 00:02:39,210
 

65
00:02:39,210 --> 00:02:41,040
 

66
00:02:41,040 --> 00:02:43,650
 

67
00:02:43,650 --> 00:02:46,740
后尝试恢复 另一方面，被迫使用乐观

68
00:02:46,740 --> 00:02:49,980
并发控制，

69
00:02:49,980 --> 00:02:52,590
他们获得的性能远远

70
00:02:52,590 --> 00:02:56,300
高于 spanner farm 可以

71
00:02:56,300 --> 00:02:58,770
在 58 微秒内完成一个简单事务的传输

72
00:02:58,770 --> 00:03:00,900
，这是来自图 7

73
00:03:00,900 --> 00:03:03,750
和第 6.3 节，所以这是 58

74
00:03:03,750 --> 00:03:06,780
微秒而不是 10

75
00:03:06,780 --> 00:03:10,170
毫秒 扳手需要的是它

76
00:03:10,170 --> 00:03:12,960
比扳手快大约一百倍，所以

77
00:03:12,960 --> 00:03:15,900
这可能是主要的巨大差异

78
00:03:15,900 --> 00:03:17,730
让我们获得更高的性能

79
00:03:17,730 --> 00:03:21,390
但不是针对 在地理

80
00:03:21,390 --> 00:03:26,640
复制中，因此您知道农场的

81
00:03:26,640 --> 00:03:28,830
性能非常令人印象深刻，例如

82
00:03:28,830 --> 00:03:31,790
比其他任何东西都快多少

83
00:03:31,790 --> 00:03:33,720
另一种看待它的方式是

84
00:03:33,720 --> 00:03:35,370
扳手和农场针对不同的

85
00:03:35,370 --> 00:03:37,470
瓶颈和跨度是

86
00:03:37,470 --> 00:03:39,150
人们担心的主要瓶颈

87
00:03:39,150 --> 00:03:41,430
是光速和网络 数据中心

88
00:03:41,430 --> 00:03:42,900
之间的光速延迟和网络离开，

89
00:03:42,900 --> 00:03:46,560
而在农场

90
00:03:46,560 --> 00:03:50,130
中，设计担心的主要瓶颈

91
00:03:50,130 --> 00:03:52,560
是服务器上的 CPU 时间，

92
00:03:52,560 --> 00:03:54,209
因为他们有点希望

93
00:03:54,209 --> 00:03:55,620
通过

94
00:03:55,620 --> 00:03:57,180
将所有副本放在同一个副本中来消除光速和网络延迟

95
00:03:57,180 --> 00:04:01,070
数据中心

96
00:04:01,220 --> 00:04:03,540
好吧，这是如何

97
00:04:03,540 --> 00:04:08,459
适应 684 序列的背景 设置和

98
00:04:08,459 --> 00:04:10,080
场是你让它全部

99
00:04:10,080 --> 00:04:15,860
在一个数据中心运行 有一种

100
00:04:16,040 --> 00:04:18,779
我们以前

101
00:04:18,779 --> 00:04:21,120
见过的配置

102
00:04:21,120 --> 00:04:24,210
管理器和负责的配置管理器 在每个数据分片之前决定哪些

103
00:04:24,210 --> 00:04:25,110
 

104
00:04:25,110 --> 00:04:26,879
服务器应该是备份中的主要服务器

105
00:04:26,879 --> 00:04:30,479
，如果

106
00:04:30,479 --> 00:04:31,560
您仔细阅读，您会看到 他们

107
00:04:31,560 --> 00:04:37,110
使用 zookeeper 来帮助他们

108
00:04:37,110 --> 00:04:38,520
实现这个配置管理器，

109
00:04:38,520 --> 00:04:40,139
但这根本不是本文的重点，

110
00:04:40,139 --> 00:04:40,409
 

111
00:04:40,409 --> 00:04:42,539
有趣的

112
00:04:42,539 --> 00:04:44,669
是数据被分片

113
00:04:44,669 --> 00:04:47,490
在一堆主要的备用付款人之间，

114
00:04:47,490 --> 00:04:50,129
所以我的意思是一个分片 继续，您知道

115
00:04:50,129 --> 00:04:52,919
主要的一台服务器主要的一台备份

116
00:04:52,919 --> 00:04:55,919
另一台短的一台主要备份

117
00:04:55,919 --> 00:04:59,879
两个等等，这意味着

118
00:04:59,879 --> 00:05:01,740
每当您更新数据时，您都需要

119
00:05:01,740 --> 00:05:03,870
在主要和备份上更新它，

120
00:05:03,870 --> 00:05:06,659
而这些不是这些

121
00:05:06,659 --> 00:05:08,250
主要副本这些副本 不由

122
00:05:08,250 --> 00:05:11,759
PAC 或类似的东西维护，而是在发生更改

123
00:05:11,759 --> 00:05:14,969
时更新数据的所有副本

124
00:05:14,969 --> 00:05:16,830
，如果您

125
00:05:16,830 --> 00:05:18,180
阅读，您总是必须从

126
00:05:18,180 --> 00:05:21,120
主要读取，这种复制的原因

127
00:05:21,120 --> 00:05:24,210
当然是容错

128
00:05:24,210 --> 00:05:26,159
和容错类型 他们得到的是，

129
00:05:26,159 --> 00:05:29,039
只要给定分片的一个

130
00:05:29,039 --> 00:05:31,529
副本可用，那么该分片将

131
00:05:31,529 --> 00:05:33,409
可用，因此他们只需要一个

132
00:05:33,409 --> 00:05:37,620
活的副本而不是多数，

133
00:05:37,620 --> 00:05:39,900
系统 tem 作为一个整体，如果说数据

134
00:05:39,900 --> 00:05:42,089
中心白色电源故障

135
00:05:42,089 --> 00:05:43,889
，只要系统中每个分片至少有一个

136
00:05:43,889 --> 00:05:47,089
副本，它就可以恢复

137
00:05:47,089 --> 00:05:49,560
另一种说法，如果

138
00:05:49,560 --> 00:05:52,199
你有 F 加上一个副本，那么他们

139
00:05:52,199 --> 00:05:54,330
最多可以容忍 F 该分片的故障

140
00:05:54,330 --> 00:05:58,229
除了每种数据的主备份

141
00:05:58,229 --> 00:06:00,860
副本之外，还有

142
00:06:00,860 --> 00:06:04,770
运行事务代码

143
00:06:04,770 --> 00:06:06,479
将

144
00:06:06,479 --> 00:06:07,949
事务代码作为单独的

145
00:06:07,949 --> 00:06:11,789
客户端运行可能是最方便的，

146
00:06:11,789 --> 00:06:13,379
实际上他们在相同的实验中运行事务代码

147
00:06:13,379 --> 00:06:16,560
机器作为实际的农场存储

148
00:06:16,560 --> 00:06:21,180
服务器，但我主要将它们

149
00:06:21,180 --> 00:06:24,270
视为一组单独的客户端，

150
00:06:24,270 --> 00:06:27,120
并且客户端正在运行事务，

151
00:06:27,120 --> 00:06:29,960
并且事务需要读取和写入

152
00:06:29,960 --> 00:06:34,120
存储在分片服务器中的数据对象

153
00:06:34,120 --> 00:06:38,020
此外 这些

154
00:06:38,020 --> 00:06:40,150
事务 这些客户端 每个客户端

155
00:06:40,150 --> 00:06:42,849
不仅运行事务，而且还

156
00:06:42,849 --> 00:06:45,879
充当两阶段提交的事务协调器

157
00:06:45,879 --> 00:06:48,330
 

158
00:06:48,330 --> 00:06:52,059
好的，所以这是基本设置

159
00:06:52,059 --> 00:06:53,589
他们获得性能的方式，因为这真的

160
00:06:53,589 --> 00:06:55,419
是一篇关于如何

161
00:06:55,419 --> 00:06:57,669
获得高性能并且仍然有

162
00:06:57,669 --> 00:06:59,919
事务的论文，他们

163
00:06:59,919 --> 00:07:04,150
通过分片获得高性能的方式从

164
00:07:04,150 --> 00:07:09,189
某种意义上说，主要方式是

165
00:07:09,189 --> 00:07:12,219
通过分片实验他们对数据进行分片

166
00:07:12,219 --> 00:07:14,379
90 台服务器的 90 多种方式，

167
00:07:14,379 --> 00:07:17,050
或者可能是 45 种方式，而

168
00:07:17,050 --> 00:07:19,659
不仅仅是只要操作和

169
00:07:19,659 --> 00:07:21,279
不同的分片或多或少

170
00:07:21,279 --> 00:07:23,439
相互独立，这只

171
00:07:23,439 --> 00:07:25,899
会让你自动加速 90 倍，

172
00:07:25,899 --> 00:07:27,520
因为你可以运行任何

173
00:07:27,520 --> 00:07:30,699
你想要的东西 重新在 90 个糖浆上并行运行，

174
00:07:30,699 --> 00:07:34,199
这个巨大的来自更短的分片

175
00:07:34,199 --> 00:07:36,520
他们为了获得良好的性能而玩的另一个技巧，

176
00:07:36,520 --> 00:07:38,169
因为数据都必须

177
00:07:38,169 --> 00:07:41,919
适合服务器的 RAM，他们并没有

178
00:07:41,919 --> 00:07:44,349
真正将数据存储在

179
00:07:44,349 --> 00:07:46,089
磁盘上 安装在 RAM 中，这

180
00:07:46,089 --> 00:07:46,930
当然意味着你可以很快摆脱

181
00:07:46,930 --> 00:07:50,620
他们获得高性能的另一种方式

182
00:07:50,620 --> 00:07:53,289
是他们需要容忍

183
00:07:53,289 --> 00:07:56,199
电源故障，这意味着他们

184
00:07:56,199 --> 00:07:57,789
不能只使用 RAM b 因为他们

185
00:07:57,789 --> 00:07:59,499
需要在断电后恢复数据，

186
00:07:59,499 --> 00:08:02,110
而 RAM 在断电时会丢失内容，

187
00:08:02,110 --> 00:08:04,589
因此他们有一个聪明

188
00:08:04,589 --> 00:08:09,189
的非易失性 Ram 方案，可以让

189
00:08:09,189 --> 00:08:11,020
RAM 的内容在断电后幸存下来，

190
00:08:11,020 --> 00:08:14,020
这与

191
00:08:14,020 --> 00:08:16,360
将数据持久存储在 我的磁盘

192
00:08:16,360 --> 00:08:20,080
比磁盘快得多，

193
00:08:20,080 --> 00:08:22,180
他们玩的另一个技巧是他们使用这种 RDMA

194
00:08:22,180 --> 00:08:25,300
技术，这种技术本质上是聪明的

195
00:08:25,300 --> 00:08:31,289
网络接口卡，允许

196
00:08:31,289 --> 00:08:34,479
接受数据包，

197
00:08:34,479 --> 00:08:35,919
指示我们是接口卡直接

198
00:08:35,919 --> 00:08:37,269
读取和写入内存 服务器

199
00:08:37,269 --> 00:08:42,698
而不中断服务器 我

200
00:08:42,698 --> 00:08:45,310
知道他们玩的把戏就是你通常

201
00:08:45,310 --> 00:08:48,569
所说的内核旁路

202
00:08:48,680 --> 00:08:54,260
，这意味着应用程序级

203
00:08:54,260 --> 00:08:58,790
代码可以直接访问网络

204
00:08:58,790 --> 00:09:00,170
接口卡而无需

205
00:09:00,170 --> 00:09:02,540
涉及内核，所以这些都是

206
00:09:02,540 --> 00:09:05,480
我们所使用的聪明技巧

207
00:09:05,480 --> 00:09:07,520
看看他们过去常常获得

208
00:09:07,520 --> 00:09:09,860
高性能，我会谈论

209
00:09:09,860 --> 00:09:11,270
我们已经谈论了很多分片，

210
00:09:11,270 --> 00:09:13,730
但我会谈论剩下的我 在本次

211
00:09:13,730 --> 00:09:15,430
讲座中

212
00:09:15,430 --> 00:09:19,220
，首先我将讨论

213
00:09:19,220 --> 00:09:21,560
非易失性 RAM，我的意思是这确实是一个

214
00:09:21,560 --> 00:09:27,200
主题，不会

215
00:09:27,200 --> 00:09:31,310
直接影响设计的其余部分，因为我

216
00:09:31,310 --> 00:09:34,400
说过所有数据和农场都存储

217
00:09:34,400 --> 00:09:37,190
在 RAM 中 当您更新它时，当客户端

218
00:09:37,190 --> 00:09:38,600
事务更新一条数据时

219
00:09:38,600 --> 00:09:39,800
，真正意味着它会到达

220
00:09:39,800 --> 00:09:41,570
存储数据的相关服务器

221
00:09:41,570 --> 00:09:43,760
并导致这些服务器修改

222
00:09:43,760 --> 00:09:46,700
事务正在

223
00:09:46,700 --> 00:09:49,370
修改的任何对象，以便在

224
00:09:49,370 --> 00:09:51,770
RAM 中修改它 就写入而言，

225
00:09:51,770 --> 00:09:53,540
它们不会进入磁盘，这

226
00:09:53,540 --> 00:09:54,620
与您的 raft 实现形成对比

227
00:09:54,620 --> 00:09:56,959
，例如，它

228
00:09:56,959 --> 00:09:59,570
花费大量时间将数据持久化到磁盘

229
00:09:59,570 --> 00:10:04,310
，没有持久化，在农场，这

230
00:10:04,310 --> 00:10:06,589
是一个大风写东西 在 RAM 中

231
00:10:06,589 --> 00:10:07,880
写入 ram 写入大约需要 200

232
00:10:07,880 --> 00:10:09,529
纳秒，而对

233
00:10:09,529 --> 00:10:11,930
固态驱动器的 raid 甚至是相当快的固态驱动

234
00:10:11,930 --> 00:10:14,480
器的停止搜索驱动器的权利大约

235
00:10:14,480 --> 00:10:17,330
需要 100 微秒，而写入

236
00:10:17,330 --> 00:10:18,440
我们的硬盘驱动器大约需要 10

237
00:10:18,440 --> 00:10:21,080
毫秒 ds 因此，对于修改事物的事务而言，能够写入

238
00:10:21,080 --> 00:10:24,320
ram 值得许多

239
00:10:24,320 --> 00:10:26,270
数量级和速度，

240
00:10:26,270 --> 00:10:27,589
但伊朗当然

241
00:10:27,589 --> 00:10:30,770
会丢失其内容和电源故障，因此

242
00:10:30,770 --> 00:10:34,180
它本身并不持久，

243
00:10:34,180 --> 00:10:37,990
您可能会认为将

244
00:10:37,990 --> 00:10:41,060
修改写入 多

245
00:10:41,060 --> 00:10:43,610
台服务器的 RAM，如果您有副本服务器

246
00:10:43,610 --> 00:10:45,260
并且您更新所有

247
00:10:45,260 --> 00:10:48,080
可能足够持久的副本，那么

248
00:10:48,080 --> 00:10:50,180
毕竟如果您有 F 1 F +1 个副本，

249
00:10:50,180 --> 00:10:53,150
您最多可以容忍 F 次故障，

250
00:10:53,150 --> 00:10:55,520
以及为什么只是简单地写入

251
00:10:55,520 --> 00:10:57,350
多台服务器上的 RAM 还

252
00:10:57,350 --> 00:10:59,990
不够好，因为站点范围内的电源故障

253
00:10:59,990 --> 00:11:00,870
会破坏

254
00:11:00,870 --> 00:11:06,150
您的所有服务器，因此违反

255
00:11:06,150 --> 00:11:09,029
了故障发生在

256
00:11:09,029 --> 00:11:11,220
不同服务器上的假设是独立的，因此我们

257
00:11:11,220 --> 00:11:12,810
需要一个即使电源故障也能正常工作的方案

258
00:11:12,810 --> 00:11:16,770
整个数据中心，

259
00:11:16,770 --> 00:11:24,210
所以论坛所做的是它

260
00:11:24,210 --> 00:11:26,490
在每个机架中放置一个电池一个大电池，并

261
00:11:26,490 --> 00:11:28,230
通过电池运行电源系统，

262
00:11:28,230 --> 00:11:31,050
以便电池自动充电

263
00:11:31,050 --> 00:11:32,970
如果发生电源故障并

264
00:11:32,970 --> 00:11:34,890
保持所有机器运行至少

265
00:11:34,890 --> 00:11:37,830
直到电池出现故障，但当然

266
00:11:37,830 --> 00:11:39,630
你知道电池不是很大，它

267
00:11:39,630 --> 00:11:41,490
可能只能运行他们的

268
00:11:41,490 --> 00:11:44,100
机器比如说 10 分钟或其他东西，

269
00:11:44,100 --> 00:11:45,900
所以电池本身

270
00:11:45,900 --> 00:11:47,760
不足以使系统能够

271
00:11:47,760 --> 00:11:50,760
承受长时间的电源故障，因此

272
00:11:50,760 --> 00:11:53,580
当电池系统

273
00:11:53,580 --> 00:11:56,460
发现主电源发生故障时，

274
00:11:56,460 --> 00:11:57,630
电池系统在保持

275
00:11:57,630 --> 00:12:00,330
服务器的 Marling 的同时也会提醒

276
00:12:00,330 --> 00:12:02,640
服务器的所有服务器，并以

277
00:12:02,640 --> 00:12:04,500
某种方式发出警报 中断或消息告诉

278
00:12:04,500 --> 00:12:06,480
他们看看电源刚刚失效你

279
00:12:06,480 --> 00:12:09,020
知道在电池失效前你只剩下 10 分钟了

280
00:12:09,020 --> 00:12:12,150
所以那时

281
00:12:12,150 --> 00:12:16,170
农场服务器上的软件复制所有

282
00:12:16,170 --> 00:12:18,570
的雨活动停止所有处理它

283
00:12:18,570 --> 00:12:21,630
首先为农场然后复制每个

284
00:12:21,630 --> 00:12:23,820
服务器 将其所有 RAM 复制到

285
00:12:23,820 --> 00:12:25,650
连接到该服务器的固态驱动器

286
00:12:25,650 --> 00:12:27,930
我希望可能需要

287
00:12:27,930 --> 00:12:30,089
几分钟，一旦所有 RAM 都

288
00:12:30,089 --> 00:12:32,100
复制到固态驱动器然后

289
00:12:32,100 --> 00:12:33,600
机器会自行关闭并

290
00:12:33,600 --> 00:12:37,410
自行关闭，因此如果一切顺利，则会出现

291
00:12:37,410 --> 00:12:39,870
站点范围内的电源故障

292
00:12:39,870 --> 00:12:43,500
，当数据中心恢复供电时，所有机器都会将其 RAM 保存到磁盘中，

293
00:12:43,500 --> 00:12:45,180
 

294
00:12:45,180 --> 00:12:49,160
当它们重新启动时，所有机器都会

295
00:12:49,160 --> 00:12:51,540
读取内存映像 保存在磁盘上

296
00:12:51,540 --> 00:12:54,570
恢复到 RAM 中，但是

297
00:12:54,570 --> 00:12:57,420
必须进行一些恢复，但基本上

298
00:12:57,420 --> 00:12:58,920
它们不会由于电源故障而丢失任何

299
00:12:58,920 --> 00:13:00,570
持久状态

300
00:13:00,570 --> 00:13:03,720
，所以这真正

301
00:13:03,720 --> 00:13:07,310
意味着农场正在使用传统的 Ram

302
00:13:07,310 --> 00:13:10,470
但它基本上使 RAM

303
00:13:10,470 --> 00:13:13,200
非易失性能够

304
00:13:13,200 --> 00:13:14,339
 

305
00:13:14,339 --> 00:13:17,339
通过使用电池的技巧在电源故障中幸存下来 具有

306
00:13:17,339 --> 00:13:18,779
电池警报的服务器 让

307
00:13:18,779 --> 00:13:21,660
服务器存储 RAM 内容 固态

308
00:13:21,660 --> 00:13:26,160
驱动器 关于 nvram

309
00:13:26,160 --> 00:13:33,509
方案的任何问题 好吧，这是一个 是一个有用的

310
00:13:33,509 --> 00:13:37,920
技巧，但值得记住的

311
00:13:37,920 --> 00:13:40,559
是，它真的只有在出现

312
00:13:40,559 --> 00:13:44,610
电源故障时才有帮助，也就是说，如果你

313
00:13:44,610 --> 00:13:46,499
知道整个事件序列，只有当

314
00:13:46,499 --> 00:13:47,730
 

315
00:13:47,730 --> 00:13:50,639
如果

316
00:13:50,639 --> 00:13:51,720
有其他原因

317
00:13:51,720 --> 00:13:53,749
导致服务器出现故障，例如

318
00:13:53,749 --> 00:13:55,620
硬件出现问题

319
00:13:55,620 --> 00:13:57,120
或软件中存在导致崩溃的错误，那么电池会注意到主电源出现

320
00:13:57,120 --> 00:14:00,600
故障，这些崩溃与

321
00:14:00,600 --> 00:14:02,670
非易失性 RAM 系统

322
00:14:02,670 --> 00:14:04,230
无关 那些崩溃 那些崩溃

323
00:14:04,230 --> 00:14:06,809
将导致机器重新启动并

324
00:14:06,809 --> 00:14:08,970
丢失其 RAM 的内容，

325
00:14:08,970 --> 00:14:10,470
并且无法恢复它们，因此此

326
00:14:10,470 --> 00:14:14,009
NVRAM 方案适用于电源故障，

327
00:14:14,009 --> 00:14:15,660
但不适用于其他崩溃，这

328
00:14:15,660 --> 00:14:19,319
就是除了 NVRAM 场之外的原因 每个分片也有

329
00:14:19,319 --> 00:14:21,720
多个副本，

330
00:14:21,720 --> 00:14:26,519
所以这个 NVRAM

331
00:14:26,519 --> 00:14:28,730
方案基本上消除了

332
00:14:28,730 --> 00:14:32,490
持久性速率作为

333
00:14:32,490 --> 00:14:35,160
系统

334
00:14:35,160 --> 00:14:37,259
性能的瓶颈，只留下网络

335
00:14:37,259 --> 00:14:39,120
和 CPU 的性能瓶颈，这就是我们接下来要

336
00:14:39,120 --> 00:14:43,769
讨论的内容 一个问题，

337
00:14:43,769 --> 00:14:49,679
如果数据中心电源出现故障并且农场失去

338
00:14:49,679 --> 00:14:52,170
了固态驱动器的所有内容，

339
00:14:52,170 --> 00:14:53,759
是否有可能将所有数据传输

340
00:14:53,759 --> 00:14:55,410
到不同的数据中心并进行配置？

341
00:14:55,410 --> 00:15:01,009
原则上继续在那里运行，绝对

342
00:15:01,009 --> 00:15:05,069
在实践中，我认为

343
00:15:05,069 --> 00:15:07,230
恢复数据中心的电源肯定会更容易，

344
00:15:07,230 --> 00:15:10,589
然后移动驱动器

345
00:15:10,589 --> 00:15:12,240
问题是没有电源，而且

346
00:15:12,240 --> 00:15:14,519
过时的旧数据中心没有电源，所以

347
00:15:14,519 --> 00:15:16,230
你必须 物理地将驱动器

348
00:15:16,230 --> 00:15:19,019
和计算机移动

349
00:15:19,019 --> 00:15:21,389
到新的数据中心可能只是驱动器，所以如果

350
00:15:21,389 --> 00:15:23,490
你想这样做，它可能是

351
00:15:23,490 --> 00:15:27,279
可能的，但肯定不是，

352
00:15:27,279 --> 00:15:29,079
这不是农场设计师的

353
00:15:29,079 --> 00:15:32,879
想法，他们认为电力可以恢复，

354
00:15:33,300 --> 00:15:38,589
所以 那是 NVRAM，在这一点上，

355
00:15:38,589 --> 00:15:40,930
我们可以在设计的其余部分忽略

356
00:15:40,930 --> 00:15:45,249
 

357
00:15:45,249 --> 00:15:46,540
 

358
00:15:46,540 --> 00:15:48,910
 

359
00:15:48,910 --> 00:15:54,269
nvram 因此，

360
00:15:54,269 --> 00:15:56,620
正如我提到的，

361
00:15:56,620 --> 00:15:59,290
一旦您消除了将大量数据存储

362
00:15:59,290 --> 00:16:00,879
到磁盘以持久存在剩余

363
00:16:00,879 --> 00:16:02,769
瓶颈的剩余

364
00:16:02,769 --> 00:16:07,360
瓶颈，实际上与 CPU 和网络有关

365
00:16:07,360 --> 00:16:09,220
 

366
00:16:09,220 --> 00:16:13,509
涉及到一个巨大的瓶颈

367
00:16:13,509 --> 00:16:16,420
是处理网络交互所需的 CPU 时间，

368
00:16:16,420 --> 00:16:18,550
所以现在我们可以

369
00:16:18,550 --> 00:16:21,309
CPU 是这里的一种联合瓶颈，

370
00:16:21,309 --> 00:16:23,470
农场没有任何类型的

371
00:16:23,470 --> 00:16:27,550
光速网络问题它只是有

372
00:16:27,550 --> 00:16:30,009
问题或 它只是花费大量时间来

373
00:16:30,009 --> 00:16:31,689
消除必须做的瓶颈是

374
00:16:31,689 --> 00:16:34,059
将网络数据传入和传出

375
00:16:34,059 --> 00:16:38,309
计算机，所以首先作为背景，我

376
00:16:38,309 --> 00:16:40,899
想列出传统

377
00:16:40,899 --> 00:16:43,180
架构是什么，用于

378
00:16:43,180 --> 00:16:46,029
在应用程序之间和不同的应用程序之间获取远程过程调用数据包之类的东西

379
00:16:46,029 --> 00:16:51,610
 

380
00:16:51,610 --> 00:16:54,309
计算机，这样我们才能知道为什么

381
00:16:54,309 --> 00:16:56,949
农场采用的这种方法更

382
00:16:56,949 --> 00:16:58,930
有效，所以通常情况下发生

383
00:16:58,930 --> 00:17:03,220
在一台可能想要

384
00:17:03,220 --> 00:17:05,500
发送过程调用消息的计算机上，您可能

385
00:17:05,500 --> 00:17:09,429
有一个应用程序，然后该

386
00:17:09,429 --> 00:17:11,250
应用程序在用户中运行 空间

387
00:17:11,250 --> 00:17:15,490
这里有一个用户内核边界

388
00:17:15,490 --> 00:17:17,109
应用程序对内核进行系统调用，

389
00:17:17,109 --> 00:17:19,359
这些调用并不是特别便宜

390
00:17:19,359 --> 00:17:22,599
，以便发送数据然后再发送 e是内核

391
00:17:22,599 --> 00:17:24,339
中的一整套软件，

392
00:17:24,339 --> 00:17:26,140
涉及通过网络发送数据

393
00:17:26,140 --> 00:17:29,620
可能有通常

394
00:17:29,620 --> 00:17:32,559
称为套接字层的缓冲层，

395
00:17:32,559 --> 00:17:36,070
它涉及复制

396
00:17:36,070 --> 00:17:38,590
数据，这需要时间通常

397
00:17:38,590 --> 00:17:40,230
有一个复杂的

398
00:17:40,230 --> 00:17:42,600
TCP协议栈知道所有关于

399
00:17:42,600 --> 00:17:45,059
诸如 重传和序列

400
00:17:45,059 --> 00:17:49,130
号以及校验和和流控制

401
00:17:49,130 --> 00:17:51,650
 

402
00:17:51,650 --> 00:17:54,510
在底部有相当多的处理有一个

403
00:17:54,510 --> 00:17:57,299
称为网络接口

404
00:17:57,299 --> 00:18:00,510
卡的硬件，它有一堆寄存器

405
00:18:00,510 --> 00:18:04,830
，内核可以与之交谈以配置

406
00:18:04,830 --> 00:18:07,230
它，它有硬件 需要

407
00:18:07,230 --> 00:18:09,260
通过电缆将比特发送到网络上

408
00:18:09,260 --> 00:18:11,760
，因此内核中有某种网络

409
00:18:11,760 --> 00:18:15,080
接口卡驱动程序，

410
00:18:15,080 --> 00:18:18,179
然后所有自尊我们

411
00:18:18,179 --> 00:18:19,919
将定价卡使用直接内存

412
00:18:19,919 --> 00:18:22,110
访问将数据包移入和移出

413
00:18:22,110 --> 00:18:23,970
主机内存，所以 会有

414
00:18:23,970 --> 00:18:26,910
一些东西，比如

415
00:18:26,910 --> 00:18:28,919
网络接口卡 D 放入

416
00:18:28,919 --> 00:18:30,630
内存的数据包队列，等待内核

417
00:18:30,630 --> 00:18:33,630
读取和传出内核想要的数据包

418
00:18:33,630 --> 00:18:34,740
，然后我们

419
00:18:34,740 --> 00:18:36,840
将面对汽车发送

420
00:18:36,840 --> 00:18:39,390
方便，所以你想发送

421
00:18:39,390 --> 00:18:41,700
一个像 RPC 请求这样的消息让我们

422
00:18:41,700 --> 00:18:43,049
通过堆栈网络从应用程序下去

423
00:18:43,049 --> 00:18:45,240
接口卡通过

424
00:18:45,240 --> 00:18:48,390
电缆将位发送出去，然后

425
00:18:48,390 --> 00:18:51,840
另一侧的反向堆栈不是

426
00:18:51,840 --> 00:18:55,950
网络接口

427
00:18:55,950 --> 00:18:57,270
内核中的硬件然后器官或面部可能会

428
00:18:57,270 --> 00:19:00,059
中断内核内核运行驱动程序

429
00:19:00,059 --> 00:19:02,850
代码将数据包传递给写入的TCP

430
00:19:02,850 --> 00:19:06,169
协议 它们到缓冲区中

431
00:19:06,169 --> 00:19:08,630
等待应用程序

432
00:19:08,630 --> 00:19:10,830
在某个时候读取它们 应用程序可以

433
00:19:10,830 --> 00:19:12,419
读取它们 使系统调用

434
00:19:12,419 --> 00:19:15,390
进入内核 将数据从

435
00:19:15,390 --> 00:19:19,440
这些缓冲区复制到用户空间 这是

436
00:19:19,440 --> 00:19:21,980
很多软件 它需要大量处理

437
00:19:21,980 --> 00:19:24,630
和大量 相当昂贵的 CPU

438
00:19:24,630 --> 00:19:26,100
操作，如系统调用和

439
00:19:26,100 --> 00:19:29,669
中断以及因此复制数据，

440
00:19:29,669 --> 00:19:32,820
因此经典网络通信

441
00:19:32,820 --> 00:19:35,340
相对较慢，

442
00:19:35,340 --> 00:19:37,470
构建 RPC 系统非常困难 使用这种

443
00:19:37,470 --> 00:19:39,360
传统架构每秒可以

444
00:19:39,360 --> 00:19:41,730
传递超过几

445
00:19:41,730 --> 00:19:45,390
十万或 BC 消息，

446
00:19:45,390 --> 00:19:47,250
这可能看起来很多，但

447
00:19:47,250 --> 00:19:49,500
对于农场试图瞄准的那种性能来说，它的数量级太少了

448
00:19:49,500 --> 00:19:51,390
 

449
00:19:51,390 --> 00:19:53,290
，一般来说

450
00:19:53,290 --> 00:19:54,850
每秒几十万台电脑

451
00:19:54,850 --> 00:19:58,810
远远

452
00:19:58,810 --> 00:20:01,300
低于实际网络硬件（如

453
00:20:01,300 --> 00:20:03,130
网络接口卡中的网络线）的速度，

454
00:20:03,130 --> 00:20:05,110
这些

455
00:20:05,110 --> 00:20:07,390
电缆通常以每秒 10 吉比特的速度运行，

456
00:20:07,390 --> 00:20:11,140
编写我们的 PC 软件非常非常困难

457
00:20:11,140 --> 00:20:12,970
可以生成

458
00:20:12,970 --> 00:20:16,630
数据库

459
00:20:16,630 --> 00:20:18,760
经常需要使用的那种小消息 很难

460
00:20:18,760 --> 00:20:20,590
编写这种风格的软件 可以

461
00:20:20,590 --> 00:20:24,280
生成或吸收每秒 10

462
00:20:24,280 --> 00:20:30,400
吉比特的消息 每秒数

463
00:20:30,400 --> 00:20:32,080
百万甚至数千万条

464
00:20:32,080 --> 00:20:34,390
消息 好的，所以这是

465
00:20:34,390 --> 00:20:37,660
农场不使用的计划，以及

466
00:20:37,660 --> 00:20:45,610
对该计划的一种反应，而不是农场

467
00:20:45,610 --> 00:20:52,030
使用 - - 减少

468
00:20:52,030 --> 00:20:55,330
推包成本的想法 第一个

469
00:20:55,330 --> 00:21:01,480
我将调用内核旁路，这里的想法

470
00:21:01,480 --> 00:21:05,010
是，不是应用程序

471
00:21:05,010 --> 00:21:06,880
通过

472
00:21:06,880 --> 00:21:15,460
复杂的内核代码堆栈向下发送所有数据，而是

473
00:21:15,460 --> 00:21:18,130
应用程序内核配置

474
00:21:18,130 --> 00:21:21,370
计算机中的保护机制以

475
00:21:21,370 --> 00:21:24,310
允许应用程序直接访问

476
00:21:24,310 --> 00:21:26,410
网络接口卡，因此

477
00:21:26,410 --> 00:21:28,060
应用程序实际上可以伸手

478
00:21:28,060 --> 00:21:30,640
触摸网络接口寄存器

479
00:21:30,640 --> 00:21:33,340
并告诉它除了

480
00:21:33,340 --> 00:21:35,550
网络接口卡之外该做什么 DMA

481
00:21:35,550 --> 00:21:38,770
和这个内核绕过方案它的 DNA

482
00:21:38,770 --> 00:21:41,050
直接进入应用程序内存中

483
00:21:41,050 --> 00:21:42,700
的应用程序可以看到字节

484
00:21:42,700 --> 00:21:46,210
到达 直接无需内核

485
00:21:46,210 --> 00:21:47,650
干预，当应用程序

486
00:21:47,650 --> 00:21:49,930
需要发送数据时，应用程序可以

487
00:21:49,930 --> 00:21:53,620
创建网络接口

488
00:21:53,620 --> 00:21:56,830
卡可以直接使用 DMA 读取并

489
00:21:56,830 --> 00:21:58,360
通过线路发送的队列，所以现在我们已经

490
00:21:58,360 --> 00:22:01,300
完全消除了

491
00:22:01,300 --> 00:22:03,280
网络内核中涉及的所有内核代码，只是

492
00:22:03,280 --> 00:22:04,600
没有 涉及 没有系统调用

493
00:22:04,600 --> 00:22:06,140
没有

494
00:22:06,140 --> 00:22:08,120
中断 应用程序只是直接原因 为什么

495
00:22:08,120 --> 00:22:09,530
网络接口卡看到的是内存

496
00:22:09,530 --> 00:22:11,420
，当然

497
00:22:11,420 --> 00:22:21,920
另一边也有同样的东西，

498
00:22:21,920 --> 00:22:25,130
这是一个想法，

499
00:22:25,130 --> 00:22:27,950
几年前网络接口卡实际上是不可能的，

500
00:22:27,950 --> 00:22:30,590
但大多数现代严肃的

501
00:22:30,590 --> 00:22:33,200
网络接口卡都可以设置

502
00:22:33,200 --> 00:22:34,820
但是，要做到这一点，它确实需要

503
00:22:34,820 --> 00:22:37,250
您知道的应用程序

504
00:22:37,250 --> 00:22:39,710
知道 TCP 为您做的所有事情，

505
00:22:39,710 --> 00:22:43,280
例如校验和或重新传输

506
00:22:43,280 --> 00:22:46,280
，如果我们想这样做，应用程序现在将负责

507
00:22:46,280 --> 00:22:49,190
，您实际上

508
00:22:49,190 --> 00:22:55,510
可以自己做内核绕过 使用一个

509
00:22:55,510 --> 00:22:57,530
工具包，你可以在升级过程中找到一个

510
00:22:57,530 --> 00:22:57,970
叫做

511
00:22:57,970 --> 00:23:02,060
DP DK 的工具包，它相对容易使用，

512
00:23:02,060 --> 00:23:04,820
并且允许人们编写

513
00:23:04,820 --> 00:23:08,620
性能极高的网络应用程序，

514
00:23:08,620 --> 00:23:12,710
但是所以 form 确实使用它，它的

515
00:23:12,710 --> 00:23:14,180
应用程序直接

516
00:23:14,180 --> 00:23:15,680
与颈部 DM ace 对话 事情直接进入

517
00:23:15,680 --> 00:23:19,850
应用程序内存我们有一个学生

518
00:23:19,850 --> 00:23:22,910
问题我很抱歉是的这是否

519
00:23:22,910 --> 00:23:24,290
意味着农场机器可以很好地运行修改后的

520
00:23:24,290 --> 00:23:31,370
操作系统我不知道这个

521
00:23:31,370 --> 00:23:32,750
行为 我相信

522
00:23:32,750 --> 00:23:36,500
农场在 Windows 上运行某种形式的

523
00:23:36,500 --> 00:23:38,120
Windows 无论他们是否必须

524
00:23:38,120 --> 00:23:44,240
修改 Windows 我不知道在

525
00:23:44,240 --> 00:23:46,940
Linux 世界中的那种 Linux 世界中

526
00:23:46,940 --> 00:23:48,950
已经完全支持这个问题

527
00:23:48,950 --> 00:23:50,690
它确实需要内核干预，

528
00:23:50,690 --> 00:23:54,380
因为内核 必须愿意

529
00:23:54,380 --> 00:23:56,600
提供通常应用程序代码不能

530
00:23:56,600 --> 00:23:58,750
直接对设备执行任何操作，因此

531
00:23:58,750 --> 00:24:01,520
必须修改 Linux 以

532
00:24:01,520 --> 00:24:05,890
允许内核将

533
00:24:05,890 --> 00:24:08,660
硬件访问权限委派给应用程序，因此

534
00:24:08,660 --> 00:24:12,410
确实需要内核修改那些

535
00:24:12,410 --> 00:24:13,670
监控场合已经在 Linux 中

536
00:24:13,670 --> 00:24:16,190
并且可能已经 在 Windows 中，

537
00:24:16,190 --> 00:24:18,419
虽然这

538
00:24:18,419 --> 00:24:21,360
在相当智能的尼克斯上也是如此，因为

539
00:24:21,360 --> 00:24:22,380
当然你会有多个

540
00:24:22,380 --> 00:24:23,940
应用程序想要

541
00:24:23,940 --> 00:24:25,769
使用网络接口卡玩这个游戏，所以

542
00:24:25,769 --> 00:24:27,899
现代 NIC 实际上知道如何

543
00:24:27,899 --> 00:24:30,390
与多个不同的线索交谈，这样你

544
00:24:30,390 --> 00:24:32,039
就可以拥有 多个应用程序，每个应用程序都有

545
00:24:32,039 --> 00:24:33,870
自己的一组提示，尼克

546
00:24:33,870 --> 00:24:36,269
知道，所以它需要

547
00:24:36,269 --> 00:24:41,460
修改 在很多事情上都可以，

548
00:24:41,460 --> 00:24:47,190
所以第一步是绕过上校的

549
00:24:47,190 --> 00:24:50,309
想法，第二步甚至更聪明

550
00:24:50,309 --> 00:24:51,539
 

551
00:24:51,539 --> 00:24:54,919
 

552
00:24:54,919 --> 00:24:59,039
 

553
00:24:59,039 --> 00:25:03,110
默认是这个 RDMA 方案，它是

554
00:25:03,110 --> 00:25:11,929
远程直接内存访问，

555
00:25:11,929 --> 00:25:18,600
这是一种特殊的网络

556
00:25:18,600 --> 00:25:21,230
接口卡，支持远程

557
00:25:21,230 --> 00:25:28,470
支持我们的 DMA，所以现在我们有一个 RDM，一个

558
00:25:28,470 --> 00:25:35,480
脖子两边都必须有这些

559
00:25:35,570 --> 00:25:38,399
特殊的网络接口卡，所以我 我

560
00:25:38,399 --> 00:25:39,899
画这些是通过电缆连接的，

561
00:25:39,899 --> 00:25:43,919
实际上这里总是有一个开关，

562
00:25:43,919 --> 00:25:47,480
它连接到许多不同的

563
00:25:47,480 --> 00:25:50,370
服务器，并允许任何服务器与

564
00:25:50,370 --> 00:25:52,110
任何服务器通信，所以我们有这些 RDMA

565
00:25:52,110 --> 00:25:55,200
颈部，我们再次拥有

566
00:25:55,200 --> 00:25:56,820
应用程序和应用程序支持

567
00:25:56,820 --> 00:26:02,010
内存，现在虽然应用

568
00:26:02,010 --> 00:26:06,559
程序本质上可以通过请求发送一个特殊消息

569
00:26:06,559 --> 00:26:10,260
，所以我们

570
00:26:10,260 --> 00:26:13,620
在源主机上有一个应用程序，

571
00:26:13,620 --> 00:26:15,980
也许我们不会称之为

572
00:26:15,980 --> 00:26:18,750
目标主机可以发送一个 s

573
00:26:18,750 --> 00:26:22,110
通过我们的 DMA 系统的特殊消息，

574
00:26:22,110 --> 00:26:24,899
告诉该网络接口卡

575
00:26:24,899 --> 00:26:28,919
直接读取或写入一个字节

576
00:26:28,919 --> 00:26:30,450
一些内存字节可能是

577
00:26:30,450 --> 00:26:32,190
 

578
00:26:32,190 --> 00:26:33,990
目标应用程序地址空间中的内存缓存线，

579
00:26:33,990 --> 00:26:36,570
因此网络接口控制器上的硬件和软件

580
00:26:36,570 --> 00:26:38,220
正在

581
00:26:38,220 --> 00:26:40,320
读取 并直接写入

582
00:26:40,320 --> 00:26:41,820
应用程序目标应用程序内存的读取或写入

583
00:26:41,820 --> 00:26:44,730
，然后我们有一种

584
00:26:44,730 --> 00:26:47,700
请求会导致读取

585
00:26:47,700 --> 00:26:49,769
或写入，然后将结果发送

586
00:26:49,769 --> 00:26:55,340
回

587
00:26:55,340 --> 00:26:58,860
源应用程序上的其他两个传入队列，这很酷

588
00:26:58,860 --> 00:27:01,230
这是这台计算机

589
00:27:01,230 --> 00:27:03,659
的 CPU 这个应用程序

590
00:27:03,659 --> 00:27:06,450
对读取或写入一无所知

591
00:27:06,450 --> 00:27:09,529
读取或写入完全

592
00:27:09,529 --> 00:27:12,000
在网络接口卡的固件中执行，

593
00:27:12,000 --> 00:27:13,799
所以这里没有中断

594
00:27:13,799 --> 00:27:15,330
，应用程序不必

595
00:27:15,330 --> 00:27:16,710
考虑 请求或考虑

596
00:27:16,710 --> 00:27:18,929
回复网络接口卡只是

597
00:27:18,929 --> 00:27:20,340
读取或写入内存并将

598
00:27:20,340 --> 00:27:22,879
结果发送回源应用程序

599
00:27:22,879 --> 00:27:25,470
这比

600
00:27:25,470 --> 00:27:27,990
 

601
00:27:27,990 --> 00:27:30,419
 

602
00:27:30,419 --> 00:27:32,490
在目标应用程序

603
00:27:32,490 --> 00:27:35,399
的 RAM 中读取

604
00:27:35,399 --> 00:27:37,769
或写入内存和内容的开销要低得多

605
00:27:37,769 --> 00:27:42,769
即使使用魔术内核绕过网络，

606
00:27:42,769 --> 00:27:46,379
这是一个问题，这是否意味着

607
00:27:46,379 --> 00:27:48,960
已经可能总是需要内核绕过

608
00:27:48,960 --> 00:27:54,389
才能工作你知道我不知道

609
00:27:54,389 --> 00:27:56,820
答案我想我

610
00:27:56,820 --> 00:27:59,250
只听说过它与内核绕过一起使用

611
00:27:59,250 --> 00:28:02,070
cuz 你知道那些

612
00:28:02,070 --> 00:28:04,080
对这方面感兴趣的人，

613
00:28:04,080 --> 00:28:07,049
或者只是为了

614
00:28:07,049 --> 00:28:10,190
出色的表现而对它感兴趣，我认为你会浪费

615
00:28:10,190 --> 00:28:12,539
掉很多性能

616
00:28:12,539 --> 00:28:14,279
我猜你会丢掉很多

617
00:28:14,279 --> 00:28:16,620
性能上的胜利，如果你有

618
00:28:16,620 --> 00:28:22,259
通过内核发送请求 好的 另一个

619
00:28:22,259 --> 00:28:31,650
问题 问题指出

620
00:28:31,650 --> 00:28:34,410
TCP 软件的 TCP 支持订单

621
00:28:34,410 --> 00:28:36,870
交付重复检测和

622
00:28:36,870 --> 00:28:38,970
许多其他您

623
00:28:38,970 --> 00:28:41,790
实际需要的优秀属性，所以它实际上会

624
00:28:41,790 --> 00:28:44,070
如果这种设置

625
00:28:44,070 --> 00:28:48,540
牺牲了可靠的交付或按顺序

626
00:28:48,540 --> 00:28:50,700
交付，那会非常尴尬，所以问题的

627
00:28:50,700 --> 00:28:53,010
答案实际上是这些 DMA NIC 运行它们

628
00:28:53,010 --> 00:28:56,460
自己的可靠序列协议，

629
00:28:56,460 --> 00:28:59,640
就像 TCP 一样，虽然脖子之间不是 TCP

630
00:28:59,640 --> 00:29:02,790
，所以当你问你已经

631
00:29:02,790 --> 00:29:04,770
是脖子了 要进行读取或写入，它将

632
00:29:04,770 --> 00:29:08,010
继续传输，直到您

633
00:29:08,010 --> 00:29:09,480
知道请求是否丢失并保持

634
00:29:09,480 --> 00:29:10,530
保证意义，直到它得到

635
00:29:10,530 --> 00:29:12,810
响应并且它实际上告诉

636
00:29:12,810 --> 00:29:15,540
原始软件请求

637
00:29:15,540 --> 00:29:17,130
是否成功，因此您会得到

638
00:29:17,130 --> 00:29:20,220
确认 最后，是的，您

639
00:29:20,220 --> 00:29:22,490
知道实际上必须牺牲

640
00:29:22,490 --> 00:29:25,710
大部分 TCP 是好的属性，现在这些

641
00:29:25,710 --> 00:29:28,530
东西只能在本地网络

642
00:29:28,530 --> 00:29:32,010
 

643
00:29:32,010 --> 00:29:34,560
 

644
00:29:34,560 --> 00:29:38,940
 

645
00:29:38,940 --> 00:29:45,320
上运行 轻访问 好的

646
00:29:45,320 --> 00:29:47,970
 

647
00:29:47,970 --> 00:29:56,150
论文使用的一个特定术语是我们的 DMA，

648
00:29:56,150 --> 00:29:57,870
这基本上就是我刚刚

649
00:29:57,870 --> 00:30:01,560
提到的应用程序使用我们的

650
00:30:01,560 --> 00:30:02,700
DMA 读取或 写入另一个站点的内存，

651
00:30:02,700 --> 00:30:06,680
我们的 DMA 现在实际上农场

652
00:30:06,680 --> 00:30:13,230
使用我们的 DMA 在类似 RPC 的协议中发送消息，

653
00:30:13,230 --> 00:30:15,870
所以实际上有时农场

654
00:30:15,870 --> 00:30:18,300
直接使用我们的 DMA 进行读取，

655
00:30:18,300 --> 00:30:20,610
但有时农场使用我们的 DMA

656
00:30:20,610 --> 00:30:23,820
的目的是附加一个 消息到

657
00:30:23,820 --> 00:30:26,340
目标内部的传入消息队列，

658
00:30:26,340 --> 00:30:27,810
所以有时

659
00:30:27,810 --> 00:30:31,590
井实际上总是写什么

660
00:30:31,590 --> 00:30:33,450
农场实际在做什么是使用我们的 DMA

661
00:30:33,450 --> 00:30:38,040
写入将新消息附加到

662
00:30:38,040 --> 00:30:40,470
目标中的传入队列，

663
00:30:40,470 --> 00:30:42,180
因为有 没有人

664
00:30:42,180 --> 00:30:45,179
在这里打断目标

665
00:30:45,179 --> 00:30:47,639
的方式，这样的消息的目的地

666
00:30:47,639 --> 00:30:49,529
知道我收到的消息会

667
00:30:49,529 --> 00:30:52,289
定期检查这些密钥

668
00:30:52,289 --> 00:30:53,609
队列和内存中的一个，看看我

669
00:30:53,609 --> 00:30:55,639
是如何从任何人那里得到最近的消息的，

670
00:30:55,639 --> 00:30:58,080
所以一旦我这样做了 MA 只是

671
00:30:58,080 --> 00:31:00,149
读取或写入，但使用我们的 DMA

672
00:31:00,149 --> 00:31:02,219
发送消息或附加到消息

673
00:31:02,219 --> 00:31:03,419
队列或日志

674
00:31:03,419 --> 00:31:06,389
有时农场将消息或日志

675
00:31:06,389 --> 00:31:09,059
条目附加到日志，另一台服务器也

676
00:31:09,059 --> 00:31:11,429
使用我们的 D  MA，你知道

677
00:31:11,429 --> 00:31:15,049
这个被写入的内存都是

678
00:31:15,049 --> 00:31:17,249
非易失性的，所以所有的消息

679
00:31:17,249 --> 00:31:20,190
队列都写到磁盘如果

680
00:31:20,190 --> 00:31:24,749
出现电源故障，这个性能

681
00:31:24,749 --> 00:31:29,940
是图 2 显示你

682
00:31:29,940 --> 00:31:34,169
可以获得 1000 万个小的我们的 DMA

683
00:31:34,169 --> 00:31:37,580
每秒读取和写入速度

684
00:31:37,580 --> 00:31:40,739
远远快于您

685
00:31:40,739 --> 00:31:43,979
使用 TCP 发送消息（例如我们的 pc）的速度，并且

686
00:31:43,979 --> 00:31:46,139
使用我们的 DMA 进行简单

687
00:31:46,139 --> 00:31:48,979
读取或写入的延迟大约为 5 微秒，所以

688
00:31:48,979 --> 00:31:54,029
这又是您知道的非常非常短的 5

689
00:31:54,029 --> 00:31:56,669
微秒 它是否比

690
00:31:56,669 --> 00:31:59,789
访问您自己的本地内存要慢，但它

691
00:31:59,789 --> 00:32:01,379
比人们在网络中所做的任何其他事情都快

692
00:32:01,379 --> 00:32:05,629
，好吧，所以这是一种

693
00:32:05,629 --> 00:32:07,950
承诺，我们的 DMA

694
00:32:07,950 --> 00:32:10,080
技术不久前就出现了

695
00:32:10,080 --> 00:32:11,909
，在农场人们想

696
00:32:11,909 --> 00:32:15,599
利用你 知道您可以想象的最酷的

697
00:32:15,599 --> 00:32:17,219
 

698
00:32:17,219 --> 00:32:20,820
事情是使用我们的 DMA 一个标志它

699
00:32:20,820 --> 00:32:23,489
已经是直接

700
00:32:23,489 --> 00:32:26,190
执行所有原因的原因权利写入

701
00:32:26,190 --> 00:32:28,559
存储在数据库服务器内存中的记录所以

702
00:32:28,559 --> 00:32:29,789
如果我们

703
00:32:29,789 --> 00:32:32,639
永远不能与数据库服务器 CPU 或

704
00:32:32,639 --> 00:32:34,889
软件通信，而只是使用直接单面的 DMA Reiser 编写的单面数据，

705
00:32:34,889 --> 00:32:37,109
只需在 5 微秒内获取我们需要您知道的数据，那就太棒了，

706
00:32:37,109 --> 00:32:40,739
 

707
00:32:40,739 --> 00:32:43,259
所以从某种意义上说，这篇论文

708
00:32:43,259 --> 00:32:45,749
是 关于你知道你从那里开始

709
00:32:45,749 --> 00:32:49,019
你必须做什么才能真正构建

710
00:32:49,019 --> 00:32:53,009
有用的东西所以一个有趣的

711
00:32:53,009 --> 00:32:56,239
问题是你是否真的可以

712
00:32:56,239 --> 00:32:58,410
 

713
00:32:58,410 --> 00:33:01,620
使用单面 RDMA 实现事务，即你

714
00:33:01,620 --> 00:33:03,540
知道我们想要读取或写入数据的任何内容

715
00:33:03,540 --> 00:33:07,020
服务器唯一的用途已经可能并且

716
00:33:07,020 --> 00:33:10,110
永远不会真正发送

717
00:33:10,110 --> 00:33:13,760
必须由服务器软件解释的消息

718
00:33:13,760 --> 00:33:16,830
 

719
00:33:16,830 --> 00:33:19,950
在某种意义上值得考虑农场正在回答这个

720
00:33:19,950 --> 00:33:22,650
问题，因为这不是

721
00:33:22,650 --> 00:33:25,950
农场的真正运作方式，但

722
00:33:25,950 --> 00:33:28,110
绝对值得思考如何

723
00:33:28,110 --> 00:33:31,770
纯单面 RDMA 无法

724
00:33:31,770 --> 00:33:37,620
正常工作，因此在

725
00:33:37,620 --> 00:33:42,480
 

726
00:33:42,480 --> 00:33:46,890
具有复制和分片的事务系统中

727
00:33:46,890 --> 00:33:48,960
使用我们的 DMA 的挑战是我们面临的挑战是

728
00:33:48,960 --> 00:33:50,460
如何 组合已经使用事务

729
00:33:50,460 --> 00:33:52,740
图表和复制，因为您

730
00:33:52,740 --> 00:33:54,360
需要有分片和事务

731
00:33:54,360 --> 00:33:56,940
复制才能拥有一个非常有用的

732
00:33:56,940 --> 00:33:59,760
数据库系统事实证明，

733
00:33:59,760 --> 00:34:02,250
到目前为止我们看到的所有用于

734
00:34:02,250 --> 00:34:04,320
进行事务复制的协议都需要

735
00:34:04,320 --> 00:34:06,810
服务器

736
00:34:06,810 --> 00:34:11,668
软件的积极参与，即 服务器必须采用

737
00:34:11,668 --> 00:34:13,110
我们迄今为止看到的所有协议

738
00:34:13,110 --> 00:34:15,150
服务器积极参与

739
00:34:15,150 --> 00:34:17,370
帮助客户端读取或写入

740
00:34:17,370 --> 00:34:21,270
数据，例如在

741
00:34:21,270 --> 00:34:23,969
我们看到的两阶段提交方案中服务器

742
00:34:23,969 --> 00:34:25,800
必须做的事情 比如决定一条

743
00:34:25,800 --> 00:34:27,960
记录是否被锁定，如果它没有被锁定，那么

744
00:34:27,960 --> 00:34:31,530
设置它的锁定是不清楚的

745
00:34:31,530 --> 00:34:35,580
 

746
00:34:35,580 --> 00:34:37,350
 

747
00:34:37,350 --> 00:34:39,060
 

748
00:34:39,060 --> 00:34:40,469
 

749
00:34:40,469 --> 00:34:43,139
 

750
00:34:43,139 --> 00:34:45,360
如果我们

751
00:34:45,360 --> 00:34:45,900
 

752
00:34:45,900 --> 00:34:48,000
在服务器上有两阶段

753
00:34:48,000 --> 00:34:50,370
提交

754
00:34:50,370 --> 00:34:52,500
数据的事务，那么考虑如何找到最新版本 n 已写入但尚未提交

755
00:34:52,500 --> 00:34:54,929
传统上它是

756
00:34:54,929 --> 00:34:58,520
服务器来整理

757
00:34:58,520 --> 00:35:00,810
最近更新的数据是否已提交

758
00:35:00,810 --> 00:35:01,950
，这是为了保护

759
00:35:01,950 --> 00:35:03,900
客户端不被您知道防止他们

760
00:35:03,900 --> 00:35:06,840
看到已锁定或尚不

761
00:35:06,840 --> 00:35:08,850
知道已提交的数据 这

762
00:35:08,850 --> 00:35:10,590
意味着，如果没有一些聪明的

763
00:35:10,590 --> 00:35:12,150
想法

764
00:35:12,150 --> 00:35:15,420
RDMA 或单方面纯粹使用我们的

765
00:35:15,420 --> 00:35:18,550
DME，单方面 RDMA 似乎并不能

766
00:35:18,550 --> 00:35:21,069
立即与事务

767
00:35:21,069 --> 00:35:26,410
和复制兼容，而且确实是农场，而

768
00:35:26,410 --> 00:35:29,319
农场确实使用它读取来获取的单方面

769
00:35:29,319 --> 00:35:32,020
直接从数据库中的数据输出

770
00:35:32,020 --> 00:35:34,990
它不能使用单方面的权限

771
00:35:34,990 --> 00:35:43,300
来修改数据，所以这导致我们

772
00:35:43,300 --> 00:35:46,690
进行乐观并发控制，

773
00:35:46,690 --> 00:35:54,220
事实证明，从某种意义上

774
00:35:54,220 --> 00:35:59,410
说，农场用来允许它都使用 RDMA 的主要技巧

775
00:35:59,410 --> 00:36:02,160
并且获取事务是通过使用

776
00:36:02,160 --> 00:36:05,859
乐观并发控制所以如果你

777
00:36:05,859 --> 00:36:12,599
记得我之前提到的

778
00:36:12,599 --> 00:36:14,770
并发控制方案

779
00:36:14,770 --> 00:36:18,809
分为两大类

780
00:36:18,960 --> 00:36:23,680
悲观和乐观pes 简单的

781
00:36:23,680 --> 00:36:28,359
方案使用锁，其想法是，

782
00:36:28,359 --> 00:36:30,130
如果您有一个事务要

783
00:36:30,130 --> 00:36:32,410
读取或写入一些数据，然后您才能

784
00:36:32,410 --> 00:36:34,059
读取或写入数据或查看它

785
00:36:34,059 --> 00:36:36,730
，它必须获取锁并且它必须

786
00:36:36,730 --> 00:36:41,230
等待锁，所以您 阅读有关

787
00:36:41,230 --> 00:36:45,339
两阶段锁定的信息，例如

788
00:36:45,339 --> 00:36:48,400
从 633 读取，因此在使用数据之前，

789
00:36:48,400 --> 00:36:50,859
您必须锁定它，并且

790
00:36:50,859 --> 00:36:52,559
在整个事务期间保持锁定，

791
00:36:52,559 --> 00:36:54,730
并且只有在事务

792
00:36:54,730 --> 00:36:56,530
提交或中止时才释放

793
00:36:56,530 --> 00:37:01,240
锁定，如果 存在冲突，因为

794
00:37:01,240 --> 00:37:05,380
两个事务想要同时写入相同的

795
00:37:05,380 --> 00:37:06,760
数据，或者一个想要

796
00:37:06,760 --> 00:37:08,140
读取，一个是怪物，他们

797
00:37:08,140 --> 00:37:10,390
不能同时做到这一点，其中一个

798
00:37:10,390 --> 00:37:12,220
必须阻止，或者除了一个已进行的

799
00:37:12,220 --> 00:37:13,630
事务之外的所有事务 对你来说，一些数据

800
00:37:13,630 --> 00:37:15,430
错过了一个块等待锁被

801
00:37:15,430 --> 00:37:17,920
释放，当然这个锁定

802
00:37:17,920 --> 00:37:20,109
方案是数据必须

803
00:37:20,109 --> 00:37:21,910
被锁定并且有人必须

804
00:37:21,910 --> 00:37:23,890
跟踪谁拥有锁以及

805
00:37:23,890 --> 00:37:27,000
何时释放锁等等

806
00:37:27,619 --> 00:37:30,619
这是  使我们的 DMA 发生的一

807
00:37:30,619 --> 00:37:33,329
件事尚不清楚如何

808
00:37:33,329 --> 00:37:35,609
在锁定方案中使用我们的 DMA 来执行权限甚至读取，

809
00:37:35,609 --> 00:37:37,500
因为有人必须强制

810
00:37:37,500 --> 00:37:40,289
执行锁定我对此有点犹豫

811
00:37:40,289 --> 00:37:42,359
，因为我怀疑

812
00:37:42,359 --> 00:37:45,410
我们的 DMA NIC 更聪明 可以

813
00:37:45,410 --> 00:37:49,460
支持更广泛的操作，例如

814
00:37:49,460 --> 00:37:51,359
原子测试和设置，

815
00:37:51,359 --> 00:37:54,029
您可能有朝一日能够

816
00:37:54,029 --> 00:37:58,490
使用纯单面 RDMA 执行锁定方案，

817
00:37:58,490 --> 00:38:02,849
但农场无法做到这一点，所以农场

818
00:38:02,849 --> 00:38:04,799
实际上用作乐观方案

819
00:38:04,799 --> 00:38:08,190
，在这里 您可以

820
00:38:08,190 --> 00:38:12,720
使用的乐观方案至少可以在不锁定的情况下读取

821
00:38:12,720 --> 00:38:18,660
您只是读取您还不知道的数据

822
00:38:18,660 --> 00:38:20,460
是否允许您

823
00:38:20,460 --> 00:38:21,809
读取数据或者其他人是否在

824
00:38:21,809 --> 00:38:23,460
修改它的模型中间或者

825
00:38:23,460 --> 00:38:25,500
您只是读取数据的任何内容 和一个

826
00:38:25,500 --> 00:38:27,059
事务，它使用它

827
00:38:27,059 --> 00:38:30,809
发生的任何事情，你也不会

828
00:38:30,809 --> 00:38:33,420
直接在乐观方案中写入数据，

829
00:38:33,420 --> 00:38:35,940
而是缓冲，所以你

830
00:38:35,940 --> 00:38:38,099
在本地和客户端缓冲写入，

831
00:38:38,099 --> 00:38:41,539
直到事务最终结束

832
00:38:41,539 --> 00:38:44,250
并且 n 当事务最终

833
00:38:44,250 --> 00:38:46,200
完成并且您想尝试提交

834
00:38:46,200 --> 00:38:50,549
它时，会有一个

835
00:38:50,549 --> 00:38:56,359
验证阶段，即所谓的验证阶段，在此阶段，

836
00:38:56,359 --> 00:38:58,559
事务处理系统会尝试

837
00:38:58,559 --> 00:39:00,839
确定

838
00:39:00,839 --> 00:39:02,759
您所做的实际原因权限是否与

839
00:39:02,759 --> 00:39:04,799
他们试图

840
00:39:04,799 --> 00:39:06,390
弄清楚的可序列化性一致 哦，有人

841
00:39:06,390 --> 00:39:07,799
在我读数据的时候写数据，如果他们

842
00:39:07,799 --> 00:39:08,970
是男孩，

843
00:39:08,970 --> 00:39:10,680
我们不能提交这个事务，因为

844
00:39:10,680 --> 00:39:13,640
它用垃圾而不是

845
00:39:13,640 --> 00:39:18,450
一致的读取值计算，所以如果

846
00:39:18,450 --> 00:39:21,900
验证成功，那么你提交，

847
00:39:21,900 --> 00:39:24,150
如果验证不成功 如果

848
00:39:24,150 --> 00:39:25,529
 

849
00:39:25,529 --> 00:39:26,910
您在中止时尝试使用数据时检测到其他人在弄乱数据，

850
00:39:26,910 --> 00:39:29,099
这意味着

851
00:39:29,099 --> 00:39:33,630
如果您正在读取或写入

852
00:39:33,630 --> 00:39:35,880
数据并且其他一些事务

853
00:39:35,880 --> 00:39:38,780
也在同时修改

854
00:39:38,780 --> 00:39:41,130
乐观方案时出现冲突，那么乐观方案将中止

855
00:39:41,130 --> 00:39:43,290
因为

856
00:39:43,290 --> 00:39:45,809
在提交点计算已经不正确，即

857
00:39:45,809 --> 00:39:47,880
您已经读取了您不应该读取的损坏数据

858
00:39:47,880 --> 00:39:49,980
，所以那里'

859
00:39:49,980 --> 00:39:52,290
例如，没有办法阻止你知道，直到

860
00:39:52,290 --> 00:39:53,339
一切正常，

861
00:39:53,339 --> 00:39:56,130
相反，事务已经有点

862
00:39:56,130 --> 00:39:57,960
中毒，只需要中止，

863
00:39:57,960 --> 00:40:03,750
可能会尝试正常，所以农场使用

864
00:40:03,750 --> 00:40:05,760
乐观，因为他希望

865
00:40:05,760 --> 00:40:08,309
能够使用单面 RDMA 来读取

866
00:40:08,309 --> 00:40:12,990
任何内容 很快就到了，所以

867
00:40:12,990 --> 00:40:16,470
这个设计实际上是通过使用我们的 DMA 强制实现的。

868
00:40:16,470 --> 00:40:19,589
这通常是 OCC

869
00:40:19,589 --> 00:40:26,400
的缩写，表示乐观并发

870
00:40:26,400 --> 00:40:27,660
控制，然后有趣的是，

871
00:40:27,660 --> 00:40:28,890
乐观并发控制协议

872
00:40:28,890 --> 00:40:31,770
是验证的工作原理，您如何

873
00:40:31,770 --> 00:40:33,569
实际检测到其他人正在

874
00:40:33,569 --> 00:40:35,010
编写 当你

875
00:40:35,010 --> 00:40:38,099
尝试使用它时的数据，这实际上主要

876
00:40:38,099 --> 00:40:39,540
是我在本讲座的其余部分中谈到的内容，

877
00:40:39,540 --> 00:40:42,420
尽管

878
00:40:42,420 --> 00:40:44,339
只是为了让它回到

879
00:40:44,339 --> 00:40:47,190
设计的顶层，这

880
00:40:47,190 --> 00:40:49,910
对农场所做的是 读取可以使用

881
00:40:49,910 --> 00:40:56,099
单面 RDMA，因此

882
00:40:56,099 --> 00:40:59,250
速度非常快，因为我们稍后会检查

883
00:40:59,250 --> 00:41:07,650
读取是否正常

884
00:41:07,650 --> 00:41:10,770
 

885
00:41:10,770 --> 00:41:16,589
不支持 sequel 之类的东西 它

886
00:41:16,589 --> 00:41:20,670
支持一个相当简单的

887
00:41:20,670 --> 00:41:23,849
事务 API 这个 API 只是为了

888
00:41:23,849 --> 00:41:26,460
让您了解事务

889
00:41:26,460 --> 00:41:29,099
代码的实际外观 如果您

890
00:41:29,099 --> 00:41:31,170
有事务必须清除

891
00:41:31,170 --> 00:41:32,520
事务的开始，因为我们

892
00:41:32,520 --> 00:41:34,829
需要说哦，这组特定的

893
00:41:34,829 --> 00:41:36,690
原因权限需要作为一个

894
00:41:36,690 --> 00:41:40,530
完整的事务发生代码

895
00:41:40,530 --> 00:41:43,170
通过调用 TX create 声明一个新事务

896
00:41:43,170 --> 00:41:45,140
这一切都是按

897
00:41:45,140 --> 00:41:47,640
我认为从 2014 年开始

898
00:41:47,640 --> 00:41:51,080
由同一作者发表的稍早的论文中的方式进行的

899
00:41:51,080 --> 00:41:53,120
您创建一个新事务，

900
00:41:53,120 --> 00:41:55,760
然后显式读取这些函数以

901
00:41:55,760 --> 00:42:02,360
读取对象，您必须提供一个

902
00:42:02,360 --> 00:42:06,380
对象标识符一个 OID，指示

903
00:42:06,380 --> 00:42:08,420
您要读取的对象然后您

904
00:42:08,420 --> 00:42:10,070
返回一些对象，您可以

905
00:42:10,070 --> 00:42:12,200
在本地内存中修改该对象，我们没有 '

906
00:42:12,200 --> 00:42:14,900
不要写它，你有一个

907
00:42:14,900 --> 00:42:16,790
你从服务器读取的副本，TX

908
00:42:16,790 --> 00:42:18,350
从服务器读回，所以你知道你

909
00:42:18,350 --> 00:42:22,450
可能会增加对象中的某些字段

910
00:42:22,450 --> 00:42:26,420
，然后当你想要 更新一个

911
00:42:26,420 --> 00:42:30,980
你称之为 TX 的对象，然后

912
00:42:30,980 --> 00:42:34,730
再次给它对象 ID 和新的

913
00:42:34,730 --> 00:42:37,070
对象内容，最后当你

914
00:42:37,070 --> 00:42:39,590
完成所有这些时，你必须

915
00:42:39,590 --> 00:42:41,090
告诉助手提交这个

916
00:42:41,090 --> 00:42:44,000
事务实际上做验证，

917
00:42:44,000 --> 00:42:46,310
如果它 成功会导致权限

918
00:42:46,310 --> 00:42:48,500
真正生效并可见，

919
00:42:48,500 --> 00:42:53,000
您将其称为提交例程，

920
00:42:53,000 --> 00:42:54,290
社区团队

921
00:42:54,290 --> 00:42:56,350
在图 4 中运行了一大堆我们将讨论的东西

922
00:42:56,350 --> 00:42:59,270
，它返回这个好的值，它

923
00:42:59,270 --> 00:43:02,330
需要告诉应用程序哦做了

924
00:43:02,330 --> 00:43:04,490
提交成功还是被中止，所以

925
00:43:04,490 --> 00:43:07,370
我们需要返回这个好的返回

926
00:43:07,370 --> 00:43:09,830
值你知道正确地

927
00:43:09,830 --> 00:43:13,220
表明事务成功了，有

928
00:43:13,220 --> 00:43:16,310
一些问题是问题，因为 OCC

929
00:43:16,310 --> 00:43:20,210
中止如果存在争用问题是

930
00:43:20,210 --> 00:43:23,180
重试是否涉及指数

931
00:43:23,180 --> 00:43:25,850
回退，否则它似乎 就像

932
00:43:25,850 --> 00:43:29,060
如果您只是立即被尝试并且

933
00:43:29,060 --> 00:43:32,990
有很多交易都

934
00:43:32,990 --> 00:43:34,400
试图在同一时间更新相同的值，

935
00:43:34,400 --> 00:43:36,050
他们都将全部

936
00:43:36,050 --> 00:43:39,470
退出 ry 并浪费大量时间，我

937
00:43:39,470 --> 00:43:40,700
不知道该问题的答案 我

938
00:43:40,700 --> 00:43:42,230
不记得看到他们

939
00:43:42,230 --> 00:43:44,240
在论文中提到过指数回退，但是

940
00:43:44,240 --> 00:43:46,900
 

941
00:43:46,900 --> 00:43:49,550
在重试之间延迟并

942
00:43:49,550 --> 00:43:52,940
增加 延迟给某人成功的机会

943
00:43:52,940 --> 00:43:56,260
这很像

944
00:43:56,260 --> 00:43:59,490
收集筏的随机化

945
00:43:59,490 --> 00:44:04,080
Tanner 的另一个问题是农场

946
00:44:04,080 --> 00:44:05,970
API 在精神上更接近无

947
00:44:05,970 --> 00:44:09,030
续集数据库是的，你知道这是查看它的一种方式

948
00:44:09,030 --> 00:44:12,300
，它确实

949
00:44:12,300 --> 00:44:15,869
没有 任何花哨的查询内容，例如

950
00:44:15,869 --> 00:44:19,200
连接，例如续集，它

951
00:44:19,200 --> 00:44:20,490
实际上是一种非常低级的

952
00:44:20,490 --> 00:44:25,050
读写接口以及事务

953
00:44:25,050 --> 00:44:27,119
支持，因此您可以将其

954
00:44:27,119 --> 00:44:30,600
视为无续集数据库，也许与

955
00:44:30,600 --> 00:44:36,570
事务有关，这就是

956
00:44:36,570 --> 00:44:40,410
事务看起来像，

957
00:44:40,410 --> 00:44:41,880
这些都是库调用创建的

958
00:44:41,880 --> 00:44:44,460
读/写提交提交作为一种

959
00:44:44,460 --> 00:44:46,500
复杂的写调用，实际上

960
00:44:46,500 --> 00:44:49,710
首先运行事务协调器代码，

961
00:44:49,710 --> 00:44:52,200
这是两相的罕见变体 se commit

962
00:44:52,200 --> 00:44:56,460
这在图四中描述只是

963
00:44:56,460 --> 00:44:59,100
重复，当召回

964
00:44:59,100 --> 00:45:00,420
开始并实际读取相关

965
00:45:00,420 --> 00:45:04,109
服务器时，正确的调用只是在本地

966
00:45:04,109 --> 00:45:08,100
缓冲，然后是新的修改对象

967
00:45:08,100 --> 00:45:10,560
，并且只有在提交时，对象

968
00:45:10,560 --> 00:45:14,280
才会被发送到这些对象 ID 的服务器

969
00:45:14,280 --> 00:45:17,790
实际上是

970
00:45:17,790 --> 00:45:19,710
对象的复合标识符，它们包含两部分，一个

971
00:45:19,710 --> 00:45:25,530
是标识一个区域，即

972
00:45:25,530 --> 00:45:27,359
所有服务器的所有内存都被

973
00:45:27,359 --> 00:45:29,460
分成这些区域，并且

974
00:45:29,460 --> 00:45:31,580
配置管理器会跟踪

975
00:45:31,580 --> 00:45:34,619
哪些服务器复制哪个区域

976
00:45:34,619 --> 00:45:36,630
编号，所以这是有原因的 数字在

977
00:45:36,630 --> 00:45:40,980
这里，然后你知道你的

978
00:45:40,980 --> 00:45:42,750
客户可以在表格中查找

979
00:45:42,750 --> 00:45:44,609
给定

980
00:45:44,609 --> 00:45:46,020
区域编号的当前主和备份，然后有一个

981
00:45:46,020 --> 00:45:47,940
地址，例如该区域内的直接内存

982
00:45:47,940 --> 00:45:53,510
地址，因此

983
00:45:53,510 --> 00:45:55,470
客户端使用原因号 选择

984
00:45:55,470 --> 00:45:57,390
备份中的主节点进行通信，

985
00:45:57,390 --> 00:46:00,000
然后将地址传递给我们的 DMA

986
00:46:00,000 --> 00:46:03,060
NIC 并告诉它看，请阅读

987
00:46:03,060 --> 00:46:05,310
这个地址或 为了获取这个

988
00:46:05,310 --> 00:46:07,760
对象

989
00:46:11,700 --> 00:46:14,920
好吧，我们

990
00:46:14,920 --> 00:46:17,920
必须摆脱的另一个细节是查看

991
00:46:17,920 --> 00:46:25,630
服务器内存布局我在任何一台

992
00:46:25,630 --> 00:46:29,770
服务器内存中有一堆东西

993
00:46:29,770 --> 00:46:33,040
所以一部分是服务器

994
00:46:33,040 --> 00:46:37,630
有 它的内存如果它正在

995
00:46:37,630 --> 00:46:39,160
复制一个或多个区域它

996
00:46:39,160 --> 00:46:41,860
具有实际区域或原因

997
00:46:41,860 --> 00:46:43,000
包含的是一大堆这些

998
00:46:43,000 --> 00:46:47,140
对象并且每个对象有很多

999
00:46:47,140 --> 00:46:52,720
对象对象位于内存中每个

1000
00:46:52,720 --> 00:46:58,810
对象都在其中包含一个标题

1001
00:46:58,810 --> 00:47:00,760
版本号，所以这些是

1002
00:47:00,760 --> 00:47:03,070
版本化的对象，但每个对象一次

1003
00:47:03,070 --> 00:47:07,290
只有一个版本，所以这是

1004
00:47:07,290 --> 00:47:13,630
版本号，在高位让

1005
00:47:13,630 --> 00:47:15,790
我在这里再试一次，

1006
00:47:15,790 --> 00:47:17,680
每个版本号的高位是一个锁定标志，所以

1007
00:47:17,680 --> 00:47:19,000
在标题中 一个对象有一个锁定

1008
00:47:19,000 --> 00:47:21,940
标志和高位，然后是一点点的版本

1009
00:47:21,940 --> 00:47:26,290
号，然后

1010
00:47:26,290 --> 00:47:29,800
是对象的实际数据，所以每个对象

1011
00:47:29,800 --> 00:47:31,900
都有相同的服务器内存它是

1012
00:47:31,900 --> 00:47:33,640
相同的布局高位

1013
00:47:33,640 --> 00:47:37,120
和当前版本的锁定位 数 ber 一

1014
00:47:37,120 --> 00:47:39,000
点点，每次系统写入

1015
00:47:39,000 --> 00:47:41,500
修改一个对象时，它都会增加

1016
00:47:41,500 --> 00:47:42,790
版本号，让我们看看

1017
00:47:42,790 --> 00:47:44,820
锁定位在几分钟内是如何使用的

1018
00:47:44,820 --> 00:47:47,710
，此外在服务器的内存中

1019
00:47:47,710 --> 00:47:52,590
还有成对的消息队列

1020
00:47:52,590 --> 00:47:58,060
和日志对 系统中的所有其他计算机

1021
00:47:58,060 --> 00:48:03,400
，这意味着您知道系统中

1022
00:48:03,400 --> 00:48:09,040
是否有其他四台服务器

1023
00:48:09,040 --> 00:48:11,440
正在运行，或者如果有

1024
00:48:11,440 --> 00:48:12,720
四台服务器正在运行

1025
00:48:12,720 --> 00:48:15,130
事务，

1026
00:48:15,130 --> 00:48:18,640
那么内存中将有四个日志可以

1027
00:48:18,640 --> 00:48:21,640
附加到我们的 DMA 一个 对于

1028
00:48:21,640 --> 00:48:23,220
每台其他服务器，这

1029
00:48:23,220 --> 00:48:25,780
意味着每台其他计算机都可以

1030
00:48:25,780 --> 00:48:27,130
运行事务，这意味着

1031
00:48:27,130 --> 00:48:31,330
运行在您

1032
00:48:31,330 --> 00:48:33,310
身上的事务代码知道它们的数量，您知道它是

1033
00:48:33,310 --> 00:48:36,160
计算机上运行的事务代码，

1034
00:48:36,160 --> 00:48:39,160
当它想说话时 到该服务器

1035
00:48:39,160 --> 00:48:42,280
并附加到它的日志，这也看到它

1036
00:48:42,280 --> 00:48:45,280
实际上将附加到服务器双

1037
00:48:45,280 --> 00:48:47,470
日志在这个服务器内存中，所以

1038
00:48:47,470 --> 00:48:49,930
这些队列的总 N 平方浮动 g

1039
00:48:49,930 --> 00:48:54,000
在每个服务器内存中，

1040
00:48:54,000 --> 00:48:56,440
看起来确实有

1041
00:48:56,440 --> 00:48:59,100
一组日志，这些日志意味着我

1042
00:48:59,100 --> 00:49:03,330
将是非易失性的，然后也

1043
00:49:03,330 --> 00:49:06,940
可能是一组单独的消息

1044
00:49:06,940 --> 00:49:09,070
队列，它们仅用于更多的 RPC，

1045
00:49:09,070 --> 00:49:12,610
例如再次通信 在每个

1046
00:49:12,610 --> 00:49:14,320
服务器中，一个队列消息传入

1047
00:49:14,320 --> 00:49:16,480
消息立方体每个其他服务器

1048
00:49:16,480 --> 00:49:28,240
用我们的 DMA 编写实际上写得很好

1049
00:49:28,240 --> 00:49:31,480
，接下来要讨论的是

1050
00:49:31,480 --> 00:49:33,040
论文中的第四年，

1051
00:49:33,040 --> 00:49:39,150
这是四英尺，这解释了

1052
00:49:39,150 --> 00:49:46,480
农场使用的 occ 提交协议，

1053
00:49:46,480 --> 00:49:48,370
我 我将一步一步地完成大部分步骤

1054
00:49:48,370 --> 00:49:51,190
，实际上首先

1055
00:49:51,190 --> 00:49:52,600
我将只关注并发

1056
00:49:52,600 --> 00:49:55,420
控制部分，事实证明这些

1057
00:49:55,420 --> 00:49:58,740
步骤也执行复制以及

1058
00:49:58,740 --> 00:50:01,840
实现可序列化事务，但

1059
00:50:01,840 --> 00:50:04,600
我们将讨论复制 为了

1060
00:50:04,600 --> 00:50:07,990
容错稍晚一点好吧，

1061
00:50:07,990 --> 00:50:08,980
所以发生的第一件事是

1062
00:50:08,980 --> 00:50:11,440
执行阶段，这是 TX 读取

1063
00:50:11,440 --> 00:50:13,750
和 TX 写入原因写入

1064
00:50:13,750 --> 00:50:17,050
客户端事务正在执行和 所以

1065
00:50:17,050 --> 00:50:19,210
这里的每个箭头

1066
00:50:19,210 --> 00:50:21,190
意味着事务在计算机 C 上运行

1067
00:50:21,190 --> 00:50:22,270
，当

1068
00:50:22,270 --> 00:50:26,320
需要读取它使用

1069
00:50:26,320 --> 00:50:29,200
单面 RDMA 的东西时，我们只需

1070
00:50:29,200 --> 00:50:31,990
从相关的主服务器内存中读取它，

1071
00:50:31,990 --> 00:50:34,980
所以我们在这里得到的是主备份

1072
00:50:34,980 --> 00:50:37,450
主备份 三个

1073
00:50:37,450 --> 00:50:39,010
不同分片的主备份，我们

1074
00:50:39,010 --> 00:50:42,370
想象我们的事务使用单面 RDMA

1075
00:50:42,370 --> 00:50:44,470
从每个分片中的一个对象读取某些内容，

1076
00:50:44,470 --> 00:50:47,740
这意味着

1077
00:50:47,740 --> 00:50:50,920
这些快得令人眼花缭乱的 5 微秒

1078
00:50:50,920 --> 00:50:54,670
每个都可以，因此客户端读取

1079
00:50:54,670 --> 00:50:56,350
它需要读取的所有内容 对于事务来说，

1080
00:50:56,350 --> 00:50:58,360
任何要写它的东西都会

1081
00:50:58,360 --> 00:51:01,510
首先读取它必须这样做，这个

1082
00:51:01,510 --> 00:51:04,330
读取必须首先读取，因为它

1083
00:51:04,330 --> 00:51:05,980
需要获取版本

1084
00:51:05,980 --> 00:51:08,830
号，初始版本号是正确的，所以

1085
00:51:08,830 --> 00:51:11,860
这是执行阶段，然后是

1086
00:51:11,860 --> 00:51:14,290
事务调用 TX 提交

1087
00:51:14,290 --> 00:51:18,640
表明它已经完全完成

1088
00:51:18,640 --> 00:51:21,220
了你知道客户端上的 TX 提交调用的库

1089
00:51:21,220 --> 00:51:22,750
充当事务

1090
00:51:22,750 --> 00:51:26,410
协调器并运行整个协议 ol

1091
00:51:26,410 --> 00:51:28,770
这是

1092
00:51:28,770 --> 00:51:35,910
两阶段提交第一阶段的

1093
00:51:35,910 --> 00:51:38,620
一种精细版本，它以消息轮次的形式进行描述，

1094
00:51:38,620 --> 00:51:40,060
因此事务协调器

1095
00:51:40,060 --> 00:51:41,740
发送一堆 LOC 消息并

1096
00:51:41,740 --> 00:51:43,660
等待它们回复，然后验证

1097
00:51:43,660 --> 00:51:45,340
消息并为所有人浪费

1098
00:51:45,340 --> 00:51:48,250
回复，所以提交协议的第一阶段

1099
00:51:48,250 --> 00:51:51,580
是这个阶段的锁定费，

1100
00:51:51,580 --> 00:51:55,060
客户端发送的是它

1101
00:51:55,060 --> 00:52:00,130
向每个主节点发送对象的身份，

1102
00:52:00,130 --> 00:52:02,410
每个对象的对象为写入的客户端

1103
00:52:02,410 --> 00:52:03,850
，并需要将该更新的

1104
00:52:03,850 --> 00:52:06,610
对象发送到相关的 主要的，因此它将

1105
00:52:06,610 --> 00:52:09,040
更新的对象发送到主要的对象，

1106
00:52:09,040 --> 00:52:15,160
并作为您知道此客户端的主要日志中的新日志条目，

1107
00:52:15,160 --> 00:52:18,220
 

1108
00:52:18,220 --> 00:52:20,380
因此客户端真正滥用

1109
00:52:20,380 --> 00:52:22,660
已经附加到主要日志

1110
00:52:22,660 --> 00:52:27,220
，它附加的是令状的对象ID

1111
00:52:27,220 --> 00:52:28,720
对象想要写入

1112
00:52:28,720 --> 00:52:30,820
客户端

1113
00:52:30,820 --> 00:52:33,840
在读取对象时最初读取的版本号

1114
00:52:33,840 --> 00:52:36,270
和新值，

1115
00:52:36,270 --> 00:52:38,430
因此它将您的对象编号

1116
00:52:38,430 --> 00:52:42,270
和新值附加到主登录 对于

1117
00:52:42,270 --> 00:52:43,440
充电的主要海滩，

1118
00:52:43,440 --> 00:52:48,960
它写入了一个对象，所以这些我

1119
00:52:48,960 --> 00:52:51,170
猜这里发生的事情是

1120
00:52:51,170 --> 00:52:53,460
这个事务写了两个不同的

1121
00:52:53,460 --> 00:52:55,320
对象，一个在主对象上，另一个在主对象上

1122
00:52:55,320 --> 00:52:57,630
，以便

1123
00:52:57,630 --> 00:52:59,640
在事务协调器获取时知道何时完成

1124
00:52:59,640 --> 00:53:05,280
好的，所以现在这些

1125
00:53:05,280 --> 00:53:07,050
新的日志记录

1126
00:53:07,050 --> 00:53:09,420
位于主节点的日志中，但主节点

1127
00:53:09,420 --> 00:53:11,640
必须实际主动处理这些日志

1128
00:53:11,640 --> 00:53:14,370
条目，因为它需要检查，并且

1129
00:53:14,370 --> 00:53:15,960
他们会进行一些

1130
00:53:15,960 --> 00:53:18,560
与验证有关的检查，看看是否

1131
00:53:18,560 --> 00:53:20,910
如果这个主节点是事务的一部分，则

1132
00:53:20,910 --> 00:53:23,160
可以允许提交，所以

1133
00:53:23,160 --> 00:53:25,770
此时我们必须等待每个

1134
00:53:25,770 --> 00:53:30,480
主节点轮询主节点内存中的这个客户端日志

1135
00:53:30,480 --> 00:53:32,190
，看看有

1136
00:53:32,190 --> 00:53:34,320
一个新的日志条目并处理那个新的日志

1137
00:53:34,320 --> 00:53:39,210
条目和 然后发送一个是或否投票来

1138
00:53:39,210 --> 00:53:40,710
说明它是否愿意

1139
00:53:40,710 --> 00:53:43,740
做它的事务部分，

1140
00:53:43,740 --> 00:53:46,280
所以当它的

1141
00:53:46,280 --> 00:53:51,540
轮询循环看到传入的锁

1142
00:53:51,540 --> 00:53:56,430
日志时，主节点会做什么 首先，如果

1143
00:53:56,430 --> 00:53:58,500
具有对象 ID 的对象

1144
00:53:58,500 --> 00:54:02,040
当前被阻止，则来自客户端的条目首先

1145
00:54:02,040 --> 00:54:05,280
拒绝此锁定消息并

1146
00:54:05,280 --> 00:54:07,500
使用 RDMA 向客户端发送一条消息，

1147
00:54:07,500 --> 00:54:09,600
说不，不允许此事务

1148
00:54:09,600 --> 00:54:11,790
继续进行 我投反对票并且

1149
00:54:11,790 --> 00:54:13,470
两阶段提交，这将导致

1150
00:54:13,470 --> 00:54:14,940
事务协调器中止

1151
00:54:14,940 --> 00:54:18,290
事务并且另一个未锁定，

1152
00:54:18,290 --> 00:54:21,030
然后主节点要做的下一件事是

1153
00:54:21,030 --> 00:54:22,770
检查它检查的版本号，以

1154
00:54:22,770 --> 00:54:24,150
 

1155
00:54:24,150 --> 00:54:26,190
确保客户端发送给它的版本号是

1156
00:54:26,190 --> 00:54:28,430
最初读取的客户端

1157
00:54:28,430 --> 00:54:31,830
的版本号没有改变，如果版本号

1158
00:54:31,830 --> 00:54:34,290
改变了，这意味着在我们的

1159
00:54:34,290 --> 00:54:35,850
事务读取和

1160
00:54:35,850 --> 00:54:38,760
写入之间，如果

1161
00:54:38,760 --> 00:54:39,900
版本号改变了，那么其他人写了对象，所以

1162
00:54:39,900 --> 00:54:41,790
版本号再次改变，

1163
00:54:41,790 --> 00:54:44,340
主将响应 no 和 禁止

1164
00:54:44,340 --> 00:54:47,040
事务继续，但如果

1165
00:54:47,040 --> 00:54:48,240
版本号与未设置的锁中的版本号相同

1166
00:54:48,240 --> 00:54:50,840
 

1167
00:54:51,080 --> 00:54:57,980
，则主服务器将设置锁并

1168
00:54:57,980 --> 00:55:00,480
返回 现在向客户端返回积极响应，

1169
00:55:00,480 --> 00:55:06,090
因为主节点的

1170
00:55:06,090 --> 00:55:08,160
多线程在多个 CPU 上运行，

1171
00:55:08,160 --> 00:55:10,880
并且可能有其他事务

1172
00:55:10,880 --> 00:55:13,800
可能有其他 CPU 在同一主节点上同时读取

1173
00:55:13,800 --> 00:55:16,290
来自其他客户端的其他传入日志提示

1174
00:55:16,290 --> 00:55:18,900
不同的主

1175
00:55:18,900 --> 00:55:20,250
节点之间可能存在竞争

1176
00:55:20,250 --> 00:55:23,490
事务或锁定

1177
00:55:23,490 --> 00:55:26,480
来自

1178
00:55:26,480 --> 00:55:29,640
尝试修改同一对象的不同事务的时钟记录处理，因此

1179
00:55:29,640 --> 00:55:31,590
主服务器实际上使用原子

1180
00:55:31,590 --> 00:55:33,600
指令比较和交换

1181
00:55:33,600 --> 00:55:39,840
指令，以便

1182
00:55:39,840 --> 00:55:42,030
检查版本号并锁定并

1183
00:55:42,030 --> 00:55:44,820
在该版本号上设置锁定位 作为一个

1184
00:55:44,820 --> 00:55:46,920
原子操作，这就是

1185
00:55:46,920 --> 00:55:48,450
为什么它的锁必须在

1186
00:55:48,450 --> 00:55:49,770
版本号的高位，

1187
00:55:49,770 --> 00:55:55,140
这样一条指令就可以

1188
00:55:55,140 --> 00:55:57,000
对版本号和锁

1189
00:55:57,000 --> 00:56:02,180
位进行比较和交换，现在要注意一件事 就是

1190
00:56:02,180 --> 00:56:05,160
如果对象已经锁定，

1191
00:56:05,160 --> 00:56:07,500
则没有阻塞，则无需

1192
00:56:07,500 --> 00:56:09,000
等待锁被释放，主

1193
00:56:09,000 --> 00:56:12,210
节点只需发回一个知道是否有其他对象

1194
00:56:12,210 --> 00:56:15,060
交易是否已正常

1195
00:56:15,060 --> 00:56:18,390
锁定有关委员会锁定费用的任何问题

1196
00:56:18,390 --> 00:56:23,760
都可以回到

1197
00:56:23,760 --> 00:56:25,230
客户端的趋势头中，该客户端正在充当他的

1198
00:56:25,230 --> 00:56:26,520
交易协调员它等待

1199
00:56:26,520 --> 00:56:28,950
来自分片

1200
00:56:28,950 --> 00:56:31,950
主节点的所有主节点的响应，因此对于每个

1201
00:56:31,950 --> 00:56:34,740
对象

1202
00:56:34,740 --> 00:56:37,050
如果他们中的任何一个说不，则交易被修改，如果他们需要

1203
00:56:37,050 --> 00:56:38,190
拒绝交易，那么

1204
00:56:38,190 --> 00:56:39,840
交易协调员会中止整个

1205
00:56:39,840 --> 00:56:42,180
交易，并实际上

1206
00:56:42,180 --> 00:56:43,920
向所有初选发送消息，说我

1207
00:56:43,920 --> 00:56:46,590
改变了主意，我毕竟不想提交

1208
00:56:46,590 --> 00:56:48,990
这个交易，但如果 他们

1209
00:56:48,990 --> 00:56:50,550
都回答是的所有初选

1210
00:56:50,550 --> 00:56:54,600
回答是然后事务

1211
00:56:54,600 --> 00:56:56,820
协调员认为决定

1212
00:56:56,820 --> 00:57:00,000
交易可以实际提交但

1213
00:57:00,000 --> 00:57:01,410
初选当然不知道

1214
00:57:01,410 --> 00:57:02,820
他们是否都投了赞成票

1215
00:57:02,820 --> 00:57:05,550
所以事务协调员

1216
00:57:05,550 --> 00:57:07,980
必须通知每个球主要 所以

1217
00:57:07,980 --> 00:57:10,560
是的，每个人都投了赞成票，所以

1218
00:57:10,560 --> 00:57:14,660
请实际提交这个，客户这样做的方式

1219
00:57:14,660 --> 00:57:17,400
是附加另一个

1220
00:57:17,400 --> 00:57:20,640
记录到

1221
00:57:20,640 --> 00:57:23,070
每个已修改对象的主节点的日志这次是

1222
00:57:23,070 --> 00:57:26,450
提交备份记录，它是待处理的

1223
00:57:26,450 --> 00:57:30,360
，这次是事务

1224
00:57:30,360 --> 00:57:33,720
协调器，对不起，我确实提交了

1225
00:57:33,720 --> 00:57:35,910
主节点，我跳过了验证，暂时没有

1226
00:57:35,910 --> 00:57:37,170
提交备份 我稍后会讨论

1227
00:57:37,170 --> 00:57:39,630
这些，所以暂时忽略那些

1228
00:57:39,630 --> 00:57:42,030
事务协调器

1229
00:57:42,030 --> 00:57:44,250
继续提交主发送笔，

1230
00:57:44,250 --> 00:57:47,340
将主提交到每个主日志

1231
00:57:47,340 --> 00:57:49,230
，事务协调器只需要

1232
00:57:49,230 --> 00:57:51,710
等待硬件 RDMA

1233
00:57:51,710 --> 00:57:54,270
确认它不必

1234
00:57:54,270 --> 00:57:58,440
等待主节点只是实际

1235
00:57:58,440 --> 00:58:01,050
处理日志记录事务

1236
00:58:01,050 --> 00:58:02,910
协调器一旦

1237
00:58:02,910 --> 00:58:04,560
从

1238
00:58:04,560 --> 00:58:08,760
任何主节点获得一个确认就可以返回是的，好的

1239
00:58:08,760 --> 00:58:10,590
等于事务的真，

1240
00:58:10,590 --> 00:58:12,950
表示事务六

1241
00:58:12,950 --> 00:58:16,050
成功，然后还有另一个

1242
00:58:16,050 --> 00:58:20,100
稍后的阶段，一旦事务

1243
00:58:20,100 --> 00:58:21,900
协调员知道每个主

1244
00:58:21,900 --> 00:58:24,360
节点都知道事务协调已

1245
00:58:24,360 --> 00:58:29,430
提交，您就可以告诉所有人

1246
00:58:29,430 --> 00:58:30,630
他们可以丢弃

1247
00:58:30,630 --> 00:58:35,250
此事务的所有日志条目的初选 好的 现在

1248
00:58:35,250 --> 00:58:37,800
还有最后一件事必须

1249
00:58:37,800 --> 00:58:40,080
发生 初选正在

1250
00:58:40,080 --> 00:58:42,410
查看他们的轮询长的日志

1251
00:58:42,410 --> 00:58:44,370
他们会注意到

1252
00:58:44,370 --> 00:58:46,830
在某个时候有一个提交主要记录然后

1253
00:58:46,830 --> 00:58:49,050
在接收到提交

1254
00:58:49,050 --> 00:58:53,100
主日志条目的主节点上，它将知道它

1255
00:58:53,100 --> 00:58:58,020
之前已锁定该对象并且

1256
00:58:58,020 --> 00:58:59,430
该对象仍必须被锁定，

1257
00:58:59,430 --> 00:59:01,710
因此主节点将

1258
00:59:01,710 --> 00:59:03,420
使用先前发送的新内容更新其内存中的对象

1259
00:59:03,420 --> 00:59:05,430
 

1260
00:59:05,430 --> 00:59:07,500
锁定消息我增加

1261
00:59:07,500 --> 00:59:09,030
与该对象关联的版本号

1262
00:59:09,030 --> 00:59:11,130
并最终清除该对象上的锁定位

1263
00:59:11,130 --> 00:59:13,860
，这意味着

1264
00:59:13,860 --> 00:59:16,190
一旦主

1265
00:59:16,190 --> 00:59:18,710
节点接收并处理提交主

1266
00:59:18,710 --> 00:59:21,740
日志消息，它可能会因为它清除

1267
00:59:21,740 --> 00:59:24,349
锁定 位并更新数据 它很

1268
00:59:24,349 --> 00:59:27,079
可能将此新数据暴露给

1269
00:59:27,079 --> 00:59:28,700
其他事务 在此之后的其他事务

1270
00:59:28,700 --> 00:59:30,920
可以自由使用它 可以

1271
00:59:30,920 --> 00:59:34,099
自由使用具有其 ne 的对象 w 值和

1272
00:59:34,099 --> 00:59:40,720
新版本号 好的 我

1273
00:59:40,720 --> 00:59:44,300
要做一个例子

1274
00:59:44,300 --> 00:59:46,520
在我开始考虑一个例子之前有任何关于机器的

1275
00:59:46,520 --> 00:59:51,880
问题 随时可以提问

1276
00:59:51,880 --> 00:59:55,520
好吧 举个例子

1277
00:59:55,520 --> 00:59:59,150
假设我们有两个事务

1278
00:59:59,150 --> 01:00:02,089
事务一个和事务 两个，

1279
01:00:02,089 --> 01:00:03,349
他们都在尝试做同样的事情，

1280
01:00:03,349 --> 01:00:09,800
他们都只想增加 X X 是

1281
01:00:09,800 --> 01:00:12,380
位于某些服务器

1282
01:00:12,380 --> 01:00:18,050
内存中的对象，所以我们都有两个

1283
01:00:18,050 --> 01:00:19,460
事务正在运行，

1284
01:00:19,460 --> 01:00:21,050
在我们查看实际

1285
01:00:21,050 --> 01:00:22,940
发生的情况之前，我们应该提醒自己什么

1286
01:00:22,940 --> 01:00:26,420
有效的可能性是针对

1287
01:00:26,420 --> 01:00:30,619
结果的，所以这都是关于可

1288
01:00:30,619 --> 01:00:32,300
序列化农场保证的

1289
01:00:32,300 --> 01:00:33,859
序列化能力，这意味着

1290
01:00:33,859 --> 01:00:35,690
无论农场实际做什么，它都必须

1291
01:00:35,690 --> 01:00:37,940
相当于一次

1292
01:00:37,940 --> 01:00:40,220
执行这两个事务，所以

1293
01:00:40,220 --> 01:00:41,960
我们可以看到是 结果你

1294
01:00:41,960 --> 01:00:44,660
会看到 t1 是否运行，然后严格地

1295
01:00:44,660 --> 01:00:47,390
在 t2 运行之后，或者我们

1296
01:00:47,390 --> 01:00:50,270
可以看到如果 t2 运行

1297
01:00:50,270 --> 01:00:52,280
然后 t1 运行那些 a 现在唯一

1298
01:00:52,280 --> 01:00:57,230
的可能性实际上是农场

1299
01:00:57,230 --> 01:01:00,230
有权中止交易，因此我们

1300
01:01:00,230 --> 01:01:01,579
还必须考虑

1301
01:01:01,579 --> 01:01:03,500
两个交易中的一个中止

1302
01:01:03,500 --> 01:01:06,410
或实际上它们都中止的可能性，因为

1303
01:01:06,410 --> 01:01:08,359
他们都在做同样的事情，

1304
01:01:08,359 --> 01:01:09,980
所以有一定数量 这里是对称的

1305
01:01:09,980 --> 01:01:15,079
，所以一种可能性是

1306
01:01:15,079 --> 01:01:18,410
它们都已提交，这意味着

1307
01:01:18,410 --> 01:01:20,599
发生了两次增量，因此一种合法的

1308
01:01:20,599 --> 01:01:24,940
可能性是 X 等于 2

1309
01:01:25,359 --> 01:01:28,710
，然后 TX

1310
01:01:28,710 --> 01:01:30,390
它必须同意事情是否

1311
01:01:30,390 --> 01:01:35,490
有点或中止或提交，以便两个

1312
01:01:35,490 --> 01:01:40,170
事务都需要 在这种情况下，CTX 提交返回

1313
01:01:40,170 --> 01:01:44,820
true 另一种可能性是

1314
01:01:44,820 --> 01:01:46,950
，其中只有一个事务已

1315
01:01:46,950 --> 01:01:48,930
提交，另一个已中止，然后

1316
01:01:48,930 --> 01:01:52,830
我们只想看到一个为真，

1317
01:01:52,830 --> 01:01:56,820
另一个为假，另一种可能性

1318
01:01:56,820 --> 01:01:58,619
可能它们都已中止，我们认为

1319
01:01:58,619 --> 01:02:00,900
这不一定 发生但它

1320
01:02:00,900 --> 01:02:03,720
实际上是合法的，因此 X 不会被更改

1321
01:02:03,720 --> 01:02:09,109
，我们希望两者都从 TX 提交中得到错误的返回，

1322
01:02:09,650 --> 01:02:14,550
所以我们最好不要看到

1323
01:02:14,550 --> 01:02:18,859
除了这些之外的任何东西 ree 选项

1324
01:02:21,230 --> 01:02:24,060
好吧，所以当然会发生什么

1325
01:02:24,060 --> 01:02:29,089
取决于时间，所以我将

1326
01:02:31,550 --> 01:02:33,420
整合

1327
01:02:33,420 --> 01:02:35,849
提交协议可以在早期

1328
01:02:35,849 --> 01:02:39,349
甚至为了方便的各种不同方式我有一个方便的

1329
01:02:39,349 --> 01:02:41,760
提醒，这里的实际提交

1330
01:02:41,760 --> 01:02:46,320
协议是什么所以一种可能性

1331
01:02:46,320 --> 01:02:51,930
是他们完全同步运行他们

1332
01:02:51,930 --> 01:02:55,470
都同时发送所有消息

1333
01:02:55,470 --> 01:02:57,810
他们都同时阅读我

1334
01:02:57,810 --> 01:02:59,339
将假设X开始

1335
01:02:59,339 --> 01:03:00,810
为零如果他们同时阅读

1336
01:03:00,810 --> 01:03:03,119
我们将要 看

1337
01:03:03,119 --> 01:03:05,040
 

1338
01:03:05,040 --> 01:03:07,430
 

1339
01:03:08,660 --> 01:03:10,069
 

1340
01:03:10,069 --> 01:03:11,720
 

1341
01:03:11,720 --> 01:03:13,640
 

1342
01:03:13,640 --> 01:03:16,309
 

1343
01:03:16,309 --> 01:03:19,670
零 两者同时提交

1344
01:03:19,670 --> 01:03:25,579
，所以如果这是这种

1345
01:03:25,579 --> 01:03:30,549
情况，将会发生什么以及为什么

1346
01:03:31,690 --> 01:03:33,750
 

1347
01:03:34,650 --> 01:03:37,870
他们喜欢举手并冒险

1348
01:03:37,870 --> 01:03:39,960
 

1349
01:03:48,420 --> 01:03:50,350
猜测，这是一个非常好的领域，

1350
01:03:50,350 --> 01:03:52,480
因为这是一个片面的阅读，

1351
01:03:52,480 --> 01:03:55,630
他们不可能失败 是b 实际上，其他人会

1352
01:03:55,630 --> 01:03:59,920
向任何主持有对象 X 发送相同的步行消息

1353
01:03:59,920 --> 01:04:04,270
，我都

1354
01:04:04,270 --> 01:04:06,130
发送相同的版本号，但

1355
01:04:06,130 --> 01:04:08,620
他们读取的版本号和相同的值，所以

1356
01:04:08,620 --> 01:04:10,860
主节点会看到日志意味着

1357
01:04:10,860 --> 01:04:14,800
在两个不同的传入日志中记录消息，

1358
01:04:14,800 --> 01:04:16,930
假设这些 正在

1359
01:04:16,930 --> 01:04:23,680
不同的客户端上运行，而现在究竟发生了什么，这完全

1360
01:04:23,680 --> 01:04:25,660
取决于我们的

1361
01:04:25,660 --> 01:04:28,390
想象，但我认为

1362
01:04:28,390 --> 01:04:29,920
两个传入的日志消息可以

1363
01:04:29,920 --> 01:04:31,960
 

1364
01:04:31,960 --> 01:04:35,410
在主节点的不同核心上并行处理，但主节点的关键

1365
01:04:35,410 --> 01:04:37,630
指令是原子

1366
01:04:37,630 --> 01:04:41,550
测试 并准确地设置或比较和交换

1367
01:04:41,550 --> 01:04:44,200
某人的自愿答案，即他们中的

1368
01:04:44,200 --> 01:04:46,570
一个人将首先获得比较和交换

1369
01:04:46,570 --> 01:04:51,790
指令以及我首先

1370
01:04:51,790 --> 01:04:53,800
猜测比较和交换指令的哪个核心，

1371
01:04:53,800 --> 01:04:58,470
它将在该对象版本上设置锁定位

1372
01:04:58,470 --> 01:05:00,640
并观察

1373
01:05:00,640 --> 01:05:03,130
锁定位之前没有设置，

1374
01:05:03,130 --> 01:05:04,990
每个人都执行原子

1375
01:05:04,990 --> 01:05:06,880
比较和交换第二个将观察

1376
01:05:06,880 --> 01:05:08,890
已经设置的锁定我的意思是他是

1377
01:05:08,890 --> 01:05:11,020
e 两者中的一个将返回是，而

1378
01:05:11,020 --> 01:05:13,900
另外两个将失败锁 观察

1379
01:05:13,900 --> 01:05:17,320
锁已设置为不成熟的 no 并且您

1380
01:05:17,320 --> 01:05:19,450
知道它是对称的

1381
01:05:19,450 --> 01:05:24,070
 

1382
01:05:24,070 --> 01:05:25,900
 

1383
01:05:25,900 --> 01:05:29,520
使用客户端代码将中止事务 1

1384
01:05:29,520 --> 01:05:32,110
我得到了锁，得到了一个是的回复，它

1385
01:05:32,110 --> 01:05:35,200
会在它到来时实际提交

1386
01:05:35,200 --> 01:05:38,109
当主服务器实际收到

1387
01:05:38,109 --> 01:05:40,450
提交消息时，它将安装更新的

1388
01:05:40,450 --> 01:05:41,109
对象，

1389
01:05:41,109 --> 01:05:43,750
你知道增量以清除锁定

1390
01:05:43,750 --> 01:05:46,119
位 增加版本并返回

1391
01:05:46,119 --> 01:05:51,670
true 这会说 true 因为

1392
01:05:51,670 --> 01:05:55,750
另一个主要发送回来我知道这

1393
01:05:55,750 --> 01:05:57,490
意味着 TX 提交将

1394
01:05:57,490 --> 01:06:00,760
在这里返回 false 并且最终值将是 x

1395
01:06:00,760 --> 01:06:03,280
等于一个这是我们允许的

1396
01:06:03,280 --> 01:06:06,400
结果之一但当然它不是

1397
01:06:06,400 --> 01:06:12,070
只是留下任何关于它

1398
01:06:12,070 --> 01:06:16,060
如何发挥或广泛执行的问题

1399
01:06:16,060 --> 01:06:18,300
，

1400
01:06:19,890 --> 01:06:21,760
所以还有其他可能的

1401
01:06:21,760 --> 01:06:25,930
交错所以这个怎么样

1402
01:06:25,930 --> 01:06:30,880
让我们想象事务

1403
01:06:30,880 --> 01:06:33,780
2首先完成

1404
01:06:33,780 --> 01:06:37,630
节拍 e 读取

1405
01:06:37,630 --> 01:06:39,430
是否并发并不重要，然后事务

1406
01:06:39,430 --> 01:06:41,080
一不读取，然后事务运行

1407
01:06:41,080 --> 01:06:43,090
得更快一点，它

1408
01:06:43,090 --> 01:06:47,350
获取锁定消息和

1409
01:06:47,350 --> 01:06:50,610
回复并返回提交，然后

1410
01:06:50,610 --> 01:06:55,560
事务二开始 再次

1411
01:06:55,560 --> 01:06:58,060
发送一个锁定消息，如果它可以

1412
01:06:58,060 --> 01:07:03,630
提交，那么这次发生的事情

1413
01:07:16,690 --> 01:07:20,900
是这个法律专员

1414
01:07:20,900 --> 01:07:22,670
会成功，因为没有理由

1415
01:07:22,670 --> 01:07:24,530
相信有一个锁定位被设置，

1416
01:07:24,530 --> 01:07:26,780
因为第二个锁定消息甚至还没有

1417
01:07:26,780 --> 01:07:28,970
被发送消息我们 'll set the

1418
01:07:28,970 --> 01:07:31,160
lock the commit message 此提交

1419
01:07:31,160 --> 01:07:32,359
主消息实际上应该

1420
01:07:32,359 --> 01:07:35,630
稍微清除锁，以便在

1421
01:07:35,630 --> 01:07:39,920
t2 人口普查将其锁条目插入主日志时，锁位将被清除，

1422
01:07:39,920 --> 01:07:49,609
因此

1423
01:07:49,609 --> 01:07:51,380
主将不会看到锁 在

1424
01:07:51,380 --> 01:07:54,020
这一点上设置是的，所以有人

1425
01:07:54,020 --> 01:07:57,829
自愿说这个主节点会

1426
01:07:57,829 --> 01:08:00,140
看到版本号，

1427
01:08:00,140 --> 01:08:01,940
所以锁定消息包含

1428
01:08:01,940 --> 01:08:03,380
事务最初

1429
01:08:03,380 --> 01:08:05,960
读取的版本号，所以主节点会看到

1430
01:08:05,960 --> 01:08:08,660
等一下，因为提交

1431
01:08:08,660 --> 01:08:11,079
版本号的主要增量，主要版本

1432
01:08:11,079 --> 01:08:12,980
号会看到版本

1433
01:08:12,980 --> 01:08:14,300
号是错误的，现在

1434
01:08:14,300 --> 01:08:16,100
真实对象上的数字更高，所以它

1435
01:08:16,100 --> 01:08:20,149
实际上会向协调器发送一个 no 响应

1436
01:08:20,149 --> 01:08:24,350
，协调

1437
01:08:24,350 --> 01:08:26,600
器将中止 这个交易，

1438
01:08:26,600 --> 01:08:29,420
我们将再次获得 x 等于 1

1439
01:08:29,420 --> 01:08:31,040
一个交易返回 true 另一个

1440
01:08:31,040 --> 01:08:35,988
返回 false，这

1441
01:08:35,988 --> 01:08:40,279
与之前的最终结果相同，并且允许任何

1442
01:08:40,279 --> 01:08:44,259
关于如何发挥作用的问题，一个

1443
01:08:44,259 --> 01:08:47,299
稍微不同的场景

1444
01:08:47,299 --> 01:08:51,380
就像和 实际上还可以，

1445
01:08:51,380 --> 01:08:52,609
我会想到的稍微不同的场景

1446
01:08:52,609 --> 01:08:54,880
是提交

1447
01:08:54,880 --> 01:08:57,770
消息被偷了它发生在这个

1448
01:08:57,770 --> 01:08:59,870
锁之后这基本上与

1449
01:08:59,870 --> 01:09:04,310
这个事务

1450
01:09:04,310 --> 01:09:05,750
在这个事务中设置了锁的第一个场景相同，

1451
01:09:05,750 --> 01:09:10,660
观察锁好

1452
01:09:10,660 --> 01:09:18,488
每个人最后一个场景让我们假设

1453
01:09:18,488 --> 01:09:21,939
我们看到

1454
01:09:32,180 --> 01:09:34,050
这这次会发生什么

1455
01:09:34,050 --> 01:09:37,149
[音乐]

1456
01:09:47,689 --> 01:09:51,870
是的，有人有正确的

1457
01:09:51,870 --> 01:09:53,310
答案 rse 第一个事务将通过，因为第一个事务中

1458
01:09:53,310 --> 01:09:54,810
没有争用

1459
01:09:54,810 --> 01:09:56,340
第二个

1460
01:09:56,340 --> 01:09:58,530
事务在读取 X 时

1461
01:09:58,530 --> 01:10:02,100
实际上会看到新版本号随着

1462
01:10:02,100 --> 01:10:04,830
主

1463
01:10:04,830 --> 01:10:07,710
节点上的提交主处理而增加，因此它会

1464
01:10:07,710 --> 01:10:09,750
看到新版本号

1465
01:10:09,750 --> 01:10:11,760
不会设置的锁，所以当它去

1466
01:10:11,760 --> 01:10:16,550
发送它的锁日志条目到主

1467
01:10:16,550 --> 01:10:19,140
锁时，锁在主锁中的处理代码

1468
01:10:19,140 --> 01:10:21,390
锁没有设置并且

1469
01:10:21,390 --> 01:10:23,340
版本是相同的，这不是

1470
01:10:23,340 --> 01:10:24,810
最新的 版本和我想要

1471
01:10:24,810 --> 01:10:26,460
提交的所有内容，因此我们

1472
01:10:26,460 --> 01:10:29,970
将看到的结果是 x 等于 2，因为这

1473
01:10:29,970 --> 01:10:31,290
不仅读取了新版本，

1474
01:10:31,290 --> 01:10:32,580
而且实际上读取了新值，它

1475
01:10:32,580 --> 01:10:40,490
是 1，所以这里不正确，

1476
01:10:40,490 --> 01:10:47,370
两个调用 到 TX 提交将是真的是的

1477
01:10:47,370 --> 01:10:51,080
，这是正确的，成功它 x 等于 2

1478
01:10:51,080 --> 01:10:53,430
好吧，所以你知道这

1479
01:10:53,430 --> 01:10:56,970
恰好在这些情况下解决

1480
01:10:56,970 --> 01:10:59,730
了为什么乐观并发

1481
01:10:59,730 --> 01:11:03,180
控制提供可串行化背后的直觉为什么

1482
01:11:03,180 --> 01:11:06,840
它为什么基本上

1483
01:11:06,840 --> 01:11:09,810
检查确实发生的执行是否与

1484
01:11:09,810 --> 01:11:13,830
一次执行相同，本质

1485
01:11:13,830 --> 01:11:15,690
上直觉是，如果没有

1486
01:11:15,690 --> 01:11:17,880
冲突的事务，那么版本

1487
01:11:17,880 --> 01:11:19,110
号和锁定位不会

1488
01:11:19,110 --> 01:11:20,610
改变，如果没有其他人弄乱

1489
01:11:20,610 --> 01:11:23,760
这些对象你 知道我会

1490
01:11:23,760 --> 01:11:25,020
在事务结束

1491
01:11:25,020 --> 01:11:27,690
时看到与我们第一次

1492
01:11:27,690 --> 01:11:30,420
读取对象时相同的版本号，而如果

1493
01:11:30,420 --> 01:11:32,190
 

1494
01:11:32,190 --> 01:11:33,750
在我们读取对象和尝试

1495
01:11:33,750 --> 01:11:37,780
提交更改之间存在冲突事务并且冲突

1496
01:11:37,780 --> 01:11:42,070
修改了某些内容 然后如果它真的

1497
01:11:42,070 --> 01:11:43,810
开始提交，我们将看到一个新的

1498
01:11:43,810 --> 01:11:47,320
版本号或一个锁定位设置，因此

1499
01:11:47,320 --> 01:11:48,850
版本号

1500
01:11:48,850 --> 01:11:49,870
和锁定位的比较在你第一次

1501
01:11:49,870 --> 01:11:51,190
读取对象和最终

1502
01:11:51,190 --> 01:11:53,830
提交它时告诉你是否有

1503
01:11:53,830 --> 01:11:56,370
其他 承诺

1504
01:11:56,370 --> 01:12:02,500
在你使用它们的时候偷偷溜进去，

1505
01:12:02,500 --> 01:12:03,940
你知道这里要记住的很酷的事情

1506
01:12:03,940 --> 01:12:08,400
是，这允许我们

1507
01:12:08,400 --> 01:12:11,140
使用这种乐观模式进行读取

1508
01:12:11,140 --> 01:12:13,300
只有

1509
01:12:13,300 --> 01:12:15,310
当我们第一次使用数据时，我们才真正检查锁允许我们

1510
01:12:15,310 --> 01:12:17,290
使用这个非常快的单面

1511
01:12:17,290 --> 01:12:20,470
已经读取数据并

1512
01:12:20,470 --> 01:12:24,790
获得高性能，所以我

1513
01:12:24,790 --> 01:12:28,210
到目前为止解释它的方式没有验证和

1514
01:12:28,210 --> 01:12:29,980
没有 提交备份是

1515
01:12:29,980 --> 01:12:34,600
系统的工作方式，但正如我所见，验证是

1516
01:12:34,600 --> 01:12:38,260
一种仅

1517
01:12:38,260 --> 01:12:41,560
读取对象但不写入对象的优化，并且

1518
01:12:41,560 --> 01:12:43,750
作为容错方案的一部分提交备份

1519
01:12:43,750 --> 01:12:46,180
我想我会花

1520
01:12:46,180 --> 01:12:47,230
几分钟时间我们 已经离开了，我想

1521
01:12:47,230 --> 01:12:52,900
谈谈验证，所以验证阶段

1522
01:12:52,900 --> 01:12:56,200
是一种优化，用于处理

1523
01:12:56,200 --> 01:12:57,610
我们仅由

1524
01:12:57,610 --> 01:12:59,530
事务读取而我没有写入的对象，

1525
01:12:59,530 --> 01:13:00,880
如果

1526
01:13:00,880 --> 01:13:03,040
它是一个直接的只读事务，它将特别有趣

1527
01:13:03,040 --> 01:13:05,920
没有修改任何内容，您知道

1528
01:13:05,920 --> 01:13:08,740
优化

1529
01:13:08,740 --> 01:13:11,290
是事务协调器可以

1530
01:13:11,290 --> 01:13:13,000
通过非常快的单面读取来执行验证，

1531
01:13:13,000 --> 01:13:15,460
而不

1532
01:13:15,460 --> 01:13:17,380
必将某些内容放在日志上并

1533
01:13:17,380 --> 01:13:20,140
等待 pri 玛丽看到我们的日志

1534
01:13:20,140 --> 01:13:22,860
条目并考虑一下，所以这

1535
01:13:22,860 --> 01:13:24,700
验证了单面 B 会

1536
01:13:24,700 --> 01:13:26,740
快得多它基本上会

1537
01:13:26,740 --> 01:13:28,990
取代锁定对象，只会

1538
01:13:28,990 --> 01:13:32,100
读取它会快得多

1539
01:13:35,210 --> 01:13:36,830
基本上这里发生的事情

1540
01:13:36,830 --> 01:13:41,900
是什么 验证所做的是

1541
01:13:41,900 --> 01:13:44,870
事务协调器 refetch 是

1542
01:13:44,870 --> 01:13:46,610
对象标头，因此您知道它会

1543
01:13:46,610 --> 01:13:49,040
在执行阶段读取一个对象，

1544
01:13:49,040 --> 01:13:51,380
当它提交它

1545
01:13:51,380 --> 01:13:54,140
而不是发送锁定消息时，它会

1546
01:13:54,140 --> 01:13:56,900
获取对象命中标头并检查

1547
01:13:56,900 --> 01:13:59,660
版本是否 现在的数字

1548
01:13:59,660 --> 01:14:01,940
与它第一次读取对象时的版本号相同

1549
01:14:01,940 --> 01:14:03,860
，它还会检查它

1550
01:14:03,860 --> 01:14:10,070
的锁定是否清晰，所以这就是

1551
01:14:10,070 --> 01:14:10,670
它的工作原理，

1552
01:14:10,670 --> 01:14:12,110
所以与其设置锁定消息，

1553
01:14:12,110 --> 01:14:13,640
不如发送此验证消息应该

1554
01:14:13,640 --> 01:14:17,990
更快地读取 -only 操作所以

1555
01:14:17,990 --> 01:14:21,310
让我提出另一个事务

1556
01:14:21,310 --> 01:14:23,660
示例并运行它是如何工作的

1557
01:14:23,660 --> 01:14:26,480
让我们假设 x 和 y 最初为 0 我们

1558
01:14:26,480 --> 01:14:32,630
有两个事务 t1 如果 X

1559
01:14:32,630 --> 01:14:40,060
等于零设置 y 等于 e 和 T 两个表示

1560
01:14:40,060 --> 01:14:43,870
如果 Y 为零，则

1561
01:14:44,670 --> 01:14:47,679
表示 x 等于 1，但这是一个

1562
01:14:47,679 --> 01:14:51,579
绝对经典的

1563
01:14:51,579 --> 01:14:56,800
 

1564
01:14:56,800 --> 01:15:00,820
 

1565
01:15:00,820 --> 01:15:05,139
 

1566
01:15:05,139 --> 01:15:07,030
强一致性测试

1567
01:15:07,030 --> 01:15:08,710
 

1568
01:15:08,710 --> 01:15:10,900
 

1569
01:15:10,900 --> 01:15:13,719
如果你运行 T 1 然后 t2 你会

1570
01:15:13,719 --> 01:15:18,909
得到 y 等于 1 和 x 等于 0，那么实现必须得到相同的结果，它一次运行一个，

1571
01:15:18,909 --> 01:15:21,280
因为第二个 if 语句 Y 已经是

1572
01:15:21,280 --> 01:15:22,329
1 第二个 if 语句不会 做

1573
01:15:22,329 --> 01:15:26,469
任何事情并且对称地这

1574
01:15:26,469 --> 01:15:31,050
会给你 x 等于 1 和 y 等于 0

1575
01:15:31,050 --> 01:15:33,519
事实证明，如果你如果他们都

1576
01:15:33,519 --> 01:15:36,489
中止你可以得到 x 等于 0 y 等于 0

1577
01:15:36,489 --> 01:15:38,409
但你绝对

1578
01:15:38,409 --> 01:15:45,010
不允许得到的是 x 等于 1 y 等于 1 那是

1579
01:15:45,010 --> 01:15:47,340
不允许

1580
01:15:48,269 --> 01:15:53,920
 

1581
01:15:53,920 --> 01:15:56,409
 

1582
01:15:56,409 --> 01:15:58,619
 

1583
01:15:58,619 --> 01:16:04,989
 

1584
01:16:04,989 --> 01:16:06,909
 

1585
01:16:06,909 --> 01:16:11,530
的 它吃

1586
01:16:11,530 --> 01:16:17,260
那是最难的情况 y 所以我们

1587
01:16:17,260 --> 01:16:21,659
已经读过 X 遇到 Y

1588
01:16:27,719 --> 01:16:29,250
为什么因为我们写了它并锁定了为什么

1589
01:16:29,250 --> 01:16:35,250
我在这里锁定了 X 但是现在

1590
01:16:35,250 --> 01:16:37,440
我们正在使用这个只读的验证

1591
01:16:37,440 --> 01:16:39,000
优化，这意味着这个必须

1592
01:16:39,000 --> 01:16:41,580
验证为什么这个有 要验证 X，

1593
01:16:41,580 --> 01:16:43,560
你知道它是一个红色 X，但没有写

1594
01:16:43,560 --> 01:16:45,090
它，所以它会更快地验证它

1595
01:16:45,090 --> 01:16:47,010
，也许它会提交

1596
01:16:47,010 --> 01:16:50,370
，也许它是，所以问题是

1597
01:16:50,370 --> 01:16:53,160
我们是否像我描述的那样使用这个验证，

1598
01:16:53,160 --> 01:16:54,719
它只是检查 版本号和

1599
01:16:54,719 --> 01:16:56,610
锁，但没有版本号

1600
01:16:56,610 --> 01:16:58,610
在锁中没有改变，但没有设置

1601
01:16:58,610 --> 01:17:03,560
我们会得到一个正确的答案

1602
01:17:22,599 --> 01:17:25,780
，实际上两者的验证

1603
01:17:25,780 --> 01:17:29,469
都会失败，因为当这些

1604
01:17:29,469 --> 01:17:31,599
LOC 消息由

1605
01:17:31,599 --> 01:17:33,489
相关处理时 初选它们导致 LOC

1606
01:17:33,489 --> 01:17:36,909
有点只是最初设置

1607
01:17:36,909 --> 01:17:38,710
的原因大概是清除锁仓的原因，

1608
01:17:38,710 --> 01:17:42,489
但是当我们来验证时，

1609
01:17:42,489 --> 01:17:44,949
即使客户端正在

1610
01:17:44,949 --> 01:17:48,820
对 X&Y 的对象标头进行单向读取，它

1611
01:17:48,820 --> 01:17:50,860
也会看到锁 进程设置的位

1612
01:17:50,860 --> 01:17:54,900
这些锁定请求

1613
01:17:55,320 --> 01:17:57,309
，所以他们都会

1614
01:17:57,309 --> 01:17:59,800
看到他们只是读取的对象上设置的锁定位

1615
01:17:59,800 --> 01:18:04,530
，他们都会中止，

1616
01:18:04,530 --> 01:18:08,289
X 和 Y 都不会被修改，所以

1617
01:18:08,289 --> 01:18:10,110
这是法律结果

1618
01:18:10,110 --> 01:18:12,429
之一 有人注意到

1619
01:18:12,429 --> 01:18:16,469
这确实两个验证都会失败

1620
01:18:16,469 --> 01:18:19,570
另一个当然有时

1621
01:18:19,570 --> 01:18:21,519
事务可以通过，这是一个

1622
01:18:21,519 --> 01:18:27,519
场景，它确实解决了

1623
01:18:27,519 --> 01:18:30,039
这是事务一个更快一点

1624
01:18:30,039 --> 01:18:33,840
 

1625
01:18:43,830 --> 01:18:45,670
验证没关系所以会发生什么

1626
01:18:45,670 --> 01:18:50,680
事务一个是 快一点，

1627
01:18:50,680 --> 01:19:05,080
所以这次它验证会

1628
01:19:05,080 --> 01:19:07,120
成功，因为

1629
01:19:07,120 --> 01:19:09,640
在事务 1 读取它和验证它之间 X 没有发生任何事情，

1630
01:19:09,640 --> 01:19:12,670
所以大概锁

1631
01:19:12,670 --> 01:19:14,140
也没有任何问题通过，

1632
01:19:14,140 --> 01:19:15,790
因为这里也没有人修改 Y，

1633
01:19:15,790 --> 01:19:18,900
所以主节点对此回答是

1634
01:19:18,900 --> 01:19:21,520
单面读取在这里显示了未更改的

1635
01:19:21,520 --> 01:19:24,520
版本号和锁定位，因此

1636
01:19:24,520 --> 01:19:26,890
事务一可以提交，并且

1637
01:19:26,890 --> 01:19:29,590
它将增加 Y，但此时如果

1638
01:19:29,590 --> 01:19:32,440
这 是主进程时的顺序，

1639
01:19:32,440 --> 01:19:37,360
实际上当

1640
01:19:37,360 --> 01:19:38,740
主进程被 X 锁定时，这

1641
01:19:38,740 --> 01:19:40,000
也将毫无问题地通过，因为

1642
01:19:40,000 --> 01:19:43,840
当 Y 的主进程处理 Y 的验证时，没有人修改 X，

1643
01:19:43,840 --> 01:19:47,580
尽管

1644
01:19:47,580 --> 01:19:51,460
在客户端运行时我很抱歉

1645
01:19:51,460 --> 01:19:54,910
transaction 2 refetch 是

1646
01:19:54,910 --> 01:19:57,400
为 y 解锁的版本号 它要么

1647
01:19:57,400 --> 01:19:59,830
会看到这真的取决于

1648
01:19:59,830 --> 01:20:02,050
委员会是否发生如果提交

1649
01:20:02,050 --> 01:20:03,820
还没有发生，这个有效的 a 将

1650
01:20:03,820 --> 01:20:05,320
看到锁定位被设置，因为

1651
01:20:05,320 --> 01:20:07,150
如果它被设置回这里 提交

1652
01:20:07,150 --> 01:20:09,640
已经发生，然后锁定位

1653
01:20:09,640 --> 01:20:11,460
将被清除，但是这个验证

1654
01:20:11,460 --> 01:20:13,270
单面阅读器将看到与最初看到的不同的

1655
01:20:13,270 --> 01:20:17,020
版本号

1656
01:20:17,020 --> 01:20:18,910
，它需要有人它只是这个

1657
01:20:18,910 --> 01:20:20,890
答案，所以一个人将提交，以便

1658
01:20:20,890 --> 01:20:23,280
事务一将提交和

1659
01:20:23,280 --> 01:20:25,410
事务 将中止

1660
01:20:25,410 --> 01:20:27,460
，虽然我没有时间在

1661
01:20:27,460 --> 01:20:29,410
这里谈论它，如果有一个直接的

1662
01:20:29,410 --> 01:20:31,300
只读事务，那么

1663
01:20:31,300 --> 01:20:33,400
就不需要锁定阶段，

1664
01:20:33,400 --> 01:20:35,290
也不需要 是一个提交阶段，纯

1665
01:20:35,290 --> 01:20:36,880
只读事务可以通过

1666
01:20:36,880 --> 01:20:39,670
只读取读取的盲读来完成，

1667
01:20:39,670 --> 01:20:40,150
 

1668
01:20:40,150 --> 01:20:42,360
抱歉，单面 RDMA 读取读取，

1669
01:20:42,360 --> 01:20:44,350
一方面我已经读取了

1670
01:20:44,350 --> 01:20:46,240
验证，因此它们是非常快的

1671
01:20:46,240 --> 01:20:48,700
只读事务

1672
01:20:48,700 --> 01:20:52,300
不需要任何工作都需要服务器的任何关注，

1673
01:20:52,300 --> 01:20:54,060
 

1674
01:20:54,060 --> 01:20:58,080
所以这是核心，你知道

1675
01:20:58,080 --> 01:21:00,360
这些读取的趋势，事实上，尽管

1676
01:21:00,360 --> 01:21:04,070
关于农场的一切都非常

1677
01:21:04,070 --> 01:21:06,450
精简 - 部分原因是我们的 DMA

1678
01:21:06,450 --> 01:21:09,630
并且它使用 OCC，因为它基本上是

1679
01:21:09,630 --> 01:21:12,630
被迫的 为了能够在

1680
01:21:12,630 --> 01:21:15,720
不检查锁的情况下进行读取，有

1681
01:21:15,720 --> 01:21:17,370
一些棕色的缺点，尽管事实证明，

1682
01:21:17,370 --> 01:21:18,930
 

1683
01:21:18,930 --> 01:21:20,790
如果冲突相对较少，

1684
01:21:20,790 --> 01:21:23,070
如果始终存在冲突，

1685
01:21:23,070 --> 01:21:26,190
那么乐观并发控制确实最有效，那么事务将不得不启动，

1686
01:21:26,190 --> 01:21:27,570
并且有一个你知道的一堆

1687
01:21:27,570 --> 01:21:29,340
我已经提到过的其他限制，

1688
01:21:29,340 --> 01:21:31,950
比如在农场上，比如数据必须全部

1689
01:21:31,950 --> 01:21:33,990
放入 RAM 中，并且所有计算机必须

1690
01:21:33,990 --> 01:21:35,190
意味着同一个数据中心，

1691
01:21:35,190 --> 01:21:39,000
尽管如此，这被视为 在那个时候

1692
01:21:39,000 --> 01:21:41,670
，仍然只是一个非常令人惊讶

1693
01:21:41,670 --> 01:21:45,000
的分布式事务的高速实现，

1694
01:21:45,000 --> 01:21:48,060
 

1695
01:21:48,060 --> 01:21:52,860
就像在生产使用中比任何系统都快得多

1696
01:21:52,860 --> 01:21:54,630
，而且硬件

1697
01:21:54,630 --> 01:21:56,310
确实有点异国情调，并且真的依赖于

1698
01:21:56,310 --> 01:21:58,020
这种非易失性 Ram 方案 这

1699
01:21:58,020 --> 01:22:01,650
取决于这些特殊的 RDMA NIC，

1700
01:22:01,650 --> 01:22:04,460
这些现在并不是特别普遍，

1701
01:22:04,460 --> 01:22:08,190
但是您可以，但是您可以获得它们，并且具有这样的

1702
01:22:08,190 --> 01:22:09,540
性能，它们似乎很可能

1703
01:22:09,540 --> 01:22:11,970
会同时出现，而

1704
01:22:11,970 --> 01:22:14,520
我最终将

1705
01:22:14,520 --> 01:22:16,860
在数据中心中非常普遍，所以 人们可以玩

1706
01:22:16,860 --> 01:22:19,710
这类游戏，这就是

1707
01:22:19,710 --> 01:22:23,580
我要说的关于农场的全部

1708
01:22:23,580 --> 01:22:26,270
 

1709
01:22:26,270 --> 01:22:29,400
 

1710
01:22:29,400 --> 01:22:31,320
 

1711
01:22:31,320 --> 01:22:33,800
内容 交易我

1712
01:22:33,800 --> 01:22:35,620
听到大家再见了

1713
01:22:35,620 --> 01:22:38,500
[音乐]

