1
00:00:01,460 --> 00:00:03,520
 

2
00:00:11,000 --> 00:00:15,750
好吧，让我们今天开始吧。我

3
00:00:15,750 --> 00:00:16,410
想谈谈

4
00:00:16,410 --> 00:00:19,860
堆栈，我们看

5
00:00:19,860 --> 00:00:22,320
这篇论文的原因是它涉及到三个

6
00:00:22,320 --> 00:00:25,009
我觉得很有趣的问题，

7
00:00:25,009 --> 00:00:27,689
一个可能是最低级别的如何

8
00:00:27,689 --> 00:00:30,240
构建命名系统或真正的

9
00:00:30,240 --> 00:00:32,549
从名称映射到公钥的公钥基础设施

10
00:00:32,549 --> 00:00:35,970
，这就像一个非常

11
00:00:35,970 --> 00:00:38,070
重要的问题，没有人

12
00:00:38,070 --> 00:00:39,840
真正想出一种令人信服的方法来

13
00:00:39,840 --> 00:00:43,830
构建通用的全球

14
00:00:43,830 --> 00:00:46,170
公钥基础设施或 PKI，所以

15
00:00:46,170 --> 00:00:49,770
在这个领域的任何进展都很

16
00:00:49,770 --> 00:00:52,290
有趣 我

17
00:00:52,290 --> 00:00:54,719
对块堆栈感兴趣的原因是，它是一种

18
00:00:54,719 --> 00:00:57,559
非加密货币使用的

19
00:00:57,559 --> 00:00:59,370
 

20
00:00:59,370 --> 00:01:02,730
区块链，你知道，所以区块链是否

21
00:01:02,730 --> 00:01:04,739
对金融以外的任何东西有用，这只是一个有趣的问题

22
00:01:04,739 --> 00:01:07,350
，最后，你知道

23
00:01:07,350 --> 00:01:11,210
最有趣的可能是区块链

24
00:01:11,210 --> 00:01:13,170
关于

25
00:01:13,170 --> 00:01:16,259
互联网服务

26
00:01:16,259 --> 00:01:18,600
或真正的网站如何构建网站的

27
00:01:18,600 --> 00:01:20,250
架构非常

28
00:01:20,250 --> 00:01:21,599
不同的建议 嘿，现在构建的是

29
00:01:21,599 --> 00:01:24,899
完全不同的属性，你知道

30
00:01:24,899 --> 00:01:27,300
这个想法是，也许

31
00:01:27,300 --> 00:01:28,470
布洛克麻袋

32
00:01:28,470 --> 00:01:32,130
采取的那种方法可能会产生

33
00:01:32,130 --> 00:01:34,289
在某些方面比

34
00:01:34,289 --> 00:01:37,920
现在的网站更好的网站现在阻止就像一个

35
00:01:37,920 --> 00:01:40,679
真实的系统有一家公司 那正在

36
00:01:40,679 --> 00:01:43,619
开发它

37
00:01:43,619 --> 00:01:46,670
正在被某些应用程序使用

38
00:01:46,670 --> 00:01:49,860
 

39
00:01:49,860 --> 00:01:52,380
 

40
00:01:52,380 --> 00:01:54,630
 

41
00:01:54,630 --> 00:01:56,390
 

42
00:01:56,390 --> 00:01:59,759
多年来，我不认为

43
00:01:59,759 --> 00:02:01,860
真的到了很多

44
00:02:01,860 --> 00:02:04,170
人会决定放弃

45
00:02:04,170 --> 00:02:05,700
他们现在构建网站的方式并切换到

46
00:02:05,700 --> 00:02:08,489
块堆栈的地步，但非常重要的是

47
00:02:08,489 --> 00:02:11,670
有人正在探索

48
00:02:11,670 --> 00:02:14,690
事情如何变得不同和更好

49
00:02:14,690 --> 00:02:16,709
块堆栈是许多

50
00:02:16,709 --> 00:02:19,170
不同的项目之一，它们正试图

51
00:02:19,170 --> 00:02:20,610
朝着不同的方向推动

52
00:02:20,610 --> 00:02:23,940
网站的整体架构，

53
00:02:23,940 --> 00:02:26,880
所以块堆栈的

54
00:02:26,880 --> 00:02:29,520
间距是 p  eople 应该构建

55
00:02:29,520 --> 00:02:30,360
体面的

56
00:02:30,360 --> 00:02:33,640
应用程序，那么去中心化

57
00:02:33,640 --> 00:02:35,950
意味着什么是一个

58
00:02:35,950 --> 00:02:40,420
已经流传了几年的想法

59
00:02:40,420 --> 00:02:41,560
 

60
00:02:41,560 --> 00:02:43,300
 

61
00:02:43,300 --> 00:02:46,360
 

62
00:02:46,360 --> 00:02:48,910
您知道的受控网站

63
00:02:48,910 --> 00:02:51,790
就像普通的网络服务器一样，并且以一种或另一种方式

64
00:02:51,790 --> 00:02:53,200
将用户

65
00:02:53,200 --> 00:02:56,410
信息的控制权更多地掌握在用户

66
00:02:56,410 --> 00:03:01,030
手中，因此可以

67
00:03:01,030 --> 00:03:02,620
说用户实际上拥有自己的

68
00:03:02,620 --> 00:03:05,739
数据而不是您知道 Facebook 或

69
00:03:05,739 --> 00:03:09,730
Gmail 或任何其他人。 基本上

70
00:03:09,730 --> 00:03:15,010
为他们拥有他们的数据

71
00:03:15,010 --> 00:03:16,900
 

72
00:03:16,900 --> 00:03:18,640
比特币的成功和有趣的特性是推动

73
00:03:18,640 --> 00:03:20,800
该领域近期活动的很多因素，这

74
00:03:20,800 --> 00:03:22,600
是一个古老的想法，至少可以

75
00:03:22,600 --> 00:03:25,600
 

76
00:03:25,600 --> 00:03:28,450
追溯到大约 20 年前出现在像 Nutella 和 Napster 这样的计划中

77
00:03:28,450 --> 00:03:32,069
比这更早，但比特币

78
00:03:32,069 --> 00:03:34,810
确实促使人们认真

79
00:03:34,810 --> 00:03:38,049
思考这个问题，并且

80
00:03:38,049 --> 00:03:40,959
对这些想法更有信心

81
00:03:40,959 --> 00:03:45,430
可以实现，所以我想

82
00:03:45,430 --> 00:03:48,790
先概述一下

83
00:03:48,790 --> 00:03:51,640
你知道当前网站看起来像什么集中式典型，

84
00:03:51,640 --> 00:03:54,360
谈谈为什么

85
00:03:54,360 --> 00:03:56,739
有些人

86
00:03:56,739 --> 00:04:00,310
对当前网站的工作方式并不满意，然后

87
00:04:00,310 --> 00:04:02,950
概述事情可能会如何 在

88
00:04:02,950 --> 00:04:05,890
像块堆栈这样的去中心化方案下工作，所以

89
00:04:05,890 --> 00:04:13,180
这确实是当前的网站，观点

90
00:04:13,180 --> 00:04:14,950
是你有很多用户坐在

91
00:04:14,950 --> 00:04:20,410
浏览器前，并且有一个互联网，他们

92
00:04:20,410 --> 00:04:22,930
都在与互联网交谈你有一些

93
00:04:22,930 --> 00:04:24,940
网站在那里你知道可能是

94
00:04:24,940 --> 00:04:28,840
Gmail 或 某些东西，Gmail 有

95
00:04:28,840 --> 00:04:34,060
一堆网络服务器，这些网络服务器归

96
00:04:34,060 --> 00:04:37,300
Gmail 所有，由任何网络

97
00:04:37,300 --> 00:04:40,630
服务拥有，位于网络服务器后面的

98
00:04:40,630 --> 00:04:43,110
是某种数据库

99
00:04:43,110 --> 00:04:45,740
，通过这些个人用户，我们对我们来说是一种熟悉的画面，

100
00:04:45,740 --> 00:04:48,420
这个

101
00:04:48,420 --> 00:04:51,720
数据库保存用户数据，例如 如果

102
00:04:51,720 --> 00:04:54,570
您使用 Gmail，您知道您知道您

103
00:04:54,570 --> 00:04:57,540
的用户 Gmail 位于 Gmail 的

104
00:04:57,540 --> 00:05:00,150
数据库中，您知道这是

105
00:05:00,150 --> 00:05:01,740
Gmail 拥有的数据库服务器，并且

106
00:05:01,740 --> 00:05:04,320
可以控制 r

107
00:05:04,320 --> 00:05:10,080
Gmail 运行方式的逻辑本质上

108
00:05:10,080 --> 00:05:13,380
位于拥有个人简历的网络服务器中，这些服务器

109
00:05:13,380 --> 00:05:15,390
归 Gmail 所有，并与

110
00:05:15,390 --> 00:05:17,790
数据库进行对话以获取您的数据，

111
00:05:17,790 --> 00:05:18,810
所以这里完全没有什么

112
00:05:18,810 --> 00:05:22,830
令人惊讶的，您知道这就是

113
00:05:22,830 --> 00:05:24,450
方式 几乎每个网站都能正常工作，这通常是

114
00:05:24,450 --> 00:05:26,490
一些 JavaScript 或其他东西，

115
00:05:26,490 --> 00:05:28,710
并且位于用户浏览器中，但

116
00:05:28,710 --> 00:05:30,930
所有关键的东西都位于

117
00:05:30,930 --> 00:05:33,240
Web 服务器或

118
00:05:33,240 --> 00:05:36,240
网站打哈欠的某种服务器中，所以数据库

119
00:05:36,240 --> 00:05:37,530
上的四个不同网站

120
00:05:37,530 --> 00:05:39,030
是 会是博客

121
00:05:39,030 --> 00:05:42,150
帖子或邮件之类的东西，或者您知道

122
00:05:42,150 --> 00:05:44,340
您在其他人的 reddit 上发布的评论或

123
00:05:44,340 --> 00:05:46,320
其他东西，或者可能是您的照片，您的

124
00:05:46,320 --> 00:05:48,810
日历，我是您的医疗记录或

125
00:05:48,810 --> 00:05:50,400
其他东西，

126
00:05:50,400 --> 00:05:53,360
在某些不同的网站

127
00:05:53,360 --> 00:05:56,100
上存在大量数据 感觉你知道用户

128
00:05:56,100 --> 00:05:57,660
数据，就像它真的是用户 Gmail，

129
00:05:57,660 --> 00:06:01,200
但天哪，它是 Gmail，或者可以

130
00:06:01,200 --> 00:06:05,280
控制它，或者 reddit 可以

131
00:06:05,280 --> 00:06:07,440
控制用户的评论和其他 pe  ople 的

132
00:06:07,440 --> 00:06:07,950
文章

133
00:06:07,950 --> 00:06:10,710
现在这个设置是 SuperDuper

134
00:06:10,710 --> 00:06:12,840
成功的 它实际上是

135
00:06:12,840 --> 00:06:14,460
坐下来的原因之一 它非常容易

136
00:06:14,460 --> 00:06:17,730
编程 你知道所有的逻辑听到和

137
00:06:17,730 --> 00:06:19,440
运行以及由 Gmail 控制的服务器

138
00:06:19,440 --> 00:06:22,260
他们可以通过

139
00:06:22,260 --> 00:06:23,940
诸如非常灵活的续集数据库之类的东西与这些数据库进行通信

140
00:06:23,940 --> 00:06:26,580
查询接口

141
00:06:26,580 --> 00:06:28,560
对可以访问的数据没有任何限制，

142
00:06:28,560 --> 00:06:32,700
就像您知道的那样，假设这

143
00:06:32,700 --> 00:06:36,270
是一个在这里运行的 eBay，您

144
00:06:36,270 --> 00:06:38,600
知道用户的出价现在位于 eBay 的

145
00:06:38,600 --> 00:06:41,130
数据库服务器中，

146
00:06:41,130 --> 00:06:42,330
如果我在出价我的东西，出价是非常私密的。

147
00:06:42,330 --> 00:06:43,590
不希望其他用户

148
00:06:43,590 --> 00:06:45,270
看到它但是对

149
00:06:45,270 --> 00:06:47,430
eBay 的网络服务器可以查看的内容没有限制 他们

150
00:06:47,430 --> 00:06:51,090
都可以查看

151
00:06:51,090 --> 00:06:52,170
自己数据库中的出价 他们可以查看其他

152
00:06:52,170 --> 00:06:53,580
人的出价 找到最高出价

153
00:06:53,580 --> 00:06:55,260
真的没有限制所以

154
00:06:55,260 --> 00:06:57,369
 

155
00:06:57,369 --> 00:07:00,129
它对 Web 开发人员来说非常方便，并且非常

156
00:07:00,129 --> 00:07:01,359
成功，所以从这个角度

157
00:07:01,359 --> 00:07:03,009
来看，我们应该对

158
00:07:03,009 --> 00:07:05,139
其他任何东西都持怀疑态度 可能

159
00:07:05,139 --> 00:07:07,809
会成功或超越它，但是

160
00:07:07,809 --> 00:07:09,339
您可能认为

161
00:07:09,339 --> 00:07:12,549
当前设置不完美

162
00:07:12,549 --> 00:07:14,949
的原因有很多用户可能不满意的原因，

163
00:07:14,949 --> 00:07:19,029
其中一个是如果我将

164
00:07:19,029 --> 00:07:20,769
邮件存储在 Gmail 中，我真的必须使用

165
00:07:20,769 --> 00:07:22,479
Gmail 的界面来获取 在它

166
00:07:22,479 --> 00:07:23,649
你知道，也许他们提供了一些其他的

167
00:07:23,649 --> 00:07:24,939
方式来获取它，但我通常

168
00:07:24,939 --> 00:07:26,919
没有很多自由，比如 Gmail

169
00:07:26,919 --> 00:07:29,439
为我如何获取自己的电子邮件设置了正确的规则，

170
00:07:29,439 --> 00:07:31,659
所以我可能会有点

171
00:07:31,659 --> 00:07:34,029
恼火，这是我的电子邮件 但是你知道

172
00:07:34,029 --> 00:07:35,889
我无法选择我使用的界面

173
00:07:35,889 --> 00:07:38,619
我不能只使用任何软件 Lee

174
00:07:38,619 --> 00:07:40,119
几乎必须是 Gmail

175
00:07:40,119 --> 00:07:44,609
提供的软件或 Gmail 支持

176
00:07:44,609 --> 00:07:48,369
的软件，例如 Facebook，

177
00:07:48,369 --> 00:07:50,229
其他人有时可能会看到我的

178
00:07:50,229 --> 00:07:51,849
数据真的 该网站可以

179
00:07:51,849 --> 00:07:54,099
为谁可以访问我的数据

180
00:07:54,099 --> 00:07:56,469
或我如何控制该

181
00:07:56,469 --> 00:07:59,679
访问设置规则，并且网站通常

182
00:07:59,679 --> 00:08:01,329
对他们关于如何

183
00:08:01,329 --> 00:08:03,759
执行这些东西的承诺以及如果它是

184
00:08:03,759 --> 00:08:05,799
用户数据之类的承诺有点模糊 如果是我的照片或我的

185
00:08:05,799 --> 00:08:08,199
帖子或其他东西，那

186
00:08:08,199 --> 00:08:10,299
真的不是很好，我

187
00:08:10,299 --> 00:08:12,549
无法控制网站可以

188
00:08:12,549 --> 00:08:15,339
用它做什么，人们

189
00:08:15,339 --> 00:08:17,529
抱怨当前设置的另一件事

190
00:08:17,529 --> 00:08:19,749
是网站可以嗅探 在我的

191
00:08:19,749 --> 00:08:21,399
东西上，比如 Gmail 想要查看

192
00:08:21,399 --> 00:08:23,469
我的邮件，他们可能有充分的理由，

193
00:08:23,469 --> 00:08:24,849
也许他们正在训练他们的垃圾邮件

194
00:08:24,849 --> 00:08:26,739
生成器，所以这没关系，但你知道，

195
00:08:26,739 --> 00:08:28,599
也许查看我的电子邮件以考虑

196
00:08:28,599 --> 00:08:31,179
向我展示广告，或者你知道

197
00:08:31,179 --> 00:08:33,279
告诉他们的广告客户什么

198
00:08:33,279 --> 00:08:36,539
人们对这些天更感兴趣，

199
00:08:36,539 --> 00:08:41,159
更糟糕的是，

200
00:08:41,159 --> 00:08:43,208
在网站上工作的一些员工

201
00:08:43,208 --> 00:08:45,730
有可能是腐败的，并且可能

202
00:08:45,730 --> 00:08:48,459
出于个人原因窥探人们的数据，

203
00:08:48,459 --> 00:08:50,350
因此也许

204
00:08:50,350 --> 00:08:51,850
运营该网站的公司可能是完全

205
00:08:51,850 --> 00:08:54,189
光明正大的，但可以 不一定会

206
00:08:54,189 --> 00:08:56,800
声称

207
00:08:56,800 --> 00:09:00,399
所有员工都遵守所有

208
00:09:00,399 --> 00:09:05,690
规则并不总是正确的，因此人们

209
00:09:05,690 --> 00:09:09,830
对你有很多了解，或者有些人有 我

210
00:09:09,830 --> 00:09:11,810
对当前

211
00:09:11,810 --> 00:09:16,040
系统在某种设计

212
00:09:16,040 --> 00:09:19,700
技术层面的工作方式持保留态度，查看这里发生的

213
00:09:19,700 --> 00:09:22,040
事情的一种方法是，这里的主界面

214
00:09:22,040 --> 00:09:27,370
位于整个网站和浏览器之间，

215
00:09:27,370 --> 00:09:31,280
因此 HTML

216
00:09:31,280 --> 00:09:32,540
在此处来回流动

217
00:09:32,540 --> 00:09:38,360
通常，网站和

218
00:09:38,360 --> 00:09:40,280
数据库都集成在

219
00:09:40,280 --> 00:09:42,080
界面的这一侧，所有

220
00:09:42,080 --> 00:09:43,760
浏览器真正经常看到的是

221
00:09:43,760 --> 00:09:46,790
这种 HTML 数据的最终打包形式

222
00:09:46,790 --> 00:09:49,760
，你知道它是一个非常

223
00:09:49,760 --> 00:09:52,760
面向用户界面的表示 hTML

224
00:09:52,760 --> 00:09:55,940
是和排序 Nod 没有什么可说

225
00:09:55,940 --> 00:10:00,140
的，你知道 Dave 数据本身或

226
00:10:00,140 --> 00:10:03,500
如何控制数据以及

227
00:10:03,500 --> 00:10:04,820
更有趣的界面

228
00:10:04,820 --> 00:10:06,560
，你知道整个讨论

229
00:10:06,560 --> 00:10:09,140
的重点是，这是一个更

230
00:10:09,140 --> 00:10:11,450
有趣的界面，因为它更

231
00:10:11,450 --> 00:10:13,670
接近 到数据，但在标准

232
00:10:13,670 --> 00:10:15,770
设置中没有真正的边界，

233
00:10:15,770 --> 00:10:17,930
虽然这是一种内部

234
00:10:17,930 --> 00:10:19,790
业务，如何运作是 t 的内部

235
00:10:19,790 --> 00:10:23,960
业务 他的网站

236
00:10:23,960 --> 00:10:27,950
 

237
00:10:27,950 --> 00:10:30,080
很好，这就是现有计划 块堆栈

238
00:10:30,080 --> 00:10:33,440
提出的计划类型，因此

239
00:10:33,440 --> 00:10:36,530
对于去中心化应用程序的工作方式有很多想法，

240
00:10:36,530 --> 00:10:40,360
这是其中之一，

241
00:10:40,360 --> 00:10:42,710
所以我不会称之为 块堆栈，

242
00:10:42,710 --> 00:10:46,550
因为它是一种非常

243
00:10:46,550 --> 00:10:49,280
简化的版本，我们只会说它是一个

244
00:10:49,280 --> 00:10:54,830
分散的架构，这里的

245
00:10:54,830 --> 00:10:56,180
游戏是你知道我们仍然有

246
00:10:56,180 --> 00:10:58,370
一群用户并且用户运行你知道

247
00:10:58,370 --> 00:11:02,350
iPad 或浏览器或其他东西，

248
00:11:04,180 --> 00:11:07,260
但我们' 重新在这个新的去中心

249
00:11:07,260 --> 00:11:09,520
化方案中，我们将把所有

250
00:11:09,520 --> 00:11:14,649
的应用程序代码

251
00:11:14,649 --> 00:11:16,660
放在用户机器的客户端机器上运行

252
00:11:16,660 --> 00:11:18,399
，所以这更像是一种

253
00:11:18,399 --> 00:11:20,410
传统的，或者就像你知道

254
00:11:20,410 --> 00:11:22,570
从应用程序下载应用程序一样 存储

255
00:11:22,570 --> 00:11:28,300
在 iPad 上或购买旧式 PC

256
00:11:28,300 --> 00:11:30,040
硬件，例如购买 Microsoft Word 的副本，

257
00:11:30,040 --> 00:11:31,959
这只是在您的笔记本电脑上运行只需

258
00:11:31,959 --> 00:11:34,000
购买一些您在笔记本电脑上

259
00:11:34,000 --> 00:11:38,560
运行的软件，因此不再

260
00:11:38,560 --> 00:11:42,580
在 Web 服务器中运行应用程序代码

261
00:11:42,580 --> 00:11:43,839
你想做的是使用你

262
00:11:43,839 --> 00:11:45,490
笔记本电脑上的数据你自己的笔记本电脑上的数据

263
00:11:45,490 --> 00:11:49,149
然后我们就完成了，但真正

264
00:11:49,149 --> 00:11:50,620
有趣的是你知道基于网络的基于

265
00:11:50,620 --> 00:11:52,420
互联网的应用

266
00:11:52,420 --> 00:11:54,670
程序是你可以将数据存储在

267
00:11:54,670 --> 00:11:56,350
云中 意味着你可以，如果你有

268
00:11:56,350 --> 00:11:58,330
多个设备，大多数人都

269
00:11:58,330 --> 00:12:00,730
可以，

270
00:12:00,730 --> 00:12:02,320
你可以从你的

271
00:12:02,320 --> 00:12:05,320
iPhone 和笔记本电脑上的任何设备获取数据，如果你

272
00:12:05,320 --> 00:12:07,899
以某种方式将数据存储在云中，这

273
00:12:07,899 --> 00:12:09,400
意味着你可以共享数据 与其他

274
00:12:09,400 --> 00:12:11,680
人一起构建多用户应用程序，

275
00:12:11,680 --> 00:12:15,370
比如你知道 eBay，也许是你的 reddit，或者

276
00:12:15,370 --> 00:12:18,730
谁知道共享日历，所以

277
00:12:18,730 --> 00:12:23,380
去中心化愿景的另一半

278
00:12:23,380 --> 00:12:25,120
是会有一个存储

279
00:12:25,120 --> 00:12:29,250
系统，某种云存储

280
00:12:29,250 --> 00:12:35,589
系统，我们通过它 意思是我的意思

281
00:12:35,589 --> 00:12:37,390
是你可以购买的某种服务，也许

282
00:12:37,390 --> 00:12:39,520
你知道亚马逊 AWS 或

283
00:12:39,520 --> 00:12:41,860
谁知道这只是

284
00:12:41,860 --> 00:12:43,510
为你存储数据，你可以将数据粘贴在其中

285
00:12:43,510 --> 00:12:45,940
，他们为你存储的数据是你的

286
00:12:45,940 --> 00:12:46,920
备份，

287
00:12:46,920 --> 00:12:48,940
dumi 希望 ly 某种访问

288
00:12:48,940 --> 00:12:50,470
控制，因此人们是否无法访问

289
00:12:50,470 --> 00:12:51,610
它，然后您可以稍后

290
00:12:51,610 --> 00:12:56,380
从您的任何设备中检索它，所以现在如果

291
00:12:56,380 --> 00:12:58,709
我们正在构建某种您知道的

292
00:12:58,709 --> 00:13:01,630
单用户应用程序，就像您知道我

293
00:13:01,630 --> 00:13:03,760
只需要 编辑一些文档，但我

294
00:13:03,760 --> 00:13:05,500
想将它们保存在云中，你知道，

295
00:13:05,500 --> 00:13:07,839
也许用户一正在从

296
00:13:07,839 --> 00:13:10,750
这个存储服务器

297
00:13:10,750 --> 00:13:13,680
购买存储，也许是亚马逊，用户二

298
00:13:13,680 --> 00:13:17,530
可能从谷歌的云存储系统购买存储，

299
00:13:17,530 --> 00:13:19,330
用于我自己的数据，我刚刚和我自己谈过

300
00:13:19,330 --> 00:13:21,370
我的应用程序代码通过

301
00:13:21,370 --> 00:13:24,130
Internet 与我购买存储的服务存储服务进行通信

302
00:13:24,130 --> 00:13:26,500
，大概是

303
00:13:26,500 --> 00:13:29,200
我自己付费，用户

304
00:13:29,200 --> 00:13:32,550
与他们的存储服务进行类似的通信，但是如果我们运行的

305
00:13:32,550 --> 00:13:38,140
应用程序是为允许用户共享数据而构建的，

306
00:13:38,140 --> 00:13:40,660
那么就有

307
00:13:40,660 --> 00:13:42,730
可能 如果我知道

308
00:13:42,730 --> 00:13:44,560
如何与存储服务交谈，我可以运行一个

309
00:13:44,560 --> 00:13:47,950
应用程序来读取他们

310
00:13:47,950 --> 00:13:50,020
允许我读取的数据，这样你就知道

311
00:13:50,020 --> 00:13:51,160
你是否想在上面构建某种类似

312
00:13:51,160 --> 00:13:53,710
Facebook 的东西 s

313
00:13:53,710 --> 00:13:55,030
应用程序会知道我的朋友

314
00:13:55,030 --> 00:13:59,080
是谁，并与我的朋友存储联系以

315
00:13:59,080 --> 00:14:01,090
查找更新或照片，或者谁

316
00:14:01,090 --> 00:14:03,190
知道我的朋友

317
00:14:03,190 --> 00:14:06,730
在他们自己的存储中存储了什么，这意味着我

318
00:14:06,730 --> 00:14:10,000
 

319
00:14:10,000 --> 00:14:11,890
不是在他的新模型中与 Facebook 的网站联系而是 会

320
00:14:11,890 --> 00:14:15,100
从 Facebook 下载一个应用程序并运行它

321
00:14:15,100 --> 00:14:17,610
，该应用程序会知道如何

322
00:14:17,610 --> 00:14:20,500
找到我的朋友并查看

323
00:14:20,500 --> 00:14:24,280
他们存储的数据，你知道如果我的

324
00:14:24,280 --> 00:14:26,980
朋友将照片上传到他们的存储空间，

325
00:14:26,980 --> 00:14:28,690
它实际上仍然是他们的存储空间

326
00:14:28,690 --> 00:14:30,630
。 重新付费，这是他们的照片，

327
00:14:30,630 --> 00:14:33,460
他们可以将其与 Facebook 一起

328
00:14:33,460 --> 00:14:35,080
使用，或者他们也可以将其与其他应用程序一起使用，

329
00:14:35,080 --> 00:14:36,700
因为这些应用程序

330
00:14:36,700 --> 00:14:39,670
现在与数据完全分开，

331
00:14:39,670 --> 00:14:42,640
而不是在

332
00:14:42,640 --> 00:14:47,670
现有架构中组合，所以现在

333
00:14:47,670 --> 00:14:52,450
有点像 技术层面 这

334
00:14:52,450 --> 00:14:54,940
现在是存储接口 现在是

335
00:14:54,940 --> 00:14:57,190
主接口 所以现在我们有

336
00:14:57,190 --> 00:14:58,780
某种 put get 或 readwrite 或者谁

337
00:14:58,780 --> 00:15:00,340
知道作为主接口的接口是

338
00:15:00,340 --> 00:15:02,910
什么 o 不再是 HTML，它确实是

339
00:15:02,910 --> 00:15:04,810
我们担心的主要界面，

340
00:15:04,810 --> 00:15:06,640
它是存储样式界面，它

341
00:15:06,640 --> 00:15:08,740
是一个更好的界面，可以将

342
00:15:08,740 --> 00:15:13,710
应用程序写入 HTML

343
00:15:14,610 --> 00:15:16,480
 

344
00:15:16,480 --> 00:15:18,280
 

345
00:15:18,280 --> 00:15:20,380
 

346
00:15:20,380 --> 00:15:22,390
存储有一个更清晰的概念，即

347
00:15:22,390 --> 00:15:24,580
数据实际上由用户拥有

348
00:15:24,580 --> 00:15:27,010
并由用户控制，就像

349
00:15:27,010 --> 00:15:28,810
您拥有笔记本电脑或 Athena 上的数据一样，

350
00:15:28,810 --> 00:15:29,850
 

351
00:15:29,850 --> 00:15:32,310
因为您在存储

352
00:15:32,310 --> 00:15:36,450
服务中的帐户当然有很多，

353
00:15:36,450 --> 00:15:38,730
但您知道 现在我们

354
00:15:38,730 --> 00:15:40,860
对存储系统的设计非常感兴趣，

355
00:15:40,860 --> 00:15:42,450
因为现在这不再是

356
00:15:42,450 --> 00:15:44,490
隐藏在网站内部，

357
00:15:44,490 --> 00:15:46,560
而是现在系统中的主要界面，

358
00:15:46,560 --> 00:15:48,060
所以我们非常关心它的

359
00:15:48,060 --> 00:15:50,310
设计方式，所以首先它相当

360
00:15:50,310 --> 00:15:52,650
至关重要的是它是

361
00:15:52,650 --> 00:15:54,570
云中的互联网服务，因此我们可以使用它

362
00:15:54,570 --> 00:15:57,870
从我们的任何设备中获取我们的数据它

363
00:15:57,870 --> 00:15:59,370
确实需要是通用的，

364
00:15:59,370 --> 00:16:03,090
所有应用程序 在这里的代码，所以我们

365
00:16:03,090 --> 00:16:04,350
现在在这个架构中根本没有

366
00:16:04,350 --> 00:16:06,150
真正在服务器端拥有应用程序特定的代码

367
00:16:06,150 --> 00:16:10,110
，因为

368
00:16:10,110 --> 00:16:12,120
这种服务器实际上

369
00:16:12,120 --> 00:16:12,990
与应用程序没有任何直接关系，

370
00:16:12,990 --> 00:16:14,280
所以我们需要一个

371
00:16:14,280 --> 00:16:15,870
通用的 - 目的界面

372
00:16:15,870 --> 00:16:17,880
足够强大，可以让我们做

373
00:16:17,880 --> 00:16:21,690
任何我们需要的事情这有点

374
00:16:21,690 --> 00:16:25,890
难以设计我们现在必须为

375
00:16:25,890 --> 00:16:28,260
存储付费，现在

376
00:16:28,260 --> 00:16:30,210
真正最明显的

377
00:16:30,210 --> 00:16:32,460
付费人是用户自己现在也许

378
00:16:32,460 --> 00:16:33,990
他们' 愿意这样做，也许他们

379
00:16:33,990 --> 00:16:36,330
不是我们真的很想进行这种

380
00:16:36,330 --> 00:16:37,890
共享，但我们也希望拥有私人

381
00:16:37,890 --> 00:16:39,600
数据，也许我们只想

382
00:16:39,600 --> 00:16:42,210
与某些其他人共享我们的数据，所以我们

383
00:16:42,210 --> 00:16:43,500
需要一些理由，所以存储

384
00:16:43,500 --> 00:16:45,780
接口在 存储系统以一种

385
00:16:45,780 --> 00:16:47,870
或另一种方式需要相当强大的

386
00:16:47,870 --> 00:16:51,840
共享和权限访问控制

387
00:16:51,840 --> 00:16:56,430
系统一个更微妙的问题是，如果我只是从 int 下载一些多用户游戏，我

388
00:16:56,430 --> 00:16:59,970
可能会运行多个我

389
00:16:59,970 --> 00:17:02,130
不信任的应用程序

390
00:17:02,130 --> 00:17:04,949
ernet，

391
00:17:04,949 --> 00:17:07,199
您知道，也许我不希望它

392
00:17:07,199 --> 00:17:08,670
在我玩该游戏时能够查看我的电子邮件，

393
00:17:08,670 --> 00:17:10,530
这意味着

394
00:17:10,530 --> 00:17:13,619
除了拥有具有此用户权限的此类用户的概念外，

395
00:17:13,619 --> 00:17:16,050
我们可能还

396
00:17:16,050 --> 00:17:18,180
希望有一种 附属

397
00:17:18,180 --> 00:17:20,490
权限，我们不仅可以谈论

398
00:17:20,490 --> 00:17:22,619
这个用户作为一个整体，还可以谈论这个用户

399
00:17:22,619 --> 00:17:24,869
在运行应用程序时具有

400
00:17:24,869 --> 00:17:27,660
某些权限可能只是游戏

401
00:17:27,660 --> 00:17:30,000
文件这个用户在运行应用程序

402
00:17:30,000 --> 00:17:33,000
时也可以获取用户的电子邮件

403
00:17:33,000 --> 00:17:35,240
，

404
00:17:35,910 --> 00:17:38,370
好吧，然后有趣的是 他们

405
00:17:38,370 --> 00:17:40,290
注意到这个存储接口并

406
00:17:40,290 --> 00:17:42,090
没有像 10 或 20 年前所说的那样延伸，

407
00:17:42,090 --> 00:17:44,640
 

408
00:17:44,640 --> 00:17:47,030
因为那里有许多存储

409
00:17:47,030 --> 00:17:49,140
服务，

410
00:17:49,140 --> 00:17:52,530
就像亚马逊 s3 一样被广泛使用，

411
00:17:52,530 --> 00:17:54,360
虽然它缺少一些 我们

412
00:17:54,360 --> 00:17:57,000
在这里需要的东西绝对是公共

413
00:17:57,000 --> 00:17:59,610
存储系统 您可以购买存储空间 您

414
00:17:59,610 --> 00:18:01,110
可以让其他人使用您的存储空间

415
00:18:01,110 --> 00:18:02,520
您知道没有

416
00:18:02,520 --> 00:18:05,460
我们想要的所有访问控制，但它并不

417
00:18:05,460 --> 00:18:06,840
太远 rom 这里需要什么，实际上

418
00:18:06,840 --> 00:18:08,880
今天的论文观察到，他们可以

419
00:18:08,880 --> 00:18:11,460
将存储系统分层在

420
00:18:11,460 --> 00:18:12,690
许多不同的现有

421
00:18:12,690 --> 00:18:14,880
存储系统

422
00:18:14,880 --> 00:18:16,740
 

423
00:18:16,740 --> 00:18:20,610
 

424
00:18:20,610 --> 00:18:22,740
之一之上 在天空中，因为它

425
00:18:22,740 --> 00:18:25,680
看起来不错，那么

426
00:18:25,680 --> 00:18:27,300
这种架构的意义是什么，为什么

427
00:18:27,300 --> 00:18:31,110
有人会关心可能关心的人

428
00:18:31,110 --> 00:18:33,390
是用户，这可能会让用户

429
00:18:33,390 --> 00:18:36,540
对他们的数据有更多的控制权，这可能

430
00:18:36,540 --> 00:18:38,190
会让用户更容易 切换

431
00:18:38,190 --> 00:18:39,810
应用程序，例如如果我上传了

432
00:18:39,810 --> 00:18:42,140
一堆照片并且我正在使用一个照片

433
00:18:42,140 --> 00:18:44,810
组织应用程序或照片编辑应用程序，

434
00:18:44,810 --> 00:18:47,220
因为我的照片

435
00:18:47,220 --> 00:18:48,750
与我的应用程序完全分开我可以切换

436
00:18:48,750 --> 00:18:50,640
照片应用程序并且可能仍然使用我所有

437
00:18:50,640 --> 00:18:52,350
的旧照片集 我已经存储的照片

438
00:18:52,350 --> 00:18:56,250
在这个架构中可能更

439
00:18:56,250 --> 00:18:57,900
容易让应用程序

440
00:18:57,900 --> 00:19:00,330
查看您知道的多种数据

441
00:19:00,330 --> 00:19:02,460
也许我的电子邮件系统

442
00:19:02,460 --> 00:19:04,680
能够查看我的 ca 借出者和

443
00:19:04,680 --> 00:19:06,360
其他方式可能很高兴

444
00:19:06,360 --> 00:19:08,400
能够编写备份软件，他们可以

445
00:19:08,400 --> 00:19:10,110
备份我的所有数据，无论它

446
00:19:10,110 --> 00:19:10,550
是

447
00:19:10,550 --> 00:19:12,930
定期的，也许我想要

448
00:19:12,930 --> 00:19:14,970
一种通用文件浏览器

449
00:19:14,970 --> 00:19:17,040
，它可以让我查看 在我所有的

450
00:19:17,040 --> 00:19:19,680
数据中，这一切都不可能或

451
00:19:19,680 --> 00:19:21,480
不方便，而且当前的架构，

452
00:19:21,480 --> 00:19:24,480
但现在一切似乎都触手可及

453
00:19:24,480 --> 00:19:27,000
，因为我们已经将所有

454
00:19:27,000 --> 00:19:29,430
用户数据集中到他们

455
00:19:29,430 --> 00:19:32,670
拥有的存储中，最后可能会有

456
00:19:32,670 --> 00:19:34,680
优势，因为 在隐私和窥探方面，

457
00:19:34,680 --> 00:19:35,340
 

458
00:19:35,340 --> 00:19:37,830
而不是将我的数据委托给

459
00:19:37,830 --> 00:19:39,210
谁知道它在做什么的网络服务，

460
00:19:39,210 --> 00:19:42,090
如果我们正确地玩我们的牌，我们

461
00:19:42,090 --> 00:19:44,580
可以使用加密这些应用程序

462
00:19:44,580 --> 00:19:46,500
可以在数据离开我的客户端计算机之前对其进行加密，

463
00:19:46,500 --> 00:19:48,600
这样唯一的事情

464
00:19:48,600 --> 00:19:49,690
这是一个恢复

465
00:19:49,690 --> 00:19:53,200
的数据，你知道当我读回它时，

466
00:19:53,200 --> 00:19:54,610
我将返回加密数据，然后

467
00:19:54,610 --> 00:19:56,530
在我自己的机器上本地解密，所以

468
00:19:56,530 --> 00:20:00,100
Kent 存储服务永远不会看到

469
00:20:00,100 --> 00:20:04,660
清晰的私人数据 o 这些

470
00:20:04,660 --> 00:20:07,090
都是你知道的诱人的

471
00:20:07,090 --> 00:20:09,940
可能性为什么你会喜欢为什么

472
00:20:09,940 --> 00:20:15,760
用户可能会喜欢这个

473
00:20:15,760 --> 00:20:20,620
架构所以你知道如果你

474
00:20:20,620 --> 00:20:22,000
深入了解这些

475
00:20:22,000 --> 00:20:27,600
应用程序实际必须做的事情

476
00:20:27,600 --> 00:20:29,740
你知道你会 需要计算出

477
00:20:29,740 --> 00:20:31,750
很多细节，比如

478
00:20:31,750 --> 00:20:33,970
你需要知道我的应用程序是否

479
00:20:33,970 --> 00:20:35,740
要查看你的数据，需要

480
00:20:35,740 --> 00:20:37,960
有一些关于如何

481
00:20:37,960 --> 00:20:41,410
在这里存储数据的约定，例如你知道我是否

482
00:20:41,410 --> 00:20:44,800
要查看 您最近

483
00:20:44,800 --> 00:20:46,510
为我们的社交网络应用程序发布的帖子

484
00:20:46,510 --> 00:20:48,160
您必须将它们存储在您的

485
00:20:48,160 --> 00:20:50,680
存储中，使用我的应用程序知道的密钥或名称

486
00:20:50,680 --> 00:20:53,290
才能尝试查找

487
00:20:53,290 --> 00:20:55,330
，并且您必须使用我们都理解的格式，

488
00:20:55,330 --> 00:20:56,820
以便您知道 一些

489
00:20:56,820 --> 00:20:59,200
如果我们想要进行共享

490
00:20:59,200 --> 00:21:02,200
，则必须克服某种标准化障碍，

491
00:21:02,200 --> 00:21:03,430
 

492
00:21:03,430 --> 00:21:05,740
而大型网站实际上并不存在这些障碍，因为它们

493
00:21:05,740 --> 00:21:08,430
可以存储自己的数据，但是他们喜欢

494
00:21:08,430 --> 00:21:10,480
这样，所以有一个问题 s

495
00:21:10,480 --> 00:21:12,640
 

496
00:21:12,640 --> 00:21:17,290
绝对会对应用程序性能产生不利影响 这可能对性能非常

497
00:21:17,290 --> 00:21:19,150
不利，因为在旧

498
00:21:19,150 --> 00:21:21,610
方案中，旧方案可以是

499
00:21:21,610 --> 00:21:23,200
现有方案可以以

500
00:21:23,200 --> 00:21:24,940
非常高的性能实现 你知道这些

501
00:21:24,940 --> 00:21:27,190
大多数 Web 服务器可能会发出

502
00:21:27,190 --> 00:21:28,930
数百个请求 数据库，

503
00:21:28,930 --> 00:21:30,490
例如当您查看亚马逊网页时，

504
00:21:30,490 --> 00:21:32,200
男孩是否有

505
00:21:32,200 --> 00:21:33,940
成百上千条信息

506
00:21:33,940 --> 00:21:35,440
必须从亚马逊的数据库中提取出来

507
00:21:35,440 --> 00:21:37,660
 

508
00:21:37,660 --> 00:21:40,810
 

509
00:21:40,810 --> 00:21:43,210
几十

510
00:21:43,210 --> 00:21:47,620
微秒，但如果其中一个

511
00:21:47,620 --> 00:21:49,240
应用程序需要通过互联网到达，

512
00:21:49,240 --> 00:21:51,520
你知道可能数百

513
00:21:51,520 --> 00:21:54,370
英里之外的某个存储服务，你

514
00:21:54,370 --> 00:21:55,720
知道现在一切都需要

515
00:21:55,720 --> 00:21:57,400
十到一百倍的时间来获取

516
00:21:57,400 --> 00:22:00,250
单个数据，所以现在就是这样

517
00:22:00,250 --> 00:22:02,960
肯定是个问题，

518
00:22:02,960 --> 00:22:06,030
你知道

519
00:22:06,030 --> 00:22:08,700
这种问题是聪明的

520
00:22:08,700 --> 00:22:12,870
设计师能想办法解决的问题，所以

521
00:22:12,870 --> 00:22:16,350
这肯定会是一个问题，但我的

522
00:22:16,350 --> 00:22:18,090
猜测是

523
00:22:18,090 --> 00:22:19,410
这种架构

524
00:22:19,410 --> 00:22:23,929
无法工作的全部原因还有许多其他

525
00:22:23,929 --> 00:22:26,850
同样令人不快的难题，

526
00:22:26,850 --> 00:22:29,910
尽管它绝对会改变

527
00:22:29,910 --> 00:22:31,169
人们编写应用程序的方式，因为

528
00:22:31,169 --> 00:22:32,460
而不是编写

529
00:22:32,460 --> 00:22:34,740
组装大量的应用程序它们使用大量

530
00:22:34,740 --> 00:22:36,000
的数据，您将不得不意味着

531
00:22:36,000 --> 00:22:39,600
更加简约我认为人们

532
00:22:39,600 --> 00:22:50,520
可以很好地解决它

533
00:22:50,520 --> 00:22:52,590
所以任何关于这个

534
00:22:52,590 --> 00:22:54,600
整体安排的任何问题，这是阻止的那种

535
00:22:54,600 --> 00:22:56,340
安排 堆栈正在射击

536
00:22:56,340 --> 00:23:01,710
，所以即使在这个级别，我们也应该尝试

537
00:23:01,710 --> 00:23:03,600
猜测

538
00:23:03,600 --> 00:23:09,990
可能会出现什么样的问题，一个原因是

539
00:23:09,990 --> 00:23:12,870
这个接口可能

540
00:23:12,870 --> 00:23:15,809
不如数据库接口灵活，

541
00:23:15,809 --> 00:23:17,370
这实际上

542
00:23:17,370 --> 00:23:18,840
有点回到性能上 你

543
00:23:18,840 --> 00:23:20,370
知道可能不会好我的

544
00:23:20,370 --> 00:23:23,010
意思是这有点受设计的影响，

545
00:23:23,010 --> 00:23:25,830
但我们不太可能

546
00:23:25,830 --> 00:23:29,340
支持超级灵活的喜欢 e sequel

547
00:23:29,340 --> 00:23:31,410
queries，当然我们不太可能

548
00:23:31,410 --> 00:23:34,620
对其

549
00:23:34,620 --> 00:23:36,450
他人的数据以及

550
00:23:36,450 --> 00:23:39,390
我们的共享数据进行后续查询，所以这当然是

551
00:23:39,390 --> 00:23:40,950
一个潜在的问题，这个

552
00:23:40,950 --> 00:23:43,320
接口可能不是很有表现力，

553
00:23:43,320 --> 00:23:44,700
这对于

554
00:23:44,700 --> 00:23:48,030
程序员的另一个问题是，

555
00:23:48,030 --> 00:23:49,500
这是否会给用户带来

556
00:23:49,500 --> 00:23:50,850
他们可能无法处理的流量是的，所以这

557
00:23:50,850 --> 00:23:55,230
也是一个潜在的问题是你

558
00:23:55,230 --> 00:23:57,390
知道如果你没有非常强大的

559
00:23:57,390 --> 00:23:59,760
查询，

560
00:23:59,760 --> 00:24:01,950
当你与真正的续集数据库交谈时，续集在做什么

561
00:24:01,950 --> 00:24:05,220
是它可能正在查看

562
00:24:05,220 --> 00:24:06,270
导致数据库服务器查看

563
00:24:06,270 --> 00:24:08,610
大量数据，但它只是找到

564
00:24:08,610 --> 00:24:10,140
您正在寻找的一个答案，可能

565
00:24:10,140 --> 00:24:11,700
是所有投票的总和，或者它只是

566
00:24:11,700 --> 00:24:13,260
将一小部分最终数据发送回来，

567
00:24:13,260 --> 00:24:14,970
而 如果您没有强大的

568
00:24:14,970 --> 00:24:16,060
查询语言，您

569
00:24:16,060 --> 00:24:18,210
可能不得不获取很多东西并

570
00:24:18,210 --> 00:24:20,950
自己进行过滤或聚合

571
00:24:20,950 --> 00:24:23,290
，而这可能

572
00:24:23,290 --> 00:24:27,030
需要发送大量数据 跨人群的

573
00:24:31,020 --> 00:24:34,450
链接是的，所以事情可能会更慢，事情

574
00:24:34,450 --> 00:24:36,400
会变慢，这是一个问题，

575
00:24:36,400 --> 00:24:38,080
也许在

576
00:24:38,080 --> 00:24:40,900
未来你知道每个人都有

577
00:24:40,900 --> 00:24:43,090
宽带互联网，我们有 5g

578
00:24:43,090 --> 00:24:44,500
手机，而这一切都不是

579
00:24:44,500 --> 00:24:46,210
性能的东西

580
00:24:46,210 --> 00:24:48,880
会很重要，

581
00:24:48,880 --> 00:24:50,830
 

582
00:24:50,830 --> 00:24:55,330
或者可能

583
00:24:55,330 --> 00:24:57,490
 

584
00:24:57,490 --> 00:25:00,310
 

585
00:25:00,310 --> 00:25:05,470
很重要 好吧，我必须在

586
00:25:05,470 --> 00:25:07,180
这里有两点，一是某些数据并非

587
00:25:07,180 --> 00:25:08,920
所有用户都拥有 想想

588
00:25:08,920 --> 00:25:10,780
Reddit 的首页吧，你

589
00:25:10,780 --> 00:25:12,760
知道 reddit 正在运行一些聪明的算法

590
00:25:12,760 --> 00:25:14,410
来选择首页中

591
00:25:14,410 --> 00:25:15,760
项目的顺序 我的意思是

592
00:25:15,760 --> 00:25:17,860
做投票，你知道谁知道

593
00:25:17,860 --> 00:25:20,320
这些算法运行起来有什么奇怪的

594
00:25:20,320 --> 00:25:21,730
，他们从哪里得到数据，也许

595
00:25:21,730 --> 00:25:23,260
他们把关于首页的结论存储在哪里，

596
00:25:23,260 --> 00:25:27,550
所以这

597
00:25:27,550 --> 00:25:29,020
真的不适合我哟 你知道

598
00:25:29,020 --> 00:25:31,330
也许你适合在这里，但我

599
00:25:31,330 --> 00:25:33,880
会有点难另一种

600
00:25:33,880 --> 00:25:35,590
网站

601
00:25:35,590 --> 00:25:39,490
在这里似乎很难

602
00:25:39,490 --> 00:25:41,890
 

603
00:25:41,890 --> 00:25:43,330
拥有当前

604
00:25:43,330 --> 00:25:45,460
最高出价，这需要 eBay

605
00:25:45,460 --> 00:25:47,140
查看其他人的出价，然后当您

606
00:25:47,140 --> 00:25:49,600
最终获胜时，您知道您支付的金额

607
00:25:49,600 --> 00:25:52,710
与第二高出价有关，

608
00:25:52,710 --> 00:25:55,840
但这些出价是私人权利，您

609
00:25:55,840 --> 00:25:58,600
不希望其他人看到您的出价 出价，

610
00:25:58,600 --> 00:26:00,730
因为那样他们只能

611
00:26:00,730 --> 00:26:03,100
比您高出一美分并以较低的成本获胜，所以

612
00:26:03,100 --> 00:26:06,460
您知道也许您的两个用户二

613
00:26:06,460 --> 00:26:10,330
在这里存储了一个出价但是如果我

614
00:26:10,330 --> 00:26:12,280
对用户二出价并且我们需要

615
00:26:12,280 --> 00:26:13,750
这个应用程序来告诉我 如果我是

616
00:26:13,750 --> 00:26:15,460
中标者，这意味着该

617
00:26:15,460 --> 00:26:17,170
应用程序需要回答

618
00:26:17,170 --> 00:26:19,030
该问题可能需要

619
00:26:19,030 --> 00:26:23,590
知道用户出价用户两次出价这

620
00:26:23,590 --> 00:26:24,910
意味着我必须可以访问要出价的用户，

621
00:26:24,910 --> 00:26:26,920
但如果我的应用程序

622
00:26:26,920 --> 00:26:29,290
代码知道 它在迈克电脑上运行

623
00:26:29,290 --> 00:26:31,480
，我 可以将其更改

624
00:26:31,480 --> 00:26:33,220
为您在自己的计算机上运行的代码的通常规则

625
00:26:33,220 --> 00:26:35,020
，如果我更改我的

626
00:26:35,020 --> 00:26:36,730
应用程序代码以实际显示您的

627
00:26:36,730 --> 00:26:38,920
出价，那么从

628
00:26:38,920 --> 00:26:40,420
eBay 试图做的事情的角度来看，这完全是作弊

629
00:26:40,420 --> 00:26:42,940
，所以没有人会相信拍卖

630
00:26:42,940 --> 00:26:46,210
系统允许这样做，所以真的

631
00:26:46,210 --> 00:26:48,610
不清楚你知道可能有一些

632
00:26:48,610 --> 00:26:50,410
技巧可以使用，但你知道如果我们

633
00:26:50,410 --> 00:26:52,120
只是使用这种架构和

634
00:26:52,120 --> 00:26:54,400
直接的方式，像 eBay

635
00:26:54,400 --> 00:26:57,280
这样需要查看其他人的

636
00:26:57,280 --> 00:26:59,580
秘密数据但不审查数据的网站

637
00:26:59,580 --> 00:27:04,090
是相当不错的 就像我

638
00:27:04,090 --> 00:27:05,770
已经提到的那样，网站

639
00:27:05,770 --> 00:27:08,320
必须保留自己的数据，例如索引

640
00:27:08,320 --> 00:27:10,810
或投票计数或通常

641
00:27:10,810 --> 00:27:12,700
是一个难题的东西也是一个难题，因为

642
00:27:12,700 --> 00:27:14,770
这里没有概念你知道网站

643
00:27:14,770 --> 00:27:15,610
本身

644
00:27:15,610 --> 00:27:17,170
只有应用程序代码和

645
00:27:17,170 --> 00:27:22,180
通用用户拥有 存储，因为

646
00:27:22,180 --> 00:27:23,740
通常这些东西，所以你

647
00:27:23,740 --> 00:27:25,240
可能不得不用一些

648
00:27:25,240 --> 00:27:28,000
结痂的服务器来增加它，以运行 eBay 的隐私

649
00:27:28,000 --> 00:27:30,580
关键部分或其他任何东西 它

650
00:27:30,580 --> 00:27:31,810
不太适合模型

651
00:27:31,810 --> 00:27:34,600
，另一件事我在

652
00:27:34,600 --> 00:27:38,590
这里会变成坏消息，

653
00:27:38,590 --> 00:27:39,790
如果我有数据想要与某些人分享，而

654
00:27:39,790 --> 00:27:41,650
不是其他人喜欢

655
00:27:41,650 --> 00:27:43,390
分享数据 只有六八到四名

656
00:27:43,390 --> 00:27:47,170
学生，但不是外人 你

657
00:27:47,170 --> 00:27:49,710
知道这实际上是如何强制执行的

658
00:27:49,710 --> 00:27:52,000
你知道我们真的很想使用终端和

659
00:27:52,000 --> 00:27:53,770
加密，所以我们不必信任

660
00:27:53,770 --> 00:27:54,970
存储服务器，因为毕竟这

661
00:27:54,970 --> 00:27:56,800
是离开的一大动力

662
00:27:56,800 --> 00:27:59,200
从当前的网站架构来看，

663
00:27:59,200 --> 00:28:01,270
我们不想信任

664
00:28:01,270 --> 00:28:05,080
这些云服务，所以我可以

665
00:28:05,080 --> 00:28:07,720
加密数据，以便 682 四个

666
00:28:07,720 --> 00:28:10,420
学生可以阅读它，但实际上

667
00:28:10,420 --> 00:28:12,940
很难以任何

668
00:28:12,940 --> 00:28:15,070
一种直接的方式做到这一点你知道 我可以

669
00:28:15,070 --> 00:28:17,410
 

670
00:28:17,410 --> 00:28:19,300
用

671
00:28:19,300 --> 00:28:22,270
六十二个学生密钥中的每一个加密数据一百次，或者我

672
00:28:22,270 --> 00:28:24,100
可以用某种唯一密钥加密数据一次

673
00:28:24,100 --> 00:28:27,010
，然后

674
00:28:27,010 --> 00:28:29,080
用两个学生密钥或

675
00:28:29,080 --> 00:28:32,830
其他东西加密该密钥 但是 n 你遇到一个

676
00:28:32,830 --> 00:28:34,300
问题，所以如果有人放弃课程

677
00:28:34,300 --> 00:28:35,290
并且你不希望他们能够

678
00:28:35,290 --> 00:28:36,790
看到你知道的数据，你如何

679
00:28:36,790 --> 00:28:38,710
确保他们现在看不到数据，这样

680
00:28:38,710 --> 00:28:42,240
你就可以使用加密来保护隐私但是

681
00:28:42,240 --> 00:28:43,980
一旦您进入

682
00:28:43,980 --> 00:28:47,940
具有用户组的复杂多用户应用程序，

683
00:28:47,940 --> 00:28:51,720
例如密码学

684
00:28:51,720 --> 00:28:54,119
变得很难使用来解决

685
00:28:54,119 --> 00:28:59,940
您的隐私问题，好吧，所以

686
00:28:59,940 --> 00:29:04,649
这些是系统可能

687
00:29:04,649 --> 00:29:07,590
难以编程的方式，因为它可能

688
00:29:07,590 --> 00:29:08,850
编程笨拙，

689
00:29:08,850 --> 00:29:10,259
编程功能笨拙，这些功能可能会泄漏

690
00:29:10,259 --> 00:29:12,269
到

691
00:29:12,269 --> 00:29:14,009
您可以拥有的应用程序功能集中

692
00:29:14,009 --> 00:29:16,499
，这也不会让用户感到

693
00:29:16,499 --> 00:29:20,940
 

694
00:29:20,940 --> 00:29:24,240
非常高兴 stack

695
00:29:24,240 --> 00:29:28,529
正在朝着这个方向努力，所以现在

696
00:29:28,529 --> 00:29:30,570
让我们更多地关注

697
00:29:30,570 --> 00:29:37,409
块堆栈，特别是块

698
00:29:37,409 --> 00:29:39,149
堆栈实际上起源于一个项目的地方

699
00:29:39,149 --> 00:29:43,730
是一个安全的命名方案，你

700
00:29:43,730 --> 00:29:47,909
仍然可以看到这篇论文 我们

701
00:29:47,909 --> 00:29:50,639
今天阅读的内容非常关注

702
00:29:50,639 --> 00:29:52,679
命名，尽管如果您查看他们

703
00:29:52,679 --> 00:29:54,450
当前的网站和

704
00:29:54,450 --> 00:29:56,309
他们编写的当前内容，更多的是关于这种去中心

705
00:29:56,309 --> 00:29:57,869
化架构和

706
00:29:57,869 --> 00:30:00,889
应用程序，而不是关于命名，

707
00:30:00,889 --> 00:30:02,940
但名称对他们来说仍然非常重要，

708
00:30:02,940 --> 00:30:05,940
所以问题是 他们是什么

709
00:30:05,940 --> 00:30:06,960
你知道他们为什么对

710
00:30:06,960 --> 00:30:08,730
名称感兴趣以及他们需要从

711
00:30:08,730 --> 00:30:10,710
命名系统中得到什么所以

712
00:30:10,710 --> 00:30:12,809
他们在论文中谈论的名称类型

713
00:30:12,809 --> 00:30:15,720
然后是块堆栈通常是用户

714
00:30:15,720 --> 00:30:20,570
名这些是真正的人类用户所以

715
00:30:20,570 --> 00:30:23,820
我们 重新谈论你知道的名字，

716
00:30:23,820 --> 00:30:27,690
也许罗伯特·莫里斯（Robert Morris）是的

717
00:30:27,690 --> 00:30:30,919
 

718
00:30:30,919 --> 00:30:34,139
 

719
00:30:34,139 --> 00:30:35,669
 

720
00:30:35,669 --> 00:30:37,619
 

721
00:30:37,619 --> 00:30:39,809
 

722
00:30:39,809 --> 00:30:42,269
用户需要控制的数据 谁可以看到

723
00:30:42,269 --> 00:30:44,039
他们的数据，因此他们需要能够

724
00:30:44,039 --> 00:30:47,759
命名其他用户

725
00:30:47,759 --> 00:30:51,179
他们需要解决的具体问题

726
00:30:51,179 --> 00:30:54,330
，如果我

727
00:30:54,330 --> 00:30:57,450
想查看您的，他们需要通过命名来解决 数据 um 块堆栈

728
00:30:57,450 --> 00:30:59,220
需要找到您的数据在哪里您

729
00:30:59,220 --> 00:31:00,630
知道您将数据存储在某个

730
00:31:00,630 --> 00:31:02,220
存储服务器上的某个地方我需要

731
00:31:02,220 --> 00:31:05,250
知道您知道使用 Amazon AWS

732
00:31:05,250 --> 00:31:07,890
或者您知道的 Microsoft Azure 以及如果

733
00:31:07,890 --> 00:31:10,309
是 Microsoft 正在销毁哪个服务器

734
00:31:10,309 --> 00:31:14,340
您的数据，因此块堆栈

735
00:31:14,340 --> 00:31:21,600
需要一种将名称映射到存储数据的位置的方法

736
00:31:21,600 --> 00:31:23,070
 

737
00:31:23,070 --> 00:31:25,190
，这是他们对名称所做的一件大事，

738
00:31:25,190 --> 00:31:28,440
但他们还需要确定我是否

739
00:31:28,440 --> 00:31:30,659
要读取您的数据，我需要

740
00:31:30,659 --> 00:31:31,950
能够 做一些事情，比如检查它是否

741
00:31:31,950 --> 00:31:34,980
真的是你的数据，你知道我不能存储

742
00:31:34,980 --> 00:31:36,269
，这不是重点是

743
00:31:36,269 --> 00:31:40,679
不必信任存储服务，所以

744
00:31:40,679 --> 00:31:42,389
为了让我能够检查

745
00:31:42,389 --> 00:31:45,269
它是你的数据，我们需要一个 将

746
00:31:45,269 --> 00:31:50,340
名称映射到公钥的方法，我们

747
00:31:50,340 --> 00:31:53,789
假设当您存储数据

748
00:31:53,789 --> 00:31:56,070
时，您首先使用您的公钥对其进行签名，因此我们

749
00:31:56,070 --> 00:31:57,510
需要 DeMayo 名称到哪里可以找到该

750
00:31:57,510 --> 00:31:59,250
人的数据并将名称映射

751
00:31:59,250 --> 00:32:01,080
到我们使用的公钥 检查当我们

752
00:32:01,080 --> 00:32:03,240
检索数据时它是重新 盟友您

753
00:32:03,240 --> 00:32:05,610
编写的数据，而不是存储服务或其他人编造的某种误导性的

754
00:32:05,610 --> 00:32:07,289
东西，

755
00:32:07,289 --> 00:32:08,600
 

756
00:32:08,600 --> 00:32:10,950
 

757
00:32:10,950 --> 00:32:12,840
如果我

758
00:32:12,840 --> 00:32:14,610
想加密数据以便只有您

759
00:32:14,610 --> 00:32:17,220
可以读取它，那么这个名为公钥的东西实际上也以其他方式使用 我

760
00:32:17,220 --> 00:32:19,320
要做的方法是

761
00:32:19,320 --> 00:32:22,889
使用您的公钥加密数据或其他密钥，以便

762
00:32:22,889 --> 00:32:25,200
只有您的私钥可以读取它所以如果

763
00:32:25,200 --> 00:32:27,510
我想实现加密 ACL

764
00:32:27,510 --> 00:32:29,700
或几乎任何

765
00:32:29,700 --> 00:32:32,490
我需要的权限密钥访问控制方案你有 我

766
00:32:32,490 --> 00:32:34,260
需要为

767
00:32:34,260 --> 00:32:37,049
可以使用数据的人命名，所以如果我要

768
00:32:37,049 --> 00:32:42,090
制作访问控制列表，这些通常

769
00:32:42,090 --> 00:32:44,309
 

770
00:32:44,309 --> 00:32:46,409
是由名称驱动的一种或另一种方式，并且可能能够命名

771
00:32:46,409 --> 00:32:51,850
可以读取我的数据的人，所以

772
00:32:51,850 --> 00:32:55,240
这在 特别是这部分将

773
00:32:55,240 --> 00:32:58,570
人名映射到公钥这

774
00:32:58,570 --> 00:33:01,000
通常称为公钥

775
00:33:01,000 --> 00:33:06,520
基础设施或 PKI，因此 block

776
00:33:06,520 --> 00:33:08,680
sac 提出的除其他事项外，是

777
00:33:08,680 --> 00:33:12,030
一种通用的全球

778
00:33:12,030 --> 00:33:15,790
公共 PKI 公钥基础设施，用于 将

779
00:33:15,790 --> 00:33:19,990
用户名映射到用户公钥，

780
00:33:19,990 --> 00:33:23,790
这实际上非常重要，

781
00:33:24,330 --> 00:33:26,500
因为几

782
00:33:26,500 --> 00:33:30,220
十年来人们都知道，为了

783
00:33:30,220 --> 00:33:34,300
在互联网安全方面取得重大进展，几乎

784
00:33:34,300 --> 00:33:37,420
可以肯定，唯一的方法就是

785
00:33:37,420 --> 00:33:39,520
拥有某种公钥 方案，

786
00:33:39,520 --> 00:33:43,330
以便人们可以签署您知道

787
00:33:43,330 --> 00:33:46,540
他们生成电子邮件的数据并检查电子邮件上的签名

788
00:33:46,540 --> 00:33:49,720
或他们为其他人收到的数据

789
00:33:49,720 --> 00:33:54,010
并加密，以

790
00:33:54,010 --> 00:33:55,720
确保目标

791
00:33:55,720 --> 00:33:59,350
读者的隐私可以是数据，因此几乎任何

792
00:33:59,350 --> 00:34:02,370
互联网范围的方案或

793
00:34:02,370 --> 00:34:05,320
旨在获得加密隐私或

794
00:34:05,320 --> 00:34:07,870
加密身份验证的大型方案最终

795
00:34:07,870 --> 00:34:10,270
不得不涉及某种

796
00:34:10,270 --> 00:34:12,040
公钥系统公钥基础设施，

797
00:34:12,040 --> 00:34:14,260
以便我现在可以找出

798
00:34:14,260 --> 00:34:16,030
我想与之交谈的人的身份，我

799
00:34:16,030 --> 00:34:20,460
如何找到他们的公钥，然而

800
00:34:20,460 --> 00:34:25,659
那里没有一个成功的

801
00:34:25,659 --> 00:34:26,889
公钥基础设施系统，没有

802
00:34:26,889 --> 00:34:28,600
人真正想出如何构建

803
00:34:28,600 --> 00:34:32,100
其中一个真正有用的，并且

804
00:34:32,100 --> 00:34:34,570
作为 结果人们倾向于不

805
00:34:34,570 --> 00:34:38,230
构建或部署人们倾向于不

806
00:34:38,230 --> 00:34:39,659
部署

807
00:34:39,659 --> 00:34:43,810
具有加密隐私和

808
00:34:43,810 --> 00:34:46,480
真实性的系统，因为没有 PKI，

809
00:34:46,480 --> 00:34:48,280
也许因为人们没有

810
00:34:48,280 --> 00:34:49,840
从事 PGI 工作，因为目前尚不清楚

811
00:34:49,840 --> 00:34:53,139
谁会使用它们，但无论如何

812
00:34:53,139 --> 00:34:54,280
块堆栈之所以有趣的原因之一

813
00:34:54,280 --> 00:34:56,230
是因为他们正在

814
00:34:56,230 --> 00:34:59,710
努力建立一个全球规模的公钥

815
00:34:59,710 --> 00:35:02,160
基础设施

816
00:35:02,440 --> 00:35:04,599
记住论文中

817
00:35:04,599 --> 00:35:06,280
提到的 Zuko 三角形

818
00:35:06,280 --> 00:35:08,800
的名称类型 论文谈论的名称样式

819
00:35:08,800 --> 00:35:12,700
是 三个

820
00:35:12,700 --> 00:35:14,530
这三个有趣的属性 一个

821
00:35:14,530 --> 00:35:17,319
是它们的独特性，这

822
00:35:17,319 --> 00:35:19,210
实际上意味着名称具有

823
00:35:19,210 --> 00:35:22,420
全球意义 例如罗伯特的名字

824
00:35:22,420 --> 00:35:23,920
具有相同的含义

825
00:35:23,920 --> 00:35:25,869
世界上的每个人都以

826
00:35:25,869 --> 00:35:28,030
相同的方式映射到相同的数据

827
00:35:28,030 --> 00:35:30,400
位置与世界上每个人都相同的公钥

828
00:35:30,400 --> 00:35:31,150
当然这

829
00:35:31,150 --> 00:35:32,410
对罗伯特来说有点荒谬你知道

830
00:35:32,410 --> 00:35:35,740
大概我在块堆栈下的ID

831
00:35:35,740 --> 00:35:37,210
会很多 比这更长，你知道也许

832
00:35:37,210 --> 00:35:39,760
罗伯特莫里斯有很多罗伯特

833
00:35:39,760 --> 00:35:41,849
莫里斯也许我是罗伯特莫里斯第

834
00:35:41,849 --> 00:35:44,319
67 号是罗伯特莫里斯在

835
00:35:44,319 --> 00:35:45,819
块堆栈上注册可能

836
00:35:45,819 --> 00:35:48,040
会更接近我的名字在

837
00:35:48,040 --> 00:35:50,290
块堆栈下无论如何

838
00:35:50,290 --> 00:35:52,270
世界上的每个人 当他们看到这个名字并

839
00:35:52,270 --> 00:35:53,920
通过 PKI 运行它时，他们会得到

840
00:35:53,920 --> 00:35:55,990
关于它的相同信息，所以这真的

841
00:35:55,990 --> 00:36:00,609
意味着 global 可能是一个更好的词，

842
00:36:00,609 --> 00:36:02,680
本文谈到的第二个属性

843
00:36:02,680 --> 00:36:06,750
名称是否

844
00:36:06,750 --> 00:36:08,950
像 Robert Morris 一样具有人类可读性，所以有人

845
00:36:08,950 --> 00:36:09,910
可以 看看它，你就

846
00:36:09,910 --> 00:36:13,329
知道猜一个名字的含义，也许人们

847
00:36:13,329 --> 00:36:14,440
可以记住这些名字，

848
00:36:14,440 --> 00:36:18,690
因为它们具有人类的

849
00:36:18,690 --> 00:36:21,190
意义，他们感兴趣的最后一件事

850
00:36:21,190 --> 00:36:23,380
是命名

851
00:36:23,380 --> 00:36:26,109
系统名称的分配是

852
00:36:26,109 --> 00:36:32,560
分散的 你知道这篇论文

853
00:36:32,560 --> 00:36:33,970
声称这是一个古老的说法，即

854
00:36:33,970 --> 00:36:40,450
很难得到所有这三个你知道的

855
00:36:40,450 --> 00:36:41,770
显然不是不可能的，因为

856
00:36:41,770 --> 00:36:44,619
这篇论文是那种直观的

857
00:36:44,619 --> 00:36:48,040
伊森为什么很难同时获得这三个

858
00:36:48,040 --> 00:36:51,069
是如果你有一个假设你

859
00:36:51,069 --> 00:36:53,140
有分散的助手，那么

860
00:36:53,140 --> 00:36:56,770
你知道没有一个实体可以

861
00:36:56,770 --> 00:36:59,589
很好地分配名称，如果你这样做，那么

862
00:36:59,589 --> 00:37:02,470
很难确保唯一性，如果你

863
00:37:02,470 --> 00:37:03,760
没有 一些单一的实体

864
00:37:03,760 --> 00:37:04,810
分发名称你怎么知道你

865
00:37:04,810 --> 00:37:06,280
最终不会分发同名

866
00:37:06,280 --> 00:37:08,680
的多个人如果没有一些

867
00:37:08,680 --> 00:37:11,530
中央可信实体并且你

868
00:37:11,530 --> 00:37:14,859
实际上可以拥有分散和唯一的

869
00:37:14,859 --> 00:37:15,599
名称

870
00:37:15,599 --> 00:37:18,359
但现在最明显的方法是 这

871
00:37:18,359 --> 00:37:21,180
牺牲了人类可读的部分，所以如果

872
00:37:21,180 --> 00:37:23,069
你决定你的名字将

873
00:37:23,069 --> 00:37:26,910
是你知道的公钥 1000 位

874
00:37:26,910 --> 00:37:29,069
公钥在公共私人密码

875
00:37:29,069 --> 00:37:31,440
系统中，任何人都可以组成一个新的

876
00:37:31,440 --> 00:37:34,369
公钥/私钥对，他们

877
00:37:34,369 --> 00:37:37,199
通常使用随机数 和

878
00:37:37,199 --> 00:37:38,789
emmm 数字生成器，所以因为任何人都

879
00:37:38,789 --> 00:37:41,130
可以组成一个并且它们是随机生成的，

880
00:37:41,130 --> 00:37:43,859
所以它们将是独一无二的，但

881
00:37:43,859 --> 00:37:46,019
它们不是人类可读的，所以你知道

882
00:37:46,019 --> 00:37:49,859
许多尝试获取 al 的明显方法

883
00:37:49,859 --> 00:37:51,709
l 其中三个

884
00:37:51,709 --> 00:37:59,969
不能很好地同时工作，因为块堆栈

885
00:37:59,969 --> 00:38:03,630
在非常高的水平上解决了这些问题

886
00:38:03,630 --> 00:38:04,920
 

887
00:38:04,920 --> 00:38:07,259
 

888
00:38:07,259 --> 00:38:10,019
 

889
00:38:10,019 --> 00:38:12,779
每个人都

890
00:38:12,779 --> 00:38:15,239
看到相同的映射集，

891
00:38:15,239 --> 00:38:17,099
他们在高层次上这样做的方式是，

892
00:38:17,099 --> 00:38:22,410
他们依赖比特币产生

893
00:38:22,410 --> 00:38:26,219
单个有序交易日志的能力，

894
00:38:26,219 --> 00:38:28,709
这是查看比特币的一种方式

895
00:38:28,709 --> 00:38:31,380
，每个人都同意

896
00:38:31,380 --> 00:38:33,630
比特币块的顺序是什么 你

897
00:38:33,630 --> 00:38:35,069
知道也许你会得到临时分叉，但

898
00:38:35,069 --> 00:38:37,890
比特币会迅速解决任何分叉，并

899
00:38:37,890 --> 00:38:41,729
让每个人都同意

900
00:38:41,729 --> 00:38:44,969
比特币中的区块序列是什么，所以

901
00:38:44,969 --> 00:38:47,160
一旦我们的比特币

902
00:38:47,160 --> 00:38:50,209
就一系列交易达成一致，

903
00:38:50,209 --> 00:38:55,769
我们可以坚持任何人都可以坚持

904
00:38:55,769 --> 00:38:59,039
交易 你知道的比特币日志

905
00:38:59,039 --> 00:39:01,410
以及可能是有效的

906
00:39:01,410 --> 00:39:03,539
比特币交易也

907
00:39:03,539 --> 00:39:06,599
隐藏在其中的名称保留记录中，所以

908
00:39:06,599 --> 00:39:12,479
现在这是比特上的一种命名

909
00:39:12,479 --> 00:39:14,490
硬币

910
00:39:14,490 --> 00:39:16,550
你

911
00:39:17,160 --> 00:39:19,920
是区块链，所以你知道比特币

912
00:39:19,920 --> 00:39:22,799
已经让我们获得

913
00:39:22,799 --> 00:39:25,490
了这些交易区块的独特且全球认可的序列，

914
00:39:25,490 --> 00:39:28,920
现在任何人

915
00:39:28,920 --> 00:39:30,240
都可以提交交易，所以从这个

916
00:39:30,240 --> 00:39:32,039
意义上说，它是完全去中心化的，

917
00:39:32,039 --> 00:39:37,799
所以区块堆栈使用的方式如何？

918
00:39:37,799 --> 00:39:40,230
这个命名是，如果我

919
00:39:40,230 --> 00:39:42,329
想注册一个名字，我可以选择任何我

920
00:39:42,329 --> 00:39:45,420
喜欢的名字，比如罗伯特莫里斯，只要它还

921
00:39:45,420 --> 00:39:48,359
没有被你使用并且我坚持我

922
00:39:48,359 --> 00:39:54,690
提交给比特币一个你

923
00:39:54,690 --> 00:39:55,890
知道恰好是有效比特币的交易

924
00:39:55,890 --> 00:39:59,910
交易，但阻塞堆栈也将是

925
00:39:59,910 --> 00:40:01,950
有意义的，它会

926
00:40:01,950 --> 00:40:05,880
说请保留，请分配

927
00:40:05,880 --> 00:40:10,740
名称 RTM 并将其映射到任何我的

928
00:40:10,740 --> 00:40:12,839
公钥和我的关于

929
00:40:12,839 --> 00:40:14,970
在哪里有数据的信息不是任何人都可以

930
00:40:14,970 --> 00:40:18,630
提交这些和块堆栈

931
00:40:18,630 --> 00:40:20,520
服务器 区块税服务器会在涉及比​​特

932
00:40:20,520 --> 00:40:22,609
币区块链时对其进行监控，并且

933
00:40:22,609 --> 00:40:25,950
每次他们看到其中一条记录

934
00:40:25,950 --> 00:40:29,039
是区块堆栈交易

935
00:40:29,039 --> 00:40:31,619
和比特币交易时，区块堆栈 k

936
00:40:31,619 --> 00:40:34,319
服务器考虑将此映射添加

937
00:40:34,319 --> 00:40:37,470
到他们的名称数据库中，但他们有一

938
00:40:37,470 --> 00:40:42,930
组规则用于拒绝

939
00:40:42,930 --> 00:40:44,549
比特币区块链中的坏块堆栈交易，

940
00:40:44,549 --> 00:40:47,220
例如，如果

941
00:40:47,220 --> 00:40:51,349
在我分配 RTM 后一些坏人

942
00:40:51,349 --> 00:40:54,059
自己尝试分配 RTM，他们

943
00:40:54,059 --> 00:40:56,220
可以提交 他们喜欢的任何交易，因此

944
00:40:56,220 --> 00:40:59,700
他们也可以完美地提交

945
00:40:59,700 --> 00:41:01,799
交易，试图从我那里窃取名称 RTM

946
00:41:01,799 --> 00:41:03,180
并将其映射到其他

947
00:41:03,180 --> 00:41:05,400
一些他们知道私钥的

948
00:41:05,400 --> 00:41:09,240
公钥所有块堆栈服务器

949
00:41:09,240 --> 00:41:11,190
都在监视比特币链

950
00:41:11,190 --> 00:41:12,839
只有一个 比特币链只有

951
00:41:12,839 --> 00:41:15,420
一组内容，

952
00:41:15,420 --> 00:41:18,420
所以你知道的块堆栈服务器

953
00:41:18,420 --> 00:41:20,849
 

954
00:41:20,849 --> 00:41:22,470
会查看比特币链中的连续交易，他们会首先看到我的

955
00:41:22,470 --> 00:41:26,609
分配，然后他们会

956
00:41:26,609 --> 00:41:28,200
看到其他人

957
00:41:28,200 --> 00:41:29,880
的相同分配 名称和规则将

958
00:41:29,880 --> 00:41:30,910
是一个名称已经是 Alec

959
00:41:30,910 --> 00:41:33,009
你不能被分配第二次

960
00:41:33,009 --> 00:41:36,130
并且块堆栈服务器将忽略这个

961
00:41:36,130 --> 00:41:42,119
尝试注册 n 的名称，

962
00:41:42,119 --> 00:41:45,069
所以这里实施的是

963
00:41:45,069 --> 00:41:49,779
一种先到先得的方案，用于

964
00:41:49,779 --> 00:41:51,730
分配名称 第

965
00:41:51,730 --> 00:41:54,420
一个将分配记录放入区块链的人将

966
00:41:54,420 --> 00:41:59,349
赢得该名称，就这

967
00:41:59,349 --> 00:42:01,450
三个属性 Zucco 三角形

968
00:42:01,450 --> 00:42:04,150
属性而言 去中心化，因为

969
00:42:04,150 --> 00:42:06,099
你知道我们可以 嗯，我们相信

970
00:42:06,099 --> 00:42:08,349
比特币是去中心化的，

971
00:42:08,349 --> 00:42:10,509
没有任何其他实体决定谁

972
00:42:10,509 --> 00:42:13,180
得到什么名字 这实际上只是这种

973
00:42:13,180 --> 00:42:16,869
先到先得的去中心化方案

974
00:42:16,869 --> 00:42:18,730
名字可以是任何东西

975
00:42:18,730 --> 00:42:21,069
没有任何字符串 所以

976
00:42:21,069 --> 00:42:22,539
他们把

977
00:42:22,539 --> 00:42:24,990
人类可读的名字放在这里是完全合理的，

978
00:42:24,990 --> 00:42:26,619
每个人都在

979
00:42:26,619 --> 00:42:28,900
为他们看到的任何名字查看同一个

980
00:42:28,900 --> 00:42:30,579
 

981
00:42:30,579 --> 00:42:33,369
 

982
00:42:33,369 --> 00:42:37,150
 

983
00:42:37,150 --> 00:42:40,210
区块链 设法在他们的命名系统中实际获得

984
00:42:40,210 --> 00:42:42,279
所有这三个 Zucco 属性

985
00:42:42,279 --> 00:42:44,019
有一个

986
00:42:44,019 --> 00:42:45,730
问题，这是否意味着块堆栈

987
00:42:45,730 --> 00:42:48,430
服务器必须扫描

988
00:42:48,430 --> 00:42:50,640
从后到前添加新名称的整个

989
00:42:50,640 --> 00:42:54,250
链是的，所以原则上确保

990
00:42:54,250 --> 00:42:59,529
名称数据库的状态确实

991
00:42:59,529 --> 00:43:01,180
是解释整个区块链的结果，

992
00:43:01,180 --> 00:43:02,529
但当然你知道块堆栈

993
00:43:02,529 --> 00:43:05,710
服务器将兑现你知道兑现

994
00:43:05,710 --> 00:43:07,539
他们的最新状态 ''''''ve seen and as these

995
00:43:07,539 --> 00:43:09,910
in a database so you know that each block stacks are

996
00:43:09,910 --> 00:43:11,880
you know may he's read this far and

997
00:43:11,880 --> 00:43:13,900
Bitcoin blockchain and has a database

998
00:43:13,900 --> 00:43:16,779
that has the current mapping for each

999
00:43:16,779 --> 00:43:19,779
name in the all box in this before and

1000
00:43:19,779 --> 00:43:21,640
when they see a new block 从比特币开始，

1001
00:43:21,640 --> 00:43:23,740
他们只会查看交易

1002
00:43:23,740 --> 00:43:25,750
并逐步更新他们的数据库

1003
00:43:25,750 --> 00:43:28,059
以反映这些交易，因此让

1004
00:43:28,059 --> 00:43:29,589
一个新的块堆栈服务器加速

1005
00:43:29,589 --> 00:43:31,960
实际上确实需要相当长的时间，

1006
00:43:31,960 --> 00:43:34,059
我认为当我读到的一些论文说它

1007
00:43:34,059 --> 00:43:38,170
可能需要 几天，嗯，但是

1008
00:43:38,170 --> 00:43:40,420
一旦你的块堆栈服务器

1009
00:43:40,420 --> 00:43:41,859
加速，那么它就是

1010
00:43:41,859 --> 00:43:43,960
在那之后的各种增量添加，

1011
00:43:43,960 --> 00:43:47,390
但你知道更大的

1012
00:43:47,390 --> 00:43:48,950
一点是b确实是这种情况 锁

1013
00:43:48,950 --> 00:43:52,040
堆栈是比特币的一种捎带

1014
00:43:52,040 --> 00:43:54,920
，你知道你可以很容易地争辩说

1015
00:43:54,920 --> 00:43:57,230
比特币最终的可扩展性不是很好，

1016
00:43:57,230 --> 00:44:00,559
或者使用了太多的电力，谁

1017
00:44:00,559 --> 00:44:03,400
知道太慢需要很长时间才能

1018
00:44:03,400 --> 00:44:05,780
反映新的交易，而且

1019
00:44:05,780 --> 00:44:07,790
城市有点

1020
00:44:07,790 --> 00:44:09,440
块堆栈

1021
00:44:09,440 --> 00:44:11,690
从比特币继承的不良属性，但是

1022
00:44:11,690 --> 00:44:17,270
您知道它不存在不知道在命名系统

1023
00:44:17,270 --> 00:44:21,380
中获取所有这三个 Zuko 属性的另一种方法，

1024
00:44:21,380 --> 00:44:23,960
 

1025
00:44:23,960 --> 00:44:27,349
所以如果您重视它们，您的选择

1026
00:44:27,349 --> 00:44:30,349
不是您知道很多选择以外的选择

1027
00:44:30,349 --> 00:44:35,839
这种方法没问题，所以我们可能会问

1028
00:44:35,839 --> 00:44:42,490
自己，这种命名方案是否

1029
00:44:42,490 --> 00:44:45,950
这种将名称映射到公钥

1030
00:44:45,950 --> 00:44:49,329
和位置以查找数据的方式

1031
00:44:49,329 --> 00:44:51,290
是否它是否真的具有我们

1032
00:44:51,290 --> 00:44:54,049
真正喜欢的属性所以让我们回顾一下

1033
00:44:54,049 --> 00:45:00,230
这三个属性，所以

1034
00:45:00,230 --> 00:45:03,710
一个 名称是独一无二的 这个

1035
00:45:03,710 --> 00:45:07,280
系统中的每个人都同意我们的 TM 意味着什么，这

1036
00:45:07,280 --> 00:45:09,170
确实是全局意义的名称，

1037
00:45:09,170 --> 00:45:12,680
所以问题是我们是否

1038
00:45:12,680 --> 00:45:13,730
关心这是否是一个好的

1039
00:45:13,730 --> 00:45:20,480
属性，所以你知道一件事

1040
00:45:20,480 --> 00:45:22,970
是有利的，因为它

1041
00:45:22,970 --> 00:45:27,309
使得拥有像这个人这样的名字

1042
00:45:28,059 --> 00:45:32,059
你知道如果拥有全球

1043
00:45:32,059 --> 00:45:34,190
相关的名字意味着我们可以

1044
00:45:34,190 --> 00:45:35,750
互相谈论名字 我可以通过电子邮件给

1045
00:45:35,750 --> 00:45:37,640
你一个名字，这个名字

1046
00:45:37,640 --> 00:45:39,500
对你和我的含义一样，

1047
00:45:39,500 --> 00:45:41,059
因为我们都会

1048
00:45:41,059 --> 00:45:42,799
在区块链中查找它并得到相同的结果

1049
00:45:42,799 --> 00:45:46,670
，这很好，这也意味着我

1050
00:45:46,670 --> 00:45:49,549
可以查看 记录

1051
00:45:49,549 --> 00:45:51,079
在访问控制列表之类的某处的名称，

1052
00:45:51,079 --> 00:45:54,530
并且有点了解

1053
00:45:54,530 --> 00:45:57,040
它们对我的影响，

1054
00:46:04,650 --> 00:46:09,009
但有些事情可能不太

1055
00:46:09,009 --> 00:46:12,670
好，如果你必须

1056
00:46:12,670 --> 00:46:14,259
从一个全局池中选择你的名字，

1057
00:46:14,259 --> 00:46:15,759
因为那是 我们在

1058
00:46:15,759 --> 00:46:18,690
这里所做的是因为只有一个

1059
00:46:18,690 --> 00:46:21,279
命名系统只有一组

1060
00:46:21,279 --> 00:46:26,799
名称这意味着

1061
00:46:26,799 --> 00:46:28,329
实际上很难查看一个名称并

1062
00:46:28,329 --> 00:46:30,249
确定它是否是您想要的名称，就像我的

1063
00:46:30,249 --> 00:46:31,869
名字实际上可能是 正如我

1064
00:46:31,869 --> 00:46:34,059
在你知道之前提到过，也许你知道

1065
00:46:34,059 --> 00:46:37,599
我们的 TM 九五五八七，

1066
00:46:37,599 --> 00:46:39,880
这取决于我们的团队有多少所以

1067
00:46:39,880 --> 00:46:41,740
这可能是我的名字实际上

1068
00:46:41,740 --> 00:46:44,200
很难看到它并决定

1069
00:46:44,200 --> 00:46:47,019
你真正遇到的 RTM，所以这

1070
00:46:47,019 --> 00:46:53,009
真的破坏了

1071
00:46:53,590 --> 00:46:56,510
他们在这里拥有的人类可读的属性

1072
00:46:56,510 --> 00:46:58,220
越大，系统

1073
00:46:58,220 --> 00:47:00,020
就越没有价值，拥有人类可读的

1074
00:47:00,020 --> 00:47:02,150
名字只是麻省理工学院的人，也许麻省理工学院

1075
00:47:02,150 --> 00:47:04,280
只有一个罗伯特莫里斯，

1076
00:47:04,280 --> 00:47:05,930
尽管实际上不止

1077
00:47:05,930 --> 00:47:10,310
一个，但在世界其他地方

1078
00:47:10,310 --> 00:47:13,310
一种关心

1079
00:47:13,310 --> 00:47:14,450
他们的名字是人类

1080
00:47:14,450 --> 00:47:19,520
可读的理由，我想这是非常苗条的，它也是

1081
00:47:19,520 --> 00:47:21,980
人类可读的，

1082
00:47:21,980 --> 00:47:24,890
这取决于正在发生的事情可能具有欺骗性，所以如果你

1083
00:47:24,890 --> 00:47:27,940
看到一个看起来像你在麻省理工学院知道 RTM 的名字，

1084
00:47:27,940 --> 00:47:34,220
如果你看到了那个 edu 那个名字和

1085
00:47:34,220 --> 00:47:35,810
块堆栈或者一些很

1086
00:47:35,810 --> 00:47:38,450
容易想象它可能会连接到

1087
00:47:38,450 --> 00:47:40,790
那个电子邮件地址的东西，因为它

1088
00:47:40,790 --> 00:47:42,380
看起来像人类可读它看起来

1089
00:47:42,380 --> 00:47:43,910
像是有意义的

1090
00:47:43,910 --> 00:47:45,560
拥有人类可读名称的全部意义在于

1091
00:47:45,560 --> 00:47:47,870
，它们向人们暗示了意义

1092
00:47:47,870 --> 00:47:50,060
这四个积木堆

1093
00:47:50,060 --> 00:47:52,550
严重误导了积木堆

1094
00:47:52,550 --> 00:47:54,230
名称真的没有任何意义，它

1095
00:47:54,230 --> 00:47:56,810
只是先到先得，所以我们都知道我们所

1096
00:47:56,810 --> 00:47:59,480
知道的一切 通过看到这个名字，

1097
00:47:59,480 --> 00:48:01,430
我们在麻省理工学院的团队从块

1098
00:48:01,430 --> 00:48:04,670
堆栈中告诉你这是这个名字的意思

1099
00:48:04,670 --> 00:48:07,700
是第一个人这个名字是指

1100
00:48:07,700 --> 00:48:09,320
第一个注册这个名字的人

1101
00:48:09,320 --> 00:48:11,900
这就是我们最初所知道的可能是

1102
00:48:11,900 --> 00:48:13,310
我可能是其他人 没有

1103
00:48:13,310 --> 00:48:15,230
理由相信是我，或者它

1104
00:48:15,230 --> 00:48:17,960
与麻省理工学院或其他任何事情有关

1105
00:48:17,960 --> 00:48:20,030
 

1106
00:48:20,030 --> 00:48:24,160
 

1107
00:48:24,160 --> 00:48:27,650
 

1108
00:48:27,650 --> 00:48:30,110
 

1109
00:48:30,110 --> 00:48:32,930
那张地图是我们

1110
00:48:32,930 --> 00:48:34,490
要去的，我花了一些时间和他们交谈，

1111
00:48:34,490 --> 00:48:35,870
你知道，也许我最终可以

1112
00:48:35,870 --> 00:48:38,630
说服自己，

1113
00:48:38,630 --> 00:48:40,820
他们就是我认为的那个人，但光是这个

1114
00:48:40,820 --> 00:48:43,010
名字看起来很有意义，但

1115
00:48:43,010 --> 00:48:45,680
可能实际上不是很有意义，

1116
00:48:45,680 --> 00:48:47,780
所以这是人类可读名称中的一个真正缺陷，

1117
00:48:47,780 --> 00:48:52,780
它可能是有缺陷的，

1118
00:48:53,110 --> 00:48:54,830
你知道相关

1119
00:48:54,830 --> 00:48:59,270
的块 SEC 命名方案并不能帮助

1120
00:48:59,270 --> 00:49:01,910
我找到我是否知道我

1121
00:49:01,910 --> 00:49:04,220
想和谁交谈块麻袋不 真正

1122
00:49:04,220 --> 00:49:07,790
帮助我会找到

1123
00:49:07,790 --> 00:49:09,680
我想和你交谈的人的名字知道我的意思是

1124
00:49:09,680 --> 00:49:11,750
也许你知道你想给

1125
00:49:11,750 --> 00:49:14,030
罗伯特莫里斯发送电子邮件你知道天哪这

1126
00:49:14,030 --> 00:49:16,430
非常无用而且这

1127
00:49:16,430 --> 00:49:18,290
是块堆栈命名系统中唯一的东西这些

1128
00:49:18,290 --> 00:49:21,800
名字 就像这样，所以它真的

1129
00:49:21,800 --> 00:49:24,110
不一定能解决

1130
00:49:24,110 --> 00:49:27,020
人们遇到的问题，我知道我

1131
00:49:27,020 --> 00:49:28,610
在脑海中知道我想和谁交谈，

1132
00:49:28,610 --> 00:49:30,890
但我不知道他们的公钥，

1133
00:49:30,890 --> 00:49:32,510
也不知道他们的块堆栈名称 要么

1134
00:49:32,510 --> 00:49:37,190
我如何找到他们的块技术，所以

1135
00:49:37,190 --> 00:49:39,560
这是这个系统中的一种缺陷，

1136
00:49:39,560 --> 00:49:41,150
 

1137
00:49:41,150 --> 00:49:42,920
如果你想使用块命名方案，你必须真的已经知道名称，但是你

1138
00:49:42,920 --> 00:49:45,260
如何找到这些

1139
00:49:45,260 --> 00:49:49,490
名称一些你可以

1140
00:49:49,490 --> 00:49:52,400
考虑的其他选项 命名我'  m 在一个

1141
00:49:52,400 --> 00:49:55,400
更大的去中心化系统

1142
00:49:55,400 --> 00:49:56,960
中，我们可以放弃

1143
00:49:56,960 --> 00:49:59,270
你知道的人类可读的名字，而不是尝试

1144
00:49:59,270 --> 00:50:00,770
获取所有这三个 Zucco 属性

1145
00:50:00,770 --> 00:50:03,890
，直接使用公钥

1146
00:50:03,890 --> 00:50:05,690
，这意味着如果我想

1147
00:50:05,690 --> 00:50:07,370
与你交互 我需要以某种方式找到你的公钥

1148
00:50:07,370 --> 00:50:09,650
也许你只是把它发给我

1149
00:50:09,650 --> 00:50:11,630
也许你通过电话告诉我一些

1150
00:50:11,630 --> 00:50:13,010
我可以用来获取你的公钥

1151
00:50:13,010 --> 00:50:15,830
也许你给我发一条安全消息或者

1152
00:50:15,830 --> 00:50:17,030
用纸或其他东西写在我们身上

1153
00:50:17,030 --> 00:50:19,010
以便我们可以 只需直接使用

1154
00:50:19,010 --> 00:50:21,020
公钥，然后我们就不必解决

1155
00:50:21,020 --> 00:50:22,250
所有这些问题，虽然

1156
00:50:22,250 --> 00:50:25,910
它们当然很尴尬，但也许我可以将

1157
00:50:25,910 --> 00:50:27,380
我知道的公钥存储在我的

1158
00:50:27,380 --> 00:50:29,900
个人联系人列表中，它们会

1159
00:50:29,900 --> 00:50:31,190
很有帮助，就像电话一样

1160
00:50:31,190 --> 00:50:32,260
电话号码的数量没有任何意义，

1161
00:50:32,260 --> 00:50:35,090
但是一旦我知道您的电话号码，我就可以将其

1162
00:50:35,090 --> 00:50:37,100
粘贴在我的联系人列表中，另一种

1163
00:50:37,100 --> 00:50:38,690
可能的方法是

1164
00:50:38,690 --> 00:50:41,450
放弃分散的部分，而只是尝试

1165
00:50:41,450 --> 00:50:43,670
制作一些中央实体 我

1166
00:50:43,670 --> 00:50:46,370
实际上可靠地验证身份，

1167
00:50:46,370 --> 00:50:49,040
您知道的某个集中式实体可能

1168
00:50:49,040 --> 00:50:51,290
是发放社会安全号码的社会保障系统，

1169
00:50:51,290 --> 00:50:54,200
或者您知道

1170
00:50:54,200 --> 00:50:55,520
发放驾驶

1171
00:50:55,520 --> 00:50:56,900
执照或其他东西的人以及

1172
00:50:56,900 --> 00:51:01,220
他们的工作以建立一个

1173
00:51:01,220 --> 00:51:04,440
集中式概念的

1174
00:51:04,440 --> 00:51:09,750
任何人 一种经过验证的名称

1175
00:51:09,750 --> 00:51:13,980
实际上也非常困难，但是

1176
00:51:13,980 --> 00:51:15,960
您知道无论如何这是另一种考虑的途径，

1177
00:51:15,960 --> 00:51:18,270
因此块堆栈采用这种

1178
00:51:18,270 --> 00:51:21,470
特殊方法来尝试使

1179
00:51:21,470 --> 00:51:29,190
名称正确，嗯，让我

1180
00:51:29,190 --> 00:51:31,950
概述一下块堆栈中的各个部分的大图

1181
00:51:31,950 --> 00:51:34,530
这是我之前在底部展示

1182
00:51:34,530 --> 00:51:36,359
的去中心化

1183
00:51:36,359 --> 00:51:40,490
应用程序图的

1184
00:51:40,490 --> 00:51:42,420
一种改进，他们有这个

1185
00:51:42,420 --> 00:51:46,190
比特币系统，它

1186
00:51:46,190 --> 00:51:52,380
与比特币块一起运行，并且

1187
00:51:52,380 --> 00:51:55,200
携带比特币未知的这些块

1188
00:51:55,200 --> 00:51:57,750
技术交易有一堆

1189
00:51:57,750 --> 00:52:02,180
块堆栈 命名系统服务器，

1190
00:52:02,180 --> 00:52:04,319
目前尚不清楚它们是否

1191
00:52:04,319 --> 00:52:07,410
打算让普通人运行

1192
00:52:07,410 --> 00:52:08,880
它们 它们将以某种方式成为一种服务，

1193
00:52:08,880 --> 00:52:10,170
让普通人

1194
00:52:10,170 --> 00:52:12,359
在自己的笔记本电脑上运行它们是最有意义的，因为

1195
00:52:12,359 --> 00:52:16,170
你必须信任它们，但

1196
00:52:16,170 --> 00:52:18,210
无论如何这可能不是那么好，这些块（如

1197
00:52:18,210 --> 00:52:20,670
命名服务服务器）读取

1198
00:52:20,670 --> 00:52:22,050
区块链并积累 一个

1199
00:52:22,050 --> 00:52:27,510
数据库，至少在第一个

1200
00:52:27,510 --> 00:52:30,420
实例中，块中的内容是什么，

1201
00:52:30,420 --> 00:52:34,500
比特币区块链中的内容是公钥

1202
00:52:34,500 --> 00:52:39,020
和散列，

1203
00:52:39,020 --> 00:52:41,640
描述每个用户

1204
00:52:41,640 --> 00:52:46,319
存储数据的信息的加密散列，因为你可以

1205
00:52:46,319 --> 00:52:47,910
存储这些信息，这只是你

1206
00:52:47,910 --> 00:52:51,180
知道 Artyom 存储的是数据 在亚马逊 AWS

1207
00:52:51,180 --> 00:52:56,250
或其他东西中，但它太大了，无法

1208
00:52:56,250 --> 00:52:57,990
方便地存储比特币，所以

1209
00:52:57,990 --> 00:53:00,089
有一种叫做 Atlas 的中间层，

1210
00:53:00,089 --> 00:53:03,599
它唯一的工作

1211
00:53:03,599 --> 00:53:09,180
就是将隐藏的信息的哈希值

1212
00:53:09,180 --> 00:53:11,339
和比特币映射到这些自己的

1213
00:53:11,339 --> 00:53:13,819
信息中，

1214
00:53:15,320 --> 00:53:17,810
每个人自己的记录 用户，所以这

1215
00:53:17,810 --> 00:53:21,460
意味着我的你知道我是否有一个 RT M

1216
00:53:21,460 --> 00:53:24,410
注册和

1217
00:53:24,410 --> 00:53:27,170
带有哈希值的盒子钉我的区域记录这只是

1218
00:53:27,170 --> 00:53:30,320
有 名称或您知道的 Internet

1219
00:53:30,320 --> 00:53:32,930
地址或我存储

1220
00:53:32,930 --> 00:53:35,840
数据的位置，因此您可能知道 AWS 斜杠

1221
00:53:35,840 --> 00:53:40,070
知道我用来

1222
00:53:40,070 --> 00:53:41,780
唯一标识我存储

1223
00:53:41,780 --> 00:53:46,060
在 AWS 中的内容的任何标识符，这实际上是对

1224
00:53:46,060 --> 00:53:48,670
我的存储位置的引用 我所有的

1225
00:53:48,670 --> 00:53:57,470
键值对现在都存储在哪里论文

1226
00:53:57,470 --> 00:53:59,450
我认为论文的愿景是你

1227
00:53:59,450 --> 00:54:02,330
可以让你的区域记录指向

1228
00:54:02,330 --> 00:54:04,460
任何云

1229
00:54:04,460 --> 00:54:06,890
存储事实上云存储系统必须让

1230
00:54:06,890 --> 00:54:09,800
你知道服从块堆栈接口

1231
00:54:09,800 --> 00:54:11,090
等等 你不能只在

1232
00:54:11,090 --> 00:54:12,650
现有的云存储系统中使用，所以在

1233
00:54:12,650 --> 00:54:15,800
实践中，这些都指向在

1234
00:54:15,800 --> 00:54:18,260
这些块对

1235
00:54:18,260 --> 00:54:21,770
他们运行的 gaia 服务器征税的那一刻，这些只是

1236
00:54:21,770 --> 00:54:23,840
存储服务器，它们知道

1237
00:54:23,840 --> 00:54:29,060
不同的块堆栈用户并存储

1238
00:54:29,060 --> 00:54:31,670
他们的密钥 他们的值对，这

1239
00:54:31,670 --> 00:54:33,050
意味着如果我想读取你的数据，

1240
00:54:33,050 --> 00:54:34,850
如果我正在运行一个

1241
00:54:34,850 --> 00:54:36,110
想要读取你的数据的块秒应用程序，

1242
00:54:36,110 --> 00:54:38,540
我需要以某种方式应用你的名字，我

1243
00:54:38,540 --> 00:54:41,480
必须找到你的名字，也许你

1244
00:54:41,480 --> 00:54:43,820
通过电话告诉我你的名字我

1245
00:54:43,820 --> 00:54:45,320
在我正在使用的应用程序中输入你的名字

1246
00:54:45,320 --> 00:54:48,560
也许这是一个做这个管理器并且过去

1247
00:54:48,560 --> 00:54:51,170
常常出去找到你的待办事项列表项

1248
00:54:51,170 --> 00:54:55,580
来告诉我我的应用程序将联系一个

1249
00:54:55,580 --> 00:54:58,460
块堆栈命名系统 服务器并要求

1250
00:54:58,460 --> 00:55:00,230
它翻译你的名字 它一直在

1251
00:55:00,230 --> 00:55:03,200
关注区块链 它保存一个

1252
00:55:03,200 --> 00:55:06,650
映射 它知道如何使用散列来

1253
00:55:06,650 --> 00:55:08,600
查找你的区域记录 你的区域记录

1254
00:55:08,600 --> 00:55:10,730
指向你和 Gaia 拥有的一些数据

1255
00:55:10,730 --> 00:55:14,560
，然后我的应用程序获取

1256
00:55:14,560 --> 00:55:18,530
它需要的这些数据 验证数据，以便所有

1257
00:55:18,530 --> 00:55:21,020
阻止活动的应用程序都希望数据

1258
00:55:21,020 --> 00:55:23,390
由 Gaia 中的所有者和

1259
00:55:23,390 --> 00:55:25,280
公钥签名 以检查您对

1260
00:55:25,280 --> 00:55:27,230
您知道的数据的签名 我可以使用您的

1261
00:55:27,230 --> 00:55:29,769
公钥或嵌入的公钥以及

1262
00:55:29,769 --> 00:55:32,900
您的记录和比特币，所以我 可以将

1263
00:55:32,900 --> 00:55:36,140
它用于我的应用程序 真的可以用它来检查

1264
00:55:36,140 --> 00:55:37,609
这里的签名 确保这

1265
00:55:37,609 --> 00:55:39,229
是您实际生成的数据，而

1266
00:55:39,229 --> 00:55:41,900
不是不可信

1267
00:55:41,900 --> 00:55:48,079
的 gaya 服务器 好的，所以

1268
00:55:48,079 --> 00:55:52,099
这是它如何工作的基本概述 结果

1269
00:55:52,099 --> 00:55:53,809
证明是 排序 f 将他们的

1270
00:55:53,809 --> 00:55:55,369
信息嵌入到比特币区块链上

1271
00:55:55,369 --> 00:56:00,130
并不像我描述的那样简单

1272
00:56:00,130 --> 00:56:03,710
 

1273
00:56:03,710 --> 00:56:05,809
 

1274
00:56:05,809 --> 00:56:07,729
 

1275
00:56:07,729 --> 00:56:09,619
 

1276
00:56:09,619 --> 00:56:11,059
有一个

1277
00:56:11,059 --> 00:56:13,190
分叉来检测它我的意思是他们的意思

1278
00:56:13,190 --> 00:56:14,569
是侦探因为分叉可能

1279
00:56:14,569 --> 00:56:20,930
是攻击的一部分而且你知道比特币

1280
00:56:20,930 --> 00:56:24,470
并没有为他们过滤掉不良记录

1281
00:56:24,470 --> 00:56:26,029
所以他们必须自己做并

1282
00:56:26,029 --> 00:56:27,289
强迫自己

1283
00:56:27,289 --> 00:56:29,420
他们得到的记录规则就像忽略重复

1284
00:56:29,420 --> 00:56:32,479
注册一样 他们

1285
00:56:32,479 --> 00:56:34,489
还需要绘制图表 他们收取

1286
00:56:34,489 --> 00:56:35,930
注册名称的费用，这意味着作为名称注册

1287
00:56:35,930 --> 00:56:39,920
的比特币交易

1288
00:56:39,920 --> 00:56:42,650
必须支付一些

1289
00:56:42,650 --> 00:56:44,479
钱来所谓的烧毁 地址

1290
00:56:44,479 --> 00:56:47,329
支付一些比特币当前比特币到

1291
00:56:47,329 --> 00:56:49,369
销毁地址，以便

1292
00:56:49,369 --> 00:56:52,609
有权注册该名称，并且

1293
00:56:52,609 --> 00:56:53,989
在

1294
00:56:53,989 --> 00:56:56,630
每个名称注册交易中实际检查的块堆栈名称服务 n 确实

1295
00:56:56,630 --> 00:57:00,890
向这个没有私钥的销毁地址支付了足够的比特币，

1296
00:57:00,890 --> 00:57:02,719
因此

1297
00:57:02,719 --> 00:57:05,569
钱就消失了，

1298
00:57:05,569 --> 00:57:08,269
他们这样做的原因是他们要求

1299
00:57:08,269 --> 00:57:10,460
每个名称注册都浪费一些

1300
00:57:10,460 --> 00:57:13,969
钱的原因是，否则

1301
00:57:13,969 --> 00:57:16,819
坏人注册太容易了 很多

1302
00:57:16,819 --> 00:57:19,130
很多的名字，比如

1303
00:57:19,130 --> 00:57:21,319
域名系统的体验，

1304
00:57:21,319 --> 00:57:22,880
有一段时间名字注册是

1305
00:57:22,880 --> 00:57:24,920
免费的

1306
00:57:24,920 --> 00:57:27,979
 

1307
00:57:27,979 --> 00:57:30,109
 

1308
00:57:30,109 --> 00:57:32,239
 

1309
00:57:32,239 --> 00:57:34,670
免费名称或知道

1310
00:57:34,670 --> 00:57:37,369
我真的想拥有 RTM 名称的人

1311
00:57:37,369 --> 00:57:41,060
可能会在我之前注册

1312
00:57:41,060 --> 00:57:42,620
，然后如果我想使用它，我必须

1313
00:57:42,620 --> 00:57:44,690
付钱给他们，所以为了试图

1314
00:57:44,690 --> 00:57:48,770
阻止他们有一个他们需要费用，

1315
00:57:48,770 --> 00:57:50,420
这实际上是 pulmo 可能

1316
00:57:50,420 --> 00:57:53,210
是设计的重要组成部分，因为

1317
00:57:53,210 --> 00:57:55,070
互联网上的免费东西往往是

1318
00:57:55,070 --> 00:57:55,610
是的，

1319
00:57:55,610 --> 00:57:59,540
往往被滥用或

1320
00:57:59,540 --> 00:58:07,460
淹没在故意垃圾邮件中好吧，一个

1321
00:58:07,460 --> 00:58:08,900
细节 我在这张照片上所以我在这张照片中省略了

1322
00:58:08,900 --> 00:58:11,180
爪子我们有客户端

1323
00:58:11,180 --> 00:58:16,250
机器运行一些应用程序这是

1324
00:58:16,250 --> 00:58:21,950
客户端设备现在当应用程序需要

1325
00:58:21,950 --> 00:58:26,270
获取我的数据时获取我的数据它需要

1326
00:58:26,270 --> 00:58:30,530
能够随时解密它

1327
00:58:30,530 --> 00:58:32,330
将数据写入我的存储我的应用程序

1328
00:58:32,330 --> 00:58:33,470
需要能够

1329
00:58:33,470 --> 00:58:36,620
最终使用我的私钥对其进行加密，当

1330
00:58:36,620 --> 00:58:38,000
我取回数据时，很高兴能够使用我的私钥

1331
00:58:38,000 --> 00:58:40,790
最终以一种或另一种方式解密它，

1332
00:58:40,790 --> 00:58:42,470
因此这些

1333
00:58:42,470 --> 00:58:44,390
应用程序需要得到 在私钥，

1334
00:58:44,390 --> 00:58:46,160
但私钥对超级

1335
00:58:46,160 --> 00:58:50,900
敏感，而这些应用程序

1336
00:58:50,900 --> 00:58:52,790
只是我从

1337
00:58:52,790 --> 00:58:54,770
块堆栈应用程序商店下载的任何垃圾，可能

1338
00:58:54,770 --> 00:58:57,140
完全不可信，所以我们永远不想

1339
00:58:57,140 --> 00:58:59,540
给他们一个私钥所以

1340
00:58:59,540 --> 00:59:00,890
实际发生的是有一个

1341
00:59:00,890 --> 00:59:04,550
单独的程序 我一直在运行的

1342
00:59:04,550 --> 00:59:12,380
称为块堆栈浏览器，它是

1343
00:59:12,380 --> 00:59:14,970
这个程序

1344
00:59:14,970 --> 00:59:17,760
知道我的私钥，所以如果

1345
00:59:17,760 --> 00:59:19,830
应用程序想要像我一样做事情，真的

1346
00:59:19,830 --> 00:59:22,140
必须首先通过块堆栈做它

1347
00:59:22,140 --> 00:59:25,110
兄弟 wser，实际上这个

1348
00:59:25,110 --> 00:59:27,210
地方的细节如此复杂，

1349
00:59:27,210 --> 00:59:29,370
块样式浏览器基本上构成

1350
00:59:29,370 --> 00:59:32,250
了每个应用程序的私钥在这个应用程序中

1351
00:59:32,250 --> 00:59:35,520
只使用每个应用程序的私钥，而

1352
00:59:35,520 --> 00:59:38,010
不是我真正的主私钥，

1353
00:59:38,010 --> 00:59:39,990
所以这个应用程序再次没有 '不知道我

1354
00:59:39,990 --> 00:59:43,290
真正的私钥，但是这个问题不

1355
00:59:43,290 --> 00:59:45,860
向这些应用程序透露敏感的密钥材料，

1356
00:59:45,860 --> 00:59:48,120
 

1357
00:59:48,120 --> 00:59:51,750
作为一个重要的细节和

1358
00:59:51,750 --> 00:59:53,760
阻止我的主私钥

1359
00:59:53,760 --> 00:59:57,300
现在在私钥主题上是

1360
00:59:57,300 --> 01:00:00,740
一个弱点，这可能确实是非常不可信的 在

1361
01:00:00,740 --> 01:00:03,990
你所知道的基本上每个系统中，比如比特币本身和块

1362
01:00:03,990 --> 01:00:09,390
堆栈，而且用户往往

1363
01:00:09,390 --> 01:00:11,310
不像他们应该对私钥那样小心，

1364
01:00:11,310 --> 01:00:13,770
所以你知道我是否

1365
01:00:13,770 --> 01:00:16,140
要使用手机上的块堆栈，你

1366
01:00:16,140 --> 01:00:17,940
知道 意味着如果我将手机留在自助餐厅，我的手机必须知道我的

1367
01:00:17,940 --> 01:00:21,990
私钥，

1368
01:00:21,990 --> 01:00:23,150
 

1369
01:00:23,150 --> 01:00:26,250
那么现在找到它的人都有一个设备

1370
01:00:26,250 --> 01:00:28,710
，里面有我的私钥，并且可以

1371
01:00:28,710 --> 01:00:30,450
像我一样做任何事情，因为就块

1372
01:00:30,450 --> 01:00:32,460
攻击而言，他们是 对我来说，他们

1373
01:00:32,460 --> 01:00:36,210
知道我的私钥用户也往往会

1374
01:00:36,210 --> 01:00:40,560
丢失私钥你知道我

1375
01:00:40,560 --> 01:00:42,120
有一段时间不使用该服务你知道

1376
01:00:42,120 --> 01:00:44,160
我忘记了任何密码短语，

1377
01:00:44,160 --> 01:00:45,660
例如保护

1378
01:00:45,660 --> 01:00:48,300
私钥或我把我的私钥放在

1379
01:00:48,300 --> 01:00:49,980
从某处保管的 USB 某人密钥

1380
01:00:49,980 --> 01:00:52,500
然后丢失 USB 密钥，因此

1381
01:00:52,500 --> 01:00:56,100
这完全是用户遇到的常规问题，

1382
01:00:56,100 --> 01:00:59,430
并且阻止攻击实际上

1383
01:00:59,430 --> 01:01:01,620
并没有真正回答这些

1384
01:01:01,620 --> 01:01:04,470
问题我几乎假设

1385
01:01:04,470 --> 01:01:05,910
用户会小心他们的私人

1386
01:01:05,910 --> 01:01:08,480
密钥，如果您丢失了

1387
01:01:08,480 --> 01:01:10,950
无法为您找回的私钥块，

1388
01:01:10,950 --> 01:01:13,020
这就像是为了超级

1389
01:01:13,020 --> 01:01:14,550
安全，如果您不必

1390
01:01:14,550 --> 01:01:16,800
信任块堆栈，只有您的客户知道

1391
01:01:16,800 --> 01:01:18,780
您的私钥，如果您丢失了 您的客户

1392
01:01:18,780 --> 01:01:22,510
我们忘记了您是什么

1393
01:01:22,510 --> 01:01:24,940
短语您完全不

1394
01:01:24,940 --> 01:01:28,120
走运并且无法帮助您，

1395
01:01:28,120 --> 01:01:31,210
因此这只是现实

1396
01:01:31,210 --> 01:01:32,770
生活中的一个困难人们不想使用

1397
01:01:32,770 --> 01:01:37,060
那么脆弱和真实的系统 生活

1398
01:01:37,060 --> 01:01:38,350
是什么 发生的事情是，即使

1399
01:01:38,350 --> 01:01:40,420
你知道严肃的

1400
01:01:40,420 --> 01:01:42,910
密码学的系统通常也有某种

1401
01:01:42,910 --> 01:01:46,030
密钥检索方案，我可以搅拌

1402
01:01:46,030 --> 01:01:47,770
一些东西我可以告诉一个块堆栈可能是

1403
01:01:47,770 --> 01:01:51,010
我母亲的娘家姓，或者你知道他们

1404
01:01:51,010 --> 01:01:53,380
给我发短信到我的电话或

1405
01:01:53,380 --> 01:01:55,480
无论我可以使用什么方案来

1406
01:01:55,480 --> 01:01:59,500
恢复我的私钥，如果你

1407
01:01:59,500 --> 01:02:02,440
想攻击一个系统，通常是系统

1408
01:02:02,440 --> 01:02:04,830
的密钥恢复

1409
01:02:04,830 --> 01:02:06,880
方面的密码恢复是最

1410
01:02:06,880 --> 01:02:08,560
容易攻击的我只是调用一个块堆栈我

1411
01:02:08,560 --> 01:02:10,960
说过我说过告诉他们 你知道

1412
01:02:10,960 --> 01:02:13,600
我真的是罗伯特·莫里斯 你必须

1413
01:02:13,600 --> 01:02:15,310
相信我 请你知道我们说过

1414
01:02:15,310 --> 01:02:17,200
罗伯特·莫里斯这是我的关键你的

1415
01:02:17,200 --> 01:02:17,620
密码

1416
01:02:17,620 --> 01:02:20,500
不告诉我新密码如果

1417
01:02:20,500 --> 01:02:22,870
我足够有说服力你知道并且

1418
01:02:22,870 --> 01:02:27,550
系统允许 Hebe 设置他们

1419
01:02:27,550 --> 01:02:29,500
会让我拥有它，

1420
01:02:29,500 --> 01:02:31,240
如果真的是攻击

1421
01:02:31,240 --> 01:02:32,620
者在打电话并假装是我，

1422
01:02:32,620 --> 01:02:35,470
他们可能也会让攻击者重置

1423
01:02:35,470 --> 01:02:38,110
密钥的密码或任何

1424
01:02:38,110 --> 01:02:39,280
不会发生的块 放慢它，因为

1425
01:02:39,280 --> 01:02:41,680
它显然是不安全的，但是

1426
01:02:41,680 --> 01:02:46,510
如果他们不希望他们的

1427
01:02:46,510 --> 01:02:49,060
用户放弃他们，那么现实世界的系统需要有一个

1428
01:02:49,060 --> 01:02:50,800
更好的计划，并且不清楚如何

1429
01:02:50,800 --> 01:02:57,180
使它变得更好，

1430
01:03:01,549 --> 01:03:07,839
好吧，

1431
01:03:08,890 --> 01:03:11,539
我想要一些问题 谈论

1432
01:03:11,539 --> 01:03:14,749
系统中出现的问题对我来说，块堆栈

1433
01:03:14,749 --> 01:03:17,689
实际上是一种需要思考的问题来源，

1434
01:03:17,689 --> 01:03:21,619
甚至是一种

1435
01:03:21,619 --> 01:03:25,609
不太好的事情你知道

1436
01:03:25,609 --> 01:03:28,189
使用更多事情的建议你

1437
01:03:28,189 --> 01:03:29,899
知道块 SEC 我认为

1438
01:03:29,899 --> 01:03:31,579
现在的黑人性情况是，你

1439
01:03:31,579 --> 01:03:34,189
可能实际上并不想用它来

1440
01:03:34,189 --> 01:03:38,140
为真实用户构建一个真实的系统，但

1441
01:03:38,140 --> 01:03:40,459
它试图为

1442
01:03:40,459 --> 01:03:42,409
一个系统指明道路，如果足够聪明的话，有朝一日可能会出现

1443
01:03:42,409 --> 01:03:44,059
 

1444
01:03:44,059 --> 01:03:45,679
开发是在它上面完成的，它

1445
01:03:45,679 --> 01:03:47,959
实际上可能是一个既

1446
01:03:47,959 --> 01:03:50,749
方便程序员又实际上

1447
01:03:50,749 --> 01:03:52,749
为用户提供了一些真正价值的系统，但

1448
01:03:52,749 --> 01:03:54,739
可能还没有，但它的入口

1449
01:03:54,739 --> 01:03:56,630
让你知道它的

1450
01:03:56,630 --> 01:03:58,759
设计方式不同 ently 或更好，

1451
01:03:58,759 --> 01:04:00,619
以便让它更接近

1452
01:04:00,619 --> 01:04:05,749
真正有用的东西，所以

1453
01:04:05,749 --> 01:04:07,189
你可能会有一个问题，尤其是在

1454
01:04:07,189 --> 01:04:08,719
to for 的上下文中，块堆栈是否

1455
01:04:08,719 --> 01:04:10,789
真的需要像那样使用比特币，

1456
01:04:10,789 --> 01:04:13,309
你真的不知道不是那么

1457
01:04:13,309 --> 01:04:18,499
好 你必须支付的费用你

1458
01:04:18,499 --> 01:04:20,449
知道注册一个你知道的名字

1459
01:04:20,449 --> 01:04:22,399
在比特币中的价值因你知道的因素而变化

1460
01:04:22,399 --> 01:04:26,719
100 几乎每晚一夜之间

1461
01:04:26,719 --> 01:04:29,269
有时另外人们

1462
01:04:29,269 --> 01:04:31,399
真的像你使用工作量证明的比特币一样落后

1463
01:04:31,399 --> 01:04:34,579
烧毁 CPU 以

1464
01:04:34,579 --> 01:04:37,069
确保安全，因此您知道比特币并不

1465
01:04:37,069 --> 01:04:39,889
完美，尽管它

1466
01:04:39,889 --> 01:04:40,969
是系统的重要组成部分，否则

1467
01:04:40,969 --> 01:04:43,399
他们无法知道他们如果

1468
01:04:43,399 --> 01:04:44,599
 

1469
01:04:44,599 --> 01:04:46,909
没有整个比特币捆绑，他们将如何命名并不清楚 所以

1470
01:04:46,909 --> 01:04:49,309
你可能有八到四个问题是

1471
01:04:49,309 --> 01:04:51,169
我是否是证书透明度

1472
01:04:51,169 --> 01:04:54,529
，这是一个你知道我们上周看过

1473
01:04:54,529 --> 01:04:57,109
的证书透明度

1474
01:04:57,109 --> 01:04:58,909
没有采矿没有工作证明

1475
01:04:58,909 --> 01:05:01,489
，但你知道它很强大 ul 足以

1476
01:05:01,489 --> 01:05:04,369
对命名系统有所帮助，所以

1477
01:05:04,369 --> 01:05:06,019
问题是是否说比特币

1478
01:05:06,019 --> 01:05:09,109
盒子是否可以使用

1479
01:05:09,109 --> 01:05:12,380
证书透明度之类的东西不是

1480
01:05:12,380 --> 01:05:14,919
为了

1481
01:05:14,930 --> 01:05:19,250
强制执行有关名称的适当规则并且

1482
01:05:19,250 --> 01:05:21,210
实际上不知道答案

1483
01:05:21,210 --> 01:05:26,550
我的猜测是答案 不，我的感觉

1484
01:05:26,550 --> 01:05:28,020
是，虽然证书透明度

1485
01:05:28,020 --> 01:05:32,910
可以揭示冲突或冲突

1486
01:05:32,910 --> 01:05:35,160
，但对于注册同名的人来说确实是一个问题，

1487
01:05:35,160 --> 01:05:38,040
例如如果您要求每个人都将

1488
01:05:38,040 --> 01:05:39,330
他们的姓名注册提交到

1489
01:05:39,330 --> 01:05:41,880
证书透明度日志，是的，

1490
01:05:41,880 --> 01:05:43,530
您确实可以看到两个人

1491
01:05:43,530 --> 01:05:45,510
已经注册 相同的名称，但

1492
01:05:45,510 --> 01:05:47,430
证书透明并不能解决

1493
01:05:47,430 --> 01:05:50,370
所有权冲突，所以如果我注册 RT，

1494
01:05:50,370 --> 01:05:51,720
你应该知道去年我

1495
01:05:51,720 --> 01:05:53,550
注册了 RT M，并且明年我一直在

1496
01:05:53,550 --> 01:05:55,740
愉快地使用它，然后

1497
01:05:55,740 --> 01:05:59,940
其他人今天注册了 RT M 是的，

1498
01:05:59,940 --> 01:06:01,400
你知道他们 '会将他们的

1499
01:06:01,400 --> 01:06:03,480
注册提交到证书

1500
01:06:03,480 --> 01:06:06,780
透明度日志，所以现在也许这

1501
01:06:06,780 --> 01:06:09,950
会使我的名字无法使用或其他东西，

1502
01:06:09,950 --> 01:06:12,240
但它不是 cl 耳朵真的应该拥有

1503
01:06:12,240 --> 01:06:13,470
这个名字，因为证书

1504
01:06:13,470 --> 01:06:15,420
透明度没有非常强大的

1505
01:06:15,420 --> 01:06:19,350
机制来解决这些冲突，

1506
01:06:19,350 --> 01:06:21,780
您可能认为顺序就

1507
01:06:21,780 --> 01:06:25,080
足够了，但是相同的记录和

1508
01:06:25,080 --> 01:06:26,670
不同的证书透明度日志

1509
01:06:26,670 --> 01:06:28,020
可以有不同的顺序，因为没有

1510
01:06:28,020 --> 01:06:29,700
什么强制不同的

1511
01:06:29,700 --> 01:06:33,330
透明度日志 拥有完全相同的

1512
01:06:33,330 --> 01:06:37,260
顺序，如果你想知道

1513
01:06:37,260 --> 01:06:39,570
比特币如何强制执行

1514
01:06:39,570 --> 01:06:41,340
你添加相同顺序的块的每个

1515
01:06:41,340 --> 01:06:43,170
 

1516
01:06:43,170 --> 01:06:46,410
 

1517
01:06:46,410 --> 01:06:49,130
 

1518
01:06:49,130 --> 01:06:52,610
副本 复制区块链并

1519
01:06:52,610 --> 01:06:54,630
强制协议，如果您不进行

1520
01:06:54,630 --> 01:06:57,060
挖掘，至少您知道或

1521
01:06:57,060 --> 01:07:00,570
类似挖掘，目前尚不清楚如何

1522
01:07:00,570 --> 01:07:03,600
根据记录顺序添加强制协议，

1523
01:07:03,600 --> 01:07:10,290
因此除了

1524
01:07:10,290 --> 01:07:13,050
块堆栈收费的费用之外

1525
01:07:13,050 --> 01:07:15,470
避免

1526
01:07:15,470 --> 01:07:18,480
命名系统中的各种垃圾邮件至关重要 各种

1527
01:07:18,480 --> 01:07:20,880
滥用，你知道块堆栈建立在

1528
01:07:20,880 --> 01:07:22,320
比特币可以自动

1529
01:07:22,320 --> 01:07:24,480
要求人们付费注册

1530
01:07:24,480 --> 01:07:25,770
基于证书透明度的块堆栈，

1531
01:07:25,770 --> 01:07:27,160
你知道

1532
01:07:27,160 --> 01:07:31,390
没有直接的机制来要求

1533
01:07:31,390 --> 01:07:36,820
费用，事实上我认为

1534
01:07:36,820 --> 01:07:38,380
这里的重点实际上要大得多，

1535
01:07:38,380 --> 01:07:43,510
这就是很多人都在谈论的

1536
01:07:43,510 --> 01:07:45,070
将区块链用于

1537
01:07:45,070 --> 01:07:48,670
加密货币以外的许多东西，但实际上

1538
01:07:48,670 --> 01:07:51,010
似乎很难使用

1539
01:07:51,010 --> 01:07:53,640
区块链打开具有无限制访问权限的区块链，

1540
01:07:53,640 --> 01:07:57,220
除非它们再次与

1541
01:07:57,220 --> 01:07:58,270
某种加密汽车

1542
01:07:58,270 --> 01:08:01,540
加密货币相结合我不知道

1543
01:08:01,540 --> 01:08:02,800
这是不是真的，但它肯定是我的

1544
01:08:02,800 --> 01:08:07,150
印象不错，所以

1545
01:08:07,150 --> 01:08:10,000
块堆栈的一个大问题是它是否

1546
01:08:10,000 --> 01:08:12,160
会方便程序员，对

1547
01:08:12,160 --> 01:08:15,010
我来说，这个问题绝对

1548
01:08:15,010 --> 01:08:18,970
至关重要，因为它是两个非常

1549
01:08:18,970 --> 01:08:20,620
关键的问题之一，另一个是

1550
01:08:20,620 --> 01:08:22,359
另一个关键问题是它是否

1551
01:08:22,359 --> 01:08:30,189
让用户生活得更好 我目前的

1552
01:08:30,189 --> 01:08:32,020
看法是，对于我认为我用过的程序员来说，

1553
01:08:32,020 --> 01:08:33,670
盒子 AK 确实不是特别方便

1554
01:08:33,670 --> 01:08:36,370
块

1555
01:08:36,370 --> 01:08:38,350
堆栈 一个程序块堆栈 我

1556
01:08:38,350 --> 01:08:41,950
试图构建一个喜欢它的系统，我的强烈

1557
01:08:41,950 --> 01:08:44,020
印象是，

1558
01:08:44,020 --> 01:08:45,910
在

1559
01:08:45,910 --> 01:08:48,270
这些去中心化平台之一上构建一个 Web 应用程序

1560
01:08:48,270 --> 01:08:51,069
比在普通平台上要困难得多，

1561
01:08:51,069 --> 01:08:52,840
你知道那是 有点破坏性，因为

1562
01:08:52,840 --> 01:08:55,060
如果网站开发人员不参与，

1563
01:08:55,060 --> 01:08:57,430
那么没有人会得到很大的

1564
01:08:57,430 --> 01:09:00,010
牵引力，如果网站开发人员

1565
01:09:00,010 --> 01:09:03,160
不喜欢你，我知道我

1566
01:09:03,160 --> 01:09:05,830
觉得系统很难以

1567
01:09:05,830 --> 01:09:07,930
你唯一的方式编程

1568
01:09:07,930 --> 01:09:10,149
如果对用户的吸引力

1569
01:09:10,149 --> 01:09:12,580
如此之大，以至于你知道用户

1570
01:09:12,580 --> 01:09:15,910
需要分散的应用程序，

1571
01:09:15,910 --> 01:09:18,149
这可能会迫使程序员使用它，

1572
01:09:18,149 --> 01:09:20,229
但程序员只是在为自己说话，

1573
01:09:20,229 --> 01:09:23,770
我的猜测是，

1574
01:09:23,770 --> 01:09:25,450
基本上所有代码都在其中的架构

1575
01:09:25,450 --> 01:09:27,550
坐在客户端，我们

1576
01:09:27,550 --> 01:09:29,770
没有特别的你知道网站

1577
01:09:29,770 --> 01:09:33,460
服务器非常痛苦

1578
01:09:33,460 --> 01:09:34,960
很难拥有特定于应用程序的数据，

1579
01:09:34,960 --> 01:09:37,180
因为所有数据都归

1580
01:09:37,180 --> 01:09:40,000
用户 很难有索引，或者你

1581
01:09:40,000 --> 01:09:42,250
知道点赞数或投票数

1582
01:09:42,250 --> 01:09:44,380
你知道

1583
01:09:44,380 --> 01:09:46,029
我在 reddit 或黑客新闻中提到的那种首页排名

1584
01:09:46,029 --> 01:09:47,710
很难 有各种各样的东西

1585
01:09:47,710 --> 01:09:51,490
如果你没有概念，那就很痛苦

1586
01:09:51,490 --> 01:09:53,080
网站本身有

1587
01:09:53,080 --> 01:09:59,020
自己的数据 这访问控制

1588
01:09:59,020 --> 01:10:01,990
实际上同样痛苦

1589
01:10:01,990 --> 01:10:03,490
编写代码和传统

1590
01:10:03,490 --> 01:10:05,020
网站很容易决定谁可以看到

1591
01:10:05,020 --> 01:10:07,600
分散系统中的哪些数据，

1592
01:10:07,600 --> 01:10:09,550
实际上你只能使用

1593
01:10:09,550 --> 01:10:11,490
加密访问控制来强制执行 或者这些

1594
01:10:11,490 --> 01:10:14,230
就是从示例中看起来

1595
01:10:14,230 --> 01:10:17,800
是块堆栈的方式，

1596
01:10:17,800 --> 01:10:20,050
结果只是非常简单，就像

1597
01:10:20,050 --> 01:10:21,850
一个用户使用他们自己的私有数据

1598
01:10:21,850 --> 01:10:24,010
使用密码学来强制

1599
01:10:24,010 --> 01:10:28,800
访问它只是非常痛苦，

1600
01:10:29,430 --> 01:10:33,490
所以程序员可能只会在用户感到兴奋

1601
01:10:33,490 --> 01:10:36,280
很兴奋所以我们的用户会很

1602
01:10:36,280 --> 01:10:37,810
兴奋你知道一种看待

1603
01:10:37,810 --> 01:10:41,110
那个问题的一种方法是

1604
01:10:41,110 --> 01:10:42,940
这种去中心化使用你自己的

1605
01:10:42,940 --> 01:10:46,870
存储是否是g 有利于用户隐私，因为

1606
01:10:46,870 --> 01:10:49,350
这是一个重要的宣传点，即通过

1607
01:10:49,350 --> 01:10:52,600
将数据存储在

1608
01:10:52,600 --> 01:10:55,060
用户拥有并为你付费的存储服务上，也许

1609
01:10:55,060 --> 01:10:56,890
这会使数据更加私密，

1610
01:10:56,890 --> 01:10:59,080
比将数据存储在网站上更安全，

1611
01:10:59,080 --> 01:11:02,800
所以我真的在问

1612
01:11:02,800 --> 01:11:05,050
比信任 Facebook 或 Google 更好

1613
01:11:05,050 --> 01:11:09,090
地保护我的数据对

1614
01:11:09,090 --> 01:11:11,410
Facebook 员工和

1615
01:11:11,410 --> 01:11:13,330
网站的其他用户以及你可能

1616
01:11:13,330 --> 01:11:17,050
试图闯入的黑客的隐私，这只是一个

1617
01:11:17,050 --> 01:11:20,140
你知道的问题，

1618
01:11:20,140 --> 01:11:21,640
取决于你对 Facebook 的信任程度 事实

1619
01:11:21,640 --> 01:11:23,230
是，您仍然将数据存储

1620
01:11:23,230 --> 01:11:25,420
在某些服务上的云中，

1621
01:11:25,420 --> 01:11:30,310
只是可能不是 Facebook，而且您仍在

1622
01:11:30,310 --> 01:11:33,610
客户端上运行

1623
01:11:33,610 --> 01:11:36,280
可能由 Facebook 提供给您的

1624
01:11:36,280 --> 01:11:37,630
软件，因此您正在运行 Facebook 软件和

1625
01:11:37,630 --> 01:11:42,010
您的 客户，你知道它是，所以你

1626
01:11:42,010 --> 01:11:44,020
仍然有点相信这个

1627
01:11:44,020 --> 01:11:46,150
这个facebook给你的这个代码，或者

1628
01:11:46,150 --> 01:11:49,390
你从哪里得到你的代码，你知道

1629
01:11:49,390 --> 01:11:51,040
对于我们中间真正的黑客来说，你可以

1630
01:11:51,040 --> 01:11:52,450
查看代码和c 说服自己，

1631
01:11:52,450 --> 01:11:53,770
因为您在自己的计算机上运行它

1632
01:11:53,770 --> 01:11:54,990
并且可以很好地满足自己，

1633
01:11:54,990 --> 01:11:57,960
但对于公众来说，您知道

1634
01:11:57,960 --> 01:11:59,550
 

1635
01:11:59,550 --> 01:12:01,530
在他们的网络服务器上与 Facebook 的网络软件交谈

1636
01:12:01,530 --> 01:12:03,210
与我的名字的 Facebook 软件

1637
01:12:03,210 --> 01:12:05,610
和他们自己的客户端之间的区别可能看起来不是

1638
01:12:05,610 --> 01:12:08,550
很好 谁知道

1639
01:12:08,550 --> 01:12:11,700
您正在运行的 Facebook 应用程序可能会向

1640
01:12:11,700 --> 01:12:14,010
Facebook 发送有关

1641
01:12:14,010 --> 01:12:16,680
您要窥探您的信息有一个

1642
01:12:16,680 --> 01:12:18,990
关于明智的密码访问控制的问题，这

1643
01:12:18,990 --> 01:12:21,630
对程序员来说很痛苦 嗯，一种

1644
01:12:21,630 --> 01:12:23,280
看待它的方式是访问控制

1645
01:12:23,280 --> 01:12:26,190
检查您必须在某种

1646
01:12:26,190 --> 01:12:27,180
标准网站中进行的检查非常

1647
01:12:27,180 --> 01:12:28,950
简单，您只需编写

1648
01:12:28,950 --> 01:12:30,950
一点 Python 代码或其他任何东西来

1649
01:12:30,950 --> 01:12:33,330
决定某些用户是否应该

1650
01:12:33,330 --> 01:12:35,100
能够看到一些数据，您甚至可以

1651
01:12:35,100 --> 01:12:36,780
使用数据进行计算

1652
01:12:36,780 --> 01:12:39,390
只要您不

1653
01:12:39,390 --> 01:12:40,370
向用户透露它，用户就不应该看到它，

1654
01:12:40,370 --> 01:12:44,430
而在除了简单的

1655
01:12:44,430 --> 01:12:50,480
情况下，进行加密以

1656
01:12:50,480 --> 01:12:53,310
允许某些用户但不允许其他用户

1657
01:12:53,310 --> 01:12:56,040
离开 你的数据只需要

1658
01:12:56,040 --> 01:12:59,610
更多的思考，所以你知道假设麻省理工学院的

1659
01:12:59,610 --> 01:13:02,190
注册商维护了一份所有

1660
01:13:02,190 --> 01:13:05,250
8 到 4 人的名单，如果是这样，他们作为一个

1661
01:13:05,250 --> 01:13:08,430
小组维护这个名单，我

1662
01:13:08,430 --> 01:13:10,260
想用它来管理

1663
01:13:10,260 --> 01:13:14,180
保护 对于存储在

1664
01:13:14,180 --> 01:13:16,200
Krypton 中的具有加密保护

1665
01:13:16,200 --> 01:13:18,660
和块堆栈的某些文件，因为列出

1666
01:13:18,660 --> 01:13:20,250
了 8 到 4 名学生的组列表可能会

1667
01:13:20,250 --> 01:13:24,150
改变你知道我为加密所做的工作

1668
01:13:24,150 --> 01:13:27,950
可能也必须改变所以

1669
01:13:27,950 --> 01:13:31,470
我知道如果我加密我可以

1670
01:13:31,470 --> 01:13:34,110
加密数据 一次使用

1671
01:13:34,110 --> 01:13:37,590
a 到 4 组列表中每个用户的密钥，这

1672
01:13:37,590 --> 01:13:39,870
将起作用，因为他们可以读取

1673
01:13:39,870 --> 01:13:42,180
为他们加密的副本，

1674
01:13:42,180 --> 01:13:43,620
但是随着用户的添加，

1675
01:13:43,620 --> 01:13:45,840
注册商将列表更改为或删除

1676
01:13:45,840 --> 01:13:46,410
用户

1677
01:13:46,410 --> 01:13:48,750
我需要我的软件 我需要

1678
01:13:48,750 --> 01:13:52,290
注意到该列表已更改并

1679
01:13:52,290 --> 01:13:55,230
忙于更改内容的

1680
01:13:55,230 --> 01:13:56,880
加密方式我们为新用户加密

1681
01:13:56,880 --> 01:13:59,010
为旧用户删除了两个副本

1682
01:13:59,010 --> 01:14:01,350
，这就像损坏

1683
01:14:01,350 --> 01:14:03,390
程度或损坏程度

1684
01:14:03,390 --> 01:14:05,550
当前系统中不存在的那种复杂性

1685
01:14:05,550 --> 01:14:09,440
不一定不能完成，

1686
01:14:09,440 --> 01:14:11,520
但它确实需要很多

1687
01:14:11,520 --> 01:14:16,340
通常不需要的机器，

1688
01:14:19,430 --> 01:14:27,860
 

1689
01:14:27,860 --> 01:14:30,210
从用户的角度来看，另一种信任问题是

1690
01:14:30,210 --> 01:14:32,400
他们 仍然必须信任他们的存储

1691
01:14:32,400 --> 01:14:36,120
提供商来保存他们的数据，他们

1692
01:14:36,120 --> 01:14:37,380
仍然只相信他们的存储

1693
01:14:37,380 --> 01:14:38,970
提供商总是提供

1694
01:14:38,970 --> 01:14:41,820
最新的版权，作弊的存储

1695
01:14:41,820 --> 01:14:44,070
提供商可能会试图通过提供旧版本来制造麻烦，

1696
01:14:44,070 --> 01:14:46,260
所以我们在

1697
01:14:46,260 --> 01:14:48,410
那个区块中租用 堆栈设计 你知道你

1698
01:14:48,410 --> 01:14:50,850
真的信任你的存储服务器

1699
01:14:50,850 --> 01:14:52,650
从你的角度来看，这个中心服务可以

1700
01:14:52,650 --> 01:14:54,180
用你的数据做正确的事情

1701
01:14:54,180 --> 01:14:57,060
来保存它 备份它以便

1702
01:14:57,060 --> 01:14:58,560
在被要求时生成它 在被要求时生成

1703
01:14:58,560 --> 01:15:01,260
正确的版本 对于普通人来说，这是一个

1704
01:15:01,260 --> 01:15:03,900
有点问题

1705
01:15:03,900 --> 01:15:07,830
，如果您相信亚马逊

1706
01:15:07,830 --> 01:15:11,190
AWS 能够正确存储您的数据并且不会

1707
01:15:11,190 --> 01:15:14,250
丢失它，那么相信亚马逊本身并没有那么大的

1708
01:15:14,250 --> 01:15:16,620
一步 o 运行

1709
01:15:16,620 --> 01:15:19,140
网站，你知道我们可以

1710
01:15:19,140 --> 01:15:21,120
与之争论，这确实是真的，但我

1711
01:15:21,120 --> 01:15:23,250
认为你

1712
01:15:23,250 --> 01:15:25,320
从大多数人大多数普通人的高级角度来看，

1713
01:15:25,320 --> 01:15:28,170
这确实是一个非常小的

1714
01:15:28,170 --> 01:15:30,210
区别，你必须

1715
01:15:30,210 --> 01:15:31,470
克服它 为了说服

1716
01:15:31,470 --> 01:15:35,460
人们，男孩你知道

1717
01:15:35,460 --> 01:15:38,940
使用亚马逊作为存储

1718
01:15:38,940 --> 01:15:41,430
服务的块堆栈方法比

1719
01:15:41,430 --> 01:15:45,930
使用亚马逊作为网站的标准方式更好

1720
01:15:45,930 --> 01:15:47,280
从用户的角度来看

1721
01:15:47,280 --> 01:15:49,260
另一个问题 另一个关于为什么分散式

1722
01:15:49,260 --> 01:15:51,450
架构可能更适合 用户

1723
01:15:51,450 --> 01:15:53,430
是，它使他们可以更好地

1724
01:15:53,430 --> 01:15:56,640
控制您不知道隐私，而只是

1725
01:15:56,640 --> 01:15:58,440
了解他们对数据使用的应用程序，

1726
01:15:58,440 --> 01:16:00,210
因此如果您想切换

1727
01:16:00,210 --> 01:16:02,430
应用程序但仍然使用相同的数据，

1728
01:16:02,430 --> 01:16:04,800
例如更改照片编辑应用程序，就像我

1729
01:16:04,800 --> 01:16:07,380
原则上提到的那样

1730
01:16:07,380 --> 01:16:10,110
使用这种去中心化的

1731
01:16:10,110 --> 01:16:14,280
应用程序架构会更容易，因为如果你想使用数据，你

1732
01:16:14,280 --> 01:16:16,130
会再次知道数据不属于

1733
01:16:16,130 --> 01:16:18,870
应用程序

1734
01:16:18,870 --> 01:16:20,370
网站 多个不同

1735
01:16:20,370 --> 01:16:21,750
应用程序中的相同数据，例如我想要

1736
01:16:21,750 --> 01:16:24,020
一个日历应用程序，但使用

1737
01:16:24,020 --> 01:16:27,000
来自我的电子邮件应用程序的相同数据，这也是你知道

1738
01:16:27,000 --> 01:16:29,220
 

1739
01:16:29,220 --> 01:16:31,200
分散方案相对方便，因为数据

1740
01:16:31,200 --> 01:16:32,550
再次独立于

1741
01:16:32,550 --> 01:16:37,320
你知道用户可能想要的应用程序

1742
01:16:37,320 --> 01:16:39,300
这也许他们可能不在

1743
01:16:39,300 --> 01:16:42,420
任何人的列表的顶部，还有一个

1744
01:16:42,420 --> 01:16:44,010
额外的问题是，即使是为了

1745
01:16:44,010 --> 01:16:46,890
实现这一愿景，也必须

1746
01:16:46,890 --> 01:16:49,680
对文件格式进行大量标准化，

1747
01:16:49,680 --> 01:16:53,580
这样你就知道我的

1748
01:16:53,580 --> 01:16:54,840
日历程序有的日历文件 以

1749
01:16:54,840 --> 01:16:57,780
我的电子邮件程序可以理解的格式存储其日历数据，

1750
01:16:57,780 --> 01:17:00,060
否则将

1751
01:17:00,060 --> 01:17:01,470
无法正常工作，如果我要

1752
01:17:01,470 --> 01:17:04,710
很好地切换电子邮件应用程序，我的旧电子邮件

1753
01:17:04,710 --> 01:17:06,390
应用程序最好

1754
01:17:06,390 --> 01:17:08,190
以我的新电子邮件应用程序可以理解的格式存储我的电子邮件

1755
01:17:08,190 --> 01:17:11,100
否则

1756
01:17:11,100 --> 01:17:14,640
我很容易在其中切换的去中心化应用程序的愿景

1757
01:17:14,640 --> 01:17:17,190
无法

1758
01:17:17,190 --> 01:17:22,530
实现最后一个让我

1759
01:17:22,530 --> 01:17:24,510
担心的问题是它不是

1760
01:17:24,510 --> 01:17:25,890
很明显，

1761
01:17:25,890 --> 01:17:28,800
如果

1762
01:17:28,800 --> 01:17:29,580
人们不愿意为我的存储付费，那么用户将愿意为自己的存储付费，

1763
01:17:29,580 --> 01:17:31,910
那么整个安排

1764
01:17:31,910 --> 01:17:34,230
就很没有吸引力，因为很重要的

1765
01:17:34,230 --> 01:17:36,510
一点是给用户更多的

1766
01:17:36,510 --> 01:17:39,450
责任 在他们自己存储

1767
01:17:39,450 --> 01:17:43,500
自己的东西时，我认为用户

1768
01:17:43,500 --> 01:17:47,310
使用了免费的广告广告

1769
01:17:47,310 --> 01:17:50,130
支持的服务，他们

1770
01:17:50,130 --> 01:17:52,830
可能不愿意接受

1771
01:17:52,830 --> 01:17:54,920
支付互联网东西的费用，

1772
01:17:54,920 --> 01:17:59,970
好吧，但是我觉得这

1773
01:17:59,970 --> 01:18:02,130
整个领域你都知道值得

1774
01:18:02,130 --> 01:18:04,890
保留 关注甚至可能值得

1775
01:18:04,890 --> 01:18:06,810
对它的不同部分进行研究，以

1776
01:18:06,810 --> 01:18:08,730
对寻找

1777
01:18:08,730 --> 01:18:12,360
研究问题感兴趣，而且我

1778
01:18:12,360 --> 01:18:13,920
现在不太相信它

1779
01:18:13,920 --> 01:18:17,310
，因为我概述的原因我认为它

1780
01:18:17,310 --> 01:18:19,530
绝对值得追求，因为

1781
01:18:19,530 --> 01:18:23,430
有一天如果喜欢 毫无疑问，这种去中心

1782
01:18:23,430 --> 01:18:25,290
化系统的

1783
01:18:25,290 --> 01:18:28,530
工作方式已经变得越来越好，并且

1784
01:18:28,530 --> 01:18:30,420
最终可能会变得足够好，以至于

1785
01:18:30,420 --> 01:18:33,210
现有的 w 系统存在激烈的竞争

1786
01:18:33,210 --> 01:18:35,940
ebsite architectures，

1787
01:18:35,940 --> 01:18:38,130
如果

1788
01:18:38,130 --> 01:18:41,100
像这样严重的竞争出现的

1789
01:18:41,100 --> 01:18:42,530
话

1790
01:18:42,530 --> 01:18:45,450
 

1791
01:18:45,450 --> 01:18:47,969
 

1792
01:18:47,969 --> 01:18:50,070
，我会很

1793
01:18:50,070 --> 01:18:52,830
高兴的 还

1794
01:18:52,830 --> 01:18:56,090
没有做实验四已经到了

1795
01:18:56,090 --> 01:19:01,010
如果你有问题请问我

