1
00:00:00,540 --> 00:00:03,510
all right today's topic is distributed

2
00:00:03,510 --> 00:00:15,509
transactions and these come in really to

3
00:00:15,509 --> 00:00:17,670
implementation pieces and that's how

4
00:00:17,670 --> 00:00:20,010
I'll cover them the first big piece of

5
00:00:20,010 --> 00:00:28,650
concurrency control the second is atomic

6
00:00:28,650 --> 00:00:35,100
commit and the reason why distributive

7
00:00:35,100 --> 00:00:36,600
transactions come up is that it's very

8
00:00:36,600 --> 00:00:38,640
frequent for people with large amounts

9
00:00:38,640 --> 00:00:41,100
of data to end up splitting or sharding

10
00:00:41,100 --> 00:00:43,980
the data over many different servers so

11
00:00:43,980 --> 00:00:45,570
maybe if you're running a bank for

12
00:00:45,570 --> 00:00:49,320
example the bank balances for half your

13
00:00:49,320 --> 00:00:51,420
customers are one server and the bank

14
00:00:51,420 --> 00:00:53,040
balances for the other half are on a

15
00:00:53,040 --> 00:00:54,780
different server let's do it like split

16
00:00:54,780 --> 00:00:56,610
the load both the processing load and

17
00:00:56,610 --> 00:01:00,810
the space requirements this comes up for

18
00:01:00,810 --> 00:01:02,190
other things too maybe you're recording

19
00:01:02,190 --> 00:01:05,430
vote counts on articles at a website you

20
00:01:05,430 --> 00:01:07,380
know the maybe there's so many millions

21
00:01:07,380 --> 00:01:08,880
millions of articles half the vote

22
00:01:08,880 --> 00:01:11,580
counts are and are on one server and

23
00:01:11,580 --> 00:01:15,510
half the vote cancer or another but some

24
00:01:15,510 --> 00:01:18,510
operations require touching modifying or

25
00:01:18,510 --> 00:01:20,280
reading data on multiple different

26
00:01:20,280 --> 00:01:21,659
servers so if we're doing a bank

27
00:01:21,659 --> 00:01:23,700
transfer from one customer into another

28
00:01:23,700 --> 00:01:25,440
well their balances may be on different

29
00:01:25,440 --> 00:01:27,479
servers and therefore in order to do the

30
00:01:27,479 --> 00:01:29,490
balance we have to modify data read and

31
00:01:29,490 --> 00:01:33,090
write data on two different servers and

32
00:01:33,090 --> 00:01:37,290
we'd really like to or one way building

33
00:01:37,290 --> 00:01:39,299
these systems and we'll see others later

34
00:01:39,299 --> 00:01:40,619
on in the course one way to build the

35
00:01:40,619 --> 00:01:43,680
system just try to hide the complexity

36
00:01:43,680 --> 00:01:46,020
of splitting this data across multiple

37
00:01:46,020 --> 00:01:47,670
servers try to hide it from the

38
00:01:47,670 --> 00:01:51,810
application programmer and this is like

39
00:01:51,810 --> 00:01:53,909
traditionally has been a database

40
00:01:53,909 --> 00:01:56,939
concern for for many decades and so a

41
00:01:56,939 --> 00:01:58,500
lot of today's material originated with

42
00:01:58,500 --> 00:02:00,840
databases but the ideas have been used

43
00:02:00,840 --> 00:02:03,390
much more widely in distributed systems

44
00:02:03,390 --> 00:02:04,650
which you wouldn't necessarily call a

45
00:02:04,650 --> 00:02:09,508
traditional database the way people sort

46
00:02:09,508 --> 00:02:13,019
of usually package up concurrency

47
00:02:13,019 --> 00:02:15,739
control plus

48
00:02:16,620 --> 00:02:23,260
atomic commit is in abstraction called a

49
00:02:23,260 --> 00:02:30,959
transaction which we've seen before and

50
00:02:30,959 --> 00:02:33,940
the idea is that the programmer you know

51
00:02:33,940 --> 00:02:36,519
has a bunch of different operations may

52
00:02:36,519 --> 00:02:37,890
be on different records in the database

53
00:02:37,890 --> 00:02:40,690
they'd like all those operations to be

54
00:02:40,690 --> 00:02:43,599
sort of a single unit and not split by

55
00:02:43,599 --> 00:02:45,730
failures or by observation from other

56
00:02:45,730 --> 00:02:50,200
activities and the transaction

57
00:02:50,200 --> 00:02:52,120
processing system will require the

58
00:02:52,120 --> 00:02:53,860
programmer to mark the beginning and the

59
00:02:53,860 --> 00:02:56,260
end of that sequence of reading and

60
00:02:56,260 --> 00:02:58,569
writing and updating operations in order

61
00:02:58,569 --> 00:02:59,739
to mark the beginning and of the

62
00:02:59,739 --> 00:03:00,910
transaction and the transaction

63
00:03:00,910 --> 00:03:03,099
processing system has certainly will

64
00:03:03,099 --> 00:03:05,620
provide certain guarantees about what

65
00:03:05,620 --> 00:03:07,090
happens between the beginning and the

66
00:03:07,090 --> 00:03:07,660
end

67
00:03:07,660 --> 00:03:11,200
so for example supposing we're running

68
00:03:11,200 --> 00:03:15,130
our bank and we want to do a transfer

69
00:03:15,130 --> 00:03:19,299
from account of user X to the account of

70
00:03:19,299 --> 00:03:21,670
user wide now these balances from both

71
00:03:21,670 --> 00:03:23,910
of them start out as 10 so initially

72
00:03:23,910 --> 00:03:30,000
expose 10 y equals 10 and x and y I'm

73
00:03:30,000 --> 00:03:35,560
mean to be records in a database and we

74
00:03:35,560 --> 00:03:38,049
want to transfer we will actually

75
00:03:38,049 --> 00:03:40,239
imagine that there's two transactions

76
00:03:40,239 --> 00:03:41,739
that might be running at the same time

77
00:03:41,739 --> 00:03:44,829
one to transfer a dollar from account X

78
00:03:44,829 --> 00:03:47,019
to account Y and the other transaction

79
00:03:47,019 --> 00:03:49,989
to do an audit of of all the accounts at

80
00:03:49,989 --> 00:03:51,700
the bank to make sure that the total

81
00:03:51,700 --> 00:03:53,410
amount of money in the bank never

82
00:03:53,410 --> 00:03:54,819
changes because after all if you do

83
00:03:54,819 --> 00:03:56,769
transfers you know the total shouldn't

84
00:03:56,769 --> 00:03:58,030
change even if you move money between

85
00:03:58,030 --> 00:04:01,180
accounts in order to express this with

86
00:04:01,180 --> 00:04:04,720
transactions we might have two

87
00:04:04,720 --> 00:04:07,090
transactions the first transaction call

88
00:04:07,090 --> 00:04:10,959
it t1 is the transfer well mark the

89
00:04:10,959 --> 00:04:12,850
programmer is expected to mark the

90
00:04:12,850 --> 00:04:13,959
beginning of it with the begin

91
00:04:13,959 --> 00:04:17,978
transaction which all right at the

92
00:04:17,978 --> 00:04:21,220
beginning and then the operations on the

93
00:04:21,220 --> 00:04:23,919
two balances on the two records in the

94
00:04:23,919 --> 00:04:25,550
database so we might add

95
00:04:25,550 --> 00:04:27,130
[Music]

96
00:04:27,130 --> 00:04:34,100
one might add one the balance X and add

97
00:04:34,100 --> 00:04:42,669
-1 to Y and then we need to mark the end

98
00:04:42,669 --> 00:04:46,400
by the transaction currently we might

99
00:04:46,400 --> 00:04:49,220
have a transaction that's going to check

100
00:04:49,220 --> 00:04:50,690
all the balance do an audit of all the

101
00:04:50,690 --> 00:04:52,820
balances find the sum or look at all the

102
00:04:52,820 --> 00:04:54,380
balances make sure they add up to the

103
00:04:54,380 --> 00:04:56,600
number that doesn't change despite

104
00:04:56,600 --> 00:04:59,870
transfers so the second transaction I'm

105
00:04:59,870 --> 00:05:04,570
thinking about the audit transaction

106
00:05:05,590 --> 00:05:07,940
also we need to mark the beginning and

107
00:05:07,940 --> 00:05:13,430
end this time we're just reading there's

108
00:05:13,430 --> 00:05:16,400
a read-only transaction we need to get

109
00:05:16,400 --> 00:05:19,550
the current balances of all the accounts

110
00:05:19,550 --> 00:05:21,320
lists they were just these two accounts

111
00:05:21,320 --> 00:05:24,260
for now so we have two temporary

112
00:05:24,260 --> 00:05:27,910
variables we're gonna read the first one

113
00:05:27,910 --> 00:05:32,660
it's going to be the value of balance X

114
00:05:32,660 --> 00:05:34,970
just right get to mean we're reading

115
00:05:34,970 --> 00:05:40,729
that record we also read Y and we print

116
00:05:40,729 --> 00:05:48,620
them both and that's the end of the

117
00:05:48,620 --> 00:05:55,700
transaction the question is what are

118
00:05:55,700 --> 00:05:57,200
legal results from these two

119
00:05:57,200 --> 00:05:59,660
transactions that's the first thing we

120
00:05:59,660 --> 00:06:01,400
want to establish is what are you know

121
00:06:01,400 --> 00:06:03,620
given the starting state namely the two

122
00:06:03,620 --> 00:06:06,020
balances for ten dollars and what could

123
00:06:06,020 --> 00:06:07,669
be the final results after you've run

124
00:06:07,669 --> 00:06:09,169
both these transactions maybe at the

125
00:06:09,169 --> 00:06:12,050
same time so we need a notion of what

126
00:06:12,050 --> 00:06:14,660
would be correct and once we know that

127
00:06:14,660 --> 00:06:17,330
we need to be able to build machinery

128
00:06:17,330 --> 00:06:18,680
that will actually be able to execute

129
00:06:18,680 --> 00:06:23,060
these transactions and get only those

130
00:06:23,060 --> 00:06:25,390
correct answers despite concurrency and

131
00:06:25,390 --> 00:06:28,190
failures so first what's correctness

132
00:06:28,190 --> 00:06:33,350
well databases usually have a notion of

133
00:06:33,350 --> 00:06:36,580
correctness called acid

134
00:06:38,110 --> 00:06:44,919
or bb-8 is acid and it stands for atomic

135
00:06:44,919 --> 00:06:48,770
and this means that a transaction that

136
00:06:48,770 --> 00:06:49,820
has multiple steps

137
00:06:49,820 --> 00:06:50,960
you know maybe writes multiple different

138
00:06:50,960 --> 00:06:53,090
records if there's a failure despite

139
00:06:53,090 --> 00:06:55,940
failures either all of the right should

140
00:06:55,940 --> 00:06:58,370
be done or none of them it shouldn't be

141
00:06:58,370 --> 00:07:00,080
the case that a failure at an awkward

142
00:07:00,080 --> 00:07:01,400
time in the middle of a transaction

143
00:07:01,400 --> 00:07:04,340
should leave half the updates completed

144
00:07:04,340 --> 00:07:06,530
invisible and half the updates never

145
00:07:06,530 --> 00:07:16,160
done it's all or nothing so this is or

146
00:07:16,160 --> 00:07:25,400
not despite failures the C stands for

147
00:07:25,400 --> 00:07:32,000
consistent it's actually we're not going

148
00:07:32,000 --> 00:07:35,840
to worry about that that's usually meant

149
00:07:35,840 --> 00:07:38,030
to refer to the fact that database will

150
00:07:38,030 --> 00:07:40,460
enforce certain invariants declared by

151
00:07:40,460 --> 00:07:43,610
the application it's not really our

152
00:07:43,610 --> 00:07:45,380
concern today the I though it's quite

153
00:07:45,380 --> 00:07:49,389
important it usually stands for isolated

154
00:07:49,389 --> 00:07:52,340
and this is a really a property of

155
00:07:52,340 --> 00:07:54,830
whether or not two transactions that run

156
00:07:54,830 --> 00:07:56,360
at the same time can see each other's

157
00:07:56,360 --> 00:07:58,610
changes before the transactions have

158
00:07:58,610 --> 00:08:00,440
finished whether or not they can see

159
00:08:00,440 --> 00:08:02,630
sort of intermediate updates and from

160
00:08:02,630 --> 00:08:06,229
the middle of another transaction and

161
00:08:06,229 --> 00:08:11,360
your goal is no and the sort of

162
00:08:11,360 --> 00:08:14,030
technical specific thing that most

163
00:08:14,030 --> 00:08:17,539
people generally mean by isolation is

164
00:08:17,539 --> 00:08:19,280
that the transaction execution is

165
00:08:19,280 --> 00:08:21,139
serializable and I'll explain what that

166
00:08:21,139 --> 00:08:27,669
means in a bit but it boils down to

167
00:08:27,669 --> 00:08:29,630
transactions can't see each other's

168
00:08:29,630 --> 00:08:32,089
changes can't see intermediate states

169
00:08:32,089 --> 00:08:34,909
but only complete transaction results

170
00:08:34,909 --> 00:08:38,830
and the final D stands for durable

171
00:08:39,969 --> 00:08:42,610
and this means that after a transaction

172
00:08:42,610 --> 00:08:44,800
commits after the client or whatever

173
00:08:44,800 --> 00:08:46,360
program that submitted the transaction

174
00:08:46,360 --> 00:08:49,000
gets a reply back from the database

175
00:08:49,000 --> 00:08:49,839
saying yes

176
00:08:49,839 --> 00:08:52,769
you know we've executed your transaction

177
00:08:52,769 --> 00:08:56,560
the D in acid means that the

178
00:08:56,560 --> 00:08:58,689
transactions modifications the database

179
00:08:58,689 --> 00:08:59,949
will be durable that they'll still be

180
00:08:59,949 --> 00:09:02,620
there they won't be erased by a some

181
00:09:02,620 --> 00:09:06,189
sort of failure and in practice that

182
00:09:06,189 --> 00:09:08,199
means that stuff has to be written into

183
00:09:08,199 --> 00:09:10,240
some non-volatile storage persistent

184
00:09:10,240 --> 00:09:13,540
storage like a disk and so today you are

185
00:09:13,540 --> 00:09:16,029
in fact for this whole course really our

186
00:09:16,029 --> 00:09:18,660
concerns are going to revolve around

187
00:09:18,660 --> 00:09:21,220
good behavior with respect to failure

188
00:09:21,220 --> 00:09:25,509
good respect good behavior with respect

189
00:09:25,509 --> 00:09:28,720
to other from multiple parallel

190
00:09:28,720 --> 00:09:31,120
activities and making sure that the data

191
00:09:31,120 --> 00:09:35,139
is there still they are after even if

192
00:09:35,139 --> 00:09:40,660
something crashes so the most

193
00:09:40,660 --> 00:09:42,430
interesting part of this for us is the

194
00:09:42,430 --> 00:09:44,949
specific definition of ice of isolated

195
00:09:44,949 --> 00:09:48,879
or serializable so I'm going to lay that

196
00:09:48,879 --> 00:09:51,459
out before before talking about how it

197
00:09:51,459 --> 00:09:52,930
actually applies to these transactions

198
00:09:52,930 --> 00:10:03,639
so the ioan isolated is usually and the

199
00:10:03,639 --> 00:10:06,910
definition for this if a set of

200
00:10:06,910 --> 00:10:10,329
transactions executes you know

201
00:10:10,329 --> 00:10:12,189
concurrently more or less at the same

202
00:10:12,189 --> 00:10:16,720
time they you are the set of results and

203
00:10:16,720 --> 00:10:19,180
here the results refer to both the new

204
00:10:19,180 --> 00:10:21,879
database records created by any

205
00:10:21,879 --> 00:10:23,709
modifications the transactions might do

206
00:10:23,709 --> 00:10:26,829
and in addition any output that the

207
00:10:26,829 --> 00:10:28,930
transaction is produced so broader

208
00:10:28,930 --> 00:10:30,970
transactions these two adds since they

209
00:10:30,970 --> 00:10:32,410
change records their needs change

210
00:10:32,410 --> 00:10:34,480
records are part of the results and the

211
00:10:34,480 --> 00:10:35,769
output of this print statement is part

212
00:10:35,769 --> 00:10:38,319
of the results so the definition of

213
00:10:38,319 --> 00:10:42,430
serializable says the results are

214
00:10:42,430 --> 00:10:44,850
serializable

215
00:10:47,250 --> 00:10:55,709
if there exists some order of execution

216
00:10:55,709 --> 00:11:20,610
of the transactions so we're gonna say a

217
00:11:20,610 --> 00:11:23,220
specific execution parallel concurrent

218
00:11:23,220 --> 00:11:24,930
execution of transactions is

219
00:11:24,930 --> 00:11:28,139
serializable if there exists some serial

220
00:11:28,139 --> 00:11:31,430
order really emphasizing serial here a

221
00:11:31,430 --> 00:11:34,079
serial order of execution of those same

222
00:11:34,079 --> 00:11:37,110
transactions that yields the same result

223
00:11:37,110 --> 00:11:39,000
as the actual execution and the

224
00:11:39,000 --> 00:11:40,139
difference of here is the actual

225
00:11:40,139 --> 00:11:41,189
execution may have had a lot of

226
00:11:41,189 --> 00:11:46,470
parallelism in it but it's required to

227
00:11:46,470 --> 00:11:48,839
produce the same result as some one at a

228
00:11:48,839 --> 00:11:49,470
time

229
00:11:49,470 --> 00:11:52,559
execution of the same transactions and

230
00:11:52,559 --> 00:11:54,629
so the way you check whether an

231
00:11:54,629 --> 00:11:56,449
execution is serializable whether some

232
00:11:56,449 --> 00:11:59,040
concurrent execution is serializable is

233
00:11:59,040 --> 00:12:01,139
you look at the results and see if you

234
00:12:01,139 --> 00:12:03,720
can find actually some one at a time

235
00:12:03,720 --> 00:12:06,029
execution of the same transactions that

236
00:12:06,029 --> 00:12:09,180
does produce the same results so for our

237
00:12:09,180 --> 00:12:14,040
transaction up here there's only two

238
00:12:14,040 --> 00:12:16,139
orders there's only two one at a time

239
00:12:16,139 --> 00:12:19,110
serial orders available transaction 1

240
00:12:19,110 --> 00:12:22,170
then transaction 2 or transaction 2 then

241
00:12:22,170 --> 00:12:25,889
transaction 1 and so we can just look at

242
00:12:25,889 --> 00:12:27,509
the results that they would produce if

243
00:12:27,509 --> 00:12:29,490
executed one at a time in each of these

244
00:12:29,490 --> 00:12:34,910
orders so if we execute t1 and then t2

245
00:12:34,910 --> 00:12:41,839
then we get x equals 11

246
00:12:42,240 --> 00:12:46,600
why equals 9 and this print statement

247
00:12:46,600 --> 00:12:49,750
since t1 executed first this print

248
00:12:49,750 --> 00:12:51,970
statement sees these two updated values

249
00:12:51,970 --> 00:12:58,690
and so it will print the string 11 9 the

250
00:12:58,690 --> 00:13:01,900
other possible order is that perhaps t2

251
00:13:01,900 --> 00:13:06,279
ran first and then t1 and in that case

252
00:13:06,279 --> 00:13:09,070
t2 will see that 2 records before they

253
00:13:09,070 --> 00:13:11,980
were modified but the modifications will

254
00:13:11,980 --> 00:13:14,830
still take place since t1 runs later so

255
00:13:14,830 --> 00:13:16,750
the final results will again be x equals

256
00:13:16,750 --> 00:13:22,450
11 y equal 9 but this time t2 sodded

257
00:13:22,450 --> 00:13:27,600
before our values so these are the two

258
00:13:27,600 --> 00:13:33,100
legal results for serializability and if

259
00:13:33,100 --> 00:13:34,480
we ever see anything else from running

260
00:13:34,480 --> 00:13:36,130
these two transactions at the same time

261
00:13:36,130 --> 00:13:38,110
we'll know that the database were

262
00:13:38,110 --> 00:13:39,870
running against does not provide

263
00:13:39,870 --> 00:13:42,130
serializable execution it's doing

264
00:13:42,130 --> 00:13:45,820
something else and so while we're

265
00:13:45,820 --> 00:13:48,820
thinking through what would happen if or

266
00:13:48,820 --> 00:13:50,560
what would happen if will always be

267
00:13:50,560 --> 00:13:52,900
against these AHA these are the only two

268
00:13:52,900 --> 00:13:55,180
legal results we better be doing

269
00:13:55,180 --> 00:13:56,910
something that produces one or the other

270
00:13:56,910 --> 00:13:59,890
it's interesting to note that there's

271
00:13:59,890 --> 00:14:02,950
more than one possible result depending

272
00:14:02,950 --> 00:14:04,900
on the actual order you if you you

273
00:14:04,900 --> 00:14:06,430
submit these two transactions at the

274
00:14:06,430 --> 00:14:08,020
same time you don't know whether it's

275
00:14:08,020 --> 00:14:11,980
gonna be t1 t2 or t2 t1 so you have to

276
00:14:11,980 --> 00:14:13,779
be willing to expect more than one

277
00:14:13,779 --> 00:14:15,310
possible legal result and as you have

278
00:14:15,310 --> 00:14:16,630
more or transactions running

279
00:14:16,630 --> 00:14:18,459
concurrently a more complicated there

280
00:14:18,459 --> 00:14:20,709
may be many many possible different

281
00:14:20,709 --> 00:14:22,810
correct results that are all

282
00:14:22,810 --> 00:14:25,930
serializable because of many many orders

283
00:14:25,930 --> 00:14:28,600
here that could be used to fulfill this

284
00:14:28,600 --> 00:14:34,029
requirement okay so now that we have a

285
00:14:34,029 --> 00:14:35,560
definition of correctness and we even

286
00:14:35,560 --> 00:14:37,660
know what all the possible results are

287
00:14:37,660 --> 00:14:42,400
we can ask a few questions so few

288
00:14:42,400 --> 00:14:44,560
what-if questions about how these could

289
00:14:44,560 --> 00:14:48,610
execute so for example suppose that the

290
00:14:48,610 --> 00:14:50,980
way the system actually executed this

291
00:14:50,980 --> 00:14:53,260
was that it started transaction 2 and

292
00:14:53,260 --> 00:14:55,069
got as far as

293
00:14:55,069 --> 00:14:58,180
just after reading X and then

294
00:14:58,180 --> 00:15:03,559
transaction one ran at this point and

295
00:15:03,559 --> 00:15:05,350
then after transaction one finished

296
00:15:05,350 --> 00:15:11,569
transaction to continue executing now it

297
00:15:11,569 --> 00:15:13,819
turns out in with different other

298
00:15:13,819 --> 00:15:15,439
transactions than this that might

299
00:15:15,439 --> 00:15:18,259
actually be legal but here we want to

300
00:15:18,259 --> 00:15:20,509
know if it's legal so we're wondering

301
00:15:20,509 --> 00:15:22,279
gosh if we actually executed that way

302
00:15:22,279 --> 00:15:23,749
what results will we get and are they

303
00:15:23,749 --> 00:15:27,350
the same as either of these two well if

304
00:15:27,350 --> 00:15:29,629
we execute transaction one here then t1

305
00:15:29,629 --> 00:15:32,509
is gonna see value 10 t2 is gonna see

306
00:15:32,509 --> 00:15:35,990
the value after decrementing Y so t1

307
00:15:35,990 --> 00:15:38,749
will be 10 t2 will be 9 and what this

308
00:15:38,749 --> 00:15:42,290
print will be 10 9 and that's neither of

309
00:15:42,290 --> 00:15:45,439
these two outputs here so that means

310
00:15:45,439 --> 00:15:47,179
executing in this way that I just drew

311
00:15:47,179 --> 00:15:49,369
is not serializable it would not be

312
00:15:49,369 --> 00:15:55,059
legal another interesting question is

313
00:15:55,059 --> 00:15:57,860
what if we started executing transaction

314
00:15:57,860 --> 00:15:59,629
1 and we got as far as just after the

315
00:15:59,629 --> 00:16:02,420
first ad and then at that point all the

316
00:16:02,420 --> 00:16:08,720
transaction 2 executed right here so

317
00:16:08,720 --> 00:16:10,939
that would mean at this point X is value

318
00:16:10,939 --> 00:16:17,870
11 the transaction 2 would read 1110 now

319
00:16:17,870 --> 00:16:20,179
print 1110 and 1110 is not one of these

320
00:16:20,179 --> 00:16:22,189
two legal values so this execution is

321
00:16:22,189 --> 00:16:23,749
also not legal for these two

322
00:16:23,749 --> 00:16:26,589
transactions

323
00:16:35,510 --> 00:16:39,350
so the reason why serializable

324
00:16:39,350 --> 00:16:43,110
serializability is a popular and useful

325
00:16:43,110 --> 00:16:44,840
definition of what it means for

326
00:16:44,840 --> 00:16:47,280
transactions to be correct for execution

327
00:16:47,280 --> 00:16:48,930
of transactions to be correct is that

328
00:16:48,930 --> 00:16:51,030
it's a very easy model for programmers

329
00:16:51,030 --> 00:16:53,220
you can write complicated transactions

330
00:16:53,220 --> 00:16:56,190
without having to worry about what else

331
00:16:56,190 --> 00:16:57,990
may be running in the system there may

332
00:16:57,990 --> 00:16:59,370
be lots of other transactions may be

333
00:16:59,370 --> 00:17:00,870
using the same date as you may be

334
00:17:00,870 --> 00:17:02,610
reading trying to read and write it at

335
00:17:02,610 --> 00:17:04,800
the same time there might be failures

336
00:17:04,800 --> 00:17:10,319
who knows but the guarantee here is that

337
00:17:10,319 --> 00:17:12,869
it's safe to write your transactions as

338
00:17:12,869 --> 00:17:15,689
if nothing else was happening because

339
00:17:15,689 --> 00:17:19,560
the final results have to be as if your

340
00:17:19,560 --> 00:17:22,319
transaction was executed by itself in

341
00:17:22,319 --> 00:17:24,540
this one-at-a-time order which is a very

342
00:17:24,540 --> 00:17:28,020
simple very nice programming model it's

343
00:17:28,020 --> 00:17:31,590
also nice that this definition allows

344
00:17:31,590 --> 00:17:34,410
truly parallel execution of transactions

345
00:17:34,410 --> 00:17:36,420
as long as they don't use the same data

346
00:17:36,420 --> 00:17:38,010
so we run into trouble here because

347
00:17:38,010 --> 00:17:39,720
these two transactions are both reading

348
00:17:39,720 --> 00:17:41,370
x and y but if they were using

349
00:17:41,370 --> 00:17:44,070
completely disjoint database records

350
00:17:44,070 --> 00:17:46,170
they could it turns out this definition

351
00:17:46,170 --> 00:17:48,840
allows you to build a database system

352
00:17:48,840 --> 00:17:51,840
that would execute transactions to use

353
00:17:51,840 --> 00:17:54,510
disjoint data completely in parallel and

354
00:17:54,510 --> 00:17:56,220
if you are a sharded system which is

355
00:17:56,220 --> 00:17:57,750
what we're sort of working up to today

356
00:17:57,750 --> 00:17:59,490
with the data different data is on

357
00:17:59,490 --> 00:18:01,200
different machines you can get true

358
00:18:01,200 --> 00:18:02,790
parallel speed-up because maybe one

359
00:18:02,790 --> 00:18:04,800
transaction executes Spira in the first

360
00:18:04,800 --> 00:18:06,510
shard on the first machine and the other

361
00:18:06,510 --> 00:18:09,390
in parallel on the second machine so

362
00:18:09,390 --> 00:18:12,960
there are opportunities here for for

363
00:18:12,960 --> 00:18:17,490
good performance before I dig into how

364
00:18:17,490 --> 00:18:21,590
to implement serializable transactions

365
00:18:21,590 --> 00:18:24,480
there's one more small point I want to

366
00:18:24,480 --> 00:18:29,310
bring up it turns out that one of the

367
00:18:29,310 --> 00:18:30,540
things we need to be able to cope with

368
00:18:30,540 --> 00:18:33,150
is that transactions may for one reason

369
00:18:33,150 --> 00:18:34,370
or another

370
00:18:34,370 --> 00:18:39,420
basically fail or decide to fail in the

371
00:18:39,420 --> 00:18:41,670
middle of the transaction and this is

372
00:18:41,670 --> 00:18:47,160
usually called an abort and you know for

373
00:18:47,160 --> 00:18:48,840
many transaction systems we need to be

374
00:18:48,840 --> 00:18:50,880
prepared to handle Oh what should happen

375
00:18:50,880 --> 00:18:53,490
if a transaction tries to access a

376
00:18:53,490 --> 00:18:56,070
record that doesn't exist or divides by

377
00:18:56,070 --> 00:18:59,460
zero or maybe you know since some

378
00:18:59,460 --> 00:19:01,140
transaction implementation schemes use

379
00:19:01,140 --> 00:19:03,720
locking maybe a transaction causes a

380
00:19:03,720 --> 00:19:05,460
locking deadlock and the only way to

381
00:19:05,460 --> 00:19:08,010
break the deadlock is to kill one of one

382
00:19:08,010 --> 00:19:09,450
or more of the transactions this

383
00:19:09,450 --> 00:19:13,170
participating in the deadlock so one of

384
00:19:13,170 --> 00:19:14,910
the things that's going to be kind of

385
00:19:14,910 --> 00:19:16,170
hanging in the background and will come

386
00:19:16,170 --> 00:19:18,720
up is the necessity of coping with

387
00:19:18,720 --> 00:19:20,820
transactions that all of a sudden in the

388
00:19:20,820 --> 00:19:22,970
middle decide they just cannot proceed

389
00:19:22,970 --> 00:19:26,580
and you know maybe really in the middle

390
00:19:26,580 --> 00:19:28,530
after they've done some work and started

391
00:19:28,530 --> 00:19:30,240
modifying things we need to be able to

392
00:19:30,240 --> 00:19:33,150
kind of back out of these transactions

393
00:19:33,150 --> 00:19:35,690
and undo any modifications they've made

394
00:19:35,690 --> 00:19:38,190
all right

395
00:19:38,190 --> 00:19:40,830
the implementation strategy for

396
00:19:40,830 --> 00:19:42,390
transactions for these asset

397
00:19:42,390 --> 00:19:46,140
transactions I'm gonna split into two

398
00:19:46,140 --> 00:19:48,510
big pieces but and talk about both of

399
00:19:48,510 --> 00:19:52,560
them the main topics in the lecture the

400
00:19:52,560 --> 00:19:54,360
first big implementation topic is

401
00:19:54,360 --> 00:20:05,430
concurrency control this is the main

402
00:20:05,430 --> 00:20:07,380
tool we use to provide serializability

403
00:20:07,380 --> 00:20:10,080
the current or isolation so concurrency

404
00:20:10,080 --> 00:20:13,250
control bias

405
00:20:16,509 --> 00:20:19,879
by its isolation from other concurrent

406
00:20:19,879 --> 00:20:21,320
transactions that might be trying to use

407
00:20:21,320 --> 00:20:24,049
the same data and the other big pieces I

408
00:20:24,049 --> 00:20:27,639
mentioned is atomic commit and this is

409
00:20:28,809 --> 00:20:31,369
what's going to help us deal with the

410
00:20:31,369 --> 00:20:34,070
possibility that oh yeah this

411
00:20:34,070 --> 00:20:35,960
transactions executing a long and it's

412
00:20:35,960 --> 00:20:38,330
may be modified X and then all of a

413
00:20:38,330 --> 00:20:41,899
sudden there's a failure and one of the

414
00:20:41,899 --> 00:20:44,480
server's involved but other servers that

415
00:20:44,480 --> 00:20:45,919
were maybe actually in other parts of

416
00:20:45,919 --> 00:20:48,139
the transaction that is if x and y are

417
00:20:48,139 --> 00:20:50,779
in different machines we need to be able

418
00:20:50,779 --> 00:20:52,730
to recover even if there's a partial

419
00:20:52,730 --> 00:20:55,340
failure of only some of the machines the

420
00:20:55,340 --> 00:20:58,460
transactions running off and the big

421
00:20:58,460 --> 00:21:00,169
tool people use for that is this atomic

422
00:21:00,169 --> 00:21:03,889
commit you'll talk about all right so

423
00:21:03,889 --> 00:21:08,960
first concurrency control there's really

424
00:21:08,960 --> 00:21:11,480
two classes two major approaches to

425
00:21:11,480 --> 00:21:13,990
concurrency control I'll talk about both

426
00:21:13,990 --> 00:21:20,450
during the course if they're just mean

427
00:21:20,450 --> 00:21:22,960
strategies the first strategy is a

428
00:21:22,960 --> 00:21:29,480
pessimistic usually called pessimist

429
00:21:29,480 --> 00:21:32,360
pessimistic concurrency control and this

430
00:21:32,360 --> 00:21:34,519
is usually locking we've all done

431
00:21:34,519 --> 00:21:36,440
locking in the labs in the context of go

432
00:21:36,440 --> 00:21:38,509
program so it turns out databases

433
00:21:38,509 --> 00:21:40,879
transaction processing systems also used

434
00:21:40,879 --> 00:21:45,409
locking and the idea here is U is the

435
00:21:45,409 --> 00:21:46,909
same as well you're quite familiar with

436
00:21:46,909 --> 00:21:48,860
this that before transaction uses any

437
00:21:48,860 --> 00:21:50,960
data it needs to acquire a lock on that

438
00:21:50,960 --> 00:21:52,850
data and if some other transactions

439
00:21:52,850 --> 00:21:54,619
already using the data the lock will be

440
00:21:54,619 --> 00:21:57,080
held and we'll have to wait before we

441
00:21:57,080 --> 00:21:58,909
can acquire the lock wait for the other

442
00:21:58,909 --> 00:22:02,899
transaction to finish and in pessimistic

443
00:22:02,899 --> 00:22:04,730
systems if there's locking conflicts

444
00:22:04,730 --> 00:22:06,230
somebody else has the lock it'll cause

445
00:22:06,230 --> 00:22:09,139
delays so you're sort of treating

446
00:22:09,139 --> 00:22:14,419
performance for correctness the other

447
00:22:14,419 --> 00:22:20,679
main approach is optimistic approaches

448
00:22:21,450 --> 00:22:23,980
the basic idea here is you don't worry

449
00:22:23,980 --> 00:22:25,330
about whether maybe some other

450
00:22:25,330 --> 00:22:26,980
transactions reading or writing the data

451
00:22:26,980 --> 00:22:28,779
at the same time as you you just go

452
00:22:28,779 --> 00:22:30,309
ahead and do whatever reads and writes

453
00:22:30,309 --> 00:22:32,200
you're gonna do although typically into

454
00:22:32,200 --> 00:22:33,940
some sort of temporary area and then

455
00:22:33,940 --> 00:22:37,330
only at the end you go and check whether

456
00:22:37,330 --> 00:22:38,799
actually maybe some other transaction

457
00:22:38,799 --> 00:22:40,870
might have been interfering and if

458
00:22:40,870 --> 00:22:42,309
there's no other transaction now you're

459
00:22:42,309 --> 00:22:44,470
done and you never had to go through any

460
00:22:44,470 --> 00:22:46,029
of the overhead or weighting of taking

461
00:22:46,029 --> 00:22:47,950
out locks the locks are reasonably

462
00:22:47,950 --> 00:22:51,730
expensive to manipulate but if somebody

463
00:22:51,730 --> 00:22:54,340
else was modifying the data in a

464
00:22:54,340 --> 00:22:56,830
conflicting way at the same time you

465
00:22:56,830 --> 00:22:58,480
were then you have to abort that

466
00:22:58,480 --> 00:23:05,309
transaction and we try and the

467
00:23:05,309 --> 00:23:06,940
abbreviation for this is often

468
00:23:06,940 --> 00:23:10,120
optimistic concurrency control um it

469
00:23:10,120 --> 00:23:11,080
turns out that under different

470
00:23:11,080 --> 00:23:12,759
circumstances these two strategies one

471
00:23:12,759 --> 00:23:15,179
can be faster than the other

472
00:23:15,179 --> 00:23:17,830
if conflicts are very frequent you

473
00:23:17,830 --> 00:23:18,580
probably actually want to use

474
00:23:18,580 --> 00:23:20,679
pessimistic concurrency control not

475
00:23:20,679 --> 00:23:22,120
because of conflicts are frequent you're

476
00:23:22,120 --> 00:23:23,529
gonna get a lot of aborts due to

477
00:23:23,529 --> 00:23:25,899
conflicts for optimistic seems if

478
00:23:25,899 --> 00:23:27,580
complex are rare than optimistic

479
00:23:27,580 --> 00:23:29,980
concurrency control can be faster

480
00:23:29,980 --> 00:23:31,539
because it completely avoids locking

481
00:23:31,539 --> 00:23:33,580
overhead today will be all about

482
00:23:33,580 --> 00:23:36,580
pessimistic concurrency control and then

483
00:23:36,580 --> 00:23:39,610
some later paper in particular farm in a

484
00:23:39,610 --> 00:23:41,950
couple weeks we'll deal with an

485
00:23:41,950 --> 00:23:48,549
optimistic scheme okay so today talking

486
00:23:48,549 --> 00:23:51,190
about pessimistic schemes refers

487
00:23:51,190 --> 00:23:53,500
basically to locking and in particular

488
00:23:53,500 --> 00:23:54,700
for today the reading was about

489
00:23:54,700 --> 00:23:57,059
two-phase locking which is the most

490
00:23:57,059 --> 00:24:00,990
common type of locking

491
00:24:07,640 --> 00:24:10,140
and the idea in two-phase locking for

492
00:24:10,140 --> 00:24:12,090
transactions is that transactions gonna

493
00:24:12,090 --> 00:24:14,280
use a bunch of Records like X&Y and our

494
00:24:14,280 --> 00:24:19,140
example the first rule is that you

495
00:24:19,140 --> 00:24:25,350
acquire a lock before using date any

496
00:24:25,350 --> 00:24:30,360
piece of data we're reading or writing

497
00:24:30,360 --> 00:24:35,400
any record and the second rule for

498
00:24:35,400 --> 00:24:37,710
transactions is that a transaction must

499
00:24:37,710 --> 00:24:40,770
hold any locks it acquires until after

500
00:24:40,770 --> 00:24:43,650
it commits or aborts you're not allowed

501
00:24:43,650 --> 00:24:44,820
to give up locks in the middle of the

502
00:24:44,820 --> 00:24:46,020
transaction you have to hold them all

503
00:24:46,020 --> 00:24:48,270
you can only accumulate them until

504
00:24:48,270 --> 00:24:52,580
you're done until after you're done so

505
00:24:54,680 --> 00:24:59,670
until Phoebe done so this is two-phase

506
00:24:59,670 --> 00:25:01,500
locking the phases are the phases which

507
00:25:01,500 --> 00:25:03,570
we acquire locks and then phase in which

508
00:25:03,570 --> 00:25:07,490
we just hold onto them until we're done

509
00:25:07,490 --> 00:25:11,640
so for two phase locking to sort of see

510
00:25:11,640 --> 00:25:15,810
why locking works your typical locking

511
00:25:15,810 --> 00:25:17,700
systems well there's a lot of variation

512
00:25:17,700 --> 00:25:19,110
typical locking systems associate a

513
00:25:19,110 --> 00:25:21,060
separate lock with each record in the

514
00:25:21,060 --> 00:25:23,250
database with each row in each table for

515
00:25:23,250 --> 00:25:25,500
example although they can be more more

516
00:25:25,500 --> 00:25:28,500
coarse-grained these transactions start

517
00:25:28,500 --> 00:25:29,910
out holding no locks let's say

518
00:25:29,910 --> 00:25:31,470
transaction one starts out holding no

519
00:25:31,470 --> 00:25:34,500
locks when it first uses X before so

520
00:25:34,500 --> 00:25:35,880
I'll have to use it it has to acquire

521
00:25:35,880 --> 00:25:38,540
the lock on X and it may have to wait

522
00:25:38,540 --> 00:25:41,130
and when it first uses Y it acquires

523
00:25:41,130 --> 00:25:43,860
another lock the lock on Y when it

524
00:25:43,860 --> 00:25:45,750
finishes after it's done becoming these

525
00:25:45,750 --> 00:25:48,180
both if we ran both these transactions

526
00:25:48,180 --> 00:25:50,760
at the same time they're gonna basically

527
00:25:50,760 --> 00:25:53,310
race to get the lock on X and whichever

528
00:25:53,310 --> 00:25:56,160
of them gets the managed to get the lock

529
00:25:56,160 --> 00:25:59,400
on X first it will proceed and finish

530
00:25:59,400 --> 00:26:02,310
and commit meantime the other

531
00:26:02,310 --> 00:26:04,230
transaction that didn't manage to get

532
00:26:04,230 --> 00:26:05,610
the lock on X first it's going to see if

533
00:26:05,610 --> 00:26:08,910
you're waiting before it what you does

534
00:26:08,910 --> 00:26:10,860
anything with accent OA can acquire the

535
00:26:10,860 --> 00:26:13,200
lock so transaction 2 actually got the

536
00:26:13,200 --> 00:26:14,460
lock first

537
00:26:14,460 --> 00:26:16,380
you would get the value of X get the

538
00:26:16,380 --> 00:26:20,190
value of y cuz transaction one hasn't

539
00:26:20,190 --> 00:26:22,370
gotten at this point hasn't locked Y yet

540
00:26:22,370 --> 00:26:24,540
it'll print and it will finish and

541
00:26:24,540 --> 00:26:26,130
release its locks and only then

542
00:26:26,130 --> 00:26:28,560
transaction one will be able to acquire

543
00:26:28,560 --> 00:26:30,960
the lock on X and as you can see that

544
00:26:30,960 --> 00:26:33,750
basically forces a serial order because

545
00:26:33,750 --> 00:26:35,220
it forced in this case it force the

546
00:26:35,220 --> 00:26:38,550
order T two and then when T two finishes

547
00:26:38,550 --> 00:26:43,080
only then T 1 so with it's explicitly

548
00:26:43,080 --> 00:26:47,330
forcing an order which causes the that

549
00:26:47,330 --> 00:26:49,620
execution to follow the definition of

550
00:26:49,620 --> 00:26:51,450
serializability that you know really is

551
00:26:51,450 --> 00:26:54,360
executing T 2 to completion and only

552
00:26:54,360 --> 00:27:00,620
then T 1 so we do get correct execution

553
00:27:06,930 --> 00:27:15,040
all right so one question is why you

554
00:27:15,040 --> 00:27:16,840
need to hold the locks until the

555
00:27:16,840 --> 00:27:19,060
transactions completely finished you

556
00:27:19,060 --> 00:27:22,210
might think that you could just hold a

557
00:27:22,210 --> 00:27:24,520
lock while you are actually using the

558
00:27:24,520 --> 00:27:25,810
data and that would be more efficient

559
00:27:25,810 --> 00:27:28,660
and indeed it would that is you know

560
00:27:28,660 --> 00:27:31,480
maybe only hold the lock for the period

561
00:27:31,480 --> 00:27:34,030
of time in which t2 is actually looking

562
00:27:34,030 --> 00:27:36,040
at record X or maybe only hold the lock

563
00:27:36,040 --> 00:27:39,180
on X here for the duration of the add

564
00:27:39,180 --> 00:27:41,680
operation and then immediately release

565
00:27:41,680 --> 00:27:43,480
it and in that case that what if we

566
00:27:43,480 --> 00:27:45,280
transaction one immediately released a

567
00:27:45,280 --> 00:27:47,140
lock on X there there by disobeying this

568
00:27:47,140 --> 00:27:48,910
rule of course but if it immediately

569
00:27:48,910 --> 00:27:50,740
release the lock on X then transaction

570
00:27:50,740 --> 00:27:51,970
two might be able to start a little bit

571
00:27:51,970 --> 00:27:53,590
earlier we get more concurrency more

572
00:27:53,590 --> 00:27:55,240
higher performance so this rule

573
00:27:55,240 --> 00:27:57,820
definitely you know bad for performance

574
00:27:57,820 --> 00:28:00,040
so we want to make pretty sure that it's

575
00:28:00,040 --> 00:28:02,530
it's good for that's required for

576
00:28:02,530 --> 00:28:05,010
correctness

577
00:28:05,220 --> 00:28:08,440
so what won't happen if transactions did

578
00:28:08,440 --> 00:28:11,740
actually release locks as early as

579
00:28:11,740 --> 00:28:12,430
possible

580
00:28:12,430 --> 00:28:15,940
so suppose t2 here reads X and then

581
00:28:15,940 --> 00:28:20,440
immediately releases this lock on X that

582
00:28:20,440 --> 00:28:23,680
would allow t1 since at now at this

583
00:28:23,680 --> 00:28:26,860
point in the execution t2 doesn't hold

584
00:28:26,860 --> 00:28:28,630
any locks because it's just released it

585
00:28:28,630 --> 00:28:31,420
illegally release the lock on X since it

586
00:28:31,420 --> 00:28:33,040
holds a no locks that means t1 could

587
00:28:33,040 --> 00:28:36,610
completely execute right here and we

588
00:28:36,610 --> 00:28:40,090
already knew from from before that this

589
00:28:40,090 --> 00:28:42,070
interleaving is not correct as it

590
00:28:42,070 --> 00:28:45,300
doesn't produce either these two outputs

591
00:28:45,300 --> 00:28:52,600
similarly if if t1 released this lock on

592
00:28:52,600 --> 00:28:55,030
X after finished adding one to X that

593
00:28:55,030 --> 00:28:57,700
would allow all of t2 to slip in right

594
00:28:57,700 --> 00:28:59,770
here and we know also from before that

595
00:28:59,770 --> 00:29:07,200
that results in in illegal results

596
00:29:07,620 --> 00:29:12,570
there's a an additional kind of problem

597
00:29:12,570 --> 00:29:14,010
that can come up with releasing locks

598
00:29:14,010 --> 00:29:18,690
after modifying data if t1 were to

599
00:29:18,690 --> 00:29:21,090
release the lock on X it might allow t2

600
00:29:21,090 --> 00:29:24,360
to see the modified version of X here to

601
00:29:24,360 --> 00:29:26,730
see the X after adding 1 to it and to

602
00:29:26,730 --> 00:29:28,950
print that output and then for tteyuu to

603
00:29:28,950 --> 00:29:31,740
complete after printing the incremented

604
00:29:31,740 --> 00:29:33,900
value of x if transaction one were to

605
00:29:33,900 --> 00:29:36,029
abort after that point maybe because

606
00:29:36,029 --> 00:29:39,720
bank balance Y doesn't exist or maybe

607
00:29:39,720 --> 00:29:41,820
bank bonds Y exists but its balance is

608
00:29:41,820 --> 00:29:43,770
zero and you know we're not allowed to

609
00:29:43,770 --> 00:29:46,260
decrement 0 for bank balances because

610
00:29:46,260 --> 00:29:48,870
that's an overdraft so t1 might modify X

611
00:29:48,870 --> 00:29:51,299
then abort and part of the abort has to

612
00:29:51,299 --> 00:29:56,659
be undoing its update to X in order to

613
00:29:56,659 --> 00:29:59,490
maintain atomicity and what that would

614
00:29:59,490 --> 00:30:00,750
mean if it released the locks is that

615
00:30:00,750 --> 00:30:03,000
transaction 2 would have seen this sort

616
00:30:03,000 --> 00:30:05,490
of phantom value of 11 that went away

617
00:30:05,490 --> 00:30:08,700
because t1 aborted you would have seen a

618
00:30:08,700 --> 00:30:10,590
value that according to the rules never

619
00:30:10,590 --> 00:30:13,940
existed right because then the

620
00:30:13,940 --> 00:30:16,770
transaction 1 aborts then it's as if it

621
00:30:16,770 --> 00:30:18,330
never existed and so that means the

622
00:30:18,330 --> 00:30:21,450
results from t2 had better be as if t2

623
00:30:21,450 --> 00:30:24,960
ran by itself without t1 at all but if

624
00:30:24,960 --> 00:30:26,070
it sees the increment that it's gonna

625
00:30:26,070 --> 00:30:31,880
print 11 for X 11 10 actually which is

626
00:30:31,880 --> 00:30:34,380
just doesn't correspond to any state in

627
00:30:34,380 --> 00:30:37,760
the database given that t1 didn't really

628
00:30:37,760 --> 00:30:42,659
complete okay so that's why those are

629
00:30:42,659 --> 00:30:45,299
two dangers that are averted due to

630
00:30:45,299 --> 00:30:48,000
violations serialize ability that are

631
00:30:48,000 --> 00:30:50,460
averted because transactions hold the

632
00:30:50,460 --> 00:30:56,580
locks until they're done a further thing

633
00:30:56,580 --> 00:30:59,010
to note about these rules or that it's

634
00:30:59,010 --> 00:31:01,169
very easy for them to produce deadlock

635
00:31:01,169 --> 00:31:06,059
so you know for example if we have two

636
00:31:06,059 --> 00:31:12,750
transactions one of them reads record ax

637
00:31:12,750 --> 00:31:15,710
and reads record y

638
00:31:15,710 --> 00:31:19,909
and the other transaction reads Y and

639
00:31:19,909 --> 00:31:26,450
then X that's that's just a deadlock if

640
00:31:26,450 --> 00:31:28,880
they run at the same time they each of

641
00:31:28,880 --> 00:31:32,059
them gets this lock on the record it

642
00:31:32,059 --> 00:31:34,309
first read they don't release till the

643
00:31:34,309 --> 00:31:37,669
transactions finish so they both sit

644
00:31:37,669 --> 00:31:39,289
there waiting for the lock that's held

645
00:31:39,289 --> 00:31:41,539
by the other transaction and unless the

646
00:31:41,539 --> 00:31:42,890
database does something clever which it

647
00:31:42,890 --> 00:31:44,630
will

648
00:31:44,630 --> 00:31:46,159
they'll deadlock forever and in fact

649
00:31:46,159 --> 00:31:47,570
transactions have various strategies

650
00:31:47,570 --> 00:31:50,840
including tracing cycles or timeouts in

651
00:31:50,840 --> 00:31:53,000
order to detect that they've gone into

652
00:31:53,000 --> 00:31:54,679
the situation the database will abort

653
00:31:54,679 --> 00:31:56,929
one of these two transactions and undo

654
00:31:56,929 --> 00:31:58,340
all its changes and act as if that

655
00:31:58,340 --> 00:32:02,539
transaction that never occurred okay so

656
00:32:02,539 --> 00:32:04,760
that's concurrency control with

657
00:32:04,760 --> 00:32:12,440
two-phase locking and this is just

658
00:32:12,440 --> 00:32:16,760
completely standard database behavior so

659
00:32:16,760 --> 00:32:22,399
far and it's the same in a single

660
00:32:22,399 --> 00:32:24,730
machine databases as it will be and

661
00:32:24,730 --> 00:32:26,809
distributed databases that are a little

662
00:32:26,809 --> 00:32:30,080
more interest to us but our next topic

663
00:32:30,080 --> 00:32:32,620
is a little is actually specific to

664
00:32:32,620 --> 00:32:35,510
building databases or storage systems in

665
00:32:35,510 --> 00:32:39,340
general that support transactions on

666
00:32:39,340 --> 00:32:41,360
distributed setting that is splitting

667
00:32:41,360 --> 00:32:45,590
the data over multiple machines so now

668
00:32:45,590 --> 00:32:47,990
the topic is how to build distributed

669
00:32:47,990 --> 00:32:53,720
distributed transactions and in

670
00:32:53,720 --> 00:32:56,020
particular how to cope with failures and

671
00:32:56,020 --> 00:32:58,880
more specifically the kind of partial

672
00:32:58,880 --> 00:33:00,590
failures of just one of many servers

673
00:33:00,590 --> 00:33:02,360
that you often see in distributed

674
00:33:02,360 --> 00:33:04,600
systems so beyond distributed

675
00:33:04,600 --> 00:33:07,250
transactions and we're worried about how

676
00:33:07,250 --> 00:33:09,890
they behave you make sure they're

677
00:33:09,890 --> 00:33:13,159
serializable and also have sort of

678
00:33:13,159 --> 00:33:15,470
all-or-nothing ad Amissah T even in the

679
00:33:15,470 --> 00:33:21,970
face of failures so

680
00:33:21,970 --> 00:33:24,410
you know I you know what the way this

681
00:33:24,410 --> 00:33:26,000
looks like is that we may have two

682
00:33:26,000 --> 00:33:30,020
servers and we got server one and maybe

683
00:33:30,020 --> 00:33:33,260
it stores record X in our bank and we

684
00:33:33,260 --> 00:33:35,300
have server two and maybe it's stores

685
00:33:35,300 --> 00:33:37,850
record Y so they all start out with

686
00:33:37,850 --> 00:33:41,510
value 10 and we need to run these two

687
00:33:41,510 --> 00:33:44,150
transactions that transaction 1 of

688
00:33:44,150 --> 00:33:48,110
course modifies both x and y so now we

689
00:33:48,110 --> 00:33:49,850
need to send messages the database is

690
00:33:49,850 --> 00:33:51,770
saying oh please increment X please

691
00:33:51,770 --> 00:33:55,190
decrement Y but it would be easy if we

692
00:33:55,190 --> 00:33:56,570
weren't careful to get into a situation

693
00:33:56,570 --> 00:33:59,390
where we had told server 1 to increase

694
00:33:59,390 --> 00:34:01,430
the balance for X but then something

695
00:34:01,430 --> 00:34:03,530
failed maybe the client sending the

696
00:34:03,530 --> 00:34:05,780
requests or maybe server the server -

697
00:34:05,780 --> 00:34:07,730
that's holding Y fails or something and

698
00:34:07,730 --> 00:34:10,690
we never managed to do the second update

699
00:34:10,690 --> 00:34:14,270
right so that's one problem is failure

700
00:34:14,270 --> 00:34:16,850
somewhere may sort of cut the

701
00:34:16,850 --> 00:34:19,399
transaction in half and if we're not

702
00:34:19,399 --> 00:34:20,719
careful cause only half of the

703
00:34:20,719 --> 00:34:26,739
transaction to actually take effect

704
00:34:34,460 --> 00:34:36,989
this can happen even without crashes if

705
00:34:36,989 --> 00:34:39,149
X does its part in the transaction it

706
00:34:39,149 --> 00:34:40,440
could be that over on server-to-server

707
00:34:40,440 --> 00:34:42,918
to actually gets the request to

708
00:34:42,918 --> 00:34:46,319
decrement bank account y but maybe

709
00:34:46,319 --> 00:34:47,760
server 2 discovers this bank account

710
00:34:47,760 --> 00:34:50,099
doesn't exist or maybe it does exist and

711
00:34:50,099 --> 00:34:52,079
it's balance is already 0 when it can't

712
00:34:52,079 --> 00:34:53,969
be decrease and so it can't do its part

713
00:34:53,969 --> 00:34:56,039
of the transaction but X look has

714
00:34:56,039 --> 00:34:58,220
already done its part of the transaction

715
00:34:58,220 --> 00:35:00,329
so that's a problem that needs to be

716
00:35:00,329 --> 00:35:09,450
dealt with so the the property we want

717
00:35:09,450 --> 00:35:11,849
as I mentioned before is that all the

718
00:35:11,849 --> 00:35:13,650
pieces of the system either all the

719
00:35:13,650 --> 00:35:15,059
pieces of the system should do their

720
00:35:15,059 --> 00:35:18,089
part of the transaction or none right so

721
00:35:18,089 --> 00:35:20,849
you know the kind of the thing we

722
00:35:20,849 --> 00:35:25,440
violated here is what atomicity against

723
00:35:25,440 --> 00:35:33,029
crashes versus failure where atomicity

724
00:35:33,029 --> 00:35:40,650
is all or not all parts all parts of the

725
00:35:40,650 --> 00:35:42,210
transaction that we're trying to execute

726
00:35:42,210 --> 00:35:50,069
or none of them and for you more the

727
00:35:50,069 --> 00:35:51,089
kind of solution we're going to be

728
00:35:51,089 --> 00:35:54,089
looking at is atomic commitments atomic

729
00:35:54,089 --> 00:35:59,299
commit protocols and the general kind of

730
00:35:59,299 --> 00:36:01,769
flavor of atomic commit protocols is

731
00:36:01,769 --> 00:36:02,940
that you have a bunch of computers

732
00:36:02,940 --> 00:36:04,559
they're all doing different parts of

733
00:36:04,559 --> 00:36:08,190
some larger task and the atomic commit

734
00:36:08,190 --> 00:36:10,980
protocol is gonna help the computers

735
00:36:10,980 --> 00:36:12,630
decide that either they're all going to

736
00:36:12,630 --> 00:36:13,950
do they're they're all capable of doing

737
00:36:13,950 --> 00:36:15,359
their part and they're actually gonna do

738
00:36:15,359 --> 00:36:17,430
it or something has gone wrong and

739
00:36:17,430 --> 00:36:19,470
they're all going to agree that oh

740
00:36:19,470 --> 00:36:21,119
they're actually none of them are gonna

741
00:36:21,119 --> 00:36:23,809
do their part of the whatever the

742
00:36:23,809 --> 00:36:26,970
overall task is and the big challenges

743
00:36:26,970 --> 00:36:28,230
are of course how to cope with various

744
00:36:28,230 --> 00:36:29,970
failures machine failures loss of

745
00:36:29,970 --> 00:36:32,089
messages and it'll turn out that

746
00:36:32,089 --> 00:36:35,430
performance is also a little bit

747
00:36:35,430 --> 00:36:39,000
difficult to do a good job with the

748
00:36:39,000 --> 00:36:40,440
specific protocol we're gonna look at

749
00:36:40,440 --> 00:36:42,150
and is the protocol explained in a

750
00:36:42,150 --> 00:36:46,849
reading for today our two-phase commit

751
00:36:52,920 --> 00:36:57,480
this is an atomic commitment protocol

752
00:36:58,109 --> 00:37:00,460
and this is used both by distributed

753
00:37:00,460 --> 00:37:02,619
databases and also by all kinds of other

754
00:37:02,619 --> 00:37:05,289
distributed systems that might not have

755
00:37:05,289 --> 00:37:07,200
first looked like traditional databases

756
00:37:07,200 --> 00:37:10,170
the general setting is we assume that

757
00:37:10,170 --> 00:37:13,329
that in one way or another the task we

758
00:37:13,329 --> 00:37:15,010
need to perform is split up over

759
00:37:15,010 --> 00:37:16,660
multiple servers each of which needs to

760
00:37:16,660 --> 00:37:19,420
do some part a different part each one

761
00:37:19,420 --> 00:37:22,390
of them so for example because I'm set

762
00:37:22,390 --> 00:37:24,670
up I showed here in which the it's

763
00:37:24,670 --> 00:37:26,440
really the data that split up and so the

764
00:37:26,440 --> 00:37:28,510
tasks being split up our incrementing X

765
00:37:28,510 --> 00:37:34,690
and decrementing Y D we're going to

766
00:37:34,690 --> 00:37:38,319
assume that there's one computer that's

767
00:37:38,319 --> 00:37:40,210
driving the transaction called the

768
00:37:40,210 --> 00:37:55,869
transaction coordinator there's lots of

769
00:37:55,869 --> 00:37:57,460
ways of arranging how the transaction

770
00:37:57,460 --> 00:37:59,230
coordinator steps in but we'll just

771
00:37:59,230 --> 00:38:00,910
imagine it as a computer that is

772
00:38:00,910 --> 00:38:03,130
actually running the transaction there's

773
00:38:03,130 --> 00:38:04,539
one computer the transaction coordinator

774
00:38:04,539 --> 00:38:06,940
that's that's executing the sort of code

775
00:38:06,940 --> 00:38:08,950
for the transaction like the puts and

776
00:38:08,950 --> 00:38:11,289
the gets and the adds and it sends

777
00:38:11,289 --> 00:38:14,589
messages to the computers that hold the

778
00:38:14,589 --> 00:38:16,210
different pieces of data that need to

779
00:38:16,210 --> 00:38:18,900
actually execute the different parts so

780
00:38:18,900 --> 00:38:21,700
for our setup we're going to have one

781
00:38:21,700 --> 00:38:23,500
computer of the transaction coordinator

782
00:38:23,500 --> 00:38:28,299
and it's going to be these server one

783
00:38:28,299 --> 00:38:33,430
and server two that hold X&Y transaction

784
00:38:33,430 --> 00:38:34,930
coordinator we'll send a message to

785
00:38:34,930 --> 00:38:36,549
server one saying oh please increment X

786
00:38:36,549 --> 00:38:38,890
send a message to server Y saying oh

787
00:38:38,890 --> 00:38:40,510
please decrement Y and then there'll be

788
00:38:40,510 --> 00:38:42,520
more messages in order to make sure that

789
00:38:42,520 --> 00:38:44,680
either they both do it or neither than

790
00:38:44,680 --> 00:38:46,569
do it and that's where two-phase commit

791
00:38:46,569 --> 00:38:50,109
steps in something to keep in the back

792
00:38:50,109 --> 00:38:52,180
your mind is that in the full system

793
00:38:52,180 --> 00:38:53,980
there may be many different transactions

794
00:38:53,980 --> 00:38:55,750
running concurrently and many

795
00:38:55,750 --> 00:38:57,890
transaction coordinators

796
00:38:57,890 --> 00:39:00,890
sort of executing their own transactions

797
00:39:00,890 --> 00:39:03,319
and so the various parties here need to

798
00:39:03,319 --> 00:39:04,940
keep track of oh you know this is a

799
00:39:04,940 --> 00:39:06,890
message for such-and-such a transaction

800
00:39:06,890 --> 00:39:09,589
and where they keep state like these

801
00:39:09,589 --> 00:39:10,849
turns out these servers are going to

802
00:39:10,849 --> 00:39:12,710
maintain table two blocks for example

803
00:39:12,710 --> 00:39:14,660
and they keep state like that they need

804
00:39:14,660 --> 00:39:15,950
to keep track of oh this is a lock

805
00:39:15,950 --> 00:39:18,680
that's being held for transactions 17 so

806
00:39:18,680 --> 00:39:28,660
there's a notion of transaction IDs and

807
00:39:28,660 --> 00:39:31,819
I'm just gonna assume although you know

808
00:39:31,819 --> 00:39:33,619
I'm not actually show it that every

809
00:39:33,619 --> 00:39:35,630
message in the system is tagged with the

810
00:39:35,630 --> 00:39:37,069
transaction with the unique transaction

811
00:39:37,069 --> 00:39:39,470
ID of the transaction it applies to and

812
00:39:39,470 --> 00:39:41,359
these IDs are chosen by the transaction

813
00:39:41,359 --> 00:39:43,099
coordinator when the transaction starts

814
00:39:43,099 --> 00:39:44,990
the transaction coordinator will send

815
00:39:44,990 --> 00:39:47,420
out oh this is a message for transaction

816
00:39:47,420 --> 00:39:51,410
1995 and it'll keep all its state here

817
00:39:51,410 --> 00:39:52,579
about the transaction will be tagged

818
00:39:52,579 --> 00:39:57,050
with 95 and the various tables in the

819
00:39:57,050 --> 00:39:59,210
different participants in the

820
00:39:59,210 --> 00:40:01,609
transaction will be tagged with the

821
00:40:01,609 --> 00:40:04,040
transaction IDs and so that's another

822
00:40:04,040 --> 00:40:05,960
piece of terminology we got the

823
00:40:05,960 --> 00:40:07,910
transaction coordinator and then the

824
00:40:07,910 --> 00:40:11,569
other servers that are doing parts of

825
00:40:11,569 --> 00:40:15,700
the transaction are called participants

826
00:40:20,020 --> 00:40:21,380
all right

827
00:40:21,380 --> 00:40:24,589
so let me draw out the two-phase commit

828
00:40:24,589 --> 00:40:28,690
protocol example execution so this is

829
00:40:28,690 --> 00:40:32,390
abbreviate this to PC for two-phase

830
00:40:32,390 --> 00:40:37,599
commit the parties involved are the

831
00:40:37,599 --> 00:40:40,130
transaction coordinator and we'll just

832
00:40:40,130 --> 00:40:42,230
say there's two participants that is you

833
00:40:42,230 --> 00:40:43,160
know maybe we're executing the

834
00:40:43,160 --> 00:40:44,510
transactions I've shown next and why

835
00:40:44,510 --> 00:40:48,250
aren't different servers maybe we've got

836
00:40:48,250 --> 00:40:53,540
participant a and participant B these

837
00:40:53,540 --> 00:40:57,010
are two different servers holding data

838
00:40:57,010 --> 00:40:59,540
so the transaction coordinator it's

839
00:40:59,540 --> 00:41:01,099
running the whole transaction it's it's

840
00:41:01,099 --> 00:41:03,920
gonna send puts and gets to a and B to

841
00:41:03,920 --> 00:41:06,170
tell them to you know read the value of

842
00:41:06,170 --> 00:41:09,079
x or y or add one to X so we're going to

843
00:41:09,079 --> 00:41:11,109
see at the beginning of the tree

844
00:41:11,109 --> 00:41:12,849
action that the transaction coordinator

845
00:41:12,849 --> 00:41:15,309
is sending for example maybe a get

846
00:41:15,309 --> 00:41:19,239
requests to Trent participant a and it

847
00:41:19,239 --> 00:41:21,160
gets a reply and then maybe it sends

848
00:41:21,160 --> 00:41:27,970
that put for whatever I might see a long

849
00:41:27,970 --> 00:41:29,170
sequence of these if there's a

850
00:41:29,170 --> 00:41:33,759
complicated transaction then when

851
00:41:33,759 --> 00:41:35,410
transaction coordinator gets to the end

852
00:41:35,410 --> 00:41:38,259
of the transaction and wants to commit

853
00:41:38,259 --> 00:41:40,779
it and be able to you know release all

854
00:41:40,779 --> 00:41:42,130
those locks and make the transactions

855
00:41:42,130 --> 00:41:44,140
results visible to the outside world and

856
00:41:44,140 --> 00:41:47,289
maybe reply to a client or a human user

857
00:41:47,289 --> 00:41:49,569
so they were assuming there's a sort of

858
00:41:49,569 --> 00:41:52,480
external client or human that said oh

859
00:41:52,480 --> 00:41:54,160
please run this transaction and it's

860
00:41:54,160 --> 00:41:56,890
waiting for a response before we can do

861
00:41:56,890 --> 00:41:59,019
any of that the transaction coordinate

862
00:41:59,019 --> 00:42:02,079
coordinator has to make sure that all

863
00:42:02,079 --> 00:42:04,119
the different participants can actually

864
00:42:04,119 --> 00:42:07,329
do their part of the transaction and in

865
00:42:07,329 --> 00:42:08,950
particular if there were any puts in the

866
00:42:08,950 --> 00:42:11,440
transaction we need to make sure that

867
00:42:11,440 --> 00:42:14,230
the participants who are doing those

868
00:42:14,230 --> 00:42:16,059
puts well are actually still capable of

869
00:42:16,059 --> 00:42:19,509
doing the puts so in order to find that

870
00:42:19,509 --> 00:42:22,529
out the transaction coordinator sends

871
00:42:22,529 --> 00:42:32,009
prepare messages to all of the

872
00:42:32,009 --> 00:42:35,829
participants so we're going to send pair

873
00:42:35,829 --> 00:42:39,180
messages to both a and B

874
00:42:41,619 --> 00:42:44,599
and when a or B would receive a preparer

875
00:42:44,599 --> 00:42:45,650
message you know they know the

876
00:42:45,650 --> 00:42:47,329
transaction is nearing completion but

877
00:42:47,329 --> 00:42:49,089
not not over yet

878
00:42:49,089 --> 00:42:51,440
they look at their state and decide

879
00:42:51,440 --> 00:42:52,849
whether they are actually able to

880
00:42:52,849 --> 00:42:54,200
complete the transaction you know maybe

881
00:42:54,200 --> 00:42:56,119
they needed to abort it break a deadlock

882
00:42:56,119 --> 00:42:58,339
or maybe they've crashed and we started

883
00:42:58,339 --> 00:43:02,299
but between you know when they did the

884
00:43:02,299 --> 00:43:04,069
last operation are now and they've

885
00:43:04,069 --> 00:43:05,029
completely forgotten about the

886
00:43:05,029 --> 00:43:07,039
transaction and can't complete it so a

887
00:43:07,039 --> 00:43:08,690
and B you know look at their state and

888
00:43:08,690 --> 00:43:10,460
say oh I'm going to be able to or I'm

889
00:43:10,460 --> 00:43:11,809
not gonna be able to do this transaction

890
00:43:11,809 --> 00:43:18,910
and they respond with either yes or no

891
00:43:24,730 --> 00:43:28,730
so the transaction coordinator is

892
00:43:28,730 --> 00:43:31,880
waiting for these yes or no votes from

893
00:43:31,880 --> 00:43:35,329
each of the participants if they all say

894
00:43:35,329 --> 00:43:42,589
yes then the transaction can commit

895
00:43:42,589 --> 00:43:45,890
nothing goes wrong the transaction can

896
00:43:45,890 --> 00:43:47,839
commit and the transaction coordinator

897
00:43:47,839 --> 00:43:57,289
sends out a commit message to each of

898
00:43:57,289 --> 00:44:02,839
the participants and then the

899
00:44:02,839 --> 00:44:05,240
participants usually reply with an

900
00:44:05,240 --> 00:44:07,880
acknowledgement saying yes we now know

901
00:44:07,880 --> 00:44:10,990
the outcome this is called the echnology

902
00:44:10,990 --> 00:44:14,630
all right so they all transaction

903
00:44:14,630 --> 00:44:17,000
coordinator since I preparers if all the

904
00:44:17,000 --> 00:44:19,160
participants say yes it can commit if

905
00:44:19,160 --> 00:44:21,759
anyone in any of them even a single one

906
00:44:21,759 --> 00:44:24,289
says no actually I cannot complete this

907
00:44:24,289 --> 00:44:27,130
transaction because I had a failure or

908
00:44:27,130 --> 00:44:29,329
there was an inconsistency like a

909
00:44:29,329 --> 00:44:32,059
missing record and I have to abort even

910
00:44:32,059 --> 00:44:34,099
a single participant says no at this

911
00:44:34,099 --> 00:44:36,200
point then the transaction coordinator

912
00:44:36,200 --> 00:44:38,390
won't commit it'll send out a round of

913
00:44:38,390 --> 00:44:41,180
abort messages saying oops please

914
00:44:41,180 --> 00:44:47,380
retract this transaction either way the

915
00:44:47,380 --> 00:44:51,410
after the commit sort of to two things

916
00:44:51,410 --> 00:44:52,700
happen of interest to us

917
00:44:52,700 --> 00:44:54,440
one is the transaction coordinator will

918
00:44:54,440 --> 00:44:57,349
mint whatever the transactions output is

919
00:44:57,349 --> 00:44:59,420
to the client or human that requested it

920
00:44:59,420 --> 00:45:00,980
and say look oh yes the transactions

921
00:45:00,980 --> 00:45:03,250
finish and so now if it didn't abort a

922
00:45:03,250 --> 00:45:04,970
committed it's durable

923
00:45:04,970 --> 00:45:07,640
the other interesting thing is that in

924
00:45:07,640 --> 00:45:12,890
order to obey these locking rules the

925
00:45:12,890 --> 00:45:15,800
participants unlock when they see either

926
00:45:15,800 --> 00:45:23,240
commit or an abort and indeed in order

927
00:45:23,240 --> 00:45:27,170
to obey the two phase locking rule each

928
00:45:27,170 --> 00:45:32,420
participant locked any data that it read

929
00:45:32,420 --> 00:45:33,890
as part of doing its part of the

930
00:45:33,890 --> 00:45:35,990
transaction so we're imagining that in

931
00:45:35,990 --> 00:45:37,940
each participant there's a table of the

932
00:45:37,940 --> 00:45:40,369
locks associated with the data stored at

933
00:45:40,369 --> 00:45:43,010
that participant and the participant

934
00:45:43,010 --> 00:45:44,900
sort of lock things in those tables

935
00:45:44,900 --> 00:45:47,599
remember oh this is you know this piece

936
00:45:47,599 --> 00:45:49,040
of data this record is locked for

937
00:45:49,040 --> 00:45:51,230
transaction twenty nine and one finally

938
00:45:51,230 --> 00:45:52,819
the commit or abort comes back versions

939
00:45:52,819 --> 00:45:55,490
action twenty-nine the participant

940
00:45:55,490 --> 00:45:57,170
unlocks that data and then other

941
00:45:57,170 --> 00:45:59,540
transactions can use so we may have to

942
00:45:59,540 --> 00:46:02,750
wait here and this unlock may unblock

943
00:46:02,750 --> 00:46:06,140
other transactions that's really part of

944
00:46:06,140 --> 00:46:13,640
the serializability machinery so you

945
00:46:13,640 --> 00:46:14,839
know so far the reason why this is

946
00:46:14,839 --> 00:46:19,310
correct basically is that the if

947
00:46:19,310 --> 00:46:20,630
everybody's following this protocol

948
00:46:20,630 --> 00:46:23,480
there's no failures then the two

949
00:46:23,480 --> 00:46:25,280
participants only commit if both of them

950
00:46:25,280 --> 00:46:29,060
commit and if I them can't commit if

951
00:46:29,060 --> 00:46:30,859
I've them has to abort then they both

952
00:46:30,859 --> 00:46:33,230
abort so we get that either they all do

953
00:46:33,230 --> 00:46:36,380
it or none of them do it result that we

954
00:46:36,380 --> 00:46:40,790
wanted the atomicity result with this

955
00:46:40,790 --> 00:46:43,339
protocol so far without without thinking

956
00:46:43,339 --> 00:46:47,270
about failures and so now our job is to

957
00:46:47,270 --> 00:46:49,430
think through in our head all sort of

958
00:46:49,430 --> 00:46:50,510
the different kinds of failures that

959
00:46:50,510 --> 00:46:53,900
might occur and figure out whether the

960
00:46:53,900 --> 00:46:56,810
protocol still provides atomicity either

961
00:46:56,810 --> 00:46:59,720
both do it or neither do it in the face

962
00:46:59,720 --> 00:47:01,490
of these failures and how we have to

963
00:47:01,490 --> 00:47:05,300
adjust or extend the protocol in order

964
00:47:05,300 --> 00:47:07,579
to cause it to do the right thing so the

965
00:47:07,579 --> 00:47:08,239
first thing I want

966
00:47:08,239 --> 00:47:11,059
consider is what it be crashes and

967
00:47:11,059 --> 00:47:11,959
restarts

968
00:47:11,959 --> 00:47:15,739
I mean power failure or something be

969
00:47:15,739 --> 00:47:17,659
just some suddenly stops executing and

970
00:47:17,659 --> 00:47:20,269
then powers restored and it's brought

971
00:47:20,269 --> 00:47:22,309
back to life and run some maybe some

972
00:47:22,309 --> 00:47:26,359
sort of recovery software as part of the

973
00:47:26,359 --> 00:47:28,729
transaction processing system well

974
00:47:28,729 --> 00:47:32,059
there's really two scenarios we have to

975
00:47:32,059 --> 00:47:35,089
worry about one is B might have crashed

976
00:47:35,089 --> 00:47:41,169
before ascending it's yes message back

977
00:47:41,889 --> 00:47:44,719
so B crash before sending its yes

978
00:47:44,719 --> 00:47:48,559
message back then it never said yes so

979
00:47:48,559 --> 00:47:50,029
the transaction coordinator couldn't

980
00:47:50,029 --> 00:47:53,479
possibly have committed or be about to

981
00:47:53,479 --> 00:47:55,489
commit because it has to wait for a yes

982
00:47:55,489 --> 00:47:57,799
from all participants so if B can

983
00:47:57,799 --> 00:47:58,969
convince itself that it could not

984
00:47:58,969 --> 00:48:02,029
possibly have sent a yes back that is a

985
00:48:02,029 --> 00:48:04,069
crash before sending the yes then B is

986
00:48:04,069 --> 00:48:06,859
entitled to unilaterally abort the

987
00:48:06,859 --> 00:48:09,289
transaction itself and forget about it

988
00:48:09,289 --> 00:48:11,119
because it knows the transaction

989
00:48:11,119 --> 00:48:15,500
coordinator can't possibly commit it so

990
00:48:15,500 --> 00:48:18,159
[Music]

991
00:48:18,159 --> 00:48:19,969
there's you know a number of ways of

992
00:48:19,969 --> 00:48:21,619
implementing this one possibility is

993
00:48:21,619 --> 00:48:23,809
that all of these information about

994
00:48:23,809 --> 00:48:25,549
transactions that haven't reached this

995
00:48:25,549 --> 00:48:27,979
point is in memory and it simply lost it

996
00:48:27,979 --> 00:48:30,079
B crashes and reboots so B just won't

997
00:48:30,079 --> 00:48:31,939
know anything about transactions that

998
00:48:31,939 --> 00:48:35,179
haven't haven't sent yes back yet and

999
00:48:35,179 --> 00:48:37,099
then if the transaction coordinator

1000
00:48:37,099 --> 00:48:39,649
sends a prepare message to a participant

1001
00:48:39,649 --> 00:48:41,119
that doesn't know anything about the

1002
00:48:41,119 --> 00:48:42,439
transaction because it crashed before

1003
00:48:42,439 --> 00:48:45,139
sending yes the the parties will say no

1004
00:48:45,139 --> 00:48:47,959
no I cannot possibly agree to that you

1005
00:48:47,959 --> 00:48:50,829
know please abort

1006
00:48:51,489 --> 00:48:55,099
okay but of course maybe B crashed after

1007
00:48:55,099 --> 00:49:00,589
sending a yes back so that's a little

1008
00:49:00,589 --> 00:49:02,509
more tricky so wasn't in the crash

1009
00:49:02,509 --> 00:49:05,479
this wasn't a B gets a prepare its it's

1010
00:49:05,479 --> 00:49:07,189
happy it says yes I'm going to commit

1011
00:49:07,189 --> 00:49:09,739
and then it crashes before it gets the

1012
00:49:09,739 --> 00:49:12,049
commit message from the transaction

1013
00:49:12,049 --> 00:49:14,599
employer coordinator well now we had

1014
00:49:14,599 --> 00:49:16,789
we're in a totally different situation B

1015
00:49:16,789 --> 00:49:19,329
is promised to commit if told to do so

1016
00:49:19,329 --> 00:49:21,770
because the send a yes back and for all

1017
00:49:21,770 --> 00:49:23,360
knows and indeed the most likely thing

1018
00:49:23,360 --> 00:49:24,530
that's happening is the transaction

1019
00:49:24,530 --> 00:49:26,960
coordinator got yeses from a and B and a

1020
00:49:26,960 --> 00:49:28,670
sent a commit message to a so that a

1021
00:49:28,670 --> 00:49:31,100
actually will do its part of the

1022
00:49:31,100 --> 00:49:32,660
transaction and make it permanent and

1023
00:49:32,660 --> 00:49:35,300
release locks and in that case in order

1024
00:49:35,300 --> 00:49:37,060
to honor all or nothing we're absolutely

1025
00:49:37,060 --> 00:49:39,860
required it B should crash at this point

1026
00:49:39,860 --> 00:49:42,530
that on recovery that it be still

1027
00:49:42,530 --> 00:49:44,660
prepared to complete its part of the

1028
00:49:44,660 --> 00:49:45,410
transaction

1029
00:49:45,410 --> 00:49:46,460
it doesn't actually know at that point

1030
00:49:46,460 --> 00:49:48,140
whether you know because it hasn't

1031
00:49:48,140 --> 00:49:50,030
received the committee ette and whether

1032
00:49:50,030 --> 00:49:51,110
it should commit or not but it must

1033
00:49:51,110 --> 00:49:53,210
still be prepared to commit and what

1034
00:49:53,210 --> 00:49:57,110
that means the fact that we can't lose

1035
00:49:57,110 --> 00:49:59,390
the state for a transaction across

1036
00:49:59,390 --> 00:50:01,790
crashes and reboots

1037
00:50:01,790 --> 00:50:07,580
is that before B replies to a prepare it

1038
00:50:07,580 --> 00:50:13,190
must make the transaction state this

1039
00:50:13,190 --> 00:50:14,780
sort of intermediate transaction state

1040
00:50:14,780 --> 00:50:16,400
the memory of all of the changes that's

1041
00:50:16,400 --> 00:50:17,960
made which may have to be undone if

1042
00:50:17,960 --> 00:50:20,240
there's an abort plus the record of all

1043
00:50:20,240 --> 00:50:22,040
the locks the transactions how it held

1044
00:50:22,040 --> 00:50:26,210
it must make that durable on disk in

1045
00:50:26,210 --> 00:50:28,400
between it's almost always in a log on

1046
00:50:28,400 --> 00:50:33,620
disk so before B replies yes before B

1047
00:50:33,620 --> 00:50:35,930
sends the s4 in reply to a prepare

1048
00:50:35,930 --> 00:50:39,680
message it first must write to disk in

1049
00:50:39,680 --> 00:50:42,020
its log all the information required to

1050
00:50:42,020 --> 00:50:44,330
commit that transaction that is all the

1051
00:50:44,330 --> 00:50:48,260
new values produced by put plus a full

1052
00:50:48,260 --> 00:50:51,230
list of locks on the disk or some other

1053
00:50:51,230 --> 00:50:53,750
persistent memory before applying with

1054
00:50:53,750 --> 00:50:55,880
yes and then if there should be if it

1055
00:50:55,880 --> 00:50:58,250
B's your crash after sanity yes that's

1056
00:50:58,250 --> 00:50:59,870
part of recovery when it restarts that a

1057
00:50:59,870 --> 00:51:01,670
look at his it's log and say oh gosh I

1058
00:51:01,670 --> 00:51:03,140
was in the middle of a transaction I had

1059
00:51:03,140 --> 00:51:06,290
replied yes for transaction 92 I mean

1060
00:51:06,290 --> 00:51:07,790
you know here's all the modifications it

1061
00:51:07,790 --> 00:51:09,410
should make if committed and all the

1062
00:51:09,410 --> 00:51:10,250
locks it held

1063
00:51:10,250 --> 00:51:13,760
I better restore that state and then

1064
00:51:13,760 --> 00:51:15,740
when he finally gets a commitment nor an

1065
00:51:15,740 --> 00:51:17,900
abort it'll know from having read its

1066
00:51:17,900 --> 00:51:20,210
log how to actually finish its part of

1067
00:51:20,210 --> 00:51:23,060
the transaction so so this is an

1068
00:51:23,060 --> 00:51:24,970
important thing I left out of the

1069
00:51:24,970 --> 00:51:29,510
original laying out of this protocol is

1070
00:51:29,510 --> 00:51:32,750
that B must write to its disk at this

1071
00:51:32,750 --> 00:51:34,230
point

1072
00:51:34,230 --> 00:51:36,510
and this is part of what makes two-phase

1073
00:51:36,510 --> 00:51:39,000
commit a little bit slow is that there's

1074
00:51:39,000 --> 00:51:41,040
these necessary persisting of

1075
00:51:41,040 --> 00:51:47,400
information here okay so we also have to

1076
00:51:47,400 --> 00:51:50,580
worry about okay and you know the final

1077
00:51:50,580 --> 00:51:51,900
place I guess where you might crash is

1078
00:51:51,900 --> 00:51:54,359
you might crash be my crashed after

1079
00:51:54,359 --> 00:51:58,250
receiving the commit or or after both

1080
00:51:58,250 --> 00:52:00,180
you might crash after actually

1081
00:52:00,180 --> 00:52:02,250
processing the commit and but in that

1082
00:52:02,250 --> 00:52:06,359
case it's made modifications that the

1083
00:52:06,359 --> 00:52:08,820
transaction means to make permanent in

1084
00:52:08,820 --> 00:52:12,109
its database presumably also on disk

1085
00:52:12,109 --> 00:52:15,150
before after it received a commit

1086
00:52:15,150 --> 00:52:16,950
message and in that case there's maybe

1087
00:52:16,950 --> 00:52:18,660
not anything to do if it restarts

1088
00:52:18,660 --> 00:52:20,600
because the transaction is finished so

1089
00:52:20,600 --> 00:52:23,850
when B receives the commit message it

1090
00:52:23,850 --> 00:52:28,070
probably writes the copies the

1091
00:52:28,070 --> 00:52:29,910
modifications from its log on to its

1092
00:52:29,910 --> 00:52:32,780
permanent storage releases this locks

1093
00:52:32,780 --> 00:52:34,710
erases the information about the

1094
00:52:34,710 --> 00:52:36,180
transaction of months log and then

1095
00:52:36,180 --> 00:52:38,970
replies and of course we have to worry

1096
00:52:38,970 --> 00:52:40,859
about you know what if it receives a

1097
00:52:40,859 --> 00:52:43,680
commit message twice probably the right

1098
00:52:43,680 --> 00:52:45,840
thing to do is either for B to remember

1099
00:52:45,840 --> 00:52:48,600
about the transaction that takes memory

1100
00:52:48,600 --> 00:52:51,480
so it turns out that it B simply forgets

1101
00:52:51,480 --> 00:52:53,100
about committed transactions that it's

1102
00:52:53,100 --> 00:52:56,400
made durable on disk it can reply to a

1103
00:52:56,400 --> 00:52:58,740
repeated commit message if it doesn't

1104
00:52:58,740 --> 00:53:00,330
know anything about that transaction by

1105
00:53:00,330 --> 00:53:03,420
simply acknowledging it again and

1106
00:53:03,420 --> 00:53:04,950
that'll be an important a little bit

1107
00:53:04,950 --> 00:53:08,250
later on ok so that's the story of one

1108
00:53:08,250 --> 00:53:10,320
of the participants crashes at various

1109
00:53:10,320 --> 00:53:12,930
awkward points what about the

1110
00:53:12,930 --> 00:53:14,640
transaction coordinator it's also just a

1111
00:53:14,640 --> 00:53:16,470
single computer sorry you know if it

1112
00:53:16,470 --> 00:53:26,060
fails might be a problem okay so again

1113
00:53:26,060 --> 00:53:29,460
the critical where things start getting

1114
00:53:29,460 --> 00:53:32,730
critical is if any party might have

1115
00:53:32,730 --> 00:53:36,900
committed then we cannot forget about

1116
00:53:36,900 --> 00:53:39,359
that if any either of these participants

1117
00:53:39,359 --> 00:53:41,369
might have committed or if the

1118
00:53:41,369 --> 00:53:43,200
transaction coordinator might have

1119
00:53:43,200 --> 00:53:47,500
replied to the client then we cannot

1120
00:53:47,500 --> 00:53:50,830
have that transaction go away right if a

1121
00:53:50,830 --> 00:53:52,840
is committed but maybe its transaction

1122
00:53:52,840 --> 00:53:54,310
the coordinator sent out a commit

1123
00:53:54,310 --> 00:53:56,050
message to a but hadn't gotten around to

1124
00:53:56,050 --> 00:53:58,240
sending a commitment to be the crashes

1125
00:53:58,240 --> 00:53:59,770
at that point the transaction

1126
00:53:59,770 --> 00:54:02,560
coordinator must be prepared on restart

1127
00:54:02,560 --> 00:54:05,230
to resend the commit messages to make

1128
00:54:05,230 --> 00:54:08,290
sure that both parties know that the

1129
00:54:08,290 --> 00:54:14,710
transaction is committed so okay so you

1130
00:54:14,710 --> 00:54:16,090
know whether that matters depends on

1131
00:54:16,090 --> 00:54:17,140
where the transaction coordinator

1132
00:54:17,140 --> 00:54:20,050
crashes if the crash is before sending

1133
00:54:20,050 --> 00:54:21,910
commit messages it doesn't really matter

1134
00:54:21,910 --> 00:54:24,760
neither party if you know since the

1135
00:54:24,760 --> 00:54:26,620
transaction coordinator didn't send

1136
00:54:26,620 --> 00:54:29,140
commit messages before crashing it can

1137
00:54:29,140 --> 00:54:33,120
just abort the transaction and if either

1138
00:54:33,120 --> 00:54:35,290
participant asks about that transaction

1139
00:54:35,290 --> 00:54:36,670
because they you know see it's in their

1140
00:54:36,670 --> 00:54:38,320
log but they never got a commit message

1141
00:54:38,320 --> 00:54:40,570
the transaction coordinator can say I

1142
00:54:40,570 --> 00:54:41,230
don't know anything about that

1143
00:54:41,230 --> 00:54:43,270
transaction it must have been aborted

1144
00:54:43,270 --> 00:54:46,150
possibly due to a crash so that's what

1145
00:54:46,150 --> 00:54:47,680
happens if the transaction coordinator

1146
00:54:47,680 --> 00:54:50,350
crashes before the commit but if a

1147
00:54:50,350 --> 00:54:52,570
crashes after sending one or more

1148
00:54:52,570 --> 00:54:59,950
commits message then it cannot defends

1149
00:54:59,950 --> 00:55:02,170
action coordinator can't be allowed to

1150
00:55:02,170 --> 00:55:05,320
forget about the transaction and what

1151
00:55:05,320 --> 00:55:08,260
that means is that at this point when

1152
00:55:08,260 --> 00:55:09,700
that after the transaction coordinator

1153
00:55:09,700 --> 00:55:11,920
it's made its commit versus abort

1154
00:55:11,920 --> 00:55:13,690
decision on the basis of these yes/no

1155
00:55:13,690 --> 00:55:16,060
votes before sending out any commit

1156
00:55:16,060 --> 00:55:20,100
messages it must first write information

1157
00:55:20,100 --> 00:55:22,960
about the transaction to its login in

1158
00:55:22,960 --> 00:55:26,140
persistent storage like a disk that will

1159
00:55:26,140 --> 00:55:27,850
still be there if it crashes and

1160
00:55:27,850 --> 00:55:30,760
restarts so transaction coordinator

1161
00:55:30,760 --> 00:55:32,800
after receives a full set of yeses or

1162
00:55:32,800 --> 00:55:35,680
noes writes the outcome and the

1163
00:55:35,680 --> 00:55:38,020
transaction ID to its log on disk and

1164
00:55:38,020 --> 00:55:40,060
only then it starts to send out commit

1165
00:55:40,060 --> 00:55:41,920
messages and that way if a crash is at

1166
00:55:41,920 --> 00:55:45,640
any point maybe before its end the first

1167
00:55:45,640 --> 00:55:47,710
commit message or after its sent one or

1168
00:55:47,710 --> 00:55:49,570
maybe even after sent all of them if it

1169
00:55:49,570 --> 00:55:51,640
crashes that point its recovery software

1170
00:55:51,640 --> 00:55:53,980
will see in the log AHA which is in the

1171
00:55:53,980 --> 00:55:55,630
middle of a transaction the transaction

1172
00:55:55,630 --> 00:55:57,880
was either known to have been committed

1173
00:55:57,880 --> 00:55:59,470
or aborted

1174
00:55:59,470 --> 00:56:01,590
and as part of recovery it will resend

1175
00:56:01,590 --> 00:56:04,349
commit messages to all the participants

1176
00:56:04,349 --> 00:56:06,940
or abort messages whatever the decision

1177
00:56:06,940 --> 00:56:10,420
was in case it hadn't sent them before

1178
00:56:10,420 --> 00:56:12,390
it crashed and that's one reason why the

1179
00:56:12,390 --> 00:56:14,520
participants have to be prepared to

1180
00:56:14,520 --> 00:56:24,540
receive duplicated commit messages okay

1181
00:56:27,450 --> 00:56:31,080
so there's some other so those are the

1182
00:56:31,080 --> 00:56:34,119
main crash stories we also have to worry

1183
00:56:34,119 --> 00:56:35,980
about what happens if messages are lost

1184
00:56:35,980 --> 00:56:37,510
in the network you might send a message

1185
00:56:37,510 --> 00:56:39,609
maybe the message never got there you

1186
00:56:39,609 --> 00:56:40,990
might send a message and be waiting for

1187
00:56:40,990 --> 00:56:44,470
a reply maybe the reply was sent but the

1188
00:56:44,470 --> 00:56:45,880
reply was dropped so any one of these

1189
00:56:45,880 --> 00:56:47,800
messages may be dropped and need to

1190
00:56:47,800 --> 00:56:52,030
think through what to actually do in

1191
00:56:52,030 --> 00:56:56,080
each of these cases so for example

1192
00:56:56,080 --> 00:56:57,490
supposing the transaction coordinator

1193
00:56:57,490 --> 00:57:00,040
sent out prepare messages but hasn't

1194
00:57:00,040 --> 00:57:02,260
gotten some of the yes or no replies

1195
00:57:02,260 --> 00:57:04,270
from participants what are the

1196
00:57:04,270 --> 00:57:06,070
transaction coordinators options at that

1197
00:57:06,070 --> 00:57:08,650
point well one thing I could do is send

1198
00:57:08,650 --> 00:57:11,680
out a new set of prepare messages saying

1199
00:57:11,680 --> 00:57:13,240
you know I didn't get your answer please

1200
00:57:13,240 --> 00:57:15,700
tell me your answer yes or no and you

1201
00:57:15,700 --> 00:57:17,020
know I could keep on doing that for a

1202
00:57:17,020 --> 00:57:20,320
while but if one of the partisans is

1203
00:57:20,320 --> 00:57:21,400
down for a long time we don't want to

1204
00:57:21,400 --> 00:57:24,970
sit there waiting with locks held right

1205
00:57:24,970 --> 00:57:27,130
because you know supposing a is

1206
00:57:27,130 --> 00:57:30,190
unresponsive but but B is up but because

1207
00:57:30,190 --> 00:57:31,960
that we haven't committed or aborted B

1208
00:57:31,960 --> 00:57:33,460
is still holding locks and that may

1209
00:57:33,460 --> 00:57:35,230
cause other transactions to be waiting

1210
00:57:35,230 --> 00:57:37,690
so we don't want to wait forever if we

1211
00:57:37,690 --> 00:57:39,849
can possibly avoid it so if the

1212
00:57:39,849 --> 00:57:41,530
transaction coordinator hasn't gotten

1213
00:57:41,530 --> 00:57:43,930
yes or no responses after some amount of

1214
00:57:43,930 --> 00:57:47,589
time from the participants then it can

1215
00:57:47,589 --> 00:57:49,810
simply unilaterally decide we're gonna

1216
00:57:49,810 --> 00:57:52,060
abort this transaction because it knows

1217
00:57:52,060 --> 00:57:54,099
since it didn't get a full set of yes or

1218
00:57:54,099 --> 00:57:55,750
no messages of course that can't

1219
00:57:55,750 --> 00:57:57,430
possibly have sent a commit yet so no

1220
00:57:57,430 --> 00:58:00,250
participant could have committed so it's

1221
00:58:00,250 --> 00:58:03,310
always valid to abort if the transaction

1222
00:58:03,310 --> 00:58:05,920
coordinator hasn't yet committed so the

1223
00:58:05,920 --> 00:58:07,089
transaction coordinator times out

1224
00:58:07,089 --> 00:58:09,099
waiting for yes or no x' this messages

1225
00:58:09,099 --> 00:58:11,109
were lost or somebody crashed or

1226
00:58:11,109 --> 00:58:12,150
something

1227
00:58:12,150 --> 00:58:13,410
it can just decide alright we're

1228
00:58:13,410 --> 00:58:15,270
aborting this transaction we'll send out

1229
00:58:15,270 --> 00:58:17,760
a round of abort messages and if some

1230
00:58:17,760 --> 00:58:19,200
participant comes back to life and says

1231
00:58:19,200 --> 00:58:21,270
oh you know I didn't hear back from you

1232
00:58:21,270 --> 00:58:25,680
about transaction 95 the transaction

1233
00:58:25,680 --> 00:58:26,789
coordinator will see you oh well I don't

1234
00:58:26,789 --> 00:58:28,200
know anything about transaction 95

1235
00:58:28,200 --> 00:58:30,809
because it aborted it and erased its

1236
00:58:30,809 --> 00:58:32,700
State for that transaction and it will

1237
00:58:32,700 --> 00:58:35,010
tell the participant you know you should

1238
00:58:35,010 --> 00:58:42,329
abort this transaction too similarly if

1239
00:58:42,329 --> 00:58:44,190
one of the participants times out

1240
00:58:44,190 --> 00:58:47,279
waiting for the preparer here then you

1241
00:58:47,279 --> 00:58:49,589
know for participant hasn't received a

1242
00:58:49,589 --> 00:58:51,539
preparer that means it hasn't send a yes

1243
00:58:51,539 --> 00:58:53,160
message back and that means the

1244
00:58:53,160 --> 00:58:54,900
coordinator can't possibly have sent any

1245
00:58:54,900 --> 00:58:55,799
commit messages

1246
00:58:55,799 --> 00:58:58,049
so if participant chimes out here

1247
00:58:58,049 --> 00:58:59,849
waiting for the preparer it's also

1248
00:58:59,849 --> 00:59:03,119
always allowed to just bail out and

1249
00:59:03,119 --> 00:59:05,400
decide to abort the transaction and if

1250
00:59:05,400 --> 00:59:07,079
it's some future time the transaction

1251
00:59:07,079 --> 00:59:09,210
coordinator comes back to life and sends

1252
00:59:09,210 --> 00:59:11,940
out preparer messages then B will say no

1253
00:59:11,940 --> 00:59:12,839
I don't know anything about that

1254
00:59:12,839 --> 00:59:15,270
transaction so I'm voting no and that's

1255
00:59:15,270 --> 00:59:16,859
okay because it can't possibly have

1256
00:59:16,859 --> 00:59:19,799
committed started to commit anywhere so

1257
00:59:19,799 --> 00:59:21,450
again if something goes wrong with the

1258
00:59:21,450 --> 00:59:22,799
network or the transaction coordinator

1259
00:59:22,799 --> 00:59:24,359
is down for a while

1260
00:59:24,359 --> 00:59:26,460
and the participants are still waiting

1261
00:59:26,460 --> 00:59:29,279
for prepares it's always valid for

1262
00:59:29,279 --> 00:59:31,020
participants to abort and thereby

1263
00:59:31,020 --> 00:59:32,549
release the locks that other

1264
00:59:32,549 --> 00:59:34,950
transactions may be waiting for and that

1265
00:59:34,950 --> 00:59:38,660
can be very important in a busy system

1266
00:59:39,589 --> 00:59:44,460
so that's the good news about if the

1267
00:59:44,460 --> 00:59:45,630
participants or the transaction

1268
00:59:45,630 --> 00:59:47,250
coordinators time out waiting for

1269
00:59:47,250 --> 00:59:52,819
messages from the other parties however

1270
00:59:52,819 --> 00:59:56,609
suppose participant B has received a

1271
00:59:56,609 --> 01:00:00,299
preparer and sent its yes and so is in

1272
01:00:00,299 --> 01:00:01,980
somewhere around here but it hasn't

1273
01:00:01,980 --> 01:00:03,510
received a commit and it's waiting and

1274
01:00:03,510 --> 01:00:05,099
waiting and it hasn't gotten to commit

1275
01:00:05,099 --> 01:00:06,750
back maybe something's wrong with the

1276
01:00:06,750 --> 01:00:08,730
network maybe the transaction

1277
01:00:08,730 --> 01:00:10,859
coordinator is its network connection

1278
01:00:10,859 --> 01:00:13,020
has fallen out or its powers failed or

1279
01:00:13,020 --> 01:00:14,640
something but for whatever reason B is

1280
01:00:14,640 --> 01:00:15,990
waited a long time and it still hasn't

1281
01:00:15,990 --> 01:00:18,150
heard a commit now but it's sitting

1282
01:00:18,150 --> 01:00:19,890
there holding locks is still holding on

1283
01:00:19,890 --> 01:00:21,599
to those locks for all the records that

1284
01:00:21,599 --> 01:00:22,650
were used and it's part of the

1285
01:00:22,650 --> 01:00:24,059
transaction and that means other

1286
01:00:24,059 --> 01:00:25,650
transactions may be also

1287
01:00:25,650 --> 01:00:27,660
blocked waiting for those locks to be

1288
01:00:27,660 --> 01:00:30,480
released so we're like pretty eager to a

1289
01:00:30,480 --> 01:00:32,940
border if we possibly can or release the

1290
01:00:32,940 --> 01:00:35,309
locks and so the question is if B has

1291
01:00:35,309 --> 01:00:37,890
received prepare and replied with yes

1292
01:00:37,890 --> 01:00:40,349
isn't entitle to unilaterally abort

1293
01:00:40,349 --> 01:00:42,960
after it's waited say you know 10

1294
01:00:42,960 --> 01:00:45,359
seconds or 10 minutes or something to

1295
01:00:45,359 --> 01:00:48,690
get the commit message and the answer to

1296
01:00:48,690 --> 01:00:54,180
that unfortunately is no in this region

1297
01:00:54,180 --> 01:00:56,760
after receiving the prepare we're out

1298
01:00:56,760 --> 01:00:58,950
really after sending the yes and before

1299
01:00:58,950 --> 01:01:01,740
getting the commit it's your time out

1300
01:01:01,740 --> 01:01:06,270
waiting for the commit you're not

1301
01:01:06,270 --> 01:01:08,160
allowed to abort you must keep waiting

1302
01:01:08,160 --> 01:01:12,240
you must usually called block so in this

1303
01:01:12,240 --> 01:01:14,250
region of the protocol if you don't

1304
01:01:14,250 --> 01:01:15,420
receive the commit you have to wait

1305
01:01:15,420 --> 01:01:17,930
indefinitely and the reason is that

1306
01:01:17,930 --> 01:01:21,539
since be sent back a yes that means the

1307
01:01:21,539 --> 01:01:22,950
transaction coordinator may have

1308
01:01:22,950 --> 01:01:24,539
received the yes it may have received

1309
01:01:24,539 --> 01:01:26,789
yes from all of the participants and it

1310
01:01:26,789 --> 01:01:28,260
may have started sending out commit

1311
01:01:28,260 --> 01:01:30,599
messages to some of the participants and

1312
01:01:30,599 --> 01:01:32,730
that means that a may have actually seen

1313
01:01:32,730 --> 01:01:34,140
the commit message and committed and

1314
01:01:34,140 --> 01:01:35,849
made us changes permanent and unlocked

1315
01:01:35,849 --> 01:01:37,470
and showing the changes to other

1316
01:01:37,470 --> 01:01:39,539
transactions and since that could be the

1317
01:01:39,539 --> 01:01:42,119
case for all B knows in this region of

1318
01:01:42,119 --> 01:01:44,490
the protocol B cannot unilaterally

1319
01:01:44,490 --> 01:01:47,039
decide to abort at the times out it must

1320
01:01:47,039 --> 01:01:49,950
wait indefinitely to hear from the

1321
01:01:49,950 --> 01:01:51,660
transaction coordinator as long as it

1322
01:01:51,660 --> 01:01:54,420
takes some human may have to come and

1323
01:01:54,420 --> 01:01:56,400
repair the transaction coordinator and

1324
01:01:56,400 --> 01:01:57,930
finally get it started again and have it

1325
01:01:57,930 --> 01:02:00,690
read this log and see oh yes you

1326
01:02:00,690 --> 01:02:02,400
committed that transaction and finally

1327
01:02:02,400 --> 01:02:13,619
send long delayed commit messages so and

1328
01:02:13,619 --> 01:02:23,880
similarly if on a time I you can't you

1329
01:02:23,880 --> 01:02:25,920
can't unilaterally abort it turns out

1330
01:02:25,920 --> 01:02:27,390
you can't unilaterally commit either

1331
01:02:27,390 --> 01:02:29,849
because for all B knows a might have

1332
01:02:29,849 --> 01:02:31,799
voted no but he just hasn't got the

1333
01:02:31,799 --> 01:02:33,539
important message yet so you could in

1334
01:02:33,539 --> 01:02:35,940
this region you can either abort nor

1335
01:02:35,940 --> 01:02:36,890
commit

1336
01:02:36,890 --> 01:02:44,000
on a timeout and so this actually this

1337
01:02:44,000 --> 01:02:47,870
this blocking behavior is sort of

1338
01:02:47,870 --> 01:02:51,070
critical property of two-phase commit

1339
01:02:51,070 --> 01:02:53,810
and it's not a happy property

1340
01:02:53,810 --> 01:02:56,780
it means if things go wrong you can

1341
01:02:56,780 --> 01:02:58,070
easily be in the situation where you

1342
01:02:58,070 --> 01:02:59,570
have to wait for a long time with locks

1343
01:02:59,570 --> 01:03:01,940
held and holding up other transactions

1344
01:03:01,940 --> 01:03:05,420
and so among other things people try

1345
01:03:05,420 --> 01:03:08,180
really hard to make this part of

1346
01:03:08,180 --> 01:03:10,730
two-phase commit acts as fast as humanly

1347
01:03:10,730 --> 01:03:13,520
possible so that the window of time in

1348
01:03:13,520 --> 01:03:17,060
which a failure might cause you to block

1349
01:03:17,060 --> 01:03:20,510
with locks held for a long time is as

1350
01:03:20,510 --> 01:03:22,040
small as possible so they try to make

1351
01:03:22,040 --> 01:03:23,300
this part of the protocol very

1352
01:03:23,300 --> 01:03:26,270
lightweight or even have variants of the

1353
01:03:26,270 --> 01:03:27,950
protocols that for certain special cases

1354
01:03:27,950 --> 01:03:33,590
may not have to wait at all okay so

1355
01:03:33,590 --> 01:03:37,430
that's the basic protocol one thing to

1356
01:03:37,430 --> 01:03:41,360
notice about this that is a fundamental

1357
01:03:41,360 --> 01:03:44,060
part of why we're able to get to

1358
01:03:44,060 --> 01:03:46,820
actually build a protocol that allows a

1359
01:03:46,820 --> 01:03:49,670
and B to sort of both you know they both

1360
01:03:49,670 --> 01:03:53,060
commit or they both have or abort one

1361
01:03:53,060 --> 01:03:54,770
reason for that is that really the

1362
01:03:54,770 --> 01:03:56,930
decision is made by a single entity it's

1363
01:03:56,930 --> 01:03:58,100
made by the transaction coordinator

1364
01:03:58,100 --> 01:04:01,640
alone a and B are neither of them you

1365
01:04:01,640 --> 01:04:05,150
know except that they vote no neither a

1366
01:04:05,150 --> 01:04:09,410
nor B is deciding whether to commit or

1367
01:04:09,410 --> 01:04:11,900
not and they certainly are not engaged

1368
01:04:11,900 --> 01:04:13,640
in a conversation with each other to try

1369
01:04:13,640 --> 01:04:15,500
to reach agreement about what is the

1370
01:04:15,500 --> 01:04:17,090
other thinking or they thinking commit

1371
01:04:17,090 --> 01:04:19,760
may be all commit to instead we have

1372
01:04:19,760 --> 01:04:22,640
this much is quite sort of fundamentally

1373
01:04:22,640 --> 01:04:25,610
simple protocol in which only the

1374
01:04:25,610 --> 01:04:27,050
transaction coordinator makes the

1375
01:04:27,050 --> 01:04:29,150
decision a single entity and it just

1376
01:04:29,150 --> 01:04:31,340
tells the other party here's my decision

1377
01:04:31,340 --> 01:04:38,390
please go do it the penalty for that for

1378
01:04:38,390 --> 01:04:39,790
having the transaction coordinator

1379
01:04:39,790 --> 01:04:42,200
really the single entity make the final

1380
01:04:42,200 --> 01:04:45,320
decision again is the fact that you have

1381
01:04:45,320 --> 01:04:46,700
to block there's some points in which

1382
01:04:46,700 --> 01:04:47,960
you have to block waiting for the

1383
01:04:47,960 --> 01:04:49,640
transaction recording coordinator to

1384
01:04:49,640 --> 01:04:50,630
tell you what the decision

1385
01:04:50,630 --> 01:04:58,009
was one further question is that we know

1386
01:04:58,009 --> 01:04:59,329
the transaction coordinator must

1387
01:04:59,329 --> 01:05:02,059
remember information about transactions

1388
01:05:02,059 --> 01:05:05,450
and its log in case it crashes and so

1389
01:05:05,450 --> 01:05:06,890
one question is when the transaction

1390
01:05:06,890 --> 01:05:10,039
coordinator can forget about information

1391
01:05:10,039 --> 01:05:11,779
in its log about transactions and the

1392
01:05:11,779 --> 01:05:14,029
answer to that is that if it manages to

1393
01:05:14,029 --> 01:05:16,400
get a full set of acknowledgments from

1394
01:05:16,400 --> 01:05:18,559
the participants then it knows that all

1395
01:05:18,559 --> 01:05:19,970
the participants know that that

1396
01:05:19,970 --> 01:05:22,250
transaction committed or aborted that

1397
01:05:22,250 --> 01:05:24,259
all the transactions no participants

1398
01:05:24,259 --> 01:05:25,819
knew the fate of that transaction and

1399
01:05:25,819 --> 01:05:27,559
have done their part in it and will

1400
01:05:27,559 --> 01:05:29,059
never need to know that information

1401
01:05:29,059 --> 01:05:31,160
right as they both acknowledged it so

1402
01:05:31,160 --> 01:05:33,349
when the transaction coordinator gets

1403
01:05:33,349 --> 01:05:35,150
acknowledgements it can erase all

1404
01:05:35,150 --> 01:05:39,430
information all memory the transaction

1405
01:05:39,519 --> 01:05:42,079
similarly participants once they

1406
01:05:42,079 --> 01:05:44,299
received a commit or abort message and

1407
01:05:44,299 --> 01:05:46,160
done their part of the transaction and

1408
01:05:46,160 --> 01:05:48,049
made their updates permanent and

1409
01:05:48,049 --> 01:05:50,329
released their locks at that point the

1410
01:05:50,329 --> 01:05:53,180
participants also can completely forget

1411
01:05:53,180 --> 01:05:57,589
about that transaction after they send

1412
01:05:57,589 --> 01:05:59,140
their acknowledgment back to the

1413
01:05:59,140 --> 01:06:01,880
transaction coordinator now of course

1414
01:06:01,880 --> 01:06:03,950
the transaction coordinator may not get

1415
01:06:03,950 --> 01:06:05,599
their acknowledgement and may send and

1416
01:06:05,599 --> 01:06:07,819
may therefore decide to resend the

1417
01:06:07,819 --> 01:06:09,349
commit message on the theory that maybe

1418
01:06:09,349 --> 01:06:11,569
it was lost and in that case a

1419
01:06:11,569 --> 01:06:13,039
participant if it receives a commit

1420
01:06:13,039 --> 01:06:14,960
message for a transaction which it know

1421
01:06:14,960 --> 01:06:16,940
nothing about because it's forgotten

1422
01:06:16,940 --> 01:06:21,410
about it then the participant can just

1423
01:06:21,410 --> 01:06:22,700
send another acknowledgement back

1424
01:06:22,700 --> 01:06:25,700
because it knows that it gets a commit

1425
01:06:25,700 --> 01:06:27,230
message for an unknown transaction it

1426
01:06:27,230 --> 01:06:28,579
must be because it had forgotten about

1427
01:06:28,579 --> 01:06:30,319
it because it already knew whether it

1428
01:06:30,319 --> 01:06:37,759
committed or aborted okay so that's

1429
01:06:37,759 --> 01:06:41,799
two-phase commit for atomic commitment

1430
01:06:41,799 --> 01:06:44,450
for a little perspective two-phase

1431
01:06:44,450 --> 01:06:47,960
commit is used in a lot of sharded

1432
01:06:47,960 --> 01:06:50,539
databases that have split up their data

1433
01:06:50,539 --> 01:06:54,049
among multiple servers and it's used

1434
01:06:54,049 --> 01:06:58,519
specifically in databases or storage

1435
01:06:58,519 --> 01:07:00,309
systems that need to support

1436
01:07:00,309 --> 01:07:03,319
transactions in which records in which

1437
01:07:03,319 --> 01:07:03,970
multiple

1438
01:07:03,970 --> 01:07:06,310
records may be read or written there's a

1439
01:07:06,310 --> 01:07:09,010
lot of some more specialized storage

1440
01:07:09,010 --> 01:07:12,640
systems that don't allow you to have

1441
01:07:12,640 --> 01:07:15,369
transactions on multiple records and for

1442
01:07:15,369 --> 01:07:17,140
them you don't need it you no need this

1443
01:07:17,140 --> 01:07:18,760
kind of you don't need two-phase commit

1444
01:07:18,760 --> 01:07:22,000
if the storage system doesn't allow

1445
01:07:22,000 --> 01:07:24,609
multi record transactions but if you

1446
01:07:24,609 --> 01:07:26,320
have multi record transactions and you

1447
01:07:26,320 --> 01:07:28,000
shard the data across multiple servers

1448
01:07:28,000 --> 01:07:30,160
then you need to support either

1449
01:07:30,160 --> 01:07:31,599
toothpaste you need to support two in

1450
01:07:31,599 --> 01:07:34,240
pace commit if you want to get asset

1451
01:07:34,240 --> 01:07:36,150
transactions

1452
01:07:36,150 --> 01:07:39,130
however two-phase commit has an evil

1453
01:07:39,130 --> 01:07:43,869
reputation one reason is it's slow due

1454
01:07:43,869 --> 01:07:45,490
to multiple rounds of messages there's a

1455
01:07:45,490 --> 01:07:48,270
lot of chitchat here in order to get a

1456
01:07:48,270 --> 01:07:50,560
transaction that involves multiple

1457
01:07:50,560 --> 01:07:53,619
participants to finish theirs in

1458
01:07:53,619 --> 01:07:55,300
addition a lot of disk writes both a and

1459
01:07:55,300 --> 01:07:58,390
B have to not just write data to their

1460
01:07:58,390 --> 01:08:01,119
disk between the prepare and the sending

1461
01:08:01,119 --> 01:08:02,619
of the yes they have to wait for that

1462
01:08:02,619 --> 01:08:04,840
disk rate to finish so certainly if

1463
01:08:04,840 --> 01:08:06,400
you're using a mechanical Drive that

1464
01:08:06,400 --> 01:08:09,130
takes 10 milliseconds to append to the

1465
01:08:09,130 --> 01:08:11,680
log that puts a real serious limit on

1466
01:08:11,680 --> 01:08:14,500
how fast participants can process

1467
01:08:14,500 --> 01:08:16,630
transactions you know 10 milliseconds a

1468
01:08:16,630 --> 01:08:19,719
pop means no without some cleverness

1469
01:08:19,719 --> 01:08:21,430
you're limited to 100 transactions per

1470
01:08:21,430 --> 01:08:23,859
second which is pretty slow and in

1471
01:08:23,859 --> 01:08:25,149
addition the transaction coordinator

1472
01:08:25,149 --> 01:08:28,810
also has a point in which it must after

1473
01:08:28,810 --> 01:08:30,969
it receives the last yes they must first

1474
01:08:30,969 --> 01:08:33,430
write to its log make sure the data is

1475
01:08:33,430 --> 01:08:35,799
safe on disk and only then is that

1476
01:08:35,799 --> 01:08:38,439
allowed to send that commit messages and

1477
01:08:38,439 --> 01:08:41,380
that's another 10 milliseconds and both

1478
01:08:41,380 --> 01:08:43,029
of these are 10 millisecond periods in

1479
01:08:43,029 --> 01:08:45,279
which locks are held in the participants

1480
01:08:45,279 --> 01:08:47,469
and other transactions are slowed up and

1481
01:08:47,469 --> 01:08:48,790
I keep mentioning that but it's very

1482
01:08:48,790 --> 01:08:51,310
important because in a busy transaction

1483
01:08:51,310 --> 01:08:53,020
processing system there's lots and lots

1484
01:08:53,020 --> 01:08:55,870
of transactions and many of them may be

1485
01:08:55,870 --> 01:08:57,729
waiting for the same data and we'd

1486
01:08:57,729 --> 01:09:01,120
really prefer not to hold locks over

1487
01:09:01,120 --> 01:09:02,890
long periods of time in which there's

1488
01:09:02,890 --> 01:09:04,988
lots of messages going back and forth

1489
01:09:04,988 --> 01:09:06,960
then we have to wait for long disgrace

1490
01:09:06,960 --> 01:09:09,819
but two-phase commit forces us to do

1491
01:09:09,819 --> 01:09:12,210
those weights

1492
01:09:13,569 --> 01:09:16,540
and a further problem with it is that if

1493
01:09:16,540 --> 01:09:18,189
anything goes wrong messages are lost

1494
01:09:18,189 --> 01:09:21,670
something crashes then if you're not if

1495
01:09:21,670 --> 01:09:23,560
you're a little bit unlucky then the

1496
01:09:23,560 --> 01:09:25,149
participants have to wait for long times

1497
01:09:25,149 --> 01:09:26,618
with locks held

1498
01:09:26,618 --> 01:09:30,399
so therefore to face commit you really

1499
01:09:30,399 --> 01:09:32,349
only see it within relatively small

1500
01:09:32,349 --> 01:09:34,210
domains within a single machine room

1501
01:09:34,210 --> 01:09:36,819
within a single organization you don't

1502
01:09:36,819 --> 01:09:39,670
see it for example did you transfers

1503
01:09:39,670 --> 01:09:42,219
between banks between different banks

1504
01:09:42,219 --> 01:09:44,399
you might possibly see it within a bank

1505
01:09:44,399 --> 01:09:47,349
if it's charted its database but you

1506
01:09:47,349 --> 01:09:48,939
would never see two days can it run

1507
01:09:48,939 --> 01:09:52,000
between distinct organizations that were

1508
01:09:52,000 --> 01:09:53,889
maybe physically separate because of

1509
01:09:53,889 --> 01:09:56,320
this blocking business you don't want to

1510
01:09:56,320 --> 01:09:58,900
put the fate of you know your database

1511
01:09:58,900 --> 01:10:00,610
and whether it's operational in the

1512
01:10:00,610 --> 01:10:02,980
hands of some other organization where

1513
01:10:02,980 --> 01:10:04,929
they crash at the wrong time you're

1514
01:10:04,929 --> 01:10:07,389
forced your database was forced to hold

1515
01:10:07,389 --> 01:10:12,730
locks for a long time and because it's

1516
01:10:12,730 --> 01:10:15,460
so slow also there's a lot a lot of

1517
01:10:15,460 --> 01:10:19,179
research has gone into either making it

1518
01:10:19,179 --> 01:10:21,969
fast or relaxing the rules in various

1519
01:10:21,969 --> 01:10:24,389
ways to allow to be faster or

1520
01:10:24,389 --> 01:10:27,520
specializing two-phase commit for very

1521
01:10:27,520 --> 01:10:31,179
specific situations in which you know

1522
01:10:31,179 --> 01:10:33,190
you can shave a message or write to the

1523
01:10:33,190 --> 01:10:34,570
disk or something off it because you

1524
01:10:34,570 --> 01:10:36,610
know you're only supporting a certain

1525
01:10:36,610 --> 01:10:39,070
limited kind of transaction so well

1526
01:10:39,070 --> 01:10:40,540
we'll see fair amount of this and the

1527
01:10:40,540 --> 01:10:45,699
rest of the course one question that

1528
01:10:45,699 --> 01:10:51,610
comes up a lot this exchange here where

1529
01:10:51,610 --> 01:10:53,560
you have a leader essentially and it

1530
01:10:53,560 --> 01:10:56,020
sends these messages to the followers

1531
01:10:56,020 --> 01:11:00,130
and you know we can only go forward if

1532
01:11:00,130 --> 01:11:02,020
the leader can only proceed if it

1533
01:11:02,020 --> 01:11:04,179
receives you know acknowledgments

1534
01:11:04,179 --> 01:11:07,750
replies from enough of the followers

1535
01:11:07,750 --> 01:11:11,320
this looks a lot like raft this

1536
01:11:11,320 --> 01:11:13,290
construction looks a lot like raft

1537
01:11:13,290 --> 01:11:17,050
however the properties of the protocol

1538
01:11:17,050 --> 01:11:18,699
and what you get out of it turn out to

1539
01:11:18,699 --> 01:11:20,920
be quite different from what we get out

1540
01:11:20,920 --> 01:11:24,429
of raft they solve very different

1541
01:11:24,429 --> 01:11:25,639
problems

1542
01:11:25,639 --> 01:11:28,619
so the way to think about it is that you

1543
01:11:28,619 --> 01:11:31,469
use raft to get high-availability by

1544
01:11:31,469 --> 01:11:34,469
replicating data on multiple

1545
01:11:34,469 --> 01:11:37,800
participants on multiple peers that is

1546
01:11:37,800 --> 01:11:39,420
the point of raft is to be able to

1547
01:11:39,420 --> 01:11:42,389
operate even though some of the server's

1548
01:11:42,389 --> 01:11:44,190
involved have crashed or are not

1549
01:11:44,190 --> 01:11:47,130
reachable and you can do this in raft

1550
01:11:47,130 --> 01:11:49,050
raft can do this because all the service

1551
01:11:49,050 --> 01:11:51,630
are doing the same thing they're doing

1552
01:11:51,630 --> 01:11:53,310
the same thing so we don't need all of

1553
01:11:53,310 --> 01:11:55,920
them to participate we only need a

1554
01:11:55,920 --> 01:12:00,389
majority two-phase commit however the

1555
01:12:00,389 --> 01:12:02,639
participants are not at all doing the

1556
01:12:02,639 --> 01:12:04,290
same thing the participants are each

1557
01:12:04,290 --> 01:12:05,849
doing a different part of the

1558
01:12:05,849 --> 01:12:07,679
transaction you know a maybe

1559
01:12:07,679 --> 01:12:10,260
incrementing record X and B maybe

1560
01:12:10,260 --> 01:12:13,349
decrementing record Y so two-phase

1561
01:12:13,349 --> 01:12:17,040
commit all the train all the participant

1562
01:12:17,040 --> 01:12:20,639
they all have to do their part in order

1563
01:12:20,639 --> 01:12:22,920
for the transaction to finish you really

1564
01:12:22,920 --> 01:12:24,480
need to wait for every single one of the

1565
01:12:24,480 --> 01:12:31,170
participants to do their thing so okay

1566
01:12:31,170 --> 01:12:34,230
so we got you know raft is replicating

1567
01:12:34,230 --> 01:12:35,969
doesn't need everybody to do their thing

1568
01:12:35,969 --> 01:12:37,080
two-phase commit

1569
01:12:37,080 --> 01:12:39,270
everybody's doing something different

1570
01:12:39,270 --> 01:12:42,050
that has to get done two-phase commit

1571
01:12:42,050 --> 01:12:44,790
does not help at all with availability

1572
01:12:44,790 --> 01:12:46,380
you know raft is all about availability

1573
01:12:46,380 --> 01:12:48,239
you can go on even if some of the

1574
01:12:48,239 --> 01:12:50,449
participants are not responding

1575
01:12:50,449 --> 01:12:54,000
two-phase commit is actually not at all

1576
01:12:54,000 --> 01:12:56,070
available it's not highly available at

1577
01:12:56,070 --> 01:12:58,349
all if anything goes wrong we risk

1578
01:12:58,349 --> 01:13:00,389
having to wait until that's repaired if

1579
01:13:00,389 --> 01:13:02,040
the transaction coordinator crashes at

1580
01:13:02,040 --> 01:13:03,690
the wrong time we simply have to wait

1581
01:13:03,690 --> 01:13:05,580
for to come up and read its log and send

1582
01:13:05,580 --> 01:13:08,159
out the commit messages right if if one

1583
01:13:08,159 --> 01:13:11,190
of these participants you know crashes

1584
01:13:11,190 --> 01:13:12,960
at the wrong time you know if we're

1585
01:13:12,960 --> 01:13:15,150
lucky we simply have to abort then we're

1586
01:13:15,150 --> 01:13:16,830
not lucky we have to say did you finish

1587
01:13:16,830 --> 01:13:19,409
that did you finish that so two-phase

1588
01:13:19,409 --> 01:13:21,060
commit is not at all about high

1589
01:13:21,060 --> 01:13:23,639
availability in fact it's it's a it's

1590
01:13:23,639 --> 01:13:25,650
quite low availability as such things go

1591
01:13:25,650 --> 01:13:28,820
any crash can hold up the whole system

1592
01:13:28,820 --> 01:13:33,570
and of course raft doesn't ensure that

1593
01:13:33,570 --> 01:13:36,630
all the participants do whatever the

1594
01:13:36,630 --> 01:13:38,190
operation is it only requires a majority

1595
01:13:38,190 --> 01:13:39,000
there may be

1596
01:13:39,000 --> 01:13:40,410
minority that totally didn't do the

1597
01:13:40,410 --> 01:13:42,960
operation at all and that's how the fact

1598
01:13:42,960 --> 01:13:44,760
that raft all the participants do the

1599
01:13:44,760 --> 01:13:46,290
same thing we don't have to wait for all

1600
01:13:46,290 --> 01:13:47,970
of them is why raft gets high

1601
01:13:47,970 --> 01:13:51,390
availability so these are quite

1602
01:13:51,390 --> 01:13:55,410
different protocols um it is however

1603
01:13:55,410 --> 01:13:58,050
possible to to usefully combine them

1604
01:13:58,050 --> 01:14:01,710
like two-phase commit is you know really

1605
01:14:01,710 --> 01:14:04,230
vulnerable to failures it's correct with

1606
01:14:04,230 --> 01:14:06,240
failures but it's not available with the

1607
01:14:06,240 --> 01:14:08,160
others so the question is could you

1608
01:14:08,160 --> 01:14:12,380
build some sort of combined system that

1609
01:14:12,380 --> 01:14:14,850
has the high availability of RAF to

1610
01:14:14,850 --> 01:14:19,080
replication but has two phase commits

1611
01:14:19,080 --> 01:14:21,570
ability to call as various different

1612
01:14:21,570 --> 01:14:23,280
parties each to do their part of the

1613
01:14:23,280 --> 01:14:25,230
transaction and the construction you

1614
01:14:25,230 --> 01:14:27,600
want actually is to use raft or paxos or

1615
01:14:27,600 --> 01:14:31,500
some other protocol like that to rep

1616
01:14:31,500 --> 01:14:33,840
individually replicate each of the

1617
01:14:33,840 --> 01:14:37,170
different parties so then we would for

1618
01:14:37,170 --> 01:14:39,000
this set up we would have like three

1619
01:14:39,000 --> 01:14:41,550
different clusters the transaction

1620
01:14:41,550 --> 01:14:43,200
coordinator would actually be replicated

1621
01:14:43,200 --> 01:14:50,720
service with you know three servers and

1622
01:14:50,720 --> 01:14:53,160
you know we'd run raft on these three

1623
01:14:53,160 --> 01:14:54,570
servers one will be elected as leader

1624
01:14:54,570 --> 01:14:56,760
they'd have replicated state they'd have

1625
01:14:56,760 --> 01:14:58,950
a log that helped them replicate we

1626
01:14:58,950 --> 01:15:00,780
don't only have to wait for a majority

1627
01:15:00,780 --> 01:15:02,280
the leader we'd only have to have a

1628
01:15:02,280 --> 01:15:04,860
minority of these to be up in order for

1629
01:15:04,860 --> 01:15:06,360
the transaction coordinator to do its

1630
01:15:06,360 --> 01:15:08,130
work and of course they would all and

1631
01:15:08,130 --> 01:15:10,590
you know sort of execute through the

1632
01:15:10,590 --> 01:15:12,480
various stages of the transaction and

1633
01:15:12,480 --> 01:15:16,680
the two-phase commit protocol by

1634
01:15:16,680 --> 01:15:19,500
basically by appending relevant records

1635
01:15:19,500 --> 01:15:21,390
to their logs and then each of the

1636
01:15:21,390 --> 01:15:25,080
participants would also be a cluster of

1637
01:15:25,080 --> 01:15:34,250
a rep our raft replicated cluster

1638
01:15:40,920 --> 01:15:43,930
so we would end up and they would chain

1639
01:15:43,930 --> 01:15:46,930
exchange messages back and forth you

1640
01:15:46,930 --> 01:15:49,320
know we'd send a commit message from the

1641
01:15:49,320 --> 01:15:51,220
replicated transaction coordinator

1642
01:15:51,220 --> 01:15:53,860
service to the replicated a server and

1643
01:15:53,860 --> 01:15:58,000
the replicated B server and this is you

1644
01:15:58,000 --> 01:15:59,140
know this is admittedly somewhat

1645
01:15:59,140 --> 01:16:01,690
elaborate but it does show you that you

1646
01:16:01,690 --> 01:16:03,580
can combine these ideas to get the

1647
01:16:03,580 --> 01:16:05,740
combination of high availability because

1648
01:16:05,740 --> 01:16:07,660
any one of these servers can crash and

1649
01:16:07,660 --> 01:16:09,880
the remaining two you keep operating

1650
01:16:09,880 --> 01:16:12,640
plus we get on this atomic commitment of

1651
01:16:12,640 --> 01:16:14,950
a and B are doing complete different

1652
01:16:14,950 --> 01:16:17,140
parts of the same transaction and we can

1653
01:16:17,140 --> 01:16:19,210
use two-phase commit to have the

1654
01:16:19,210 --> 01:16:21,130
transaction coordinator ensure that you

1655
01:16:21,130 --> 01:16:22,600
know that either both commit the whole

1656
01:16:22,600 --> 01:16:25,060
thing or they both abort their parts of

1657
01:16:25,060 --> 01:16:30,250
the transaction you'll actually build

1658
01:16:30,250 --> 01:16:33,370
something very much like this as part of

1659
01:16:33,370 --> 01:16:35,140
lab form which you will indeed build a

1660
01:16:35,140 --> 01:16:37,300
shard a database where each shard is

1661
01:16:37,300 --> 01:16:40,330
replicated in this form and there's a

1662
01:16:40,330 --> 01:16:42,340
basically a configuration manager which

1663
01:16:42,340 --> 01:16:45,940
will allow essentially transactional

1664
01:16:45,940 --> 01:16:48,820
shifting of chunks of shards of data

1665
01:16:48,820 --> 01:16:52,360
from one raft cluster to another under

1666
01:16:52,360 --> 01:16:55,660
the control of something that looks a

1667
01:16:55,660 --> 01:17:00,130
lot like a transaction coordinator so

1668
01:17:00,130 --> 01:17:05,920
lab 4 is like this and in addition in a

1669
01:17:05,920 --> 01:17:07,120
little bit we'll be reading a paper

1670
01:17:07,120 --> 01:17:08,680
called spanner which describes a

1671
01:17:08,680 --> 01:17:11,280
real-life database used by Google that

1672
01:17:11,280 --> 01:17:14,020
users also uses this construction in

1673
01:17:14,020 --> 01:17:16,900
order to do transactional writes to a

1674
01:17:16,900 --> 01:17:21,690
database all right thank you

