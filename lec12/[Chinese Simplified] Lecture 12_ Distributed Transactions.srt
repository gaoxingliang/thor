1
00:00:00,540 --> 00:00:03,510
好的，今天的主题是分布式

2
00:00:03,510 --> 00:00:15,509
事务，这些实际上是

3
00:00:15,509 --> 00:00:17,670
实现部分，这就是

4
00:00:17,670 --> 00:00:20,010
我将如何介绍它们的方式 第一个

5
00:00:20,010 --> 00:00:28,650
并发控制第二个是原子

6
00:00:28,650 --> 00:00:35,100
提交，分布式

7
00:00:35,100 --> 00:00:36,600
事务出现的原因是它对人们来说非常

8
00:00:36,600 --> 00:00:38,640
频繁 有

9
00:00:38,640 --> 00:00:41,100
大量数据最终将数据拆分或分片

10
00:00:41,100 --> 00:00:43,980
到许多不同的服务器上，

11
00:00:43,980 --> 00:00:45,570
所以如果您经营一家银行，

12
00:00:45,570 --> 00:00:49,320
例如，您一半

13
00:00:49,320 --> 00:00:51,420
客户的银行余额是一台服务器，

14
00:00:51,420 --> 00:00:53,040
而另一半的银行余额则在

15
00:00:53,040 --> 00:00:54,780
不同的服务器上 服务器让我们这样做，就像

16
00:00:54,780 --> 00:00:56,610
将负载分开处理负载

17
00:00:56,610 --> 00:01:00,810
和空间需求这也会出现在

18
00:01:00,810 --> 00:01:02,190
其他事情上也许你正在记录

19
00:01:02,190 --> 00:01:05,430
你知道的网站上文章的投票数

20
00:01:05,430 --> 00:01:07,380
也许有数

21
00:01:07,380 --> 00:01:08,880
百万篇文章一半的投票

22
00:01:08,880 --> 00:01:11,580
数 正在并且正在一台服务器上，

23
00:01:11,580 --> 00:01:15,510
一半的投票癌症或另一台，但某些

24
00:01:15,510 --> 00:01:18,510
操作需要修改或

25
00:01:18,510 --> 00:01:20,280
读取多个不同服务器上的数据

26
00:01:20,280 --> 00:01:21,659
rvers 因此，如果我们

27
00:01:21,659 --> 00:01:23,700
从一个客户向另一口井进行银行转账，

28
00:01:23,700 --> 00:01:25,440
他们的余额可能在不同的

29
00:01:25,440 --> 00:01:27,479
服务器上，因此为了完成

30
00:01:27,479 --> 00:01:29,490
余额，我们必须

31
00:01:29,490 --> 00:01:33,090
在两个不同的服务器上修改数据读取和写入数据，

32
00:01:33,090 --> 00:01:37,290
我们真的很喜欢 或一种构建

33
00:01:37,290 --> 00:01:39,299
这些系统的方法，我们将在课程后面看到其他

34
00:01:39,299 --> 00:01:40,619
构建

35
00:01:40,619 --> 00:01:43,680
系统的一种方法只是尝试隐藏

36
00:01:43,680 --> 00:01:46,020
将这些数据拆分到多个

37
00:01:46,020 --> 00:01:47,670
服务器的复杂性尝试对

38
00:01:47,670 --> 00:01:51,810
应用程序程序员隐藏它，这就像传统上一样

39
00:01:51,810 --> 00:01:53,909
 

40
00:01:53,909 --> 00:01:56,939
几十年来一直是数据库关注的问题，所以

41
00:01:56,939 --> 00:01:58,500
今天的很多材料都起源于

42
00:01:58,500 --> 00:02:00,840
数据库，但这些想法

43
00:02:00,840 --> 00:02:03,390
在分布式系统中得到了更广泛的应用

44
00:02:03,390 --> 00:02:04,650
，你不一定会

45
00:02:04,650 --> 00:02:09,508
像人们通常打包并发的方式那样称呼传统数据库

46
00:02:09,508 --> 00:02:13,019
 

47
00:02:13,019 --> 00:02:15,739
控制加

48
00:02:16,620 --> 00:02:23,260
原子提交在抽象中称为

49
00:02:23,260 --> 00:02:30,959
事务，我们之前见过

50
00:02:30,959 --> 00:02:33,940
，想法是你认识的程序员

51
00:02:33,940 --> 00:02:36,519
有一堆不同的操作

52
00:02:36,519 --> 00:02:37,890
可能在数据库中的不同记录上，

53
00:02:37,890 --> 00:02:40,690
他们希望所有这些操作成为

54
00:02:40,690 --> 00:02:43,599
一个单一的单元，而不是因

55
00:02:43,599 --> 00:02:45,730
故障或其他活动的观察而分裂，

56
00:02:45,730 --> 00:02:50,200
并且事务

57
00:02:50,200 --> 00:02:52,120
处理系统将要求

58
00:02:52,120 --> 00:02:53,860
程序员标记开始和

59
00:02:53,860 --> 00:02:56,260
结束

60
00:02:56,260 --> 00:02:58,569
 

61
00:02:58,569 --> 00:02:59,739
为了标记交易的开始和

62
00:02:59,739 --> 00:03:00,910
交易以及交易

63
00:03:00,910 --> 00:03:03,099
处理系统而进行的读写和更新操作序列肯定会

64
00:03:03,099 --> 00:03:05,620
为

65
00:03:05,620 --> 00:03:07,090
开始和结束之间发生的事情提供一定的保证

66
00:03:07,090 --> 00:03:07,660
 

67
00:03:07,660 --> 00:03:11,200
，例如，假设我们正在经营

68
00:03:11,200 --> 00:03:15,130
我们的银行和 我们想

69
00:03:15,130 --> 00:03:19,299
从用户 X 的帐户转移到用户范围的帐户，

70
00:03:19,299 --> 00:03:21,670
现在

71
00:03:21,670 --> 00:03:23,910
他们两个的余额都从 10 开始，所以最初

72
00:03:23,910 --> 00:03:30,000
公开 10 y 等于 10 和 x 和 y 我的

73
00:03:30,000 --> 00:03:35,560
意思是成为数据库中的记录和 我们

74
00:03:35,560 --> 00:03:38,049
想转账我们实际上会

75
00:03:38,049 --> 00:03:40,239
想象有两个交易

76
00:03:40,239 --> 00:03:41,739
可能同时运行

77
00:03:41,739 --> 00:03:44,829
一个从账户 X 向账户 Y 转账一美元，另一个

78
00:03:44,829 --> 00:03:47,019
她的交易

79
00:03:47,019 --> 00:03:49,989
对银行的所有账户进行审计，

80
00:03:49,989 --> 00:03:51,700
以确保银行中的总

81
00:03:51,700 --> 00:03:53,410
金额永远不会

82
00:03:53,410 --> 00:03:54,819
改变，因为毕竟如果你进行

83
00:03:54,819 --> 00:03:56,769
转账，你知道

84
00:03:56,769 --> 00:03:58,030
即使你在账户之间转移资金，总金额也不应该改变

85
00:03:58,030 --> 00:04:01,180
为了用事务表达这一点，

86
00:04:01,180 --> 00:04:04,720
我们可能有两个

87
00:04:04,720 --> 00:04:07,090
事务，第一个事务调用

88
00:04:07,090 --> 00:04:10,959
它 t1 是传输井标记，

89
00:04:10,959 --> 00:04:12,850
程序员

90
00:04:12,850 --> 00:04:13,959
应该用开始事务标记它的开始，在开始时

91
00:04:13,959 --> 00:04:17,978
一切正常

92
00:04:17,978 --> 00:04:21,220
，然后

93
00:04:21,220 --> 00:04:23,919
对这两个事务进行操作 数据库中两条记录的余额，

94
00:04:23,919 --> 00:04:25,550
因此我们可能会添加

95
00:04:25,550 --> 00:04:27,130
[音乐]

96
00:04:27,130 --> 00:04:34,100
一个可能会在余额 X 中添加一个并

97
00:04:34,100 --> 00:04:42,669
在 Y 中添加 -1 然后我们需要通过事务标记结束

98
00:04:42,669 --> 00:04:46,400
当前我们可能

99
00:04:46,400 --> 00:04:49,220
有一个事务将检查

100
00:04:49,220 --> 00:04:50,690
所有 余额 对所有

101
00:04:50,690 --> 00:04:52,820
余额进行审计 找到总和或查看所有

102
00:04:52,820 --> 00:04:54,380
余额 确保它们加起来的

103
00:04:54,380 --> 00:04:56,600
数字尽管转移也不会改变

104
00:04:56,600 --> 00:04:59,870
所以我正在考虑的第二笔交易

105
00:04:59,870 --> 00:05:04,570
审计交易

106
00:05:05,590 --> 00:05:07,940
我们还需要标记开始和

107
00:05:07,940 --> 00:05:13,430
结束这次我们只是在阅读有

108
00:05:13,430 --> 00:05:16,400
一个只读交易我们需要获取

109
00:05:16,400 --> 00:05:19,550
所有账户列表的当前余额

110
00:05:19,550 --> 00:05:21,320
他们现在只是这两个

111
00:05:21,320 --> 00:05:24,260
账户所以我们有两个临时

112
00:05:24,260 --> 00:05:27,910
变量 我们将阅读第一个，

113
00:05:27,910 --> 00:05:32,660
它将是余额 X 的值

114
00:05:32,660 --> 00:05:34,970
恰到好处 意味着我们正在阅读

115
00:05:34,970 --> 00:05:40,729
该记录 我们也阅读了 Y 并且我们将

116
00:05:40,729 --> 00:05:48,620
它们都打印出来，这就是

117
00:05:48,620 --> 00:05:55,700
交易的结束 问题是什么是

118
00:05:55,700 --> 00:05:57,200
合法的 这两个

119
00:05:57,200 --> 00:05:59,660
交易的结果是我们想要建立的第一件事

120
00:05:59,660 --> 00:06:01,400
是你知道什么

121
00:06:01,400 --> 00:06:03,620
给定起始状态，即

122
00:06:03,620 --> 00:06:06,020
十美元的两个余额，以及

123
00:06:06,020 --> 00:06:07,669
在你同时运行这两个交易之后可能是什么最终结果

124
00:06:07,669 --> 00:06:09,169
 

125
00:06:09,169 --> 00:06:12,050
所以 我们需要一个关于

126
00:06:12,050 --> 00:06:14,660
什么是正确的概念，一旦我们知道

127
00:06:14,660 --> 00:06:17,330
我们需要能够构建

128
00:06:17,330 --> 00:06:18,680
能够真正执行

129
00:06:18,680 --> 00:06:23,060
这些事务的机器，

130
00:06:23,060 --> 00:06:25,390
并且尽管并发和

131
00:06:25,390 --> 00:06:28,190
失败，所以首先什么是正确性，

132
00:06:28,190 --> 00:06:33,350
数据库通常有一个正确性的概念，

133
00:06:33,350 --> 00:06:36,580
称为酸

134
00:06:38,110 --> 00:06:44,919
或 bb-8 是酸，它代表原子

135
00:06:44,919 --> 00:06:48,770
，这意味着具有多个步骤的事务

136
00:06:48,770 --> 00:06:49,820
 

137
00:06:49,820 --> 00:06:50,960
可能会写入多个不同的

138
00:06:50,960 --> 00:06:53,090
记录，如果失败，尽管

139
00:06:53,090 --> 00:06:55,940
失败 所有的权利都

140
00:06:55,940 --> 00:06:58,370
应该完成或者一个都不做 不应该是

141
00:06:58,370 --> 00:07:00,080
 

142
00:07:00,080 --> 00:07:01,400
在事务中间的尴尬时间失败

143
00:07:01,400 --> 00:07:04,340
应该让一半的更新完成

144
00:07:04,340 --> 00:07:06,530
不可见，一半的更新从未

145
00:07:06,530 --> 00:07:16,160
完成它是全部或全无所以这个 是与否，

146
00:07:16,160 --> 00:07:25,400
尽管失败，C代表

147
00:07:25,400 --> 00:07:32,000
一致实际上我们

148
00:07:32,000 --> 00:07:35,840
不会担心这通常

149
00:07:35,840 --> 00:07:38,030
意味着数据库将

150
00:07:38,030 --> 00:07:40,460
强制执行应用程序声明的某些不变量这一

151
00:07:40,460 --> 00:07:43,610
事实今天并不是我们真正

152
00:07:43,610 --> 00:07:45,380
关心的问题，尽管它相当

153
00:07:45,380 --> 00:07:49,389
重要的是它通常代表隔离

154
00:07:49,389 --> 00:07:52,340
，这实际上是

155
00:07:52,340 --> 00:07:54,830
两个同时运行的事务是否

156
00:07:54,830 --> 00:07:56,360
可以互相看到的属性'  s

157
00:07:56,360 --> 00:07:58,610
在事务完成之前发生变化，

158
00:07:58,610 --> 00:08:00,440
无论他们是否可以看到

159
00:08:00,440 --> 00:08:02,630
某种中间更新以及来自

160
00:08:02,630 --> 00:08:06,229
另一个事务的中间，而

161
00:08:06,229 --> 00:08:11,360
您的目标是否定的，并且

162
00:08:11,360 --> 00:08:14,030
大多数

163
00:08:14,030 --> 00:08:17,539
人通常所说的隔离的

164
00:08:17,539 --> 00:08:19,280
那种技术特定的事情是事务执行是可

165
00:08:19,280 --> 00:08:21,139
序列化的 我会稍微解释一下这意味着什么，

166
00:08:21,139 --> 00:08:27,669
但归结为

167
00:08:27,669 --> 00:08:29,630
事务看不到彼此的

168
00:08:29,630 --> 00:08:32,089
更改，看不到中间状态

169
00:08:32,089 --> 00:08:34,909
，只能看到完整的事务结果

170
00:08:34,909 --> 00:08:38,830
，最后的 D 代表持久

171
00:08:39,969 --> 00:08:42,610
，这意味着在事务

172
00:08:42,610 --> 00:08:44,800
提交之后 在客户端或

173
00:08:44,800 --> 00:08:46,360
提交事务的任何程序

174
00:08:46,360 --> 00:08:49,000
从数据库得到回复后

175
00:08:49,000 --> 00:08:49,839
说是的，

176
00:08:49,839 --> 00:08:52,769
你知道我们已经执行了你的事务

177
00:08:52,769 --> 00:08:56,560
，酸中的 D 意味着

178
00:08:56,560 --> 00:08:58,689
事务修改数据库

179
00:08:58,689 --> 00:08:59,949
将是持久的，它们仍然会在

180
00:08:59,949 --> 00:09:02,620
那里，他们赢了 '不会因

181
00:09:02,620 --> 00:09:06,189
某种故障而被擦除，实际上这

182
00:09:06,189 --> 00:09:08,199
意味着必须将内容写入

183
00:09:08,199 --> 00:09:10,240
某些非易失性存储中 nt

184
00:09:10,240 --> 00:09:13,540
storage 就像磁盘一样，所以今天

185
00:09:13,540 --> 00:09:16,029
你实际上是整个课程的真正

186
00:09:16,029 --> 00:09:18,660
关注点是

187
00:09:18,660 --> 00:09:21,220
关于故障的良好行为 尊重

188
00:09:21,220 --> 00:09:25,509
 

189
00:09:25,509 --> 00:09:28,720
来自多个并行

190
00:09:28,720 --> 00:09:31,120
活动的其他良好行为，并确保数据

191
00:09:31,120 --> 00:09:35,139
在那里 即使某些事情崩溃了，他们仍然在追求，

192
00:09:35,139 --> 00:09:40,660
 

193
00:09:40,660 --> 00:09:42,430
所以对我们来说最有趣的部分是

194
00:09:42,430 --> 00:09:44,949
隔离或可序列化的冰的具体定义，

195
00:09:44,949 --> 00:09:48,879
所以

196
00:09:48,879 --> 00:09:51,459
在讨论它如何

197
00:09:51,459 --> 00:09:52,930
实际应用于这些事务之前，我将先阐述它，

198
00:09:52,930 --> 00:10:03,639
所以 ioan 隔离通常是，

199
00:10:03,639 --> 00:10:06,910
如果一组

200
00:10:06,910 --> 00:10:10,329
事务同时执行，您

201
00:10:10,329 --> 00:10:12,189
或多或少地

202
00:10:12,189 --> 00:10:16,720
同时知道它们是结果集，并且

203
00:10:16,720 --> 00:10:19,180
这里的结果指的

204
00:10:19,180 --> 00:10:21,879
是由事务可能执行的任何修改创建的新数据库记录

205
00:10:21,879 --> 00:10:23,709
 

206
00:10:23,709 --> 00:10:26,829
此外，

207
00:10:26,829 --> 00:10:28,930
交易产生的任何输出，因此

208
00:10:28,930 --> 00:10:30,970
这两个增加的交易更广泛，因为他们

209
00:10:30,970 --> 00:10:32,410
改变记录他们的需求改变

210
00:10:32,410 --> 00:10:34,480
记录是结果的一部分，

211
00:10:34,480 --> 00:10:35,769
这个打印语句的输出

212
00:10:35,769 --> 00:10:38,319
是结果的一部分，所以可

213
00:10:38,319 --> 00:10:42,430
序列化的定义说，

214
00:10:42,430 --> 00:10:44,850
 

215
00:10:47,250 --> 00:10:55,709
如果存在某种事务执行顺序，结果是可序列化

216
00:10:55,709 --> 00:11:20,610
的，所以我们要说一个

217
00:11:20,610 --> 00:11:23,220
特定的执行并行并发

218
00:11:23,220 --> 00:11:24,930
执行

219
00:11:24,930 --> 00:11:28,139
如果存在一些

220
00:11:28,139 --> 00:11:31,430
真正强调串行的

221
00:11:31,430 --> 00:11:34,079
串行顺序，则

222
00:11:34,079 --> 00:11:37,110
事务是可序列化的

223
00:11:37,110 --> 00:11:39,000
 

224
00:11:39,000 --> 00:11:40,139
 

225
00:11:40,139 --> 00:11:41,189
 

226
00:11:41,189 --> 00:11:46,470
但是它

227
00:11:46,470 --> 00:11:48,839
需要一次产生与执行相同事务的结果相同的结果

228
00:11:48,839 --> 00:11:49,470
 

229
00:11:49,470 --> 00:11:52,559
，

230
00:11:52,559 --> 00:11:54,629
因此检查

231
00:11:54,629 --> 00:11:56,449
执行是否可序列化的方式是否某些

232
00:11:56,449 --> 00:11:59,040
并发执行可序列化

233
00:11:59,040 --> 00:12:01,139
是查看结果并查看

234
00:12:01,139 --> 00:12:03,720
是否可以找到一些 一次

235
00:12:03,720 --> 00:12:06,029
执行相同的交易

236
00:12:06,029 --> 00:12:09,180
，产生相同的结果，所以对于我们的

237
00:12:09,180 --> 00:12:14,040
交易 n 在

238
00:12:14,040 --> 00:12:16,139
这里只有两个订单 一次只有两个

239
00:12:16,139 --> 00:12:19,110
串行订单可用 事务 1

240
00:12:19,110 --> 00:12:22,170
然后是事务 2 或事务 2 然后是

241
00:12:22,170 --> 00:12:25,889
事务 1 ，所以我们可以看看

242
00:12:25,889 --> 00:12:27,509
如果

243
00:12:27,509 --> 00:12:29,490
在每个中一次执行一个它们会产生的结果 这些

244
00:12:29,490 --> 00:12:34,910
命令所以如果我们执行 t1 然后 t2

245
00:12:34,910 --> 00:12:41,839
那么我们得到 x 等于 11

246
00:12:42,240 --> 00:12:46,600
为什么等于 9 和这个 print 语句

247
00:12:46,600 --> 00:12:49,750
因为 t1 首先执行这个 print

248
00:12:49,750 --> 00:12:51,970
语句看到这两个更新的值

249
00:12:51,970 --> 00:12:58,690
，所以它会打印字符串 11 9

250
00:12:58,690 --> 00:13:01,900
另一个可能的顺序是 也许 t2

251
00:13:01,900 --> 00:13:06,279
先运行然后 t1 并且在这种情况下

252
00:13:06,279 --> 00:13:09,070
t2 会在修改之前看到 2 条记录，

253
00:13:09,070 --> 00:13:11,980
但是修改

254
00:13:11,980 --> 00:13:14,830
仍然会发生，因为 t1 运行较晚，

255
00:13:14,830 --> 00:13:16,750
所以最终结果将再次是 x 等于

256
00:13:16,750 --> 00:13:22,450
11 y 等于 9 但这次 t2 被破坏了

257
00:13:22,450 --> 00:13:27,600
在我们的值之前，所以这是

258
00:13:27,600 --> 00:13:33,100
可序列化的两个合法结果，如果

259
00:13:33,100 --> 00:13:34,480
我们从同时运行

260
00:13:34,480 --> 00:13:36,130
这两个事务中看到任何其他结果，

261
00:13:36,130 --> 00:13:38,110
我们就会知道数据库正在

262
00:13:38,110 --> 00:13:39,870
运行 提供可

263
00:13:39,870 --> 00:13:42,130
序列化的执行，它正在做

264
00:13:42,130 --> 00:13:45,820
其他事情，所以当我们

265
00:13:45,820 --> 00:13:48,820
考虑如果会发生什么或

266
00:13:48,820 --> 00:13:50,560
如果总是违反这些 AHA 会发生什么，

267
00:13:50,560 --> 00:13:52,900
这是仅有的两个

268
00:13:52,900 --> 00:13:55,180
合法结果，我们最好做

269
00:13:55,180 --> 00:13:56,910
一些产生其中一个或另一个的事情，

270
00:13:56,910 --> 00:13:59,890
这很有趣 请注意，

271
00:13:59,890 --> 00:14:02,950
 

272
00:14:02,950 --> 00:14:04,900
根据您的实际订单，可能的结果不止一个，如果您

273
00:14:04,900 --> 00:14:06,430
同时提交这两个交易，

274
00:14:06,430 --> 00:14:08,020
您不知道

275
00:14:08,020 --> 00:14:11,980
是 t1 t2 还是 t2 t1，所以您

276
00:14:11,980 --> 00:14:13,779
必须愿意期待超过 一个

277
00:14:13,779 --> 00:14:15,310
可能的法律结果，并且当您有

278
00:14:15,310 --> 00:14:16,630
更多或同时运行的交易

279
00:14:16,630 --> 00:14:18,459
更复杂时，

280
00:14:18,459 --> 00:14:20,709
可能有许多可能的不同

281
00:14:20,709 --> 00:14:22,810
正确结果都是可

282
00:14:22,810 --> 00:14:25,930
序列化的，因为这里有许多订单

283
00:14:25,930 --> 00:14:28,600
可以用来满足这个

284
00:14:28,600 --> 00:14:34,029
要求，所以现在我们有一个

285
00:14:34,029 --> 00:14:35,560
正确性的定义，我们甚至

286
00:14:35,560 --> 00:14:37,660
知道所有可能的结果是什么，

287
00:14:37,660 --> 00:14:42,400
我们可以问几个问题，

288
00:14:42,400 --> 00:14:44,560
关于这些如何可能的假设问题很少

289
00:14:44,560 --> 00:14:48,610
xecute 例如假设

290
00:14:48,610 --> 00:14:50,980
系统实际执行的方式

291
00:14:50,980 --> 00:14:53,260
是它开始事务 2 并

292
00:14:53,260 --> 00:14:55,069
 

293
00:14:55,069 --> 00:14:58,180
在读取 X 之后

294
00:14:58,180 --> 00:15:03,559
一直到达，然后事务 1 在此时运行，

295
00:15:03,559 --> 00:15:05,350
然后在事务 1 完成

296
00:15:05,350 --> 00:15:11,569
事务后继续执行现在

297
00:15:11,569 --> 00:15:13,819
结果 与其他不同的

298
00:15:13,819 --> 00:15:15,439
交易可能

299
00:15:15,439 --> 00:15:18,259
实际上是合法的，但在这里我们想

300
00:15:18,259 --> 00:15:20,509
知道它是否合法，所以我们想知道

301
00:15:20,509 --> 00:15:22,279
天哪，如果我们真的以这种方式执行，

302
00:15:22,279 --> 00:15:23,749
我们会得到什么结果，

303
00:15:23,749 --> 00:15:27,350
它们是否与这两个中的任何一个相同如果

304
00:15:27,350 --> 00:15:29,629
我们在这里执行事务一，然后

305
00:15:29,629 --> 00:15:32,509
t1 将看到值 10 t2 将看到

306
00:15:32,509 --> 00:15:35,990
递减 Y 后的值，因此 t1

307
00:15:35,990 --> 00:15:38,749
将是 10 t2 将是 9 并且这个

308
00:15:38,749 --> 00:15:42,290
打印将是 10 9 并且

309
00:15:42,290 --> 00:15:45,439
这两个输出都不是这里所以这意味着

310
00:15:45,439 --> 00:15:47,179
执行 以这种方式，我刚刚画

311
00:15:47,179 --> 00:15:49,369
的不是可序列化的，这将是不

312
00:15:49,369 --> 00:15:55,059
合法的另一个有趣的问题

313
00:15:55,059 --> 00:15:57,860
是，如果我们开始执行事务

314
00:15:57,860 --> 00:15:59,629
1，我们就在

315
00:15:59,629 --> 00:16:02,420
第一个广告之后，然后 那时，所有

316
00:16:02,420 --> 00:16:08,720
交易 2 都在此处执行

317
00:16:08,720 --> 00:16:10,939
，这意味着此时 X 是值

318
00:16:10,939 --> 00:16:17,870
11 交易 2 将读取 1110 现在

319
00:16:17,870 --> 00:16:20,179
打印 1110 并且 1110 不是这

320
00:16:20,179 --> 00:16:22,189
两个合法值之一，因此此执行

321
00:16:22,189 --> 00:16:23,749
对于这两个也是不合法的

322
00:16:23,749 --> 00:16:26,589
事务，

323
00:16:35,510 --> 00:16:39,350
所以可序列

324
00:16:39,350 --> 00:16:43,110
化的可序列化性是一个流行且有用的

325
00:16:43,110 --> 00:16:44,840
定义，说明

326
00:16:44,840 --> 00:16:47,280
事务正确

327
00:16:47,280 --> 00:16:48,930
对于事务执行正确意味着

328
00:16:48,930 --> 00:16:51,030
什么，它对程序员来说是一个非常简单的模型，

329
00:16:51,030 --> 00:16:53,220
您可以编写复杂的事务，

330
00:16:53,220 --> 00:16:56,190
而不必担心还有什么

331
00:16:56,190 --> 00:16:57,990
可能正在系统中运行 可能

332
00:16:57,990 --> 00:16:59,370
有许多其他事务可能正在

333
00:16:59,370 --> 00:17:00,870
使用与您可能正在阅读的日期相同的日期

334
00:17:00,870 --> 00:17:02,610
尝试同时读取和写入它

335
00:17:02,610 --> 00:17:04,800
可能会出现故障

336
00:17:04,800 --> 00:17:10,319
谁知道但这里的保证是

337
00:17:10,319 --> 00:17:12,869
它是安全的写入 您的交易就

338
00:17:12,869 --> 00:17:15,689
好像没有发生任何其他事情一样，

339
00:17:15,689 --> 00:17:19,560
因为最终结果必须就像您的

340
00:17:19,560 --> 00:17:22,319
交易是

341
00:17:22,319 --> 00:17:24,540
按照一次一次的顺序自己执行的那样 ch 是一个非常

342
00:17:24,540 --> 00:17:28,020
简单非常好的编程模型

343
00:17:28,020 --> 00:17:31,590
，这个定义允许

344
00:17:31,590 --> 00:17:34,410
真正并行执行事务也很好，

345
00:17:34,410 --> 00:17:36,420
只要它们不使用相同的数据，

346
00:17:36,420 --> 00:17:38,010
所以我们在这里遇到了麻烦，因为

347
00:17:38,010 --> 00:17:39,720
这两个事务都在读取

348
00:17:39,720 --> 00:17:41,370
x 和 y 但是如果 他们使用

349
00:17:41,370 --> 00:17:44,070
完全不相交的数据库记录

350
00:17:44,070 --> 00:17:46,170
他们可以 事实证明，这个定义

351
00:17:46,170 --> 00:17:48,840
允许您构建一个数据库系统

352
00:17:48,840 --> 00:17:51,840
，该系统将执行事务以

353
00:17:51,840 --> 00:17:54,510
完全并行地使用不相交的数据，

354
00:17:54,510 --> 00:17:56,220
如果您是一个分片系统，这

355
00:17:56,220 --> 00:17:57,750
就是我们正在努力的目标 今天

356
00:17:57,750 --> 00:17:59,490
有了数据，不同的数据在

357
00:17:59,490 --> 00:18:01,200
不同的机器上，你可以获得真正的

358
00:18:01,200 --> 00:18:02,790
并行加速，因为也许一个

359
00:18:02,790 --> 00:18:04,800
事务

360
00:18:04,800 --> 00:18:06,510
在第一台机器上的第一个分片中执行 Spira，而另一个

361
00:18:06,510 --> 00:18:09,390
在第二台机器上并行执行，所以

362
00:18:09,390 --> 00:18:12,960
这里有机会获得

363
00:18:12,960 --> 00:18:17,490
良好的性能 在我深入研究

364
00:18:17,490 --> 00:18:21,590
如何实现可序列化事务

365
00:18:21,590 --> 00:18:24,480
之前，我还想提出一个小问题

366
00:18:24,480 --> 00:18:29,310
，事实证明其中一

367
00:18:29,310 --> 00:18:30,540
件事 我们需要能够应对的

368
00:18:30,540 --> 00:18:33,150
是，交易可能由于某种原因

369
00:18:33,150 --> 00:18:34,370
 

370
00:18:34,370 --> 00:18:39,420
基本上失败或决定

371
00:18:39,420 --> 00:18:41,670
在交易中间失败，这

372
00:18:41,670 --> 00:18:47,160
通常称为中止，您知道对于

373
00:18:47,160 --> 00:18:48,840
许多交易系统，我们需要

374
00:18:48,840 --> 00:18:50,880
准备好处理 哦，

375
00:18:50,880 --> 00:18:53,490
如果事务尝试访问

376
00:18:53,490 --> 00:18:56,070
不存在的记录或被零除，

377
00:18:56,070 --> 00:18:59,460
或者您知道，由于某些

378
00:18:59,460 --> 00:19:01,140
事务实现方案使用

379
00:19:01,140 --> 00:19:03,720
锁定，可能会导致

380
00:19:03,720 --> 00:19:05,460
锁定死锁，而打破死锁的唯一方法

381
00:19:05,460 --> 00:19:08,010
是杀死 参与僵局的一个

382
00:19:08,010 --> 00:19:09,450
或多个事务

383
00:19:09,450 --> 00:19:13,170
之一，因此

384
00:19:13,170 --> 00:19:14,910
将

385
00:19:14,910 --> 00:19:16,170
在后台挂起并且会出现的

386
00:19:16,170 --> 00:19:18,720
 

387
00:19:18,720 --> 00:19:20,820
事情之一是处理突然在

388
00:19:20,820 --> 00:19:22,970
中间决定它们只是的事务的必要性 无法继续

389
00:19:22,970 --> 00:19:26,580
，你知道

390
00:19:26,580 --> 00:19:28,530
在他们完成一些工作并开始

391
00:19:28,530 --> 00:19:30,240
修改我们需要

392
00:19:30,240 --> 00:19:33,150
能够退出这些交易的事情之后，你可能真的处于中间状态，

393
00:19:33,150 --> 00:19:35,690
并且 撤消他们所做的任何修改

394
00:19:35,690 --> 00:19:38,190
 

395
00:19:38,190 --> 00:19:40,830
 

396
00:19:40,830 --> 00:19:42,390
这些资产

397
00:19:42,390 --> 00:19:46,140
交易的交易的实施策略我将分成两个

398
00:19:46,140 --> 00:19:48,510
大部分，但是并讨论

399
00:19:48,510 --> 00:19:52,560
它们两个讲座中的主要主题

400
00:19:52,560 --> 00:19:54,360
第一个重要的实施主题是

401
00:19:54,360 --> 00:20:05,430
并发控制这是

402
00:20:05,430 --> 00:20:07,380
我们用来提供可串行

403
00:20:07,380 --> 00:20:10,080
化当前或隔离的主要工具，因此并发

404
00:20:10,080 --> 00:20:13,250
控制偏向

405
00:20:16,509 --> 00:20:19,879
于

406
00:20:19,879 --> 00:20:21,320
与可能试图

407
00:20:21,320 --> 00:20:24,049
使用相同数据的其他并发事务的隔离，而我提到的其他重要部分

408
00:20:24,049 --> 00:20:27,639
是原子提交，

409
00:20:28,809 --> 00:20:31,369
这将对我们有所帮助 处理这样的

410
00:20:31,369 --> 00:20:34,070
可能性，哦，是的，这个

411
00:20:34,070 --> 00:20:35,960
事务执行了很长时间，它

412
00:20:35,960 --> 00:20:38,330
可能被修改了 X，然后

413
00:20:38,330 --> 00:20:41,899
突然出现故障，其中一个

414
00:20:41,899 --> 00:20:44,480
服务器涉及但其他服务器

415
00:20:44,480 --> 00:20:45,919
可能实际上在

416
00:20:45,919 --> 00:20:48,139
事务的其他部分，如果 x 并且 y

417
00:20:48,139 --> 00:20:50,779
位于不同的机器中

418
00:20:50,779 --> 00:20:52,730
，即使

419
00:20:52,730 --> 00:20:55,340
只有部分机器出现部分故障，我们也需要能够

420
00:20:55,340 --> 00:20:58,460
恢复

421
00:20:58,460 --> 00:21:00,169
人们使用的主要工具就是这个原子

422
00:21:00,169 --> 00:21:03,889
提交，你会谈到的，所以

423
00:21:03,889 --> 00:21:08,960
首先并发控制实际上有两类并发控制的

424
00:21:08,960 --> 00:21:11,480
两种主要方法

425
00:21:11,480 --> 00:21:13,990
我将

426
00:21:13,990 --> 00:21:20,450
在课程中讨论它们，如果它们只是 平均

427
00:21:20,450 --> 00:21:22,960
策略第一个策略是

428
00:21:22,960 --> 00:21:29,480
悲观主义，通常称为悲观主义

429
00:21:29,480 --> 00:21:32,360
悲观并发控制，这

430
00:21:32,360 --> 00:21:34,519
通常是锁定我们都

431
00:21:34,519 --> 00:21:36,440
在实验室中在 go 程序的上下文中完成了锁定，

432
00:21:36,440 --> 00:21:38,509
所以事实证明数据库

433
00:21:38,509 --> 00:21:40,879
事务处理系统也使用了

434
00:21:40,879 --> 00:21:45,409
锁定，这里的想法是 U 也

435
00:21:45,409 --> 00:21:46,909
一样，您

436
00:21:46,909 --> 00:21:48,860
对此非常熟悉，在事务使用任何数据之前，

437
00:21:48,860 --> 00:21:50,960
它需要获取对该数据的锁定

438
00:21:50,960 --> 00:21:52,850
，如果其他一些事务

439
00:21:52,850 --> 00:21:54,619
已经在使用该数据，则锁定将被

440
00:21:54,619 --> 00:21:57,080
持有，我们将不得不等待 我们

441
00:21:57,080 --> 00:21:58,909
可以获取锁等待其他

442
00:21:58,909 --> 00:22:02,899
事务完成，并且在悲观的

443
00:22:02,899 --> 00:22:04,730
系统中，如果存在锁定冲突，

444
00:22:04,730 --> 00:22:06,230
其他人拥有锁会导致

445
00:22:06,230 --> 00:22:09,139
延迟，所以你很伤心 t 将

446
00:22:09,139 --> 00:22:14,419
性能视为正确性 另一种

447
00:22:14,419 --> 00:22:20,679
主要方法是乐观方法

448
00:22:21,450 --> 00:22:23,980
这里的基本思想是您不必

449
00:22:23,980 --> 00:22:25,330
担心是否有其他

450
00:22:25,330 --> 00:22:26,980
事务在读取或写入数据

451
00:22:26,980 --> 00:22:28,779
的同时

452
00:22:28,779 --> 00:22:30,309
继续执行任何读取和写入操作

453
00:22:30,309 --> 00:22:32,200
你会做，虽然通常进入

454
00:22:32,200 --> 00:22:33,940
某种临时区域，然后

455
00:22:33,940 --> 00:22:37,330
只有在最后你去检查是否

456
00:22:37,330 --> 00:22:38,799
实际上可能有其他交易

457
00:22:38,799 --> 00:22:40,870
可能已经干扰，如果

458
00:22:40,870 --> 00:22:42,309
现在没有其他交易，你就

459
00:22:42,309 --> 00:22:44,470
完成了，你永远不必去 通过

460
00:22:44,470 --> 00:22:46,029
取出锁的任何开销或权重，

461
00:22:46,029 --> 00:22:47,950
 

462
00:22:47,950 --> 00:22:51,730
操作锁的成本相当高，但是如果

463
00:22:51,730 --> 00:22:54,340
其他人同时以冲突的方式修改数据，

464
00:22:54,340 --> 00:22:56,830
 

465
00:22:56,830 --> 00:22:58,480
那么您必须中止该

466
00:22:58,480 --> 00:23:05,309
事务，我们尝试使用

467
00:23:05,309 --> 00:23:06,940
缩写 这通常是

468
00:23:06,940 --> 00:23:10,120
乐观并发控制 嗯，

469
00:23:10,120 --> 00:23:11,080
事实证明，在不同的

470
00:23:11,080 --> 00:23:12,759
情况下，这两种策略如果 confli

471
00:23:12,759 --> 00:23:15,179
可以比另一种更快

472
00:23:15,179 --> 00:23:17,830
cts 非常频繁你

473
00:23:17,830 --> 00:23:18,580
可能真的想使用

474
00:23:18,580 --> 00:23:20,679
悲观并发控制不是

475
00:23:20,679 --> 00:23:22,120
因为冲突频繁你

476
00:23:22,120 --> 00:23:23,529
会因为冲突而中止很多

477
00:23:23,529 --> 00:23:25,899
乐观似乎如果

478
00:23:25,899 --> 00:23:27,580
复杂很少比乐观

479
00:23:27,580 --> 00:23:29,980
并发控制可以更快

480
00:23:29,980 --> 00:23:31,539
因为它完全避免锁定

481
00:23:31,539 --> 00:23:33,580
今天的开销将全部与

482
00:23:33,580 --> 00:23:36,580
悲观并发控制有关，然后是

483
00:23:36,580 --> 00:23:39,610
一些稍后的论文，特别是几周后的农场，

484
00:23:39,610 --> 00:23:41,950
我们将处理一个

485
00:23:41,950 --> 00:23:48,549
乐观方案，好吧，所以今天

486
00:23:48,549 --> 00:23:51,190
谈论悲观方案

487
00:23:51,190 --> 00:23:53,500
基本上是指锁定，特别

488
00:23:53,500 --> 00:23:54,700
是今天的读数大约是

489
00:23:54,700 --> 00:23:57,059
两个 -阶段锁定是最

490
00:23:57,059 --> 00:24:00,990
常见的锁定类型，事务

491
00:24:07,640 --> 00:24:10,140
的两阶段锁定的想法

492
00:24:10,140 --> 00:24:12,090
是事务将

493
00:24:12,090 --> 00:24:14,280
使用一堆像 X&Y 这样的记录，我们的

494
00:24:14,280 --> 00:24:19,140
示例第一条规则是您

495
00:24:19,140 --> 00:24:25,350
在使用日期之前获取

496
00:24:25,350 --> 00:24:30,360
锁 我们正在读取或写入

497
00:24:30,360 --> 00:24:35,400
任何记录的数据，事务的第二条规则

498
00:24:35,400 --> 00:24:37,710
是事务必须

499
00:24:37,710 --> 00:24:40,770
持有任何锁 它获取直到

500
00:24:40,770 --> 00:24:43,650
它提交或中止之后你不能

501
00:24:43,650 --> 00:24:44,820
在事务中间放弃锁

502
00:24:44,820 --> 00:24:46,020
你必须持有它们

503
00:24:46,020 --> 00:24:48,270
你只能累积它们直到

504
00:24:48,270 --> 00:24:52,580
你完成直到你完成之后

505
00:24:54,680 --> 00:24:59,670
直到菲比这样做 这是两阶段

506
00:24:59,670 --> 00:25:01,500
锁定阶段是

507
00:25:01,500 --> 00:25:03,570
我们获取锁的阶段，然后是

508
00:25:03,570 --> 00:25:07,490
我们只持有它们直到我们完成的

509
00:25:07,490 --> 00:25:11,640
阶段，对于两阶段锁定来说，看看

510
00:25:11,640 --> 00:25:15,810
为什么锁定在您的典型锁定

511
00:25:15,810 --> 00:25:17,700
系统中工作得很好有很多

512
00:25:17,700 --> 00:25:19,110
典型的锁定系统将一个

513
00:25:19,110 --> 00:25:21,060
单独的锁与数据库中的每条记录

514
00:25:21,060 --> 00:25:23,250
与每个表中的每一行关联起来，

515
00:25:23,250 --> 00:25:25,500
例如，尽管它们可以更

516
00:25:25,500 --> 00:25:28,500
粗粒度，但这些事务开始

517
00:25:28,500 --> 00:25:29,910
时不持有锁，假设

518
00:25:29,910 --> 00:25:31,470
事务一开始时不持有

519
00:25:31,470 --> 00:25:34,500
锁 首先使用 X 之前所以

520
00:25:34,500 --> 00:25:35,880
我必须使用它它必须获取

521
00:25:35,880 --> 00:25:38,540
X 上的锁并且它可能需要等待

522
00:25:38,540 --> 00:25:41,130
，当它第一次使用 Y 时它获取

523
00:25:41,130 --> 00:25:43,860
另一个锁，当它完成后完成时 Y 上的锁

524
00:25:43,860 --> 00:25:45,750
 

525
00:25:45,750 --> 00:25:48,180
如果我们同时运行这两个事务

526
00:25:48,180 --> 00:25:50,760
，那么它们基本上都会

527
00:25:50,760 --> 00:25:53,310
竞相获得 X 上的锁定，并且

528
00:25:53,310 --> 00:25:56,160
无论他们中的哪

529
00:25:56,160 --> 00:25:59,400
一个首先设法获得 X 上的锁定，它将继续并完成

530
00:25:59,400 --> 00:26:02,310
并同时提交另一个

531
00:26:02,310 --> 00:26:04,230
事务 没有设法首先获得

532
00:26:04,230 --> 00:26:05,610
X 上的锁它会看看

533
00:26:05,610 --> 00:26:08,910
你是否在等待它之前你

534
00:26:08,910 --> 00:26:10,860
用重音做的任何事情 OA 可以获得

535
00:26:10,860 --> 00:26:13,200
锁所以事务 2 实际上首先获得了

536
00:26:13,200 --> 00:26:14,460
锁

537
00:26:14,460 --> 00:26:16,380
你会得到 X 的值 get the

538
00:26:16,380 --> 00:26:20,190
y 的值因为

539
00:26:20,190 --> 00:26:22,370
此时尚未获得的事务一尚未锁定 Y，但

540
00:26:22,370 --> 00:26:24,540
它会打印，它将完成并

541
00:26:24,540 --> 00:26:26,130
释放其锁，只有这样，

542
00:26:26,130 --> 00:26:28,560
事务一才能获得

543
00:26:28,560 --> 00:26:30,960
X 上的锁，如您所见 这

544
00:26:30,960 --> 00:26:33,750
基本上强制了一个序列顺序，因为

545
00:26:33,750 --> 00:26:35,220
它在这种情况下强制它强制

546
00:26:35,220 --> 00:26:38,550
顺序 T 2，然后当 T 2 完成

547
00:26:38,550 --> 00:26:43,080
时才 T 1 所以它明确地

548
00:26:43,080 --> 00:26:47,330
强制一个顺序，导致该

549
00:26:47,330 --> 00:26:49,620
执行遵循

550
00:26:49,620 --> 00:26:51,450
你真正知道的可序列化的定义 一世 s

551
00:26:51,450 --> 00:26:54,360
执行 T 2 直到完成，然后才执行

552
00:26:54,360 --> 00:27:00,620
T 1 所以我们确实可以正确执行，

553
00:27:06,930 --> 00:27:15,040
所以一个问题是为什么你

554
00:27:15,040 --> 00:27:16,840
需要持有锁直到

555
00:27:16,840 --> 00:27:19,060
事务完全完成你

556
00:27:19,060 --> 00:27:22,210
可能认为

557
00:27:22,210 --> 00:27:24,520
你可以在实际使用时持有锁

558
00:27:24,520 --> 00:27:25,810
数据，这将更有效

559
00:27:25,810 --> 00:27:28,660
，实际上你知道

560
00:27:28,660 --> 00:27:31,480
可能只

561
00:27:31,480 --> 00:27:34,030
在 t2 实际

562
00:27:34,030 --> 00:27:36,040
查看记录 X 的时间段内保持锁定，或者

563
00:27:36,040 --> 00:27:39,180
在添加期间只在 X 上保持锁定

564
00:27:39,180 --> 00:27:41,680
操作然后立即释放

565
00:27:41,680 --> 00:27:43,480
它，在这种情况下，如果我们

566
00:27:43,480 --> 00:27:45,280
事务一

567
00:27:45,280 --> 00:27:47,140
通过不遵守此规则立即释放 X 那里的锁，

568
00:27:47,140 --> 00:27:48,910
但如果它立即

569
00:27:48,910 --> 00:27:50,740
释放 X 上的锁，那么事务

570
00:27:50,740 --> 00:27:51,970
二可能能够开始一点点

571
00:27:51,970 --> 00:27:53,590
更早我们获得更多的并发性

572
00:27:53,590 --> 00:27:55,240
更高的性能所以这个规则

573
00:27:55,240 --> 00:27:57,820
肯定你知道对性能不好

574
00:27:57,820 --> 00:28:00,040
所以我们想

575
00:28:00,040 --> 00:28:02,530
确定它对正确性是有好处的

576
00:28:02,530 --> 00:28:05,010
 

577
00:28:05,220 --> 00:28:08,440
所以什么 如果事务

578
00:28:08,440 --> 00:28:11,740
确实尽早释放锁，则不会发生，

579
00:28:11,740 --> 00:28:12,430
 

580
00:28:12,430 --> 00:28:15,940
因此假设此处的 t2 读取 X，然后

581
00:28:15,940 --> 00:28:20,440
立即释放 X 上的此锁，这

582
00:28:20,440 --> 00:28:23,680
将允许 t1，因为

583
00:28:23,680 --> 00:28:26,860
此时执行 t2 不持有

584
00:28:26,860 --> 00:28:28,630
任何锁，因为它是 刚刚释放它

585
00:28:28,630 --> 00:28:31,420
非法释放 X 上的锁，因为它

586
00:28:31,420 --> 00:28:33,040
持有一个无锁，这意味着 t1 可以

587
00:28:33,040 --> 00:28:36,610
在这里完全执行，我们

588
00:28:36,610 --> 00:28:40,090
从之前就已经知道这种

589
00:28:40,090 --> 00:28:42,070
交错是不正确的，因为如果 t1 它

590
00:28:42,070 --> 00:28:45,300
不会产生这两个输出

591
00:28:45,300 --> 00:28:52,600
类似

592
00:28:52,600 --> 00:28:55,030
在完成向 X 添加一个后释放 X 上的这个锁，这

593
00:28:55,030 --> 00:28:57,700
将允许所有 t2 滑入

594
00:28:57,700 --> 00:28:59,770
这里，我们从之前也知道

595
00:28:59,770 --> 00:29:07,200
这会导致非法结果，

596
00:29:07,620 --> 00:29:12,570
还有另一种

597
00:29:12,570 --> 00:29:14,010
问题可以在之后释放锁

598
00:29:14,010 --> 00:29:18,690
如果 t1 要

599
00:29:18,690 --> 00:29:21,090
释放 X 上的锁定，则修改数据它可能允许 t2

600
00:29:21,090 --> 00:29:24,360
在此处查看 X 的修改版本，以便在向其

601
00:29:24,360 --> 00:29:26,730
添加 1 后查看 X 并

602
00:29:26,730 --> 00:29:28,950
打印该输出，然后让 tteyuu

603
00:29:28,950 --> 00:29:31,740
完成 aft

604
00:29:31,740 --> 00:29:33,900
如果交易一

605
00:29:33,900 --> 00:29:36,029
在该点之后中止，则打印 x 的增量值，可能是因为

606
00:29:36,029 --> 00:29:39,720
银行余额 Y 不存在，或者

607
00:29:39,720 --> 00:29:41,820
银行债券 Y 存在但其余额

608
00:29:41,820 --> 00:29:43,770
为零，并且您知道我们不允许

609
00:29:43,770 --> 00:29:46,260
为银行余额减 0 因为

610
00:29:46,260 --> 00:29:48,870
这是透支，所以 t1 可能会修改 X

611
00:29:48,870 --> 00:29:51,299
然后中止，并且中止的一部分

612
00:29:51,299 --> 00:29:56,659
必须撤消对 X 的更新以

613
00:29:56,659 --> 00:29:59,490
保持原子性，

614
00:29:59,490 --> 00:30:00,750
如果它释放锁，这意味着

615
00:30:00,750 --> 00:30:03,000
事务 2 会看到

616
00:30:03,000 --> 00:30:05,490
这种幻象 11 的值

617
00:30:05,490 --> 00:30:08,700
因为 t1 中止而消失，您会看到一个

618
00:30:08,700 --> 00:30:10,590
根据规则永远不

619
00:30:10,590 --> 00:30:13,940
存在的值，因为然后

620
00:30:13,940 --> 00:30:16,770
事务 1 中止，然后就好像它

621
00:30:16,770 --> 00:30:18,330
从未存在一样，这意味着

622
00:30:18,330 --> 00:30:21,450
t2 的结果最好就像 t2

623
00:30:21,450 --> 00:30:24,960
完全没有 t1 自行运行，但是如果

624
00:30:24,960 --> 00:30:26,070
它看到增量，它将

625
00:30:26,070 --> 00:30:31,880
为 X 11 10 打印 11，实际上这与数据库

626
00:30:31,880 --> 00:30:34,380
中的任何状态都不对应，

627
00:30:34,380 --> 00:30:37,760
因为 t1 并没有真正

628
00:30:37,760 --> 00:30:42,659
完成，所以 这就是为什么这

629
00:30:42,659 --> 00:30:45,299
两个危险是由于

630
00:30:45,299 --> 00:30:48,000
违反序列化能力而

631
00:30:48,000 --> 00:30:50,460
避免的，因为事务持有

632
00:30:50,460 --> 00:30:56,580
锁，直到他们

633
00:30:56,580 --> 00:30:59,010
对这些规则做了进一步的注意，或者

634
00:30:59,010 --> 00:31:01,169
它们很容易产生死锁，

635
00:31:01,169 --> 00:31:06,059
所以你知道例如 如果我们有两个

636
00:31:06,059 --> 00:31:12,750
事务，其中一个读取记录 ax

637
00:31:12,750 --> 00:31:15,710
并读取记录 y

638
00:31:15,710 --> 00:31:19,909
，另一个事务读取 Y

639
00:31:19,909 --> 00:31:26,450
然后 X 如果它们同时运行，那这只是一个死锁

640
00:31:26,450 --> 00:31:28,880
，它们每个

641
00:31:28,880 --> 00:31:32,059
都在它第一次读取的记录上获得这个锁

642
00:31:32,059 --> 00:31:34,309
在事务完成之前不要释放，

643
00:31:34,309 --> 00:31:37,669
所以他们都坐在

644
00:31:37,669 --> 00:31:39,289
那里等待另一个事务持有的锁

645
00:31:39,289 --> 00:31:41,539
，除非

646
00:31:41,539 --> 00:31:42,890
数据库做了一些聪明的事情，否则

647
00:31:42,890 --> 00:31:44,630
 

648
00:31:44,630 --> 00:31:46,159
它们将永远死锁，事实上

649
00:31:46,159 --> 00:31:47,570
事务有各种策略，

650
00:31:47,570 --> 00:31:50,840
包括跟踪周期或超时

651
00:31:50,840 --> 00:31:53,000
为了检测到他们已经进入

652
00:31:53,000 --> 00:31:54,679
这种情况，数据库将

653
00:31:54,679 --> 00:31:56,929
中止这两个事务之一并撤消

654
00:31:56,929 --> 00:31:58,340
其所有更改并像该事务一样

655
00:31:58,340 --> 00:32:02,539
行事 从未发生过的操作，所以

656
00:32:02,539 --> 00:32:04,760
这是具有

657
00:32:04,760 --> 00:32:12,440
两阶段锁定的并发控制，到目前为止，这只是

658
00:32:12,440 --> 00:32:16,760
完全标准的数据库行为

659
00:32:16,760 --> 00:32:22,399
，它在

660
00:32:22,399 --> 00:32:24,730
单机数据库和

661
00:32:24,730 --> 00:32:26,809
分布式数据库中是一样的，这

662
00:32:26,809 --> 00:32:30,080
对我们更感兴趣，但我们的 下一个主题

663
00:32:30,080 --> 00:32:32,620
实际上是特定于

664
00:32:32,620 --> 00:32:35,510
构建数据库或存储系统，它们

665
00:32:35,510 --> 00:32:39,340
通常支持

666
00:32:39,340 --> 00:32:41,360
分布式设置上的事务，

667
00:32:41,360 --> 00:32:45,590
将数据拆分到多台机器上，所以现在

668
00:32:45,590 --> 00:32:47,990
的主题是如何构建分布式

669
00:32:47,990 --> 00:32:53,720
分布式事务，

670
00:32:53,720 --> 00:32:56,020
特别是如何应对故障和

671
00:32:56,020 --> 00:32:58,880
更具体地说

672
00:32:58,880 --> 00:33:00,590
 

673
00:33:00,590 --> 00:33:02,360
，您在分布式

674
00:33:02,360 --> 00:33:04,600
系统中经常看到的许多服务器之一的部分故障，除了分布式

675
00:33:04,600 --> 00:33:07,250
事务之外，我们担心

676
00:33:07,250 --> 00:33:09,890
它们的行为方式，您确保它们是可

677
00:33:09,890 --> 00:33:13,159
序列化的，并且也有某种

678
00:33:13,159 --> 00:33:15,470
全有或全无 ad Amissah T 即使

679
00:33:15,470 --> 00:33:21,970
面对失败，所以

680
00:33:21,970 --> 00:33:24,410
你知道我你知道这

681
00:33:24,410 --> 00:33:26,000
看起来像什么，我们可能有 tw  o

682
00:33:26,000 --> 00:33:30,020
服务器，我们有服务器 1，

683
00:33:30,020 --> 00:33:33,260
它可能将记录 X 存储在我们的银行，我们

684
00:33:33,260 --> 00:33:35,300
有服务器 2，它可能存储

685
00:33:35,300 --> 00:33:37,850
记录 Y，所以它们都以

686
00:33:37,850 --> 00:33:41,510
值 10 开始，我们需要运行这两个

687
00:33:41,510 --> 00:33:44,150
事务，事务 1

688
00:33:44,150 --> 00:33:48,110
当然会修改两者 x 和 y 所以现在我们

689
00:33:48,110 --> 00:33:49,850
需要发送消息数据库

690
00:33:49,850 --> 00:33:51,770
说哦请增加 X 请

691
00:33:51,770 --> 00:33:55,190
减少 Y 但是如果

692
00:33:55,190 --> 00:33:56,570
我们不小心进入

693
00:33:56,570 --> 00:33:59,390
我们告诉服务器 1 增加

694
00:33:59,390 --> 00:34:01,430
X 的余额的情况会很容易但是 然后某些事情

695
00:34:01,430 --> 00:34:03,530
失败了，可能是客户端发送

696
00:34:03,530 --> 00:34:05,780
请求或服务器服务器

697
00:34:05,780 --> 00:34:07,730
- 持有 Y 失败或其他事情，

698
00:34:07,730 --> 00:34:10,690
我们从未设法正确地进行第二次更新，

699
00:34:10,690 --> 00:34:14,270
所以这是一个问题，

700
00:34:14,270 --> 00:34:16,850
某个地方的失败可能会将

701
00:34:16,850 --> 00:34:19,399
事务减半，如果我们' 不

702
00:34:19,399 --> 00:34:20,719
小心导致只有一半的

703
00:34:20,719 --> 00:34:26,739
事务实际生效 如果 X 在事务中发挥作用，

704
00:34:34,460 --> 00:34:36,989
即使没有崩溃也可能发生这种情况

705
00:34:36,989 --> 00:34:39,149
 

706
00:34:39,149 --> 00:34:40,440
 

707
00:34:40,440 --> 00:34:42,918
 

708
00:34:42,918 --> 00:34:46,319
增加银行账户 y 但也许

709
00:34:46,319 --> 00:34:47,760
服务器 2 发现该银行账户

710
00:34:47,760 --> 00:34:50,099
不存在或者它确实存在并且

711
00:34:50,099 --> 00:34:52,079
当它不能减少时它的余额已经是 0

712
00:34:52,079 --> 00:34:53,969
并且它不能做它

713
00:34:53,969 --> 00:34:56,039
的交易部分但是 X 看起来有

714
00:34:56,039 --> 00:34:58,220
已经完成了交易的一部分，

715
00:34:58,220 --> 00:35:00,329
所以这是一个需要

716
00:35:00,329 --> 00:35:09,450
处理的问题，所以

717
00:35:09,450 --> 00:35:11,849
正如我之前提到的，我们想要的属性是

718
00:35:11,849 --> 00:35:13,650
系统的所有部分，或者系统的所有

719
00:35:13,650 --> 00:35:15,059
部分都应该完成交易的

720
00:35:15,059 --> 00:35:18,089
一部分，或者 不对，所以

721
00:35:18,089 --> 00:35:20,849
你知道我们

722
00:35:20,849 --> 00:35:25,440
在这里违反的那种事情是什么原子性反对

723
00:35:25,440 --> 00:35:33,029
崩溃与失败原子性

724
00:35:33,029 --> 00:35:40,650
是全部或不是全部部分

725
00:35:40,650 --> 00:35:42,210
我们试图执行的交易的所有部分

726
00:35:42,210 --> 00:35:50,069
或没有它们，对你来说更多的是

727
00:35:50,069 --> 00:35:51,089
那种 我们将要研究的解决方案

728
00:35:51,089 --> 00:35:54,089
是原子承诺原子

729
00:35:54,089 --> 00:35:59,299
提交协议，原子提交协议的一般

730
00:35:59,299 --> 00:36:01,769
风格

731
00:36:01,769 --> 00:36:02,940
是你有一堆计算机，

732
00:36:02,940 --> 00:36:04,559
它们都在做

733
00:36:04,559 --> 00:36:08,190
一些更大的任务的不同部分，并且 原子提交

734
00:36:08,190 --> 00:36:10,980
协议将帮助计算机

735
00:36:10,980 --> 00:36:12,630
决定要么他们都要做，要么

736
00:36:12,630 --> 00:36:13,950
他们都有能力做

737
00:36:13,950 --> 00:36:15,359
他们的部分并且他们真的要

738
00:36:15,359 --> 00:36:17,430
去做，或者出现了问题，

739
00:36:17,430 --> 00:36:19,470
他们都要做 同意哦，

740
00:36:19,470 --> 00:36:21,119
他们实际上都不会

741
00:36:21,119 --> 00:36:23,809
做他们的一部分，无论

742
00:36:23,809 --> 00:36:26,970
整体任务是什么，最大的

743
00:36:26,970 --> 00:36:28,230
挑战当然是如何应对各种

744
00:36:28,230 --> 00:36:29,970
故障机器故障丢失

745
00:36:29,970 --> 00:36:32,089
消息，结果证明

746
00:36:32,089 --> 00:36:35,430
性能是

747
00:36:35,430 --> 00:36:39,000
 

748
00:36:39,000 --> 00:36:40,440
我们要研究的特定协议也有点难以做好，

749
00:36:40,440 --> 00:36:42,150
并且是

750
00:36:42,150 --> 00:36:46,849
今天阅读中解释的协议我们的两阶段提交

751
00:36:52,920 --> 00:36:57,480
这是一个原子提交协议

752
00:36:58,109 --> 00:37:00,460
，分布式数据库和分布式数据库都使用它

753
00:37:00,460 --> 00:37:02,619
同样

754
00:37:02,619 --> 00:37:05,289
对于可能

755
00:37:05,289 --> 00:37:07,200
最初看起来不像传统数据库

756
00:37:07,200 --> 00:37:10,170
的各种其他分布式系统，一般设置是我们

757
00:37:10,170 --> 00:37:13,329
假设我们需要执行的任务以一种或另一种方式

758
00:37:13,329 --> 00:37:15,010
被分成

759
00:37:15,010 --> 00:37:16,660
多个服务器，每个服务器 这需要

760
00:37:16,660 --> 00:37:19,420
做一些不同的

761
00:37:19,420 --> 00:37:22,390
部分，例如，因为我已经

762
00:37:22,390 --> 00:37:24,670
设置好了，所以我在这里展示了它

763
00:37:24,670 --> 00:37:26,440
实际上是拆分的数据，因此

764
00:37:26,440 --> 00:37:28,510
任务被拆分为我们递增的 X

765
00:37:28,510 --> 00:37:34,690
和递减的 Y D 我们'

766
00:37:34,690 --> 00:37:38,319
假设有一台

767
00:37:38,319 --> 00:37:40,210
驱动事务的计算机称为

768
00:37:40,210 --> 00:37:55,869
事务协调器 有很多

769
00:37:55,869 --> 00:37:57,460
方法可以安排事务

770
00:37:57,460 --> 00:37:59,230
协调器如何介入，但我们只是将其

771
00:37:59,230 --> 00:38:00,910
想象为

772
00:38:00,910 --> 00:38:03,130
实际运行事务的

773
00:38:03,130 --> 00:38:04,539
计算机 有一台计算机作为事务协调器

774
00:38:04,539 --> 00:38:06,940
那就是执行交易的代码

775
00:38:06,940 --> 00:38:08,950
，比如puts

776
00:38:08,950 --> 00:38:11,289
、gets和adds，它会向

777
00:38:11,289 --> 00:38:14,589
保存不同数据的计算机发送消息，这些

778
00:38:14,589 --> 00:38:16,210
数据需要

779
00:38:16,210 --> 00:38:18,900
实际执行不同的部分，所以

780
00:38:18,900 --> 00:38:21,700
对于我们的设置，我们将 有一

781
00:38:21,700 --> 00:38:23,500
台事务协调器的计算机

782
00:38:23,500 --> 00:38:28,299
，这将是这些服务器一

783
00:38:28,299 --> 00:38:33,430
和服务器二持有 X&Y 事务

784
00:38:33,430 --> 00:38:34,930
协调器，我们将向其发送消息

785
00:38:34,930 --> 00:38:36,549
服务器一个说哦，请增加 X

786
00:38:36,549 --> 00:38:38,890
向服务器 Y 发送一条消息说哦，

787
00:38:38,890 --> 00:38:40,510
请减少 Y 然后会有

788
00:38:40,510 --> 00:38:42,520
更多消息，以确保

789
00:38:42,520 --> 00:38:44,680
他们要么都这样做，要么都不

790
00:38:44,680 --> 00:38:46,569
做，这就是两阶段提交

791
00:38:46,569 --> 00:38:50,109
步骤 要

792
00:38:50,109 --> 00:38:52,180
记住的是，在整个系统

793
00:38:52,180 --> 00:38:53,980
中，可能有许多不同的事务

794
00:38:53,980 --> 00:38:55,750
同时运行，并且许多

795
00:38:55,750 --> 00:38:57,890
事务

796
00:38:57,890 --> 00:39:00,890
协调员在执行他们自己的事务

797
00:39:00,890 --> 00:39:03,319
，因此这里的各方需要

798
00:39:03,319 --> 00:39:04,940
跟踪哦，你知道这是一个

799
00:39:04,940 --> 00:39:06,890
某某事务的消息

800
00:39:06,890 --> 00:39:09,589
以及它们在哪里保持这样的状态

801
00:39:09,589 --> 00:39:10,849
结果这些服务器将

802
00:39:10,849 --> 00:39:12,710
维护表两个块，例如

803
00:39:12,710 --> 00:39:14,660
，它们保持状态，就像他们

804
00:39:14,660 --> 00:39:15,950
需要跟踪哦，这是一个

805
00:39:15,950 --> 00:39:18,680
被持有的锁 事务 17 所以

806
00:39:18,680 --> 00:39:28,660
有一个事务 ID 的概念，

807
00:39:28,660 --> 00:39:31,819
我只是假设，尽管你知道

808
00:39:31,819 --> 00:39:33,619
我实际上并没有表明

809
00:39:33,619 --> 00:39:35,630
系统中的每条消息都带有带有 un 的事务标记

810
00:39:35,630 --> 00:39:37,069
 

811
00:39:37,069 --> 00:39:39,470
它适用的事务的唯一事务 ID，

812
00:39:39,470 --> 00:39:41,359
这些 ID 由事务

813
00:39:41,359 --> 00:39:43,099
协调器在事务开始时选择，

814
00:39:43,099 --> 00:39:44,990
事务协调器将

815
00:39:44,990 --> 00:39:47,420
发送哦，这是 1995 年事务的消息

816
00:39:47,420 --> 00:39:51,410
，它将在此处保留

817
00:39:51,410 --> 00:39:52,579
有关事务的所有状态将是

818
00:39:52,579 --> 00:39:57,050
用 95 标记，事务中不同参与者中的各种表

819
00:39:57,050 --> 00:39:59,210
 

820
00:39:59,210 --> 00:40:01,609
将用

821
00:40:01,609 --> 00:40:04,040
事务 ID 标记，这是另一个

822
00:40:04,040 --> 00:40:05,960
术语，我们得到

823
00:40:05,960 --> 00:40:07,910
事务协调器，然后

824
00:40:07,910 --> 00:40:11,569
其他执行

825
00:40:11,569 --> 00:40:15,700
部分事务的服务器被称为参与者

826
00:40:20,020 --> 00:40:21,380
好吧

827
00:40:21,380 --> 00:40:24,589
所以让我画出两阶段提交

828
00:40:24,589 --> 00:40:28,690
协议示例执行，所以

829
00:40:28,690 --> 00:40:32,390
这是 PC 的缩写，用于两阶段

830
00:40:32,390 --> 00:40:37,599
提交，所涉及的各方是

831
00:40:37,599 --> 00:40:40,130
事务协调者，我们只会

832
00:40:40,130 --> 00:40:42,230
说有两个参与者，你

833
00:40:42,230 --> 00:40:43,160
知道也许我们正在执行

834
00:40:43,160 --> 00:40:44,510
我接下来显示的交易以及为什么

835
00:40:44,510 --> 00:40:48,250
不是不同的服务器也许我们有

836
00:40:48,250 --> 00:40:53,540
参与者 a 和参与者 B 这些

837
00:40:53,540 --> 00:40:57,010
是 t 两个不同的服务器保存数据，

838
00:40:57,010 --> 00:40:59,540
因此事务协调器

839
00:40:59,540 --> 00:41:01,099
正在运行整个事务，

840
00:41:01,099 --> 00:41:03,920
它将发送 put 并到达 a 和 B

841
00:41:03,920 --> 00:41:06,170
告诉他们你知道读取

842
00:41:06,170 --> 00:41:09,079
x 或 y 的值或将一个添加到 X 所以我们将

843
00:41:09,079 --> 00:41:11,109
看到 在

844
00:41:11,109 --> 00:41:12,849
事务协调器

845
00:41:12,849 --> 00:41:15,309
正在发送的树操作的开头，例如，可能是

846
00:41:15,309 --> 00:41:19,239
向 Trent 参与者 a 发送一个 get 请求，它

847
00:41:19,239 --> 00:41:21,160
会得到一个回复​​，然后它可能会发送

848
00:41:21,160 --> 00:41:27,970
那个 put 用于任何我可能会看到的长

849
00:41:27,970 --> 00:41:29,170
序列，如果有一个

850
00:41:29,170 --> 00:41:33,759
复杂的事务 然后当

851
00:41:33,759 --> 00:41:35,410
事务协调员到达

852
00:41:35,410 --> 00:41:38,259
事务结束并想要提交

853
00:41:38,259 --> 00:41:40,779
它并且能够知道释放所有

854
00:41:40,779 --> 00:41:42,130
这些锁并使事务

855
00:41:42,130 --> 00:41:44,140
结果对外界可见并且

856
00:41:44,140 --> 00:41:47,289
可能回复客户端或人类用户

857
00:41:47,289 --> 00:41:49,569
所以他们假设 有一种

858
00:41:49,569 --> 00:41:52,480
外部客户或人说

859
00:41:52,480 --> 00:41:54,160
请运行此事务，它正在

860
00:41:54,160 --> 00:41:56,890
等待响应，然后我们才能

861
00:41:56,890 --> 00:41:59,019
执行事务协调

862
00:41:59,019 --> 00:42:02,079
协调器必须执行的任何操作 确保

863
00:42:02,079 --> 00:42:04,119
所有不同的参与者实际上

864
00:42:04,119 --> 00:42:07,329
都可以完成他们的交易部分，

865
00:42:07,329 --> 00:42:08,950
特别是如果交易中有任何放置，

866
00:42:08,950 --> 00:42:11,440
我们需要确保

867
00:42:11,440 --> 00:42:14,230
执行这些

868
00:42:14,230 --> 00:42:16,059
放置的参与者实际上仍然能够

869
00:42:16,059 --> 00:42:19,509
按顺序进行放置

870
00:42:19,509 --> 00:42:22,529
找出事务协调器

871
00:42:22,529 --> 00:42:32,009
向所有参与者发送准备消息，

872
00:42:32,009 --> 00:42:35,829
因此我们

873
00:42:35,829 --> 00:42:39,180
将向 a 和 B 发送对消息

874
00:42:41,619 --> 00:42:44,599
，当 a 或 B 收到准备器

875
00:42:44,599 --> 00:42:45,650
消息时，您知道他们知道

876
00:42:45,650 --> 00:42:47,329
事务即将完成但

877
00:42:47,329 --> 00:42:49,089
不 还没有结束，

878
00:42:49,089 --> 00:42:51,440
他们会查看他们的状态并

879
00:42:51,440 --> 00:42:52,849
决定他们是否真的能够

880
00:42:52,849 --> 00:42:54,200
完成交易，你知道

881
00:42:54,200 --> 00:42:56,119
他们可能需要中止它打破僵局，

882
00:42:56,119 --> 00:42:58,339
或者他们已经崩溃了，我们开始了，

883
00:42:58,339 --> 00:43:02,299
但是你知道他们什么时候做

884
00:43:02,299 --> 00:43:04,069
最后一次操作是 现在他们已经

885
00:43:04,069 --> 00:43:05,029
完全忘记了

886
00:43:05,029 --> 00:43:07,039
交易并且无法完成它所以a

887
00:43:07,039 --> 00:43:08,690
和B你知道看看他们的状态然后

888
00:43:08,690 --> 00:43:10,460
说哦我会或者我

889
00:43:10,460 --> 00:43:11,809
不会 能够执行此事务

890
00:43:11,809 --> 00:43:18,910
并且他们以是或否响应，

891
00:43:24,730 --> 00:43:28,730
因此事务协调员正在

892
00:43:28,730 --> 00:43:31,880
等待每个参与者的这些是或否投票

893
00:43:31,880 --> 00:43:35,329
如果他们都说

894
00:43:35,329 --> 00:43:42,589
是，那么事务可以提交

895
00:43:42,589 --> 00:43:45,890
任何错误事务可以

896
00:43:45,890 --> 00:43:47,839
提交并且 事务协调员

897
00:43:47,839 --> 00:43:57,289
向每个参与者发送一条提交消息

898
00:43:57,289 --> 00:44:02,839
，然后

899
00:44:02,839 --> 00:44:05,240
参与者通常会回复

900
00:44:05,240 --> 00:44:07,880
确认说是的，我们现在

901
00:44:07,880 --> 00:44:10,990
知道结果这被称为技术，

902
00:44:10,990 --> 00:44:14,630
所以他们都是事务

903
00:44:14,630 --> 00:44:17,000
协调员，因为我准备好了，如果所有

904
00:44:17,000 --> 00:44:19,160
参与者都说是的话 如果

905
00:44:19,160 --> 00:44:21,759
他们中的任何人甚至一个人

906
00:44:21,759 --> 00:44:24,289
说不可以提交，实际上我无法完成此

907
00:44:24,289 --> 00:44:27,130
事务，因为我有一个失败或

908
00:44:27,130 --> 00:44:29,329
存在诸如丢失记录之类的不一致

909
00:44:29,329 --> 00:44:32,059
，我必须中止即使

910
00:44:32,059 --> 00:44:34,099
一个参与者在这

911
00:44:34,099 --> 00:44:36,200
一点上说不，然后 事务协调

912
00:44:36,200 --> 00:44:38,390
器不会提交它会发出一轮

913
00:44:38,390 --> 00:44:41,180
中止消息，说哎呀，请

914
00:44:41,180 --> 00:44:47,380
以任何方式撤回此事务 e

915
00:44:47,380 --> 00:44:51,410
在提交之后

916
00:44:51,410 --> 00:44:52,700
发生了我们感兴趣的两件事，

917
00:44:52,700 --> 00:44:54,440
其中一件是事务协调员

918
00:44:54,440 --> 00:44:57,349
 

919
00:44:57,349 --> 00:44:59,420
将向客户或请求它的人输出任何事务输出，

920
00:44:59,420 --> 00:45:00,980
然后说看哦，是的，事务

921
00:45:00,980 --> 00:45:03,250
完成了，所以现在如果它没有 abort a

922
00:45:03,250 --> 00:45:04,970
commit 它是持久

923
00:45:04,970 --> 00:45:07,640
的 另一个有趣的事情是，

924
00:45:07,640 --> 00:45:12,890
为了遵守这些锁定规则，

925
00:45:12,890 --> 00:45:15,800
参与者在看到

926
00:45:15,800 --> 00:45:23,240
提交或中止时解锁，实际上

927
00:45:23,240 --> 00:45:27,170
为了遵守两阶段锁定规则，每个

928
00:45:27,170 --> 00:45:32,420
参与者锁定了它作为一部分读取的任何数据

929
00:45:32,420 --> 00:45:33,890
做事务的一部分，

930
00:45:33,890 --> 00:45:35,990
所以我们想象在

931
00:45:35,990 --> 00:45:37,940
每个参与者中都有一个

932
00:45:37,940 --> 00:45:40,369
与存储在该参与者处的数据相关联的锁表，

933
00:45:40,369 --> 00:45:43,010
并且参与者

934
00:45:43,010 --> 00:45:44,900
在这些表中锁定了一些东西

935
00:45:44,900 --> 00:45:47,599
记住哦，这是你知道的这

936
00:45:47,599 --> 00:45:49,040
条数据 该记录被锁定为

937
00:45:49,040 --> 00:45:51,230
事务二十九，

938
00:45:51,230 --> 00:45:52,819
最后提交或中止返回版本

939
00:45:52,819 --> 00:45:55,490
操作二十九参与者

940
00:45:55,490 --> 00:45:57,170
解锁该数据，然后其他

941
00:45:57,170 --> 00:45:59,540
交易可以使用，所以我们可能不得不在

942
00:45:59,540 --> 00:46:02,750
这里等待，这个解锁可能会解锁

943
00:46:02,750 --> 00:46:06,140
其他交易，这实际上

944
00:46:06,140 --> 00:46:13,640
是可序列化机制的一部分，所以你

945
00:46:13,640 --> 00:46:14,839
知道到目前为止这是正确的原因

946
00:46:14,839 --> 00:46:19,310
基本上是如果

947
00:46:19,310 --> 00:46:20,630
每个人都遵循这个协议

948
00:46:20,630 --> 00:46:23,480
没有失败那么两个

949
00:46:23,480 --> 00:46:25,280
参与者只有在他们都提交时才

950
00:46:25,280 --> 00:46:29,060
提交，如果我他们不能提交，如果

951
00:46:29,060 --> 00:46:30,859
我让他们必须中止，那么他们都会

952
00:46:30,859 --> 00:46:33,230
中止，所以我们得到要么他们都做

953
00:46:33,230 --> 00:46:36,380
，要么他们都不做，结果我们

954
00:46:36,380 --> 00:46:40,790
想要原子性结果 到目前为止，这个

955
00:46:40,790 --> 00:46:43,339
协议还没有考虑

956
00:46:43,339 --> 00:46:47,270
到失败，所以现在我们的工作是

957
00:46:47,270 --> 00:46:49,430
在我们的头脑中思考可能发生的

958
00:46:49,430 --> 00:46:50,510
各种不同类型的失败，

959
00:46:50,510 --> 00:46:53,900
并确定

960
00:46:53,900 --> 00:46:56,810
协议是否仍然提供原子性，要么

961
00:46:56,810 --> 00:46:59,720
两者都做，要么都不做

962
00:46:59,720 --> 00:47:01,490
面对这些失败，以及我们必须如何

963
00:47:01,490 --> 00:47:05,300
调整或扩展协议

964
00:47:05,300 --> 00:47:07,579
以使其做正确的事情，所以

965
00:47:07,579 --> 00:47:08,239
 

966
00:47:08,239 --> 00:47:11,059
我首先要考虑的是崩溃和

967
00:47:11,059 --> 00:47:11,959
r  estarts

968
00:47:11,959 --> 00:47:15,739
我的意思是电源故障或者

969
00:47:15,739 --> 00:47:17,659
只是一些突然停止执行

970
00:47:17,659 --> 00:47:20,269
然后电源恢复，它

971
00:47:20,269 --> 00:47:22,309
恢复了生命并运行了一些可能是

972
00:47:22,309 --> 00:47:26,359
某种恢复软件作为

973
00:47:26,359 --> 00:47:28,729
事务处理

974
00:47:28,729 --> 00:47:32,059
系统的一部分，实际上有两种情况我们必须

975
00:47:32,059 --> 00:47:35,089
担心一个 是 B

976
00:47:35,089 --> 00:47:41,169
在返回它的是消息之前可能已经

977
00:47:41,889 --> 00:47:44,719
崩溃所以 B 在发送它的是

978
00:47:44,719 --> 00:47:48,559
消息之前崩溃然后它从来没有说是

979
00:47:48,559 --> 00:47:50,029
所以事务协调器

980
00:47:50,029 --> 00:47:53,479
不可能已经提交或即将

981
00:47:53,479 --> 00:47:55,489
提交，因为它必须等待

982
00:47:55,489 --> 00:47:57,799
来自所有的是 因此，如果 B 可以

983
00:47:57,799 --> 00:47:58,969
说服自己它不可能

984
00:47:58,969 --> 00:48:02,029
 

985
00:48:02,029 --> 00:48:04,069
在发送 yes 之前发送一个是崩溃的 yes 回复，那么 B

986
00:48:04,069 --> 00:48:06,859
有权单方面中止

987
00:48:06,859 --> 00:48:09,289
事务本身并忘记它，

988
00:48:09,289 --> 00:48:11,119
因为它知道事务

989
00:48:11,119 --> 00:48:15,500
协调器不可能提交 所以

990
00:48:15,500 --> 00:48:18,159
[音乐

991
00:48:18,159 --> 00:48:19,969
] 你知道实现这一可能性的许多方法

992
00:48:19,969 --> 00:48:21,619
 

993
00:48:21,619 --> 00:48:23,809
是所有这些关于

994
00:48:23,809 --> 00:48:25,549
交易的信息 尚未达到这

995
00:48:25,549 --> 00:48:27,979
一点在内存中，它只是丢失了它

996
00:48:27,979 --> 00:48:30,079
B 崩溃并重新启动，因此 B 将不

997
00:48:30,079 --> 00:48:31,939
知道有关

998
00:48:31,939 --> 00:48:35,179
尚未发送 yes 的事务的任何信息，

999
00:48:35,179 --> 00:48:37,099
然后如果事务协调器

1000
00:48:37,099 --> 00:48:39,649
发送准备消息到 一个

1001
00:48:39,649 --> 00:48:41,119
对交易一无所知的参与者，

1002
00:48:41,119 --> 00:48:42,439
因为它在

1003
00:48:42,439 --> 00:48:45,139
发送“是”之前就崩溃了，各方会说不，不，

1004
00:48:45,139 --> 00:48:47,959
我不可能同意你

1005
00:48:47,959 --> 00:48:50,829
知道，请中止

1006
00:48:51,489 --> 00:48:55,099
好吧，但是当然也许 B 在

1007
00:48:55,099 --> 00:49:00,589
发送“是”后崩溃了，所以这有点

1008
00:49:00,589 --> 00:49:02,509
更棘手所以没有在崩溃中

1009
00:49:02,509 --> 00:49:05,479
这不是 B 得到一个准备它很

1010
00:49:05,479 --> 00:49:07,189
高兴它说是的我要提交

1011
00:49:07,189 --> 00:49:09,739
然后它在它从交易雇主协调员那里得到提交消息之前就崩溃

1012
00:49:09,739 --> 00:49:12,049
 

1013
00:49:12,049 --> 00:49:14,599
了现在我们有了

1014
00:49:14,599 --> 00:49:16,789
我们 '处于完全不同的情况下

1015
00:49:16,789 --> 00:49:19,329
，如果被告知 B 承诺这样做，则 B 承诺会提交，

1016
00:49:19,329 --> 00:49:21,770
因为发送一个是的，并且

1017
00:49:21,770 --> 00:49:23,360
众所周知，实际上最有可能

1018
00:49:23,360 --> 00:49:24,530
发生的事情是事务

1019
00:49:24,530 --> 00:49:26,960
协调员从 a 和 B 那里得到是，并且 a

1020
00:49:26,960 --> 00:49:28,670
发送了一个 co 向 a 发送消息，以便 a

1021
00:49:28,670 --> 00:49:31,100
实际上将完成其

1022
00:49:31,100 --> 00:49:32,660
事务的一部分并使其永久化并

1023
00:49:32,660 --> 00:49:35,300
释放锁，在这种情况下，

1024
00:49:35,300 --> 00:49:37,060
为了尊重所有或任何内容，我们绝对

1025
00:49:37,060 --> 00:49:39,860
需要它 B 应该在此时崩溃

1026
00:49:39,860 --> 00:49:42,530
，在恢复时它 仍然

1027
00:49:42,530 --> 00:49:44,660
准备好完成

1028
00:49:44,660 --> 00:49:45,410
交易的

1029
00:49:45,410 --> 00:49:46,460
 

1030
00:49:46,460 --> 00:49:48,140
 

1031
00:49:48,140 --> 00:49:50,030
 

1032
00:49:50,030 --> 00:49:51,110
 

1033
00:49:51,110 --> 00:49:53,210
 

1034
00:49:53,210 --> 00:49:57,110
一部分 我们不能

1035
00:49:57,110 --> 00:49:59,390
在

1036
00:49:59,390 --> 00:50:01,790
崩溃和重启时丢失事务状态的事实

1037
00:50:01,790 --> 00:50:07,580
是，在 B 回复准备之前，它

1038
00:50:07,580 --> 00:50:13,190
必须使事务状态成为

1039
00:50:13,190 --> 00:50:14,780
这种中间事务状态

1040
00:50:14,780 --> 00:50:16,400
，成为所有

1041
00:50:16,400 --> 00:50:17,960
可能必须进行的更改的内存 如果

1042
00:50:17,960 --> 00:50:20,240
有一个中止加上

1043
00:50:20,240 --> 00:50:22,040
所有锁的记录它是如何保持的事务

1044
00:50:22,040 --> 00:50:26,210
它必须使它在磁盘上持久

1045
00:50:26,210 --> 00:50:28,400
它几乎总是在磁盘上的日志中

1046
00:50:28,400 --> 00:50:33,620
所以在 B 之前回答是之前 B

1047
00:50:33,620 --> 00:50:35,930
se 找到 s4 作为对准备消息的回复，

1048
00:50:35,930 --> 00:50:39,680
它首先必须在

1049
00:50:39,680 --> 00:50:42,020
其日志中将提交该事务所需的所有信息写入磁盘，

1050
00:50:42,020 --> 00:50:44,330
即

1051
00:50:44,330 --> 00:50:48,260
put 生成的所有新值加上

1052
00:50:48,260 --> 00:50:51,230
磁盘上的完整锁列表或

1053
00:50:51,230 --> 00:50:53,750
之前的一些其他持久内存 应用

1054
00:50:53,750 --> 00:50:55,880
是，然后如果应该是

1055
00:50:55,880 --> 00:50:58,250
B 是你在理智之后崩溃是的，

1056
00:50:58,250 --> 00:50:59,870
这是恢复的一部分，当它重新启动时，

1057
00:50:59,870 --> 00:51:01,670
看看他的日志，然后说哦，天哪，我

1058
00:51:01,670 --> 00:51:03,140
正处于一个事务的中间，我

1059
00:51:03,140 --> 00:51:06,290
对事务 92 回答了是 我的意思是

1060
00:51:06,290 --> 00:51:07,790
你知道

1061
00:51:07,790 --> 00:51:09,410
如果提交它应该做的所有修改以及

1062
00:51:09,410 --> 00:51:10,250
它持有的所有锁

1063
00:51:10,250 --> 00:51:13,760
我最好恢复那个状态然后

1064
00:51:13,760 --> 00:51:15,740
当他最终得到一个承诺或

1065
00:51:15,740 --> 00:51:17,900
中止它会从阅读它的

1066
00:51:17,900 --> 00:51:20,210
日志中知道如何实际完成它的部分

1067
00:51:20,210 --> 00:51:23,060
因此，这是

1068
00:51:23,060 --> 00:51:24,970
我

1069
00:51:24,970 --> 00:51:29,510
在该协议的原始布局中遗漏的重要内容

1070
00:51:29,510 --> 00:51:32,750
，即此时 B 必须写入其磁盘

1071
00:51:32,750 --> 00:51:34,230
 

1072
00:51:34,230 --> 00:51:36,510
，这是使两阶段

1073
00:51:36,510 --> 00:51:39,000
提交有点慢的部分原因是 t 帽子这里有

1074
00:51:39,000 --> 00:51:41,040
这些必要的信息持久性

1075
00:51:41,040 --> 00:51:47,400
好吧，所以我们也不得不

1076
00:51:47,400 --> 00:51:50,580
担心好吧，你知道最后一个

1077
00:51:50,580 --> 00:51:51,900
地方我猜你可能崩溃的地方是

1078
00:51:51,900 --> 00:51:54,359
你可能会崩溃是我在

1079
00:51:54,359 --> 00:51:58,250
收到提交后崩溃或者在两者之后

1080
00:51:58,250 --> 00:52:00,180
你可能会在实际处理后崩溃

1081
00:52:00,180 --> 00:52:02,250
提交，但在这种

1082
00:52:02,250 --> 00:52:06,359
情况下，它已经修改了

1083
00:52:06,359 --> 00:52:08,820
事务意味着在其数据库中永久保存，

1084
00:52:08,820 --> 00:52:12,109
大概也在磁盘

1085
00:52:12,109 --> 00:52:15,150
上，在它收到提交

1086
00:52:15,150 --> 00:52:16,950
消息之后，在这种情况下，

1087
00:52:16,950 --> 00:52:18,660
如果它重新启动，可能没有任何事情可做，

1088
00:52:18,660 --> 00:52:20,600
因为事务完成了所以

1089
00:52:20,600 --> 00:52:23,850
当 B 收到提交消息时，它

1090
00:52:23,850 --> 00:52:28,070
可能会将

1091
00:52:28,070 --> 00:52:29,910
其登录中的修改副本写入其

1092
00:52:29,910 --> 00:52:32,780
永久存储释放此锁

1093
00:52:32,780 --> 00:52:34,710
会擦除有关

1094
00:52:34,710 --> 00:52:36,180
几个月日志事务的信息，然后

1095
00:52:36,180 --> 00:52:38,970
回复，当然我们必须

1096
00:52:38,970 --> 00:52:40,859
担心你知道如果它收到会发生什么

1097
00:52:40,859 --> 00:52:43,680
两次提交消息可能正确

1098
00:52:43,680 --> 00:52:45,840
的做法是让 B

1099
00:52:45,840 --> 00:52:48,600
记住需要内存的事务

1100
00:52:48,600 --> 00:52:51,480
所以事实证明，它 B 只是忘记

1101
00:52:51,480 --> 00:52:53,100
了它

1102
00:52:53,100 --> 00:52:56,400
在磁盘上持久的已提交事务，

1103
00:52:56,400 --> 00:52:58,740
如果它不

1104
00:52:58,740 --> 00:53:00,330
知道该事务的任何内容，它可以通过

1105
00:53:00,330 --> 00:53:03,420
简单地再次确认它来回复重复的提交消息，

1106
00:53:03,420 --> 00:53:04,950
这将是一个重要的一点

1107
00:53:04,950 --> 00:53:08,250
稍后好，这就是其中

1108
00:53:08,250 --> 00:53:10,320
一个参与者在各种

1109
00:53:10,320 --> 00:53:12,930
尴尬点崩溃的故事，

1110
00:53:12,930 --> 00:53:14,640
事务协调器呢？它也只是一

1111
00:53:14,640 --> 00:53:16,470
台计算机，对不起，你知道它是否

1112
00:53:16,470 --> 00:53:26,060
失败可能是一个问题，好吧，所以

1113
00:53:26,060 --> 00:53:29,460
事情开始变得

1114
00:53:29,460 --> 00:53:32,730
关键的关键是 如果任何一方可能已经

1115
00:53:32,730 --> 00:53:36,900
提交，那么我们不能忘记

1116
00:53:36,900 --> 00:53:39,359
，如果这些参与者中的任何一个

1117
00:53:39,359 --> 00:53:41,369
可能已经提交，或者

1118
00:53:41,369 --> 00:53:43,200
事务协调器可能已经

1119
00:53:43,200 --> 00:53:47,500
回复了客户端，那么

1120
00:53:47,500 --> 00:53:50,830
如果 a 被提交，我们就不能让该事务立即消失，

1121
00:53:50,830 --> 00:53:52,840
但它的事务可能

1122
00:53:52,840 --> 00:53:54,310
是 coordinator 向 a 发送了一条提交

1123
00:53:54,310 --> 00:53:56,050
消息，但还没有

1124
00:53:56,050 --> 00:53:58,240
发送一个承诺

1125
00:53:58,240 --> 00:53:59,770
，即此时该事务的崩溃

1126
00:53:59,770 --> 00:54:02,560
协调器必须在重新启动时准备好

1127
00:54:02,560 --> 00:54:05,230
重新发送提交消息，以

1128
00:54:05,230 --> 00:54:08,290
确保双方都知道

1129
00:54:08,290 --> 00:54:14,710
事务已提交，所以您

1130
00:54:14,710 --> 00:54:16,090
知道这是否重要

1131
00:54:16,090 --> 00:54:17,140
取决于事务协调

1132
00:54:17,140 --> 00:54:20,050
器在发送提交消息之前崩溃的位置。

1133
00:54:20,050 --> 00:54:21,910
 

1134
00:54:21,910 --> 00:54:24,760
如果您知道任何一方都没有关系，因为

1135
00:54:24,760 --> 00:54:26,620
事务协调器

1136
00:54:26,620 --> 00:54:29,140
在崩溃之前没有发送提交消息，它

1137
00:54:29,140 --> 00:54:33,120
可以中止事务，并且如果任何一个

1138
00:54:33,120 --> 00:54:35,290
参与者询问该事务，

1139
00:54:35,290 --> 00:54:36,670
因为他们知道在他们的日志中看到它，

1140
00:54:36,670 --> 00:54:38,320
但他们从未收到提交

1141
00:54:38,320 --> 00:54:40,570
消息 事务协调器可以说

1142
00:54:40,570 --> 00:54:41,230
我对该事务一无所知，

1143
00:54:41,230 --> 00:54:43,270
它

1144
00:54:43,270 --> 00:54:46,150
可能由于崩溃而被中止，所以

1145
00:54:46,150 --> 00:54:47,680
如果事务协调器

1146
00:54:47,680 --> 00:54:50,350
在提交之前崩溃但如果

1147
00:54:50,350 --> 00:54:52,570
在发送一个或多个提交消息后崩溃，

1148
00:54:52,570 --> 00:54:59,950
那么它无法防御

1149
00:54:59,950 --> 00:55:02,170
不能让行动协调员

1150
00:55:02,170 --> 00:55:05,320
忘记交易，

1151
00:55:05,320 --> 00:55:08,260
这意味着什么

1152
00:55:08,260 --> 00:55:09,700
当事务协调器

1153
00:55:09,700 --> 00:55:11,920
 

1154
00:55:11,920 --> 00:55:13,690
 

1155
00:55:13,690 --> 00:55:16,060
在发送任何提交消息之前根据这些是/否投票做出提交与中止决定时，

1156
00:55:16,060 --> 00:55:20,100
它必须首先将

1157
00:55:20,100 --> 00:55:22,960
有关事务的信息写入其在

1158
00:55:22,960 --> 00:55:26,140
持久存储中的登录信息，如

1159
00:55:26,140 --> 00:55:27,850
磁盘 如果它崩溃并

1160
00:55:27,850 --> 00:55:30,760
重新启动，那么事务协调器

1161
00:55:30,760 --> 00:55:32,800
在收到一整套“是”或“否”

1162
00:55:32,800 --> 00:55:35,680
后将结果和

1163
00:55:35,680 --> 00:55:38,020
事务 ID 写入磁盘上的日志，

1164
00:55:38,020 --> 00:55:40,060
然后才开始发送提交

1165
00:55:40,060 --> 00:55:41,920
消息，如果崩溃发生在

1166
00:55:41,920 --> 00:55:45,640
任何时候 可能在第一个提交消息结束之前，

1167
00:55:45,640 --> 00:55:47,710
或者在它发送一个之后，或者

1168
00:55:47,710 --> 00:55:49,570
甚至在发送所有这些消息之后，如果它

1169
00:55:49,570 --> 00:55:51,640
崩溃了，那么它的恢复软件

1170
00:55:51,640 --> 00:55:53,980
将在日志 AHA 中看到该

1171
00:55:53,980 --> 00:55:55,630
事务处于事务中间，该

1172
00:55:55,630 --> 00:55:57,880
事务要么已知有 已提交

1173
00:55:57,880 --> 00:55:59,470
或中止，

1174
00:55:59,470 --> 00:56:01,590
并且作为恢复的一部分，它将

1175
00:56:01,590 --> 00:56:04,349
向所有参与者重新发送提交消息

1176
00:56:04,349 --> 00:56:06,940
或中止消息，无论决定

1177
00:56:06,940 --> 00:56:10,420
是什么，以防它没有发送 t 在

1178
00:56:10,420 --> 00:56:12,390
它崩溃之前下摆，这就是为什么

1179
00:56:12,390 --> 00:56:14,520
参与者必须准备

1180
00:56:14,520 --> 00:56:24,540
好接收重复的提交消息的原因之一，

1181
00:56:27,450 --> 00:56:31,080
所以还有一些其他的所以这些是

1182
00:56:31,080 --> 00:56:34,119
主要的崩溃故事我们还必须

1183
00:56:34,119 --> 00:56:35,980
担心如果消息

1184
00:56:35,980 --> 00:56:37,510
在您可能发送的网络中丢失会发生什么 一条消息

1185
00:56:37,510 --> 00:56:39,609
也许消息从未到达那里您

1186
00:56:39,609 --> 00:56:40,990
可能会发送一条消息并

1187
00:56:40,990 --> 00:56:44,470
等待回复也许回复已发送但

1188
00:56:44,470 --> 00:56:45,880
回复已被丢弃，因此这些

1189
00:56:45,880 --> 00:56:47,800
消息中的任何一条都可能被丢弃，需要

1190
00:56:47,800 --> 00:56:52,030
考虑在

1191
00:56:52,030 --> 00:56:56,080
每个消息中实际执行的操作 在这些情况下，例如，

1192
00:56:56,080 --> 00:56:57,490
假设事务协调员

1193
00:56:57,490 --> 00:57:00,040
发送了准备消息，但没有

1194
00:57:00,040 --> 00:57:02,260
得到参与者的一些是或否答复

1195
00:57:02,260 --> 00:57:04,270
 

1196
00:57:04,270 --> 00:57:06,070
，此时事务协调员的选项

1197
00:57:06,070 --> 00:57:08,650
是什么，我可以做的一件事是

1198
00:57:08,650 --> 00:57:11,680
发送一组新的准备 消息说

1199
00:57:11,680 --> 00:57:13,240
你知道我没有得到你的答案，请

1200
00:57:13,240 --> 00:57:15,700
告诉我你的答案是或否，你

1201
00:57:15,700 --> 00:57:17,020
知道我可以继续这样做一段

1202
00:57:17,020 --> 00:57:20,320
时间，但如果其中一个游击队员

1203
00:57:20,320 --> 00:57:21,400
是 wn 很长一段时间，我们不想

1204
00:57:21,400 --> 00:57:24,970
坐在那里等待持有正确的锁，

1205
00:57:24,970 --> 00:57:27,130
因为您知道假设 a

1206
00:57:27,130 --> 00:57:30,190
没有响应但 B 已启动但

1207
00:57:30,190 --> 00:57:31,960
因为我们尚未提交或中止

1208
00:57:31,960 --> 00:57:33,460
B 仍持有锁，这可能会

1209
00:57:33,460 --> 00:57:35,230
导致其他 交易正在等待，

1210
00:57:35,230 --> 00:57:37,690
所以如果我们可以避免它，我们不想永远等待

1211
00:57:37,690 --> 00:57:39,849
，所以如果

1212
00:57:39,849 --> 00:57:41,530
交易协调员

1213
00:57:41,530 --> 00:57:43,930
在一段时间后没有从参与者那里得到是或否的回应，

1214
00:57:43,930 --> 00:57:47,589
那么它可以

1215
00:57:47,589 --> 00:57:49,810
简单地单方面决定我们要

1216
00:57:49,810 --> 00:57:52,060
中止这个事务，因为它知道，

1217
00:57:52,060 --> 00:57:54,099
因为它没有得到一整套是或

1218
00:57:54,099 --> 00:57:55,750
否的消息，当然

1219
00:57:55,750 --> 00:57:57,430
不可能发送提交，所以没有

1220
00:57:57,430 --> 00:58:00,250
参与者可以提交，所以

1221
00:58:00,250 --> 00:58:03,310
如果事务协调器没有，则中止总是有效

1222
00:58:03,310 --> 00:58:05,920
的 t 尚未提交，因此

1223
00:58:05,920 --> 00:58:07,089
事务协调器超时

1224
00:58:07,089 --> 00:58:09,099
等待是或否 x' 此

1225
00:58:09,099 --> 00:58:11,109
消息丢失或有人崩溃或

1226
00:58:11,109 --> 00:58:12,150
其他事情

1227
00:58:12,150 --> 00:58:13,410
它可以决定好的我们正在

1228
00:58:13,410 --> 00:58:15,270
中止此事务我们将

1229
00:58:15,270 --> 00:58:17,760
发出一轮中止我 ssages，如果某个

1230
00:58:17,760 --> 00:58:19,200
参与者复活并说

1231
00:58:19,200 --> 00:58:21,270
哦，你知道我没有收到你

1232
00:58:21,270 --> 00:58:25,680
关于事务 95 的回复，事务

1233
00:58:25,680 --> 00:58:26,789
协调员会看到你，哦，好吧，我

1234
00:58:26,789 --> 00:58:28,200
对事务 95 一无所知，

1235
00:58:28,200 --> 00:58:30,809
因为它中止了它并删除了它的

1236
00:58:30,809 --> 00:58:32,700
状态 对于该事务，它会

1237
00:58:32,700 --> 00:58:35,010
告诉参与者你知道你应该

1238
00:58:35,010 --> 00:58:42,329
同样中止这个事务，如果

1239
00:58:42,329 --> 00:58:44,190
其中一个

1240
00:58:44,190 --> 00:58:47,279
参与者在这里等待准备者超时，那么你

1241
00:58:47,279 --> 00:58:49,589
知道参与者没有收到

1242
00:58:49,589 --> 00:58:51,539
准备者，这意味着它没有发送是

1243
00:58:51,539 --> 00:58:53,160
消息返回，这意味着

1244
00:58:53,160 --> 00:58:54,900
协调器不可能发送任何

1245
00:58:54,900 --> 00:58:55,799
提交消息，

1246
00:58:55,799 --> 00:58:58,049
所以如果参与者在这里

1247
00:58:58,049 --> 00:58:59,849
等待准备者，它也

1248
00:58:59,849 --> 00:59:03,119
总是被允许退出并

1249
00:59:03,119 --> 00:59:05,400
决定中止事务，如果

1250
00:59:05,400 --> 00:59:07,079
是将来某个时间事务

1251
00:59:07,079 --> 00:59:09,210
协调器来 恢复生命并

1252
00:59:09,210 --> 00:59:11,940
发送准备者消息，然后 B 会说不，

1253
00:59:11,940 --> 00:59:12,839
我对该交易一无所知，

1254
00:59:12,839 --> 00:59:15,270
所以我投反对票，

1255
00:59:15,270 --> 00:59:16,859
没关系，因为它不能

1256
00:59:16,859 --> 00:59:19,799
 

1257
00:59:19,799 --> 00:59:21,450
如果网络出现问题

1258
00:59:21,450 --> 00:59:22,799
或事务协调

1259
00:59:22,799 --> 00:59:24,359
器关闭了一段时间

1260
00:59:24,359 --> 00:59:26,460
并且参与者仍在

1261
00:59:26,460 --> 00:59:29,279
等待准备，那么

1262
00:59:29,279 --> 00:59:31,020
参与者中止并因此

1263
00:59:31,020 --> 00:59:32,549
释放其他

1264
00:59:32,549 --> 00:59:34,950
事务可能的锁总是有效的 等待，这

1265
00:59:34,950 --> 00:59:38,660
在繁忙的系统中可能非常重要，

1266
00:59:39,589 --> 00:59:44,460
所以这是一个好消息，如果

1267
00:59:44,460 --> 00:59:45,630
参与者或事务

1268
00:59:45,630 --> 00:59:47,250
协调器超时等待

1269
00:59:47,250 --> 00:59:52,819
来自其他方的消息，但是

1270
00:59:52,819 --> 00:59:56,609
假设参与者 B 已经收到一个

1271
00:59:56,609 --> 01:00:00,299
准备者并发送了它的是，所以在

1272
01:00:00,299 --> 01:00:01,980
在这附近的某个地方，但它还没有

1273
01:00:01,980 --> 01:00:03,510
收到提交，它正在等待和

1274
01:00:03,510 --> 01:00:05,099
等待，它还没有得到

1275
01:00:05,099 --> 01:00:06,750
提交可能是网络出了问题，

1276
01:00:06,750 --> 01:00:08,730
也许事务

1277
01:00:08,730 --> 01:00:10,859
协调器是它的网络

1278
01:00:10,859 --> 01:00:13,020
连接断开了，或者它的权力失败了，或者

1279
01:00:13,020 --> 01:00:14,640
其他什么 不管什么原因 B

1280
01:00:14,640 --> 01:00:15,990
等待了很长时间，它现在仍然没有

1281
01:00:15,990 --> 01:00:18,150
听到提交，但它坐在

1282
01:00:18,150 --> 01:00:19,890
那里拿着 lo  cks 仍然

1283
01:00:19,890 --> 01:00:21,599
为所有已使用的记录保留这些锁

1284
01:00:21,599 --> 01:00:22,650
，它是事务的一部分

1285
01:00:22,650 --> 01:00:24,059
，这意味着其他

1286
01:00:24,059 --> 01:00:25,650
事务也可能被

1287
01:00:25,650 --> 01:00:27,660
阻塞，等待这些锁被

1288
01:00:27,660 --> 01:00:30,480
释放，所以

1289
01:00:30,480 --> 01:00:32,940
如果可能的话，我们非常渴望边界 可以或释放

1290
01:00:32,940 --> 01:00:35,309
锁，所以问题是如果 B 已

1291
01:00:35,309 --> 01:00:37,890
收到准备并回答是，

1292
01:00:37,890 --> 01:00:40,349
 

1293
01:00:40,349 --> 01:00:42,960
则在等待说您知道 10

1294
01:00:42,960 --> 01:00:45,359
秒或 10 分钟或其他时间后，您无权单方面中止以

1295
01:00:45,359 --> 01:00:48,690
获取提交消息和答案

1296
01:00:48,690 --> 01:00:54,180
，不幸的是 在这个区域中是 no

1297
01:00:54,180 --> 01:00:56,760
在收到准备之后我们真的出去了

1298
01:00:56,760 --> 01:00:58,950
在发送是之后并且在

1299
01:00:58,950 --> 01:01:01,740
获得提交之前它是你的时间

1300
01:01:01,740 --> 01:01:06,270
等待提交你

1301
01:01:06,270 --> 01:01:08,160
不允许中止你必须继续等待

1302
01:01:08,160 --> 01:01:12,240
你通常必须调用 block 所以在这个

1303
01:01:12,240 --> 01:01:14,250
协议的区域如果你没有

1304
01:01:14,250 --> 01:01:15,420
收到提交，你必须

1305
01:01:15,420 --> 01:01:17,930
无限期地等待，原因是

1306
01:01:17,930 --> 01:01:21,539
因为被发回是，这意味着

1307
01:01:21,539 --> 01:01:22,950
事务协调器可能已经

1308
01:01:22,950 --> 01:01:24,539
收到了它可能会h 已经

1309
01:01:24,539 --> 01:01:26,789
收到所有参与者的“是”，它

1310
01:01:26,789 --> 01:01:28,260
可能已经开始

1311
01:01:28,260 --> 01:01:30,599
向某些参与者发送提交消息，

1312
01:01:30,599 --> 01:01:32,730
这意味着 a 可能实际上已经看到

1313
01:01:32,730 --> 01:01:34,140
了提交消息并已提交，

1314
01:01:34,140 --> 01:01:35,849
并使我们永久更改并解锁

1315
01:01:35,849 --> 01:01:37,470
并显示对其他事务的更改

1316
01:01:37,470 --> 01:01:39,539
并且由于

1317
01:01:39,539 --> 01:01:42,119
B 在协议的该区域中知道的所有 B 都可能是这种情况，

1318
01:01:42,119 --> 01:01:44,490
因此 B 不能单方面

1319
01:01:44,490 --> 01:01:47,039
决定在超时时中止它必须

1320
01:01:47,039 --> 01:01:49,950
无限期地等待

1321
01:01:49,950 --> 01:01:51,660
事务协调器的消息，只要它

1322
01:01:51,660 --> 01:01:54,420
可能需要一些人来

1323
01:01:54,420 --> 01:01:56,400
修复 事务协调器，

1324
01:01:56,400 --> 01:01:57,930
最后让它重新启动，让它

1325
01:01:57,930 --> 01:02:00,690
读取这个日志，看看哦，是的，你

1326
01:02:00,690 --> 01:02:02,400
提交了那个事务，最后

1327
01:02:02,400 --> 01:02:13,619
发送了很长的延迟提交消息，所以

1328
01:02:13,619 --> 01:02:23,880
同样地，如果有一次我你不能，你

1329
01:02:23,880 --> 01:02:25,920
不能单方面中止它轮流

1330
01:02:25,920 --> 01:02:27,390
你也不能单方面做出承诺，

1331
01:02:27,390 --> 01:02:29,849
因为 B 知道，a 可能

1332
01:02:29,849 --> 01:02:31,799
投了反对票，但他还没有得到

1333
01:02:31,799 --> 01:02:33,539
重要信息，所以你可以在

1334
01:02:33,539 --> 01:02:35,940
这个 regi 你可以

1335
01:02:35,940 --> 01:02:36,890
 

1336
01:02:36,890 --> 01:02:44,000
在超时时中止或提交，所以实际上

1337
01:02:44,000 --> 01:02:47,870
这种阻塞行为

1338
01:02:47,870 --> 01:02:51,070
是两阶段提交的关键属性

1339
01:02:51,070 --> 01:02:53,810
，它不是一个令人愉快的属性，

1340
01:02:53,810 --> 01:02:56,780
这意味着如果出现问题，你

1341
01:02:56,780 --> 01:02:58,070
很容易处于你

1342
01:02:58,070 --> 01:02:59,570
有的情况 等待很长时间持有锁

1343
01:02:59,570 --> 01:03:01,940
并阻止其他事务

1344
01:03:01,940 --> 01:03:05,420
等等，除此之外，人们

1345
01:03:05,420 --> 01:03:08,180
非常努力地使

1346
01:03:08,180 --> 01:03:10,730
两阶段提交的这部分行为尽可能快地

1347
01:03:10,730 --> 01:03:13,520
进行，以便失败可能导致的时间窗口

1348
01:03:13,520 --> 01:03:17,060
你

1349
01:03:17,060 --> 01:03:20,510
用锁来阻塞很长时间是

1350
01:03:20,510 --> 01:03:22,040
尽可能小，所以他们试图使

1351
01:03:22,040 --> 01:03:23,300
这部分协议非常

1352
01:03:23,300 --> 01:03:26,270
轻量级，甚至有

1353
01:03:26,270 --> 01:03:27,950
协议的变体，在某些特殊情况下

1354
01:03:27,950 --> 01:03:33,590
可能根本不需要等待，所以

1355
01:03:33,590 --> 01:03:37,430
这就是 基本协议

1356
01:03:37,430 --> 01:03:41,360
关于这一点需要注意的一件事，这

1357
01:03:41,360 --> 01:03:44,060
是为什么我们能够

1358
01:03:44,060 --> 01:03:46,820
实际构建一个协议的基本部分，该协议允许 a

1359
01:03:46,820 --> 01:03:49,670
和 B 排序你知道他们都

1360
01:03:49,670 --> 01:03:53,060
提交或者他们都拥有或中止一个

1361
01:03:53,060 --> 01:03:54,770
这样做的原因是，实际上

1362
01:03:54,770 --> 01:03:56,930
决定是由一个实体

1363
01:03:56,930 --> 01:03:58,100
做出的，它是由事务协调员单独做出的，

1364
01:03:58,100 --> 01:04:01,640
a 和 B 都不是你

1365
01:04:01,640 --> 01:04:05,150
知道的，除了他们投票否决，a

1366
01:04:05,150 --> 01:04:09,410
和 B 都没有决定是否提交

1367
01:04:09,410 --> 01:04:11,900
，他们当然是

1368
01:04:11,900 --> 01:04:13,640
彼此之间没有进行对话以试图

1369
01:04:13,640 --> 01:04:15,500
就对方的想法达成一致，

1370
01:04:15,500 --> 01:04:17,090
或者他们认为提交

1371
01:04:17,090 --> 01:04:19,760
可能都是承诺，相反，我们有

1372
01:04:19,760 --> 01:04:22,640
这么多是一种非常

1373
01:04:22,640 --> 01:04:25,610
简单的协议，其中只有

1374
01:04:25,610 --> 01:04:27,050
事务协调员做出

1375
01:04:27,050 --> 01:04:29,150
决定 单一实体，它只是

1376
01:04:29,150 --> 01:04:31,340
告诉另一方这是我的决定，

1377
01:04:31,340 --> 01:04:38,390
请去做吧，因为

1378
01:04:38,390 --> 01:04:39,790
让交易协调员

1379
01:04:39,790 --> 01:04:42,200
真的是单一实体再次做出最终

1380
01:04:42,200 --> 01:04:45,320
决定，这是你必须阻止的事实，

1381
01:04:45,320 --> 01:04:46,700
有些地方

1382
01:04:46,700 --> 01:04:47,960
你必须 等待

1383
01:04:47,960 --> 01:04:49,640
交易记录协调员

1384
01:04:49,640 --> 01:04:50,630
告诉你决定

1385
01:04:50,630 --> 01:04:58,009
是什么 另一个问题是我们

1386
01:04:58,009 --> 01:04:59,329
知道交易协调员 mu  st

1387
01:04:59,329 --> 01:05:02,059
记住有关事务

1388
01:05:02,059 --> 01:05:05,450
及其日志的信息，以防它崩溃，因此

1389
01:05:05,450 --> 01:05:06,890
一个问题是事务

1390
01:05:06,890 --> 01:05:10,039
协调器何时可以忘记

1391
01:05:10,039 --> 01:05:11,779
其日志中有关事务的信息，而对此的

1392
01:05:11,779 --> 01:05:14,029
答案是，如果它设法

1393
01:05:14,029 --> 01:05:16,400
从参与者那里获得一整套确认

1394
01:05:16,400 --> 01:05:18,559
然后它知道

1395
01:05:18,559 --> 01:05:19,970
所有参与者都知道该

1396
01:05:19,970 --> 01:05:22,250
事务已提交或中止，

1397
01:05:22,250 --> 01:05:24,259
所有参与者都不

1398
01:05:24,259 --> 01:05:25,819
知道该事务的命运并且

1399
01:05:25,819 --> 01:05:27,559
已在其中完成了自己的职责，并且

1400
01:05:27,559 --> 01:05:29,059
永远不需要知道该信息的

1401
01:05:29,059 --> 01:05:31,160
权利，因为他们都承认了这一点，所以

1402
01:05:31,160 --> 01:05:33,349
当 事务协调器获得

1403
01:05:33,349 --> 01:05:35,150
确认，它可以删除所有

1404
01:05:35,150 --> 01:05:39,430
信息，所有事务的内存，

1405
01:05:39,519 --> 01:05:42,079
同样，参与者一旦

1406
01:05:42,079 --> 01:05:44,299
收到提交或中止消息并

1407
01:05:44,299 --> 01:05:46,160
完成了他们的事务部分，

1408
01:05:46,160 --> 01:05:48,049
并使他们的更新永久化并

1409
01:05:48,049 --> 01:05:50,329
在那时释放他们的锁，

1410
01:05:50,329 --> 01:05:53,180
参与者也可以完全

1411
01:05:53,180 --> 01:05:57,589
忘记这一点 在他们将

1412
01:05:57,589 --> 01:05:59,140
确认发送回 t 后进行交易 他的

1413
01:05:59,140 --> 01:06:01,880
事务协调器现在

1414
01:06:01,880 --> 01:06:03,950
当然事务协调器可能不会得到

1415
01:06:03,950 --> 01:06:05,599
他们的确认，并且可能会发送并

1416
01:06:05,599 --> 01:06:07,819
因此可能决定重新发送

1417
01:06:07,819 --> 01:06:09,349
提交消息，理论可能是

1418
01:06:09,349 --> 01:06:11,569
它可能丢失了，在这种情况下，

1419
01:06:11,569 --> 01:06:13,039
如果参与者收到一个事务的提交

1420
01:06:13,039 --> 01:06:14,960
消息， 它

1421
01:06:14,960 --> 01:06:16,940
一无所知，因为它已经忘记

1422
01:06:16,940 --> 01:06:21,410
了，然后参与者可以

1423
01:06:21,410 --> 01:06:22,700
发送另一个确认，

1424
01:06:22,700 --> 01:06:25,700
因为它知道它收到

1425
01:06:25,700 --> 01:06:27,230
了一个未知事务的提交消息，它

1426
01:06:27,230 --> 01:06:28,579
一定是因为它已经忘记了

1427
01:06:28,579 --> 01:06:30,319
它，因为它已经知道它是

1428
01:06:30,319 --> 01:06:37,759
提交还是中止了 所以这

1429
01:06:37,759 --> 01:06:41,799
是原子提交的两阶段提交，

1430
01:06:41,799 --> 01:06:44,450
从一个小角度来看，两阶段

1431
01:06:44,450 --> 01:06:47,960
提交用于许多分片

1432
01:06:47,960 --> 01:06:50,539
数据库中，这些分片数据库已经在多个服务器之间分割了它们的数据

1433
01:06:50,539 --> 01:06:54,049
，它

1434
01:06:54,049 --> 01:06:58,519
专门用于需要支持事务的数据库或存储

1435
01:06:58,519 --> 01:07:00,309
系统中

1436
01:07:00,309 --> 01:07:03,319
 

1437
01:07:03,319 --> 01:07:03,970
 

1438
01:07:03,970 --> 01:07:06,310
可以读取或写入多个记录的记录有

1439
01:07:06,310 --> 01:07:09,010
很多更专业的s

1440
01:07:09,010 --> 01:07:12,640
不允许您

1441
01:07:12,640 --> 01:07:15,369
在多条记录上进行事务的存储系统，对于

1442
01:07:15,369 --> 01:07:17,140
它们，您不需要它，您不需要

1443
01:07:17,140 --> 01:07:18,760
这种，

1444
01:07:18,760 --> 01:07:22,000
如果存储系统不允许

1445
01:07:22,000 --> 01:07:24,609
多记录事务，则不需要两阶段提交，但是 如果你

1446
01:07:24,609 --> 01:07:26,320
有多记录事务并且你

1447
01:07:26,320 --> 01:07:28,000
在多个服务器上分片数据，

1448
01:07:28,000 --> 01:07:30,160
那么你需要支持任何一种

1449
01:07:30,160 --> 01:07:31,599
牙膏

1450
01:07:31,599 --> 01:07:34,240
如果你想获得资产交易，你需​​要支持两次同步提交

1451
01:07:34,240 --> 01:07:36,150
 

1452
01:07:36,150 --> 01:07:39,130
但是两阶段提交有一个邪恶的

1453
01:07:39,130 --> 01:07:43,869
名声，一个原因是它很慢

1454
01:07:43,869 --> 01:07:45,490
由于多轮消息，这里有

1455
01:07:45,490 --> 01:07:48,270
很多闲聊，以便获得

1456
01:07:48,270 --> 01:07:50,560
涉及多个

1457
01:07:50,560 --> 01:07:53,619
参与者来完成他们的事务，

1458
01:07:53,619 --> 01:07:55,300
此外，a 和

1459
01:07:55,300 --> 01:07:58,390
B 都必须进行大量磁盘写入，而不仅仅是

1460
01:07:58,390 --> 01:08:01,119
在准备和准备之间将数据写入他们的磁盘

1461
01:08:01,119 --> 01:08:02,619
发送是的，他们必须等待

1462
01:08:02,619 --> 01:08:04,840
磁盘速率完成，所以如果

1463
01:08:04,840 --> 01:08:06,400
您使用的是机械驱动器，它

1464
01:08:06,400 --> 01:08:09,130
需要 10 毫秒才能附加到

1465
01:08:09,130 --> 01:08:11,680
日志，这对

1466
01:08:11,680 --> 01:08:14,500
如何 快速的参与者可以处理

1467
01:08:14,500 --> 01:08:16,630
你知道的交易 10 毫秒一个

1468
01:08:16,630 --> 01:08:19,719
pop 意味着不，没有一些聪明，

1469
01:08:19,719 --> 01:08:21,430
你被限制为每秒 100 个交易，

1470
01:08:21,430 --> 01:08:23,859
这非常慢，

1471
01:08:23,859 --> 01:08:25,149
此外，交易协调器

1472
01:08:25,149 --> 01:08:28,810
还有一个点，它必须

1473
01:08:28,810 --> 01:08:30,969
在收到最后一个是他们 必须首先

1474
01:08:30,969 --> 01:08:33,430
写入其日志以确保数据

1475
01:08:33,430 --> 01:08:35,799
在磁盘上是安全的，然后才

1476
01:08:35,799 --> 01:08:38,439
允许发送该提交消息，

1477
01:08:38,439 --> 01:08:41,380
这又是 10 毫秒，这

1478
01:08:41,380 --> 01:08:43,029
两个都是 10 毫秒的时间段，

1479
01:08:43,029 --> 01:08:45,279
其中参与者持有锁

1480
01:08:45,279 --> 01:08:47,469
，其他事务是 放慢了速度，

1481
01:08:47,469 --> 01:08:48,790
我一直提到这一点，但这非常

1482
01:08:48,790 --> 01:08:51,310
重要，因为在繁忙的事务

1483
01:08:51,310 --> 01:08:53,020
处理系统中，有很多

1484
01:08:53,020 --> 01:08:55,870
很多事务，其中许多可能正在

1485
01:08:55,870 --> 01:08:57,729
等待相同的数据，我们

1486
01:08:57,729 --> 01:09:01,120
真的不希望长时间持有锁

1487
01:09:01,120 --> 01:09:02,890
其中有

1488
01:09:02,890 --> 01:09:04,988
很多消息来回传递，

1489
01:09:04,988 --> 01:09:06,960
然后我们必须等待很长时间的耻辱，

1490
01:09:06,960 --> 01:09:09,819
但是两阶段提交迫使我们做

1491
01:09:09,819 --> 01:09:12,210
这些权重

1492
01:09:13,569 --> 01:09:16,540
和 另一个问题是，如果

1493
01:09:16,540 --> 01:09:18,189
出现任何问题，消息会丢失，

1494
01:09:18,189 --> 01:09:21,670
某些东西会崩溃，然后如果你不是，如果

1495
01:09:21,670 --> 01:09:23,560
你有点不走运，那么

1496
01:09:23,560 --> 01:09:25,149
参与者必须等待很长时间

1497
01:09:25,149 --> 01:09:26,618
 

1498
01:09:26,618 --> 01:09:30,399
才能持有锁，因此面对提交你真的

1499
01:09:30,399 --> 01:09:32,349
只有 在单个组织内的单个机房内相对较小的域中看到它

1500
01:09:32,349 --> 01:09:34,210
 

1501
01:09:34,210 --> 01:09:36,819
您看

1502
01:09:36,819 --> 01:09:39,670
不到它 例如您是否

1503
01:09:39,670 --> 01:09:42,219
在不同银行之间的银行之间

1504
01:09:42,219 --> 01:09:44,399
进行转账 如果它绘制了它的数据库，您可能会在银行内看到它，

1505
01:09:44,399 --> 01:09:47,349
但您

1506
01:09:47,349 --> 01:09:48,939
永远不会看到两个 它可以

1507
01:09:48,939 --> 01:09:52,000
在

1508
01:09:52,000 --> 01:09:53,889
可能由于这种阻塞业务而在物理上分开的不同组织之间运行的天数

1509
01:09:53,889 --> 01:09:56,320
你不想

1510
01:09:56,320 --> 01:09:58,900
让你的命运知道你的数据库

1511
01:09:58,900 --> 01:10:00,610
以及它是否在

1512
01:10:00,610 --> 01:10:02,980
其他组织手中运行，

1513
01:10:02,980 --> 01:10:04,929
它们在错误的时间崩溃了你 '

1514
01:10:04,929 --> 01:10:07,389
被迫你的数据库被迫持有

1515
01:10:07,389 --> 01:10:12,730
锁很长一段时间，因为

1516
01:10:12,730 --> 01:10:15,460
它太慢了，也有很多

1517
01:10:15,460 --> 01:10:19,179
研究已经进入了要么使它成为

1518
01:10:19,179 --> 01:10:21,969
fa  st 或以各种方式放宽规则

1519
01:10:21,969 --> 01:10:24,389
以允许更快或

1520
01:10:24,389 --> 01:10:27,520
专门针对非常

1521
01:10:27,520 --> 01:10:31,179
特定的情况进行两阶段提交，在这些情况下，您知道

1522
01:10:31,179 --> 01:10:33,190
您可以删除消息或写入

1523
01:10:33,190 --> 01:10:34,570
磁盘或其他内容，因为您

1524
01:10:34,570 --> 01:10:36,610
知道您只支持一个 某些

1525
01:10:36,610 --> 01:10:39,070
有限类型的交易非常好，

1526
01:10:39,070 --> 01:10:40,540
我们将看到相当数量的这一点以及

1527
01:10:40,540 --> 01:10:45,699
课程的其余部分

1528
01:10:45,699 --> 01:10:51,610
 

1529
01:10:51,610 --> 01:10:53,560
 

1530
01:10:53,560 --> 01:10:56,020
 

1531
01:10:56,020 --> 01:11:00,130
仅

1532
01:11:00,130 --> 01:11:02,020
当领导者只有在

1533
01:11:02,020 --> 01:11:04,179
收到您知道

1534
01:11:04,179 --> 01:11:07,750
来自足够多的追随者的确认

1535
01:11:07,750 --> 01:11:11,320
 

1536
01:11:11,320 --> 01:11:13,290
 

1537
01:11:13,290 --> 01:11:17,050
 

1538
01:11:17,050 --> 01:11:18,699
回复时才能继续前进

1539
01:11:18,699 --> 01:11:20,920
与我们从 raft 中得到的完全不同，

1540
01:11:20,920 --> 01:11:24,429
它们解决了非常不同的

1541
01:11:24,429 --> 01:11:25,639
问题，

1542
01:11:25,639 --> 01:11:28,619
因此考虑它的方式是您

1543
01:11:28,619 --> 01:11:31,469
使用 raft 通过在多个参与者上复制数据来获得高可用性

1544
01:11:31,469 --> 01:11:34,469
 

1545
01:11:34,469 --> 01:11:37,800
多个对等

1546
01:11:37,800 --> 01:11:39,420
点上的 ts 是 raft 的重点，

1547
01:11:39,420 --> 01:11:42,389
即使其中一些涉及的服务器

1548
01:11:42,389 --> 01:11:44,190
已经崩溃或无法

1549
01:11:44,190 --> 01:11:47,130
访问，您也可以在

1550
01:11:47,130 --> 01:11:49,050
raft 中执行此操作 raft 可以做到这一点，因为所有服务

1551
01:11:49,050 --> 01:11:51,630
都在做同样的事情，他们 '正在

1552
01:11:51,630 --> 01:11:53,310
做同样的事情，所以我们不需要所有人

1553
01:11:53,310 --> 01:11:55,920
都参与我们只需要

1554
01:11:55,920 --> 01:12:00,389
多数两阶段提交但是

1555
01:12:00,389 --> 01:12:02,639
参与者根本没有做

1556
01:12:02,639 --> 01:12:04,290
同样的事情参与者每个人都

1557
01:12:04,290 --> 01:12:05,849
在做你知道的事务的不同部分

1558
01:12:05,849 --> 01:12:07,679
a 可能会

1559
01:12:07,679 --> 01:12:10,260
增加记录 X 和 B 可能会

1560
01:12:10,260 --> 01:12:13,349
减少记录 Y 所以两阶段

1561
01:12:13,349 --> 01:12:17,040
提交所有火车所有参与者

1562
01:12:17,040 --> 01:12:20,639
他们都必须尽自己的一份

1563
01:12:20,639 --> 01:12:22,920
力量才能完成交易你真的

1564
01:12:22,920 --> 01:12:24,480
需要等待每个

1565
01:12:24,480 --> 01:12:31,170
参与者做 他们的事情很好，

1566
01:12:31,170 --> 01:12:34,230
所以我们让你知道 raft 正在复制

1567
01:12:34,230 --> 01:12:35,969
不需要每个人都做他们的事情

1568
01:12:35,969 --> 01:12:37,080
两阶段提交

1569
01:12:37,080 --> 01:12:39,270
每个人都在做不同的事情

1570
01:12:39,270 --> 01:12:42,050
，必须完成 两阶段提交

1571
01:12:42,050 --> 01:12:44,790
对 av 根本没有帮助 ailability

1572
01:12:44,790 --> 01:12:46,380
你知道 raft 就是关于可用性

1573
01:12:46,380 --> 01:12:48,239
即使某些参与者没有响应，你也可以继续进行

1574
01:12:48,239 --> 01:12:50,449
 

1575
01:12:50,449 --> 01:12:54,000
两阶段提交实际上根本

1576
01:12:54,000 --> 01:12:56,070
不可用 如果出现任何问题，它根本就不是高度可用的，

1577
01:12:56,070 --> 01:12:58,349
如果出现任何问题，我们可能

1578
01:12:58,349 --> 01:13:00,389
不得不等到修复完成

1579
01:13:00,389 --> 01:13:02,040
事务协调器

1580
01:13:02,040 --> 01:13:03,690
在错误的时间崩溃，我们只需要

1581
01:13:03,690 --> 01:13:05,580
等待它出现并读取它的日志并

1582
01:13:05,580 --> 01:13:08,159
正确发送提交消息，如果

1583
01:13:08,159 --> 01:13:11,190
您知道其中一个参与者

1584
01:13:11,190 --> 01:13:12,960
在错误的时间崩溃，您知道我们是否

1585
01:13:12,960 --> 01:13:15,150
幸运，我们只是 必须中止然后我们

1586
01:13:15,150 --> 01:13:16,830
不幸运，我们不得不说你完成

1587
01:13:16,830 --> 01:13:19,409
了吗，你完成了吗，所以两阶段

1588
01:13:19,409 --> 01:13:21,060
提交根本不是关于高

1589
01:13:21,060 --> 01:13:23,639
可用性，事实上它是一个

1590
01:13:23,639 --> 01:13:25,650
非常低的可用性，因为这样的事情发生了

1591
01:13:25,650 --> 01:13:28,820
任何崩溃都可以举行 整个系统

1592
01:13:28,820 --> 01:13:33,570
，当然 raft 并不能确保

1593
01:13:33,570 --> 01:13:36,630
所有参与者都做任何

1594
01:13:36,630 --> 01:13:38,190
操作，它只需要多数

1595
01:13:38,190 --> 01:13:39,000
，可能有

1596
01:13:39,000 --> 01:13:40,410
少数完全没有做

1597
01:13:40,410 --> 01:13:42,960
操作，这就是 事实上

1598
01:13:42,960 --> 01:13:44,760
，所有参与者都做

1599
01:13:44,760 --> 01:13:46,290
同样的事情，我们不必等待所有参与者

1600
01:13:46,290 --> 01:13:47,970
，这就是 raft 获得高

1601
01:13:47,970 --> 01:13:51,390
可用性的原因，所以这些是完全

1602
01:13:51,390 --> 01:13:55,410
不同的协议，但是

1603
01:13:55,410 --> 01:13:58,050
可以像两阶段提交一样有效地组合它们

1604
01:13:58,050 --> 01:14:01,710
是你 知道真的很

1605
01:14:01,710 --> 01:14:04,230
容易受到故障的影响，它对故障是正确的，

1606
01:14:04,230 --> 01:14:06,240
但它不能与其他人一起使用，

1607
01:14:06,240 --> 01:14:08,160
所以问题是你是否可以

1608
01:14:08,160 --> 01:14:12,380
构建某种组合系统，该系统

1609
01:14:12,380 --> 01:14:14,850
具有 RAF 的高可用性以进行

1610
01:14:14,850 --> 01:14:19,080
复制，但具有两个阶段提交的

1611
01:14:19,080 --> 01:14:21,570
能力，可以作为各个不同的方调用

1612
01:14:21,570 --> 01:14:23,280
做他们的部分

1613
01:14:23,280 --> 01:14:25,230
交易和你

1614
01:14:25,230 --> 01:14:27,600
真正想要的构建是使用 raft 或 paxos 或

1615
01:14:27,600 --> 01:14:31,500
其他类似的协议来代表

1616
01:14:31,500 --> 01:14:33,840
单独复制每个

1617
01:14:33,840 --> 01:14:37,170
不同的方，所以我们将

1618
01:14:37,170 --> 01:14:39,000
为此设置我们将拥有三个

1619
01:14:39,000 --> 01:14:41,550
不同的集群 事务

1620
01:14:41,550 --> 01:14:43,200
协调器实际上是复制

1621
01:14:43,200 --> 01:14:50,720
服务，你知道三台服务器，

1622
01:14:50,720 --> 01:14:53,160
你知道我们会在这三台服务器上运行 raft，

1623
01:14:53,160 --> 01:14:54,570
其中一台将被选举 d 作为领导者，

1624
01:14:54,570 --> 01:14:56,760
他们已经复制了状态，他们将拥有

1625
01:14:56,760 --> 01:14:58,950
一个帮助他们复制的日志，

1626
01:14:58,950 --> 01:15:00,780
我们不仅需要等待

1627
01:15:00,780 --> 01:15:02,280
多数领导者，我们只需要有

1628
01:15:02,280 --> 01:15:04,860
少数这些状态

1629
01:15:04,860 --> 01:15:06,360
即可 事务协调器来完成它的

1630
01:15:06,360 --> 01:15:08,130
工作，当然他们都会，

1631
01:15:08,130 --> 01:15:10,590
你知道

1632
01:15:10,590 --> 01:15:12,480
 

1633
01:15:12,480 --> 01:15:16,680
通过

1634
01:15:16,680 --> 01:15:19,500
基本上通过将相关记录附加

1635
01:15:19,500 --> 01:15:21,390
到他们的日志来执行事务的各个阶段和两阶段提交协议，然后每个

1636
01:15:21,390 --> 01:15:25,080
参与者也将是

1637
01:15:25,080 --> 01:15:34,250
一个代表我们的筏复制集群的集群，

1638
01:15:40,920 --> 01:15:43,930
所以我们最终会结束，他们会

1639
01:15:43,930 --> 01:15:46,930
来回链接交换消息你

1640
01:15:46,930 --> 01:15:49,320
知道我们会从

1641
01:15:49,320 --> 01:15:51,220
复制的事务协调器

1642
01:15:51,220 --> 01:15:53,860
服务发送提交消息到复制的服务器

1643
01:15:53,860 --> 01:15:58,000
和复制的 B 服务器，这个 你

1644
01:15:58,000 --> 01:15:59,140
知道

1645
01:15:59,140 --> 01:16:01,690
吗，这确实有点复杂，但它确实向你展示了你

1646
01:16:01,690 --> 01:16:03,580
可以结合这些想法来获得

1647
01:16:03,580 --> 01:16:05,740
高可用性的组合，因为

1648
01:16:05,740 --> 01:16:07,660
这些服务器中的任何一个都可能崩溃，

1649
01:16:07,660 --> 01:16:09,880
而剩下的两个 你继续操作，

1650
01:16:09,880 --> 01:16:12,640
加上我们得到

1651
01:16:12,640 --> 01:16:14,950
a 和 B 的原子承诺，正在完成

1652
01:16:14,950 --> 01:16:17,140
同一事务的不同部分，我们可以

1653
01:16:17,140 --> 01:16:19,210
使用两阶段提交让

1654
01:16:19,210 --> 01:16:21,130
事务协调器确保你

1655
01:16:21,130 --> 01:16:22,600
知道要么都提交整个

1656
01:16:22,600 --> 01:16:25,060
事情，要么他们都提交 中止他们的事务部分，

1657
01:16:25,060 --> 01:16:30,250
您实际上将构建

1658
01:16:30,250 --> 01:16:33,370
非常像这样的东西，作为

1659
01:16:33,370 --> 01:16:35,140
实验室表单的一部分，您确实将构建一个分

1660
01:16:35,140 --> 01:16:37,300
片一个数据库，其中每个分片都

1661
01:16:37,300 --> 01:16:40,330
以这种形式复制，并且

1662
01:16:40,330 --> 01:16:42,340
基本上有一个配置管理器，

1663
01:16:42,340 --> 01:16:45,940
它将允许本质上是事务性的

1664
01:16:45,940 --> 01:16:48,820
 

1665
01:16:48,820 --> 01:16:52,360
在看起来很像事务协调器的东西的控制下，将数据分片从一个 raft 集群转移到另一个集群，

1666
01:16:52,360 --> 01:16:55,660
 

1667
01:16:55,660 --> 01:17:00,130
所以

1668
01:17:00,130 --> 01:17:05,920
实验室 4 就是这样，此外，

1669
01:17:05,920 --> 01:17:07,120
我们将阅读一篇名为 spanner 的论文

1670
01:17:07,120 --> 01:17:08,680
，它描述了

1671
01:17:08,680 --> 01:17:11,280
谷歌使用的真实数据库，

1672
01:17:11,280 --> 01:17:14,020
用户也使用这种结构

1673
01:17:14,020 --> 01:17:16,900
来对数据库进行事务性写入，

1674
01:17:16,900 --> 01:17:21,690
谢谢

