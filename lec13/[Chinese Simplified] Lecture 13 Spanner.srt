1
00:00:00,110 --> 00:00:08,639
嗯，也许我们应该开始了 嗯

2
00:00:08,639 --> 00:00:10,050
好久

3
00:00:10,050 --> 00:00:11,550
没有晚上都在同一个地方了 希望

4
00:00:11,550 --> 00:00:16,020
大家今天都好好的 我

5
00:00:16,020 --> 00:00:19,740
想谈谈扳手

6
00:00:19,740 --> 00:00:21,480
谈论这篇论文的原因是 一个罕见

7
00:00:21,480 --> 00:00:25,140
的系统示例

8
00:00:25,140 --> 00:00:27,210
通过广泛分离的数据提供分布式事务，这些

9
00:00:27,210 --> 00:00:28,949
数据可能

10
00:00:28,949 --> 00:00:30,449
分散在整个互联网和

11
00:00:30,449 --> 00:00:32,729
不同的数据中心我是 Saul 最

12
00:00:32,729 --> 00:00:36,149
从未在生产系统中做过的

13
00:00:36,149 --> 00:00:37,710
当然非常希望

14
00:00:37,710 --> 00:00:39,420
能够进行事务处理

15
00:00:39,420 --> 00:00:42,360
程序员真的很喜欢它，也

16
00:00:42,360 --> 00:00:44,730
非常希望将数据

17
00:00:44,730 --> 00:00:48,270
分布在整个网络上，以实现

18
00:00:48,270 --> 00:00:50,160
容错和确保数据就

19
00:00:50,160 --> 00:00:53,309
在附近，

20
00:00:53,309 --> 00:01:01,039
每个想要使用它的人附近都有数据的副本，并

21
00:01:01,039 --> 00:01:04,489
在实现这个扳手的过程中

22
00:01:04,489 --> 00:01:07,920
使用了至少两个巧妙的想法，一个是

23
00:01:07,920 --> 00:01:09,900
他们运行两阶段提交，但他们

24
00:01:09,900 --> 00:01:12,020
实际上是在 paxos 复制的参与者上运行它，

25
00:01:12,020 --> 00:01:15,470
我是为了避免

26
00:01:15,470 --> 00:01:17,850
两阶段提交的问题 在一个

27
00:01:17,850 --> 00:01:20,210
崩溃的协调器可以阻止每个人

28
00:01:20,210 --> 00:01:22,650
，另一个有趣的想法是

29
00:01:22,650 --> 00:01:25,439
他们使用同步时间来

30
00:01:25,439 --> 00:01:26,820
获得非常有效的只读

31
00:01:26,820 --> 00:01:30,960
事务，并且该系统

32
00:01:30,960 --> 00:01:32,520
实际上非常成功，它被谷歌内部

33
00:01:32,520 --> 00:01:34,740
的许多不同服务大量使用

34
00:01:34,740 --> 00:01:38,040
它已被

35
00:01:38,040 --> 00:01:40,500
Google 转变为一种为

36
00:01:40,500 --> 00:01:43,320
基于云的客户提供服务的产品，并

37
00:01:43,320 --> 00:01:46,320
激发了许多其他研究和

38
00:01:46,320 --> 00:01:48,689
其他系统的灵感，

39
00:01:48,689 --> 00:01:51,090
例如它可以进行广域

40
00:01:51,090 --> 00:01:53,090
交易，

41
00:01:53,090 --> 00:01:55,409
特别是至少有一个开放

42
00:01:55,409 --> 00:01:58,229
她的系统蟑螂数据库使用了

43
00:01:58,229 --> 00:02:01,670
很多明确地使用了很多

44
00:02:01,670 --> 00:02:05,100
设计激励用例

45
00:02:05,100 --> 00:02:06,710
论文说他们第一次

46
00:02:06,710 --> 00:02:09,239
开始设计扳手的原因是

47
00:02:09,239 --> 00:02:11,760
他们已经有了一个实际上他们有

48
00:02:11,760 --> 00:02:13,800
很多大型数据库系统和

49
00:02:13,800 --> 00:02:15,420
谷歌 但他们的广告系统，

50
00:02:15,420 --> 00:02:19,290
尤其是

51
00:02:19,290 --> 00:02:22,740
我的许多不同的续集和

52
00:02:22,740 --> 00:02:25,770
BigTable 数据库的数据被缩短了，并维护了这一点

53
00:02:25,770 --> 00:02:28,170
分片只是一个尴尬、

54
00:02:28,170 --> 00:02:30,630
手动和耗时的过程，

55
00:02:30,630 --> 00:02:33,540
此外，他们以前的广告

56
00:02:33,540 --> 00:02:36,180
数据库系统不允许

57
00:02:36,180 --> 00:02:38,040
跨越一个以上的交易，

58
00:02:38,040 --> 00:02:40,020
基本上多于一个

59
00:02:40,020 --> 00:02:42,360
服务器，但他们真的希望

60
00:02:42,360 --> 00:02:44,820
能够传播他们的数据

61
00:02:44,820 --> 00:02:47,820
为了获得更好的性能并在

62
00:02:47,820 --> 00:02:51,000
 

63
00:02:51,000 --> 00:02:55,230
其广告数据库的数据的多个分片上进行交易，

64
00:02:55,230 --> 00:02:56,970
显然工作负载

65
00:02:56,970 --> 00:02:59,010
由只读事务主导，我的

66
00:02:59,010 --> 00:03:00,780
意思是您可以在表 6 中看到这一点，

67
00:03:00,780 --> 00:03:03,270
其中有数十亿个只读

68
00:03:03,270 --> 00:03:06,860
事务和 只有数百万个

69
00:03:06,860 --> 00:03:09,300
读写事务，所以他们对

70
00:03:09,300 --> 00:03:11,880
 

71
00:03:11,880 --> 00:03:13,980
只做杂草的事务的只读性能非常感兴趣

72
00:03:13,980 --> 00:03:16,440
，显然他们还需要

73
00:03:16,440 --> 00:03:18,510
强一致性，并且你知道

74
00:03:18,510 --> 00:03:21,209
特别是哪些事务，所以他们

75
00:03:21,209 --> 00:03:22,950
想要可序列化的事务，

76
00:03:22,950 --> 00:03:27,060
他们也想要外部一致性

77
00:03:27,060 --> 00:03:28,980
这意味着如果一个事务

78
00:03:28,980 --> 00:03:33,450
提交，然后在它完成

79
00:03:33,450 --> 00:03:34,920
提交之后 事务

80
00:03:34,920 --> 00:03:37,700
开始第二个事务需要看到任何

81
00:03:37,700 --> 00:03:41,459
修改是由第一个完成的，并且

82
00:03:41,459 --> 00:03:43,560
这种外部一致性

83
00:03:43,560 --> 00:03:50,580
对于复制的数据很有趣，所以

84
00:03:50,580 --> 00:03:52,010
 

85
00:03:52,010 --> 00:03:56,040
所有权只是扳手使用它的服务器的一种基本安排类型

86
00:03:56,040 --> 00:03:57,480
的物理安排

87
00:03:57,480 --> 00:04:01,709
它的

88
00:04:01,709 --> 00:04:03,680
服务器分布在数据中心，

89
00:04:03,680 --> 00:04:06,000
大概遍布世界各地，当然

90
00:04:06,000 --> 00:04:08,880
遍布美国，

91
00:04:08,880 --> 00:04:10,890
每条数据都在多个

92
00:04:10,890 --> 00:04:14,030
数据中心复制，所以图表必须有

93
00:04:14,030 --> 00:04:17,060
多个数据中心，假设

94
00:04:17,060 --> 00:04:19,649
有三个数据中心，

95
00:04:19,649 --> 00:04:23,330
真的有 哎呀，

96
00:04:26,009 --> 00:04:27,740
所以我们整天都有

97
00:04:27,740 --> 00:04:29,990
异议，然后数据分片

98
00:04:29,990 --> 00:04:31,490
它被分解了，你可以认为它

99
00:04:31,490 --> 00:04:35,389
已经被密钥分解并

100
00:04:35,389 --> 00:04:37,340
拆分到许多服务器上，所以也许有

101
00:04:37,340 --> 00:04:39,770
一个服务器提供

102
00:04:39,770 --> 00:04:42,680
以 a 开头的密钥 数据中心或其他

103
00:04:42,680 --> 00:04:46,490
以 B 开头的等等

104
00:04:46,490 --> 00:04:48,949
大量图表和大量服务器

105
00:04:48,949 --> 00:04:52,520
实际上每个数据中心都有任何一块

106
00:04:52,520 --> 00:04:55,520
o  f 数据是在

107
00:04:55,520 --> 00:04:57,319
多个数据中心复制的任何分片，因此

108
00:04:57,319 --> 00:04:58,819
将在中心的第二天再复制一个

109
00:04:58,819 --> 00:05:01,520
a 键和 B 键的另一个副本，以此类推，

110
00:05:01,520 --> 00:05:04,130
并且

111
00:05:04,130 --> 00:05:08,090
所有这些数据的另一个希望相同的副本

112
00:05:08,090 --> 00:05:10,819
在 第三个数据中心

113
00:05:10,819 --> 00:05:14,300
此外每个数据中心都有多个

114
00:05:14,300 --> 00:05:17,960
客户端或它们的扳手客户端

115
00:05:17,960 --> 00:05:19,940
，这些客户端实际上是网络

116
00:05:19,940 --> 00:05:22,729
服务器，所以如果我们

117
00:05:22,729 --> 00:05:24,250
坐在网络浏览器前的普通人

118
00:05:24,250 --> 00:05:27,800
连接到一些使用扳手的谷歌服务，

119
00:05:27,800 --> 00:05:28,520
 

120
00:05:28,520 --> 00:05:30,050
他们会 连接到其中

121
00:05:30,050 --> 00:05:31,550
一个数据中心中的某个 Web 服务器，这

122
00:05:31,550 --> 00:05:35,509
将是这些 spanner

123
00:05:35,509 --> 00:05:40,580
客户端中的一个，这样就可以

124
00:05:40,580 --> 00:05:43,789
复制复制由 Paxos 管理，

125
00:05:43,789 --> 00:05:45,680
事实上，它确实是 Paxos 的一种变体，它

126
00:05:45,680 --> 00:05:48,320
具有领导者并且确实是 非常

127
00:05:48,320 --> 00:05:50,020
类似于我们都熟悉的 raft

128
00:05:50,020 --> 00:05:53,870
，每个 Paxos 实例管理

129
00:05:53,870 --> 00:05:56,840
给定数据分片的

130
00:05:56,840 --> 00:06:00,789
所有副本，因此该分片的所有副本

131
00:06:00,789 --> 00:06:06,620
形成一个 Paxos 组 l

132
00:06:06,620 --> 00:06:08,150
副本是这个分片，其他包

133
00:06:08,150 --> 00:06:09,740
是组，每个包都是

134
00:06:09,740 --> 00:06:13,069
独立的补丁实例，因为

135
00:06:13,069 --> 00:06:14,900
它自己的领导者运行自己的版本

136
00:06:14,900 --> 00:06:18,500
的诗歌包的实例

137
00:06:18,500 --> 00:06:21,740
是协议麻木，

138
00:06:21,740 --> 00:06:25,280
分片和独立的原因

139
00:06:25,280 --> 00:06:29,539
每个分片的 paxos 实例是为了允许并行

140
00:06:29,539 --> 00:06:31,849
加速和大量并行

141
00:06:31,849 --> 00:06:34,190
吞吐量，因为

142
00:06:34,190 --> 00:06:35,870
您知道有大量客户端

143
00:06:35,870 --> 00:06:37,490
代表 Web

144
00:06:37,490 --> 00:06:39,889
浏览器工作，因此通常会有大量

145
00:06:39,889 --> 00:06:41,190
并发

146
00:06:41,190 --> 00:06:43,930
请求，因此它付出了很多，而且

147
00:06:43,930 --> 00:06:46,780
非常巨大 将它们分成多个分

148
00:06:46,780 --> 00:06:52,060
片和多种

149
00:06:52,060 --> 00:06:56,620
并行运行的 Paxos 组，

150
00:06:56,620 --> 00:06:59,259
你可以想到，或者这些 paxos

151
00:06:59,259 --> 00:07:02,680
组中的每一个都有一个领导者，很像愤怒，所以

152
00:07:02,680 --> 00:07:04,629
也许这个分片的领导者不是

153
00:07:04,629 --> 00:07:06,669
数据是 数据中心一中的副本，

154
00:07:06,669 --> 00:07:10,020
该分片的领导者可能是

155
00:07:10,020 --> 00:07:13,599
副本和数据中心二，

156
00:07:13,599 --> 00:07:18,400
依此类推，您知道，这意味着如果

157
00:07:18,400 --> 00:07:21,250
您需要，如果客户端需要 做一个

158
00:07:21,250 --> 00:07:23,020
正确的事情，它必须将该权利发送给分片的

159
00:07:23,020 --> 00:07:28,360
领导者，它

160
00:07:28,360 --> 00:07:32,289
需要使用 Raph 写入其数据，这些

161
00:07:32,289 --> 00:07:34,750
Paxos 实例是他们真正

162
00:07:34,750 --> 00:07:36,879
在做的事情是发送一个日志，领导者正在

163
00:07:36,879 --> 00:07:38,530
复制一个日志

164
00:07:38,530 --> 00:07:40,509
对所有追随者和追随者的操作

165
00:07:40,509 --> 00:07:42,819
执行用于读取和写入数据的日志，

166
00:07:42,819 --> 00:07:45,099
因此它会

167
00:07:45,099 --> 00:07:53,199
以相同的顺序执行这些日志，

168
00:07:53,199 --> 00:07:55,539
所以这些

169
00:07:55,539 --> 00:07:58,389
设置的原因是分片，正如我提到的

170
00:07:58,389 --> 00:08:00,699
吞吐量倍数 在

171
00:08:00,699 --> 00:08:03,759
不同的数据中心复制有两个

172
00:08:03,759 --> 00:08:06,069
原因，一是你想要复制和

173
00:08:06,069 --> 00:08:07,719
不同的数据中心，以防一个数据

174
00:08:07,719 --> 00:08:10,990
中心出现故障

175
00:08:10,990 --> 00:08:12,729
 

176
00:08:12,729 --> 00:08:14,379
 

177
00:08:14,379 --> 00:08:16,930
我想要其他可能不会同时发生故障的

178
00:08:16,930 --> 00:08:19,000
其他数据中心的其他副本

179
00:08:19,000 --> 00:08:20,560
 

180
00:08:20,560 --> 00:08:22,539
，然后您知道为此付出

181
00:08:22,539 --> 00:08:24,550
代价，因为现在 paxos 协议

182
00:08:24,550 --> 00:08:27,009
现在可能需要进行

183
00:08:27,009 --> 00:08:29,409
长距离通信 o 与追随者和

184
00:08:29,409 --> 00:08:31,569
不同的数据中心交谈

185
00:08:31,569 --> 00:08:33,309
在多个数据中心拥有数据的另一个原因是

186
00:08:33,309 --> 00:08:35,229
，它可能允许您在使用它的

187
00:08:35,229 --> 00:08:39,010
所有不同客户端附近拥有数据的副本，

188
00:08:39,010 --> 00:08:40,120
因此如果您有

189
00:08:40,120 --> 00:08:42,429
一条可以读取的数据 在加利福尼亚

190
00:08:42,429 --> 00:08:45,760
和纽约可能有

191
00:08:45,760 --> 00:08:48,250
一份数据副本在加利福尼亚

192
00:08:48,250 --> 00:08:50,800
一份在纽约一份在纽约可能会很好，这样读取

193
00:08:50,800 --> 00:08:53,140
速度可以非常快，实际上很多时间的

194
00:08:53,140 --> 00:08:53,810
重点

195
00:08:53,810 --> 00:08:57,529
是从最近的本地读取

196
00:08:57,529 --> 00:09:02,020
复制既快速又正确

197
00:09:02,020 --> 00:09:04,790
最后

198
00:09:04,790 --> 00:09:06,590
，Paxos 和多个数据中心之间的另一个有趣的交互

199
00:09:06,590 --> 00:09:07,130
是，

200
00:09:07,130 --> 00:09:10,150
paxos 谎言工艺只需要

201
00:09:10,150 --> 00:09:13,400
多数才能复制日志条目并

202
00:09:13,400 --> 00:09:14,870
继续，这意味着如果有一个

203
00:09:14,870 --> 00:09:18,020
缓慢、遥远或不稳定的数据中心，

204
00:09:18,020 --> 00:09:20,960
Paxil 系统可以

205
00:09:20,960 --> 00:09:22,760
即使一个数据

206
00:09:22,760 --> 00:09:28,460
中心运行缓慢

207
00:09:28,460 --> 00:09:31,460
，也要

208
00:09:31,460 --> 00:09:33,800
继续

209
00:09:33,800 --> 00:09:35,810
努力并接受新的请求 我想

210
00:09:35,810 --> 00:09:39,830
从本地数据中心读取数据，但因为

211
00:09:39,830 --> 00:09:41,720
他们使用的是 Paxos，而且因为 Paxos

212
00:09:41,720 --> 00:09:45,529
只要求每个日志条目

213
00:09:45,529 --> 00:09:47,870
在大多数副本上进行复制，这意味着

214
00:09:47,870 --> 00:09:49,970
少数副本可能滞后

215
00:09:49,970 --> 00:09:52,910
并且可能没有看到最新的

216
00:09:52,910 --> 00:09:56,540
数据 由 paxos 提交，这

217
00:09:56,540 --> 00:09:58,970
意味着如果我们允许客户端

218
00:09:58,970 --> 00:10:02,000
从本地副本读取速度，

219
00:10:02,000 --> 00:10:04,610
如果他们的

220
00:10:04,610 --> 00:10:06,050
副本恰好是

221
00:10:06,050 --> 00:10:08,120
少数没有看到最新更新的，他们可能正在读取过期数据，所以

222
00:10:08,120 --> 00:10:09,740
他们必须 因为他们需要

223
00:10:09,740 --> 00:10:11,630
正确性，所以他们需要这种

224
00:10:11,630 --> 00:10:16,130
外部一致性想法，即每次

225
00:10:16,130 --> 00:10:18,470
读取都会看到最新的数据，他们

226
00:10:18,470 --> 00:10:20,540
必须有某种方法来处理

227
00:10:20,540 --> 00:10:22,850
本地副本

228
00:10:22,850 --> 00:10:26,510
可能滞后

229
00:10:26,510 --> 00:10:28,310
于他们必须处理的另一个问题的可能性 一个事务可能

230
00:10:28,310 --> 00:10:30,470
涉及多个分片，因此可能涉及

231
00:10:30,470 --> 00:10:32,300
多个 paxos 组，因此您可能正在

232
00:10:32,300 --> 00:10:34,190
读取或写入单个事务

233
00:10:34,190 --> 00:10:35,780
可能正在读取或写入

234
00:10:35,780 --> 00:10:37,730
存储在数据库中的多条记录

235
00:10:37,730 --> 00:10:40,250
i  n 多个分片和多个 Paxil

236
00:10:40,250 --> 00:10:42,920
脚本，所以这些必须是我们需要

237
00:10:42,920 --> 00:10:49,700
分布式事务，所以我

238
00:10:49,700 --> 00:10:51,080
将解释事务

239
00:10:51,080 --> 00:10:52,700
是如何工作的，这将

240
00:10:52,700 --> 00:10:56,600
成为讲座的重点 spanner 实际上

241
00:10:56,600 --> 00:10:58,720
击败了实现读写事务

242
00:10:58,720 --> 00:11:00,620
与读取完全不同- 只有

243
00:11:00,620 --> 00:11:02,389
交易所以让我从你

244
00:11:02,389 --> 00:11:03,949
的读写交易的美丽开始，

245
00:11:03,949 --> 00:11:07,190
它们的设计非常传统，

246
00:11:07,190 --> 00:11:20,860
好吧，所以第一次读写

247
00:11:20,860 --> 00:11:27,490
交易让我提醒你

248
00:11:27,490 --> 00:11:30,580
交易看起来像所以让我们

249
00:11:30,580 --> 00:11:32,020
选择一个简单的，就像

250
00:11:32,020 --> 00:11:37,120
模仿银行转账 所以我是

251
00:11:37,120 --> 00:11:39,010
那些客户端机器之一扳手的客户端

252
00:11:39,010 --> 00:11:41,140
你会运行一些代码你运行这个

253
00:11:41,140 --> 00:11:42,460
事务代码代码会说哦

254
00:11:42,460 --> 00:11:45,190
我正在开始一个事务然后我

255
00:11:45,190 --> 00:11:46,330
会说哦我想读取和写入

256
00:11:46,330 --> 00:11:48,310
这些记录所以 也许你

257
00:11:48,310 --> 00:11:50,350
在数据库记录 X 中有一个银行余额，我们

258
00:11:50,350 --> 00:11:53,020
想让你知道增加和增加这个

259
00:11:53,020 --> 00:11:56,740
银行余额并减少 y 的银行

260
00:11:56,740 --> 00:11:58,210
余额，哦，这就结束了

261
00:11:58,210 --> 00:12:01,090
事务，现在客户希望

262
00:12:01,090 --> 00:12:04,350
数据库能够关闭并提交，

263
00:12:05,160 --> 00:12:08,590
所以我想跟踪所有

264
00:12:08,590 --> 00:12:11,080
必须发生的步骤，

265
00:12:11,080 --> 00:12:15,220
以便扳手执行

266
00:12:15,220 --> 00:12:17,560
这个读写事务，所以

267
00:12:17,560 --> 00:12:18,970
首先有一个 驱动此事务的数据中心之一的客户端，

268
00:12:18,970 --> 00:12:21,540
 

269
00:12:21,540 --> 00:12:24,430
因此我将在此处绘制此客户端让我们

270
00:12:24,430 --> 00:12:25,690
假设 x 和 y 在不同的分

271
00:12:25,690 --> 00:12:28,240
片上，因为这是

272
00:12:28,240 --> 00:12:31,990
有趣的情况，并且两个分片中的

273
00:12:31,990 --> 00:12:35,640
每个分片都在三个不同的分片中复制

274
00:12:35,640 --> 00:12:38,740
数据中心所以知道我们

275
00:12:38,740 --> 00:12:44,410
在这里有我们的三个数据中心，并且在

276
00:12:44,410 --> 00:12:47,970
每个数据中心都有一个服务器，

277
00:12:47,970 --> 00:12:51,460
我将编写 x 用于分片的

278
00:12:51,460 --> 00:12:55,120
副本，该副本

279
00:12:55,120 --> 00:12:58,870
与这三个服务器的 x 和 y 的银行余额保持一致

280
00:12:58,870 --> 00:13:03,360
微调器一次

281
00:13:03,360 --> 00:13:06,700
两阶段提交只是为了完全支持

282
00:13:06,700 --> 00:13:08,470
我们的两阶段提交和两阶段

283
00:13:08,470 --> 00:13:13,540
锁定，几乎

284
00:13:13,540 --> 00:13:16,060
与上周从 603 三教科书的阅读中描述的完全一样

285
00:13:16,060 --> 00:13:18,780
，巨大的不同

286
00:13:18,780 --> 00:13:22,540
是 不是参与者

287
00:13:22,540 --> 00:13:24,700
和事务管理器是单独的

288
00:13:24,700 --> 00:13:26,590
计算机，而是

289
00:13:26,590 --> 00:13:30,370
事务方式管理器中的参与者是 Paxos

290
00:13:30,370 --> 00:13:33,270
复制

291
00:13:33,340 --> 00:13:35,410
的服务器组，以提高

292
00:13:35,410 --> 00:13:37,570
容错能力，这意味着只是提醒

293
00:13:37,570 --> 00:13:42,010
您存储 X 的分片的三个副本

294
00:13:42,010 --> 00:13:44,050
是一个 真正的

295
00:13:44,050 --> 00:13:46,120
应用程序访问组与这三个

296
00:13:46,120 --> 00:13:49,330
副本强 Y 相同，我们只是想象

297
00:13:49,330 --> 00:13:51,760
这三个

298
00:13:51,760 --> 00:13:53,790
服务器中的每一个都是领导者，所以假设

299
00:13:53,790 --> 00:13:56,380
服务器和数据中心 2 是

300
00:13:56,380 --> 00:14:00,760
Paxos 领导者，X 是分片，而

301
00:14:00,760 --> 00:14:02,890
仆人说一个是

302
00:14:02,890 --> 00:14:08,080
Paxos 领导者 y 好，所以发生的第一

303
00:14:08,080 --> 00:14:09,910
件事是硬币

304
00:14:09,910 --> 00:14:11,770
选择一个唯一的交易 ID

305
00:14:11,770 --> 00:14:13,590
，它将在所有这些消息上携带，

306
00:14:13,590 --> 00:14:16,470
以便系统知道

307
00:14:16,470 --> 00:14:18,790
所有不同的操作都

308
00:14:18,790 --> 00:14:21,100
与 一个单一的事务

309
00:14:21,100 --> 00:14:22,420
客户端做的第一件事

310
00:14:22,420 --> 00:14:25,270
必须是这样，尽管代码看起来

311
00:14:25,270 --> 00:14:27,430
在哪里读取和写入 X 然后

312
00:14:27,430 --> 00:14:30,520
在 fa 中读取一些写入 Y  ct 代码

313
00:14:30,520 --> 00:14:32,260
具有事务代码的方式必须组织

314
00:14:32,260 --> 00:14:34,330
它必须首先进行所有读取，

315
00:14:34,330 --> 00:14:36,880
然后在最后同时进行所有写入

316
00:14:36,880 --> 00:14:39,220
，基本上

317
00:14:39,220 --> 00:14:44,860
作为提交的一部分，以便客户端做好

318
00:14:44,860 --> 00:14:49,050
读取结果 它为了

319
00:14:49,050 --> 00:14:53,950
维护锁，因为就像

320
00:14:53,950 --> 00:14:57,520
上周的 6:53 每次读取

321
00:14:57,520 --> 00:15:00,610
或写入数据项时读取一样，

322
00:15:00,610 --> 00:15:03,790
负责它的服务器必须将

323
00:15:03,790 --> 00:15:06,490
锁与该数据项相关联 锁被

324
00:15:06,490 --> 00:15:09,280
维护 读取锁和扳手

325
00:15:09,280 --> 00:15:12,090
仅在 Paxos 领导者中维护，因此

326
00:15:12,090 --> 00:15:14,530
当客户端事务要

327
00:15:14,530 --> 00:15:18,330
读取访问权限时，向 X

328
00:15:18,330 --> 00:15:23,560
的领导者发送读取 X 请求是分片，并且该分片的

329
00:15:23,560 --> 00:15:25,240
领导者返回 x 的当前

330
00:15:25,240 --> 00:15:28,630
值加上在 X 上设置锁当然

331
00:15:28,630 --> 00:15:30,520
如果锁 已经设置，那么您将不会

332
00:15:30,520 --> 00:15:32,250
响应客户端，直到

333
00:15:32,250 --> 00:15:34,210
当前具有数据

334
00:15:34,210 --> 00:15:36,370
锁定的任何事务通过提交释放锁

335
00:15:36,370 --> 00:15:40,600
，然后该分片的领导者

336
00:15:40,600 --> 00:15:42,970
将 x 的值返回给客户端

337
00:15:42,970 --> 00:15:44,620
需要读取的客户端 我

338
00:15:44,620 --> 00:15:46,300
是因为

339
00:15:46,300 --> 00:15:48,490
假设像数据中心的客户一样

340
00:15:48,490 --> 00:15:52,210
是本地数据中心的领导者，

341
00:15:52,210 --> 00:15:54,840
所以读取速度会快得多，

342
00:15:54,840 --> 00:15:58,660
读取设置了税收

343
00:15:58,660 --> 00:16:00,490
领导者中的 Y 锁定，然后返回好的，现在

344
00:16:00,490 --> 00:16:02,260
客户在内部进行的所有读取

345
00:16:02,260 --> 00:16:03,910
计算并计算出

346
00:16:03,910 --> 00:16:05,920
 

347
00:16:05,920 --> 00:16:09,730
想要写入 x 和 y 的值的写入，因此现在

348
00:16:09,730 --> 00:16:12,130
客户端将发送

349
00:16:12,130 --> 00:16:16,060
它想要写入的记录的更新值，

350
00:16:16,060 --> 00:16:18,820
并在最后一次完成所有

351
00:16:18,820 --> 00:16:20,140
这些 事务结束，

352
00:16:20,140 --> 00:16:23,170
所以它做的第一件事

353
00:16:23,170 --> 00:16:25,930
就是选择其中一个包

354
00:16:25,930 --> 00:16:28,000
作为事务

355
00:16:28,000 --> 00:16:31,480
协调者，因为它提前选择了我们

356
00:16:31,480 --> 00:16:33,130
，它会

357
00:16:33,130 --> 00:16:35,770
发出 Paxos 组

358
00:16:35,770 --> 00:16:37,510
将充当的身份 事务

359
00:16:37,510 --> 00:16:40,150
协调器 所以让我们假设它选择了

360
00:16:40,150 --> 00:16:42,790
这个 Paxos 组 我在这里拆分了一个双框

361
00:16:42,790 --> 00:16:45,400
来说明这个服务器不仅是

362
00:16:45,400 --> 00:16:47,530
它的 Paxos 组的领导者，它还

363
00:16:47,530 --> 00:16:49,540
充当

364
00:16:49,540 --> 00:16:52,210
这个事务的事务协调器 然后客户端

365
00:16:52,210 --> 00:16:57,370
发送它想要写入的更新值，因此当每个写入值的 Paxos 领导者收到写入请求时，它将

366
00:16:57,370 --> 00:16:58,690
 

367
00:16:58,690 --> 00:17:02,080
在这里发送一个写入额外写入 X 请求，其中包含一个新

368
00:17:02,080 --> 00:17:03,250
值和

369
00:17:03,250 --> 00:17:09,520
事务协调器的身份

370
00:17:09,520 --> 00:17:11,170
 

371
00:17:11,170 --> 00:17:18,460
它

372
00:17:18,460 --> 00:17:22,720
向其追随者发送一条准备消息并将

373
00:17:22,720 --> 00:17:24,810
其放入 Paxos 日志中，以便

374
00:17:24,810 --> 00:17:27,760
我将 P 表示到

375
00:17:27,760 --> 00:17:30,850
paxos 日志中，因为它承诺

376
00:17:30,850 --> 00:17:33,190
能够实现它是错误的词，它

377
00:17:33,190 --> 00:17:35,020
承诺能够执行

378
00:17:35,020 --> 00:17:36,700
例如，该事务尚未崩溃

379
00:17:36,700 --> 00:17:40,390
并丢失其锁，因此它

380
00:17:40,390 --> 00:17:43,210
发送此准备消息

381
00:17:43,210 --> 00:17:45,340
当它从关注者获得大多数响应时，它会通过 paxos 记录准备消息，

382
00:17:45,340 --> 00:17:47,080
 

383
00:17:47,080 --> 00:17:51,010
然后此协议是领导者

384
00:17:51,010 --> 00:17:54,940
向事务协调器发送“是”

385
00:17:54,940 --> 00:17:58,120
说 是的，我很有

386
00:17:58,120 --> 00:17:59,590
希望能够对 Y V 执行我的部分

387
00:17:59,590 --> 00:18:00,230
趋势

388
00:18:00,230 --> 00:18:07,039
，并且从概念上讲，

389
00:18:07,039 --> 00:18:09,500
交易看到客户还

390
00:18:09,500 --> 00:18:15,549
判处价值被咬 - 为什么 -

391
00:18:15,549 --> 00:18:21,080
为什么是 paxos 领导者和

392
00:18:21,080 --> 00:18:24,260
充当paxos领导者的服务器

393
00:18:24,260 --> 00:18:28,100
向他的追随者发送准备消息并记录它会

394
00:18:28,100 --> 00:18:29,710
影响

395
00:18:29,710 --> 00:18:33,139
大多数确认的权重，然后

396
00:18:33,139 --> 00:18:36,769
您可以将其视为Paxos

397
00:18:36,769 --> 00:18:40,760
领导者发送

398
00:18:40,760 --> 00:18:43,090
位于同一台机器上的事务协调器

399
00:18:43,090 --> 00:18:45,620
同一个程序 一个是 投票说

400
00:18:45,620 --> 00:18:48,440
是 我可以 我可以提交 好的，所以当

401
00:18:48,440 --> 00:18:52,429
事务协调器

402
00:18:52,429 --> 00:18:54,080
从

403
00:18:54,080 --> 00:18:56,769
所有不同分片

404
00:18:56,769 --> 00:18:59,899
的领导者那里得到响应时，如果他们

405
00:18:59,899 --> 00:19:01,669
都说是，那么事务

406
00:19:01,669 --> 00:19:03,649
协调器可以 否则它

407
00:19:03,649 --> 00:19:09,370
不能假设它决定

408
00:19:09,370 --> 00:19:11,600
在那个时候提交事务

409
00:19:11,600 --> 00:19:15,529
协调器向paxos

410
00:19:15,529 --> 00:19:19,480
追随者发送一条提交消息，说

411
00:19:19,480 --> 00:19:22,669
请记住，在

412
00:19:22,669 --> 00:19:26,120
事务日志中永久记住我们正在提交

413
00:19:26,120 --> 00:19:34,809
这个事务，它还告诉

414
00:19:34,809 --> 00:19:37,070
领导者 在其他 PAC 中，那些

415
00:19:37,070 --> 00:19:39,889
参与事务的组然后他们

416
00:19:39,889 --> 00:19:42,919
也可以提交，所以现在这个

417
00:19:42,919 --> 00:19:45,710
领导 sen  ds out 提交消息给他的

418
00:19:45,710 --> 00:19:49,130
追随者以及一旦提交

419
00:19:49,130 --> 00:19:51,519
 

420
00:19:54,770 --> 00:19:56,570
是事务协调器可能

421
00:19:56,570 --> 00:19:58,040
不会将提交消息发送

422
00:19:58,040 --> 00:20:00,590
到其他分片，直到它

423
00:20:00,590 --> 00:20:02,480
在日志中被安全地提交，这样事务

424
00:20:02,480 --> 00:20:03,800
协调器就不能保证不会

425
00:20:03,800 --> 00:20:07,850
忘记 它的决定一旦提交，这些

426
00:20:07,850 --> 00:20:09,860
提交消息将提交到

427
00:20:09,860 --> 00:20:12,530
不同分片的 paxos 日志中，每个

428
00:20:12,530 --> 00:20:14,120
分片实际上都可以执行

429
00:20:14,120 --> 00:20:16,809
放置写入数据

430
00:20:16,809 --> 00:20:21,830
并释放数据项上的锁定的权限，

431
00:20:21,830 --> 00:20:26,260
以便其他事务可以使用它们

432
00:20:26,650 --> 00:20:35,150
，然后 交易结束，所以

433
00:20:35,150 --> 00:20:36,890
首先请随时提出问题

434
00:20:36,890 --> 00:20:40,910
，如果您

435
00:20:40,910 --> 00:20:45,110
有问题，请举手提出一些问题

436
00:20:45,110 --> 00:20:48,710
，所以到目前为止，有一些关于设计的要点需要观察，这

437
00:20:48,710 --> 00:20:50,900
仅涉及交易的读写方面，

438
00:20:50,900 --> 00:20:53,600
一个是它是

439
00:20:53,600 --> 00:20:56,720
确保两个事务的可序列化性的锁定

440
00:20:56,720 --> 00:20:59,240
 

441
00:20:59,240 --> 00:21:01,610
因为它们使用相同的数据而发生冲突，一个

442
00:21:01,610 --> 00:21:02,750
必须完全等待另一个

443
00:21:02,750 --> 00:21:05,179
在它可以继续之前释放锁，因此

444
00:21:05,179 --> 00:21:07,610
它使用so spanners 使用完全

445
00:21:07,610 --> 00:21:11,120
标准的两阶段锁定以

446
00:21:11,120 --> 00:21:13,940
获得可序列化性和完全

447
00:21:13,940 --> 00:21:15,740
标准的两阶段提交以获得

448
00:21:15,740 --> 00:21:19,400
分布式事务，两阶段

449
00:21:19,400 --> 00:21:22,850
提交被广泛讨厌，因为如果

450
00:21:22,850 --> 00:21:25,040
事务协调器失败或

451
00:21:25,040 --> 00:21:27,290
成为 比任何事务都无法访问，

452
00:21:27,290 --> 00:21:31,220
它无限期地管理阻塞，

453
00:21:31,220 --> 00:21:32,960
直到事务协调器

454
00:21:32,960 --> 00:21:35,570
恢复并且他们用锁帮助阻塞，所以

455
00:21:35,570 --> 00:21:37,610
人们通常非常

456
00:21:37,610 --> 00:21:40,429
不愿意在现实世界中使用两阶段提交，

457
00:21:40,429 --> 00:21:43,990
因为它的阻塞扳手

458
00:21:43,990 --> 00:21:46,580
通过复制事务来解决这个问题

459
00:21:46,580 --> 00:21:48,230
manager 事务

460
00:21:48,230 --> 00:21:50,510
管理器本身是一个 Paxos 复制

461
00:21:50,510 --> 00:21:53,240
状态机，因此它所做的一切

462
00:21:53,240 --> 00:21:55,520
例如记住它是否已

463
00:21:55,520 --> 00:21:57,740
提交都会被复制到

464
00:21:57,740 --> 00:22:02,740
paxos 日志中，因此如果这里的领导者失败，

465
00:22:02,740 --> 00:22:04,790
即使它正在管理

466
00:22:04,790 --> 00:22:07,250
事务，因为它是 raft 复制了

467
00:22:07,250 --> 00:22:08,509
其中任何一个 两个

468
00:22:08,509 --> 00:22:11,419
复制品可以焕发生机接管

469
00:22:11,419 --> 00:22:14,239
领导权 并接管

470
00:22:14,239 --> 00:22:16,159
事务管理器，他们将在

471
00:22:16,159 --> 00:22:17,959
他们的法律中，事务管理器

472
00:22:17,959 --> 00:22:20,329
决定提交任何接管的领导者

473
00:22:20,329 --> 00:22:22,879
都会看到它的日志，

474
00:22:22,879 --> 00:22:25,399
然后能够立即告诉另一个人

475
00:22:25,399 --> 00:22:27,799
告诉其他参与者和

476
00:22:27,799 --> 00:22:28,999
两个 -phase commit 看起来哦，这个

477
00:22:28,999 --> 00:22:30,559
事务被提交了，所以这

478
00:22:30,559 --> 00:22:34,429
有效地消除了

479
00:22:34,429 --> 00:22:36,049
两阶段提交的

480
00:22:36,049 --> 00:22:38,839
 

481
00:22:38,839 --> 00:22:41,469
问题

482
00:22:41,469 --> 00:22:43,429
 

483
00:22:43,429 --> 00:22:45,199
对于

484
00:22:45,199 --> 00:22:47,359
任何类型的大型系统，它

485
00:22:47,359 --> 00:22:49,879
有很多部件可能会出现故障，

486
00:22:49,879 --> 00:22:51,649
另一件需要注意的事情是，这里的图表中有

487
00:22:51,649 --> 00:22:55,879
大量消息

488
00:22:55,879 --> 00:22:59,929
，这意味着它们中的

489
00:22:59,929 --> 00:23:02,599
许多是跨数据中心的，并且

490
00:23:02,599 --> 00:23:03,889
说 其中一些消息

491
00:23:03,889 --> 00:23:05,899
在分片之间或客户端

492
00:23:05,899 --> 00:23:07,729
和分片之间传递，其领导者在另一个

493
00:23:07,729 --> 00:23:09,969
数据中心可能需要很多毫秒，

494
00:23:09,969 --> 00:23:12,729
并且在您知道的世界中

495
00:23:12,729 --> 00:23:16,959
计算需要纳秒，这

496
00:23:16,959 --> 00:23:22,209
本质上是一笔不小的开支，

497
00:23:22,209 --> 00:23:25,219
实际上，您可以从表

498
00:23:25,219 --> 00:23:28,039
6 和表 6 中看到，如果您查看它，它

499
00:23:28,039 --> 00:23:32,299
描述的是扳手部署的性能，

500
00:23:32,299 --> 00:23:33,919
其中不同的

501
00:23:33,919 --> 00:23:35,389
副本位于

502
00:23:35,389 --> 00:23:38,089
美国东部和 西海岸，

503
00:23:38,089 --> 00:23:41,319
完成一个事务大约需要一百毫秒，

504
00:23:41,319 --> 00:23:43,699
其中

505
00:23:43,699 --> 00:23:45,349
涉及的不同副本位于

506
00:23:45,349 --> 00:23:47,690
不同的外套上，这是一个巨大的

507
00:23:47,690 --> 00:23:50,299
时间，它是十分之一秒，

508
00:23:50,299 --> 00:23:51,499
可能并不像看起来那么糟糕，

509
00:23:51,499 --> 00:23:53,179
因为 系统，

510
00:23:53,179 --> 00:23:55,609
因为它是分片的，它可以并行运行

511
00:23:55,609 --> 00:23:57,379
许多非冲突事务，

512
00:23:57,379 --> 00:23:58,819
吞吐量可能非常

513
00:23:58,819 --> 00:24:02,239
高，但它们对单个事务的延迟

514
00:24:02,239 --> 00:24:03,679
非常重要我的意思是

515
00:24:03,679 --> 00:24:05,659
一百毫秒可能

516
00:24:05,659 --> 00:24:07,190
比人类注意到的要少，但是

517
00:24:07,190 --> 00:24:09,679
如果你 必须做其中的几个

518
00:24:09,679 --> 00:24:11,539
才能说生成网页或

519
00:24:11,539 --> 00:24:13,429
执行人工指令，这开始需要

520
00:24:13,429 --> 00:24:14,839
大量时间 哎呀

521
00:24:14,839 --> 00:24:16,700
，另一方面，你明显开始烦人

522
00:24:16,700 --> 00:24:19,060
 

523
00:24:19,060 --> 00:24:21,250
了，因为我想我怀疑

524
00:24:21,250 --> 00:24:23,920
从扳手的许多用途来看，所有

525
00:24:23,920 --> 00:24:26,980
复制品可能都在同一个城市或

526
00:24:26,980 --> 00:24:29,680
城市的另一边，而且它们

527
00:24:29,680 --> 00:24:31,270
是你可以看到的更快的时间 表

528
00:24:31,270 --> 00:24:34,600
三与地球相关 表

529
00:24:34,600 --> 00:24:36,520
三表明它可以完成

530
00:24:36,520 --> 00:24:38,230
数据中心

531
00:24:38,230 --> 00:24:40,300
附近的事务你知道我认为

532
00:24:40,300 --> 00:24:42,610
它是 14 毫秒而不是 100

533
00:24:42,610 --> 00:24:44,640
毫秒，所以这并不完全如此，

534
00:24:44,640 --> 00:24:47,590
尽管如此这些读/写

535
00:24:47,590 --> 00:24:50,680
事务足够慢

536
00:24:50,680 --> 00:24:54,550
如果可能

537
00:24:54,550 --> 00:24:58,090
的话，我们希望避免费用，这将把我们带到

538
00:24:58,090 --> 00:24:59,860
只读事务中，事实证明，

539
00:24:59,860 --> 00:25:01,450
如果你不写，那就是如果你

540
00:25:01,450 --> 00:25:03,640
事先知道

541
00:25:03,640 --> 00:25:05,320
事务中的所有操作都是

542
00:25:05,320 --> 00:25:08,020
保证被读取，然后 spanner 有

543
00:25:08,020 --> 00:25:10,300
一个更快、更精简、

544
00:25:10,300 --> 00:25:13,080
更少大量消息密集型方案

545
00:25:13,080 --> 00:25:18,480
来执行只读

546
00:25:19,680 --> 00:25:28,450
事务，所以只读事务开始

547
00:25:28,450 --> 00:25:30,010
一个新主题

548
00:25:30,010 --> 00:25:32,170
尽管它们依赖于

549
00:25:32,170 --> 00:25:33,730
来自读写事务的一些信息，但仅读取事务可以工作

550
00:25:33,730 --> 00:25:38,800
，而设计与

551
00:25:38,800 --> 00:25:45,040
spanner 中的读写事务的读取完全不同，

552
00:25:45,040 --> 00:25:49,330
消除了两个大成本，它的

553
00:25:49,330 --> 00:25:50,860
只读事务设计消除了存在的

554
00:25:50,860 --> 00:25:53,020
两个成本，首先是

555
00:25:53,020 --> 00:25:54,670
读写事务 最重要的是，正如我

556
00:25:54,670 --> 00:25:57,540
提到的，它从本地副本读取

557
00:25:57,540 --> 00:26:00,910
，所以如果你有一个副本，只要

558
00:26:00,910 --> 00:26:02,740
有副本 DVD 客户端

559
00:26:02,740 --> 00:26:04,300
需要本地数据中心中的事务需要，

560
00:26:04,300 --> 00:26:06,820
你就可以

561
00:26:06,820 --> 00:26:08,080
从本地副本读取，这可能需要

562
00:26:08,080 --> 00:26:10,420
 

563
00:26:10,420 --> 00:26:12,540
 

564
00:26:12,540 --> 00:26:14,230
如果您必须穿越

565
00:26:14,230 --> 00:26:15,910
国家，则可以与一小部分毫秒进行交谈，而不是几十毫秒，以便它可以从本地

566
00:26:15,910 --> 00:26:18,850
副本中读取，但是您再次知道节点的

567
00:26:18,850 --> 00:26:20,920
危险是任何给定的副本

568
00:26:20,920 --> 00:26:23,140
可能不是最新的所以 必须有

569
00:26:23,140 --> 00:26:24,780
一个故事

570
00:26:24,780 --> 00:26:27,690
，另一个大节省和

571
00:26:27,690 --> 00:26:29,850
只读设计是它不使用

572
00:26:29,850 --> 00:26:32,070
锁它不使用两阶段提交我的

573
00:26:32,070 --> 00:26:33,960
意思是不 需要一个事务

574
00:26:33,960 --> 00:26:37,410
管理器，这样可以避免

575
00:26:37,410 --> 00:26:39,660
跨数据中心或跨数据中心

576
00:26:39,660 --> 00:26:42,900
向 PAC 发送这些领导者的消息，

577
00:26:42,900 --> 00:26:44,610
因为没有锁被取出，这

578
00:26:44,610 --> 00:26:45,330
不仅使只读

579
00:26:45,330 --> 00:26:47,550
事务更快，而且避免了

580
00:26:47,550 --> 00:26:49,230
减慢只读读写

581
00:26:49,230 --> 00:26:50,850
事务的速度 因为他们现在不必对

582
00:26:50,850 --> 00:26:52,680
只读事务持有的锁进行评级，

583
00:26:52,680 --> 00:26:54,810
我的意思只是为了

584
00:26:54,810 --> 00:26:57,320
预览一下为什么这对他们很重要

585
00:26:57,320 --> 00:27:01,980
表 3 和表 6 显示，

586
00:27:01,980 --> 00:27:03,900
 

587
00:27:03,900 --> 00:27:07,410
与读写事务相比，只读事务的延迟改进了十倍，所以

588
00:27:07,410 --> 00:27:10,230
主要的唯一设计是延迟提交因子

589
00:27:10,230 --> 00:27:13,950
10 提高，并且

590
00:27:13,950 --> 00:27:15,450
复杂性低得多，几乎可以肯定

591
00:27:15,450 --> 00:27:17,580
吞吐量也高得多，最大的挑战

592
00:27:17,580 --> 00:27:19,980
是如何让你

593
00:27:19,980 --> 00:27:21,630
知道真正的交易不会做很多

594
00:27:21,630 --> 00:27:23,310
安静的事情 需要并且

595
00:27:23,310 --> 00:27:25,260
我们不会重写事务来获得

596
00:27:25,260 --> 00:27:28,350
序列化能力，所以我们

597
00:27:28,350 --> 00:27:30,570
需要找到一种方法来平衡

598
00:27:30,570 --> 00:27:32,400
这种提高的效率和

599
00:27:32,400 --> 00:27:35,940
正确性，所以有' 确实有两个

600
00:27:35,940 --> 00:27:39,510
主要的正确性约束，他们

601
00:27:39,510 --> 00:27:42,390
希望强加只读事务

602
00:27:42,390 --> 00:27:44,990
第一个是他们喜欢所有

603
00:27:44,990 --> 00:27:46,680
事务，它们仍然需要可

604
00:27:46,680 --> 00:27:52,460
序列化，这意味着

605
00:27:52,460 --> 00:27:55,130
即使只是审查，

606
00:27:55,130 --> 00:27:58,310
即使系统可能同时执行事务

607
00:27:58,310 --> 00:28:01,890
并行

608
00:28:01,890 --> 00:28:04,290
一堆并发事务

609
00:28:04,290 --> 00:28:06,600
 

610
00:28:06,600 --> 00:28:08,190
必须在返回给客户端的值

611
00:28:08,190 --> 00:28:10,650
和对数据库的修改方面产生的

612
00:28:10,650 --> 00:28:12,150
结果 一堆并发

613
00:28:12,150 --> 00:28:14,250
事务的结果必须与

614
00:28:14,250 --> 00:28:19,320
一次或串行执行中的某个相同

615
00:28:19,320 --> 00:28:23,580
这些事务和只读

616
00:28:23,580 --> 00:28:25,200
事务的本质

617
00:28:25,200 --> 00:28:28,620
意味着，一个只读事务的整个所有读取

618
00:28:28,620 --> 00:28:30,450
必须有效

619
00:28:30,450 --> 00:28:34,560
地巧妙地适应一堆事务的所有权利，

620
00:28:34,560 --> 00:28:37,620
这些事务可以被

621
00:28:37,620 --> 00:28:38,610
视为在它之前进行

622
00:28:38,610 --> 00:28:41,160
，并且 它不能

623
00:28:41,160 --> 00:28:42,870
看到我们将要查看的交易的任何权利，

624
00:28:42,870 --> 00:28:45,240
因为它正在追踪它，所以

625
00:28:45,240 --> 00:28:47,040
我们需要一种方法来对它进行排序 t 读取

626
00:28:47,040 --> 00:28:48,809
事务的所有读取 只读

627
00:28:48,809 --> 00:28:50,790
事务 在读写事务之间整齐地读取

628
00:28:50,790 --> 00:28:56,280
 

629
00:28:56,280 --> 00:29:00,000
论文谈到的另一个大约束

630
00:29:00,000 --> 00:29:01,410
是他们想要外部

631
00:29:01,410 --> 00:29:08,760
一致性，这意味着它

632
00:29:08,760 --> 00:29:15,450
实际上等同于

633
00:29:15,450 --> 00:29:16,770
我们已经看到的线性化能力 在这真正

634
00:29:16,770 --> 00:29:19,020
意味着之前，如果一个事务提交

635
00:29:19,020 --> 00:29:21,900
完成提交并且另一个

636
00:29:21,900 --> 00:29:24,840
事务在第一个事务实时完成之后开始，

637
00:29:24,840 --> 00:29:27,929
 

638
00:29:27,929 --> 00:29:30,419
那么第二个事务需要

639
00:29:30,419 --> 00:29:32,610
查看第一个事务完成的权限

640
00:29:32,610 --> 00:29:34,440
另一种说法

641
00:29:34,440 --> 00:29:36,630
是事务甚至读取 -only

642
00:29:36,630 --> 00:29:39,140
事务不应该看到陈旧的数据

643
00:29:39,140 --> 00:29:42,960
，如果

644
00:29:42,960 --> 00:29:45,360
 

645
00:29:45,360 --> 00:29:47,520
在只读事务开始之前的只读事务之前完成的事务有提交的写入，则需要只读事务

646
00:29:47,520 --> 00:29:49,290
 

647
00:29:49,290 --> 00:29:51,240
才能看到

648
00:29:51,240 --> 00:29:57,540
该权限，所以这实际上是

649
00:29:57,540 --> 00:29:58,650
这些都不是特别

650
00:29:58,650 --> 00:30:02,130
令人惊讶，但像

651
00:30:02,130 --> 00:30:07,320
我的续集或其他标准数据库 例如，

652
00:30:07,320 --> 00:30:09,720
可以配置为提供

653
00:30:09,720 --> 00:30:11,309
这种一致性，所以在某种程度上

654
00:30:11,309 --> 00:30:14,130
，如果你不知道

655
00:30:14,130 --> 00:30:16,200
更好，这正是

656
00:30:16,200 --> 00:30:18,450
你对一个简单的系统所期望的一致性，

657
00:30:18,450 --> 00:30:21,900
并且你

658
00:30:21,900 --> 00:30:23,520
知道

659
00:30:23,520 --> 00:30:24,990
有它但是 它使程序员生活

660
00:30:24,990 --> 00:30:27,720
它使产生正确答案变得更加容易

661
00:30:27,720 --> 00:30:30,120
，否则你

662
00:30:30,120 --> 00:30:32,570
没有这种一致性然后

663
00:30:32,570 --> 00:30:34,740
程序员负责

664
00:30:34,740 --> 00:30:36,360
围绕

665
00:30:36,360 --> 00:30:38,460
数据库可能提供的任何异常进行编程所以这就像

666
00:30:38,460 --> 00:30:39,390
一个晚上这有点像 正确性的黄金

667
00:30:39,390 --> 00:30:42,350
标准

668
00:30:42,350 --> 00:30:48,570
好的，所以我想谈谈

669
00:30:48,570 --> 00:30:50,130
我们如何只让交易工作。这

670
00:30:50,130 --> 00:30:52,590
是一个复杂的故事，所以我想

671
00:30:52,590 --> 00:30:54,920
我想首先谈谈

672
00:30:54,920 --> 00:30:57,390
如果我们这样做会发生什么

673
00:30:57,390 --> 00:30:59,490
绝对是最愚蠢的事情，

674
00:30:59,490 --> 00:31:02,850
并且只读事务没有做

675
00:31:02,850 --> 00:31:05,340
任何特别的事情来实现一致性，

676
00:31:05,340 --> 00:31:07,470
而只是读取数据的最新副本，

677
00:31:07,470 --> 00:31:09,000
所以每次我只读

678
00:31:09,000 --> 00:31:12,960
事务时都会做 es 读取我们

679
00:31:12,960 --> 00:31:15,930
可以让它查看本地副本并

680
00:31:15,930 --> 00:31:20,100
找到当前最新

681
00:31:20,100 --> 00:31:21,330
的数据副本，这将是非常

682
00:31:21,330 --> 00:31:24,570
简单的非常低的开销，因此我们

683
00:31:24,570 --> 00:31:27,620
需要了解为什么它不能正常

684
00:31:27,620 --> 00:31:34,710
工作所以 这是一个所以为什么不

685
00:31:34,710 --> 00:31:43,650
读取最新的值，所以也许

686
00:31:43,650 --> 00:31:45,870
我们会想象交易是一个

687
00:31:45,870 --> 00:31:51,420
简单地读取 x 和 y

688
00:31:51,420 --> 00:31:54,840
并将它们打印出来的交易金融只读我

689
00:31:54,840 --> 00:31:57,150
要打印 Y 我就 print X comma

690
00:31:57,150 --> 00:31:59,360
Y

691
00:32:01,100 --> 00:32:03,980
好的，所以我想向您展示一个

692
00:32:03,980 --> 00:32:07,070
示例，其中读取

693
00:32:07,070 --> 00:32:08,299
具有此事务的

694
00:32:08,299 --> 00:32:12,070
只是最新值产生不正确的

695
00:32:12,070 --> 00:32:14,809
不可序列化结果，因此假设我们

696
00:32:14,809 --> 00:32:21,519
有三个正在运行的事务 t1 t2 t3

697
00:32:21,639 --> 00:32:24,200
t3 将 是我们的交易 t1 和

698
00:32:24,200 --> 00:32:27,409
t2 或者是我们重写

699
00:32:27,409 --> 00:32:31,279
交易的交易，所以假设 t1 正确的

700
00:32:31,279 --> 00:32:36,200
性别和权利，然后提交，

701
00:32:36,200 --> 00:32:37,789
你知道它可能是一个银行转账

702
00:32:37,789 --> 00:32:39,080
操作，所以它把钱

703
00:32:39,080 --> 00:32:41,509
从 X 转移到 Y，我们正在打印 x 和 y

704
00:32:41,509 --> 00:32:42,769
因为我们是 d 对银行

705
00:32:42,769 --> 00:32:44,149
进行审计以确保它没有亏损

706
00:32:44,149 --> 00:32:48,759
让我们假设事务 2

707
00:32:48,759 --> 00:32:53,149
还在余额 x 和 y 之间进行了另一次转账

708
00:32:53,149 --> 00:32:54,919
，然后提交，现在我们有了

709
00:32:54,919 --> 00:32:57,769
我们的事务事务 t3，它

710
00:32:57,769 --> 00:32:59,960
需要读取 x 和 y，所以它是 将

711
00:32:59,960 --> 00:33:01,509
读取 X 假设读取 X

712
00:33:01,509 --> 00:33:04,730
发生在这个时间点，所以

713
00:33:04,730 --> 00:33:07,730
我绘制这些图表的方式

714
00:33:07,730 --> 00:33:10,519
是实时移动到

715
00:33:10,519 --> 00:33:12,679
您在手表上看到的正确挂钟时间

716
00:33:12,679 --> 00:33:14,899
向右移动，因此

717
00:33:14,899 --> 00:33:17,210
在事务 1

718
00:33:17,210 --> 00:33:20,289
完成之后，事务 2 开始之前，X 的读取发生在这里

719
00:33:20,289 --> 00:33:22,940
，假设 T 3 在一台速度较慢的计算机上运行，

720
00:33:22,940 --> 00:33:24,769
所以它只能在很久以后才设法发出

721
00:33:24,769 --> 00:33:29,179
对 Y 的读取，所以这

722
00:33:29,179 --> 00:33:31,460
将会发挥作用 是事务 3

723
00:33:31,460 --> 00:33:35,720
将看到 t1 写入的 Y 值，但

724
00:33:35,720 --> 00:33:41,590
t2 写入的 x 值

725
00:33:41,710 --> 00:33:45,259
假设它使用这个可疑的过程

726
00:33:45,259 --> 00:33:47,360
，即简单地读取

727
00:33:47,360 --> 00:33:51,559
数据库中的最新值，因此这

728
00:33:51,559 --> 00:33:56,539
不是可序列化的，因为我们

729
00:33:56,539 --> 00:33:59,059
知道任何串行顺序 可能存在

730
00:33:59,059 --> 00:34:06,080
必须 有 t1 后跟 t2 只有

731
00:34:06,080 --> 00:34:09,109
2 个地方牙齿 rica 去所以 t3 可以去

732
00:34:09,109 --> 00:34:11,560
这里

733
00:34:13,540 --> 00:34:15,699
不能放在这里，因为如果 t3

734
00:34:15,699 --> 00:34:18,040
在等效的序列顺序中排在第二位，那么它

735
00:34:18,040 --> 00:34:20,050
不应该看到 t2 的权利，

736
00:34:20,050 --> 00:34:22,630
它应该看到价值 Y

737
00:34:22,630 --> 00:34:25,210
由 t1 产生，但它没有写入它

738
00:34:25,210 --> 00:34:28,330
看到 t3 由 t2 产生的值，所以

739
00:34:28,330 --> 00:34:31,600
这不是等价的 这个序列

740
00:34:31,600 --> 00:34:33,040
订单不会产生相同的

741
00:34:33,040 --> 00:34:35,050
结果 我们唯一可用的另一个是

742
00:34:35,050 --> 00:34:39,130
这个序列订单会得到的

743
00:34:39,130 --> 00:34:41,168
与 t3 实际产生的 y 值相同，

744
00:34:41,168 --> 00:34:45,370
但如果这是串行

745
00:34:45,370 --> 00:34:47,290
订单，则 t3 应该看到

746
00:34:47,290 --> 00:34:49,510
t2 写入的值，但它实际上看到了

747
00:34:49,510 --> 00:34:52,659
t1 写入的有价值的值，因此此

748
00:34:52,659 --> 00:34:55,090
执行不等于一次执行任何一个

749
00:34:55,090 --> 00:34:58,990
订单

750
00:34:58,990 --> 00:35:03,250
所以这就像读取

751
00:35:03,250 --> 00:35:06,190
只是读取最新值有问题所以我们

752
00:35:06,190 --> 00:35:08,140
知道这不起作用你知道

753
00:35:08,140 --> 00:35:09,790
我们真正要寻找的当然是

754
00:35:09,790 --> 00:35:13,120
我们的交易

755
00:35:13,120 --> 00:35:16,720
要么在这个时间点读取这两个值

756
00:35:16,720 --> 00:35:20,200
或者它 在

757
00:35:20,200 --> 00:35:31,030
这个时间点同时读取这两个值 好的，

758
00:35:31,030 --> 00:35:36,040
所以跨越我们的口味的方法

759
00:35:36,040 --> 00:35:40,630
有点复杂 第一个大想法是

760
00:35:40,630 --> 00:35:42,730
一个现有的想法，

761
00:35:42,730 --> 00:35:46,020
它被称为快照隔离

762
00:35:52,369 --> 00:35:59,390
，我要描述的方式是

763
00:35:59,390 --> 00:36:01,930
让我们想象所有

764
00:36:01,930 --> 00:36:04,309
所涉及的计算机有同步

765
00:36:04,309 --> 00:36:06,680
时钟，你知道他们都有一个

766
00:36:06,680 --> 00:36:09,589
时钟，时钟可以为我们提供

767
00:36:09,589 --> 00:36:13,579
时钟或挂钟时间，比如哦，它是

768
00:36:13,579 --> 00:36:17,779
2020 年 4 月 7 日下午 143 点，所以这

769
00:36:17,779 --> 00:36:20,089
就是我们所说的挂钟时间一次的意思，

770
00:36:20,089 --> 00:36:21,920
所以假设

771
00:36:21,920 --> 00:36:25,069
尽管这不是真的所有计算机都假设

772
00:36:25,069 --> 00:36:26,150
所有涉及的计算机都具有

773
00:36:26,150 --> 00:36:29,779
同步时间此外让我们

774
00:36:29,779 --> 00:36:32,150
假设每个事务都被

775
00:36:32,150 --> 00:36:37,059
分配一个特定时间一个时间戳

776
00:36:37,420 --> 00:36:40,420
和

777
00:36:42,360 --> 00:36:46,620
时间戳他们的挂钟时间

778
00:36:46,620 --> 00:36:48,510
从这些同步时钟中获取用于

779
00:36:48,510 --> 00:36:52,130
读写事务它的时间戳

780
00:36:52,130 --> 00:36:55,080
我要说的只是这个

781
00:36:55,080 --> 00:36:58,860
简化的设计是在提交时的实时

782
00:36:58,860 --> 00:37:01,370
 

783
00:37:01,960 --> 00:37:06,210
和读取的

784
00:37:06,210 --> 00:37:08,680
时间 管理器开始

785
00:37:08,680 --> 00:37:11,800
提交，对于只读事务，

786
00:37:11,800 --> 00:37:17,740
时间戳等于开始时间，

787
00:37:17,740 --> 00:37:18,609
所以每个结果都是

788
00:37:18,609 --> 00:37:22,599
时间，我们将设计我们的系统

789
00:37:22,599 --> 00:37:25,569
或快照隔离系统被

790
00:37:25,569 --> 00:37:28,839
设计为执行，就好像获得

791
00:37:28,839 --> 00:37:31,059
相同 结果就像所有事务

792
00:37:31,059 --> 00:37:34,210
都按时间戳顺序执行一样，因此

793
00:37:34,210 --> 00:37:35,890
我们将为每个事务分配

794
00:37:35,890 --> 00:37:37,839
一个时间戳，然后我们

795
00:37:37,839 --> 00:37:40,170
将安排执行，

796
00:37:40,170 --> 00:37:42,910
以便事务获得结果，就好像

797
00:37:42,910 --> 00:37:45,249
它们已按该顺序执行一样 考虑

798
00:37:45,249 --> 00:37:46,869
到时间戳，我们

799
00:37:46,869 --> 00:37:49,059
需要一个可以

800
00:37:49,059 --> 00:37:51,489
轻松尊重时间戳的实现，并且

801
00:37:51,489 --> 00:37:53,589
基本上您知道向每个事务显示

802
00:37:53,589 --> 00:37:57,779
其时间戳中存在的数据排序，

803
00:37:57,779 --> 00:38:01,059
所以这

804
00:38:01,059 --> 00:38:09,190
适用于只读事务的方式是

805
00:38:09,190 --> 00:38:12,009
每个副本在存储数据时

806
00:38:12,009 --> 00:38:13,569
实际上都有多个版本的

807
00:38:13,569 --> 00:38:19,410
数据，所以我们有一个多版本的

808
00:38:19,410 --> 00:38:24,850
数据库，每条数据库记录都有你

809
00:38:24,850 --> 00:38:26,230
知道，如果它被写成一对 e

810
00:38:26,230 --> 00:38:27,970
次它在每次写入时都有该记录的单独副本，其中

811
00:38:27,970 --> 00:38:29,830
 

812
00:38:29,830 --> 00:38:30,130
 

813
00:38:30,130 --> 00:38:33,000
每一个都与

814
00:38:33,000 --> 00:38:35,350
写入它的事务的时间戳相关联

815
00:38:35,350 --> 00:38:42,820
，然后是在

816
00:38:42,820 --> 00:38:45,040
只读事务发生时

817
00:38:45,040 --> 00:38:47,230
只读事务的基本策略 读取

818
00:38:47,230 --> 00:38:49,530
 

819
00:38:49,530 --> 00:38:52,570
它在开始时已经为自己分配了一个时间戳，因此它伴随

820
00:38:52,570 --> 00:38:55,900
其读取请求及其时间戳以及

821
00:38:55,900 --> 00:39:00,970
存储事务所需数据副本的任何服务器它将

822
00:39:00,970 --> 00:39:02,890
 

823
00:39:02,890 --> 00:39:04,360
 

824
00:39:04,360 --> 00:39:06,130
查看其多版本数据库并

825
00:39:06,130 --> 00:39:10,810
找到记录 被要求

826
00:39:10,810 --> 00:39:12,580
作为仍然小于只读事务指定的时间戳的最高时间，

827
00:39:12,580 --> 00:39:16,390
 

828
00:39:16,390 --> 00:39:17,920
所以这意味着

829
00:39:17,920 --> 00:39:19,390
成为唯一的事务类型看到的

830
00:39:19,390 --> 00:39:23,080
数据是截至时间的数据，

831
00:39:23,080 --> 00:39:28,420
它的时间 jozin 时间戳可以，所以这

832
00:39:28,420 --> 00:39:32,380
是 对于这个快照隔离思想

833
00:39:32,380 --> 00:39:34,960
适用于只读事务或

834
00:39:34,960 --> 00:39:36,190
spanner 将其用于只读

835
00:39:36,190 --> 00:39:40,440
事务 spinner 用户仍然使用

836
00:39:40,440 --> 00:39:42,520
两阶段锁定和两个 p  hase commit

837
00:39:42,520 --> 00:39:45,760
用于读写事务，因此

838
00:39:45,760 --> 00:39:47,230
读写事务

839
00:39:47,230 --> 00:39:48,730
为自己分配时间戳一个提交时间，

840
00:39:48,730 --> 00:39:50,650
但除此之外，它们以

841
00:39:50,650 --> 00:39:52,510
通常的方式使用锁和两阶段

842
00:39:52,510 --> 00:39:54,150
提交工作，其中只读

843
00:39:54,150 --> 00:39:58,270
事务访问

844
00:39:58,270 --> 00:39:59,680
数据库中的多个版本并获取版本 那就是

845
00:39:59,680 --> 00:40:03,550
你知道写的

846
00:40:03,550 --> 00:40:04,450
时间戳

847
00:40:04,450 --> 00:40:05,890
是最高的，仍然

848
00:40:05,890 --> 00:40:07,770
小于只读事务的时间日期

849
00:40:07,770 --> 00:40:09,760
，这将使我们

850
00:40:09,760 --> 00:40:11,650
知道只读事务

851
00:40:11,650 --> 00:40:14,320
将看到

852
00:40:14,320 --> 00:40:16,270
具有较低时间戳的读写事务的所有权限，并且

853
00:40:16,270 --> 00:40:18,370
没有更高 tyst 时间戳的读/写事务的权利，

854
00:40:18,370 --> 00:40:21,930
 

855
00:40:21,930 --> 00:40:24,980
所以对于

856
00:40:24,980 --> 00:40:31,810
 

857
00:40:33,579 --> 00:40:37,690
我之前在这里的示例示例，隔离如何解决，在该示例中，

858
00:40:37,690 --> 00:40:39,970
 

859
00:40:39,970 --> 00:40:44,930
由于

860
00:40:44,930 --> 00:40:51,230
在读取不在之间的值之前读取事务读取，因此串行可串行化失败

861
00:40:51,230 --> 00:40:53,720
任何其他两

862
00:40:53,720 --> 00:40:56,000
笔交易都可以，所以这是

863
00:40:56,000 --> 00:41:01,150
我们的示例，但

864
00:41:01,150 --> 00:41:04,820
我向您展示了快照隔离 是为了表明

865
00:41:04,820 --> 00:41:08,720
快照隔离技术解决了我们的

866
00:41:08,720 --> 00:41:11,930
问题导致只读

867
00:41:11,930 --> 00:41:15,470
事务可序列化所以我们再次拥有

868
00:41:15,470 --> 00:41:18,320
这两个读写事务 t1 和

869
00:41:18,320 --> 00:41:20,480
t2 并且我们的事务是

870
00:41:20,480 --> 00:41:29,750
只读事务 t1 和 t2 就像

871
00:41:29,750 --> 00:41:36,530
在他们写入之前一样 他们提交，但

872
00:41:36,530 --> 00:41:36,859
现在

873
00:41:36,859 --> 00:41:39,200
他们在

874
00:41:39,200 --> 00:41:41,900
提交时为自己分配时间戳，所以除了

875
00:41:41,900 --> 00:41:43,369
使用双面命令和两阶段

876
00:41:43,369 --> 00:41:44,960
锁定之外，这些读/写事务

877
00:41:44,960 --> 00:41:46,880
分配一个时间戳，所以让我们

878
00:41:46,880 --> 00:41:49,609
假设在提交时 T one

879
00:41:49,609 --> 00:41:52,039
看了看时钟，发现

880
00:41:52,039 --> 00:41:54,799
时间是十点，我将使用十点

881
00:41:54,799 --> 00:41:57,529
和二十点之类的时间，但你知道你

882
00:41:57,529 --> 00:41:59,150
应该把时间想象成真实的时间，

883
00:41:59,150 --> 00:42:01,009
比如给定一天的凌晨四点，

884
00:42:01,009 --> 00:42:05,150
所以让我们说 T one

885
00:42:05,150 --> 00:42:09,190
看到提交时间为 10，T 2

886
00:42:09,190 --> 00:42:11,599
看到提交时间为

887
00:42:11,599 --> 00:42:14,049
20，所以我将

888
00:42:14,049 --> 00:42:18,680
在 @ 符号之后编写这些事务选择时间戳，

889
00:42:18,680 --> 00:42:22,940
然后数据库存储系统跨度

890
00:42:22,940 --> 00:42:25,329
我们的 st

891
00:42:25,329 --> 00:42:27,619
当事务 1 进行写入时，

892
00:42:27,619 --> 00:42:29,900
orage 系统将存储它们将存储一种新的 not

893
00:42:29,900 --> 00:42:31,160
而不是覆盖当前

894
00:42:31,160 --> 00:42:33,319
值，它们只会添加

895
00:42:33,319 --> 00:42:35,480
该记录的新副本和时间戳，

896
00:42:35,480 --> 00:42:37,099
因此数据库将是 要

897
00:42:37,099 --> 00:42:39,619
存储一条新记录，这表示

898
00:42:39,619 --> 00:42:43,009
x 在时间 10 的值是任何它

899
00:42:43,009 --> 00:42:46,480
碰巧是 9

900
00:42:46,480 --> 00:42:51,710
记录 Y 在时间 10 的值是 C 11 也许我们

901
00:42:51,710 --> 00:42:56,839
正在从 X 转移到 Y 类似 C

902
00:42:56,839 --> 00:42:58,489
2 选择时间戳 20，因为那是

903
00:42:58,489 --> 00:43:00,470
提交时的实时时间，并且

904
00:43:00,470 --> 00:43:02,089
数据库会记住一组新

905
00:43:02,089 --> 00:43:04,970
记录，除了这些旧记录之外，它

906
00:43:04,970 --> 00:43:10,599
会在 20 时说 X，也许我们在时间进行了

907
00:43:10,599 --> 00:43:14,210
从 X 到 Y 和 Y 的另一次传输

908
00:43:14,210 --> 00:43:18,259
20 等于 12 哦，所以现在我们

909
00:43:18,259 --> 00:43:19,519
在不同时间有每条记录的两个副本，

910
00:43:19,519 --> 00:43:21,859
现在事务 3 将出现

911
00:43:21,859 --> 00:43:25,640
并再次开始大约在这个时间

912
00:43:25,640 --> 00:43:27,950
并读取 X 并且再次它

913
00:43:27,950 --> 00:43:30,470
会很慢所以你知道它不会

914
00:43:30,470 --> 00:43:31,880
得到 直到很久以后才开始阅读葡萄酒

915
00:43:31,880 --> 00:43:35,200
实时

916
00:43:35,200 --> 00:43:38,450
然而，当事务 3 开始时，它

917
00:43:38,450 --> 00:43:40,670
通过

918
00:43:40,670 --> 00:43:43,640
查看当前时间来选择时间戳，所以

919
00:43:43,640 --> 00:43:45,680
假设因为我们实时知道

920
00:43:45,680 --> 00:43:48,589
事务 3

921
00:43:48,589 --> 00:43:50,109
在事务 2 之前的事务 1 之后开始，

922
00:43:50,109 --> 00:43:52,239
所以它必须选择一个事务

923
00:43:52,239 --> 00:43:55,259
时间在 10 到 20 之间，

924
00:43:55,259 --> 00:43:59,440
假设它从 15 开始，并

925
00:43:59,440 --> 00:44:02,410
为自己选择了时间戳 15，这

926
00:44:02,410 --> 00:44:05,710
意味着当它读取 X 时，它

927
00:44:05,710 --> 00:44:09,400
会向持有 X 的本地副本发送请求

928
00:44:09,400 --> 00:44:11,559
，它会

929
00:44:11,559 --> 00:44:13,480
伴随它是时间 15 的时间戳它会

930
00:44:13,480 --> 00:44:15,730
说请给我截至

931
00:44:15,730 --> 00:44:19,900
时间 15 的最新数据，当然事务 2000

932
00:44:19,900 --> 00:44:21,970
尚未执行，但是

933
00:44:21,970 --> 00:44:26,890
X 的最高时间戳副本是

934
00:44:26,890 --> 00:44:29,289
从时间 10 开始由事务 1 写入的，所以

935
00:44:29,289 --> 00:44:33,489
我们将得到 9 这一次

936
00:44:33,489 --> 00:44:35,619
通过事务 2 现在提交

937
00:44:35,619 --> 00:44:37,359
事务 3 在一家公司再次进行第二次读取

938
00:44:37,359 --> 00:44:39,700
，该公司适合读取请求，

939
00:44:39,700 --> 00:44:42,339
其时间戳为 15 中心

940
00:44:42,339 --> 00:44:43,569
服务器现在服务器必须

941
00:44:43,569 --> 00:44:46,390
记录但 再次因为服务器

942
00:44:46,390 --> 00:44:48,849
获得事务三时间戳 15

943
00:44:48,849 --> 00:44:51,009
它查看它的记录并说 ha 15

944
00:44:51,009 --> 00:44:53,349
位于这两个之间

945
00:44:53,349 --> 00:44:56,170
 

946
00:44:56,170 --> 00:44:59,140
 

947
00:44:59,140 --> 00:45:02,380
Y

948
00:45:02,380 --> 00:45:04,930
从时间 10 开始，因此 Y 的读取将

949
00:45:04,930 --> 00:45:06,450
在 11 返回

950
00:45:06,450 --> 00:45:09,489
，即 X 的读取基本上

951
00:45:09,489 --> 00:45:11,410
发生在此时，但是因为我们

952
00:45:11,410 --> 00:45:13,450
记住了一个时间戳，并且我们让

953
00:45:13,450 --> 00:45:17,200
数据库将数据保存在不同的时间

954
00:45:17,200 --> 00:45:17,769
，就

955
00:45:17,769 --> 00:45:21,940
好像两者都有 读取发生在时间

956
00:45:21,940 --> 00:45:25,630
15 而不是一个在时间 15 和一个

957
00:45:25,630 --> 00:45:29,680
之后，现在您会看到实际上

958
00:45:29,680 --> 00:45:33,730
这实际上只是一次模拟串行

959
00:45:33,730 --> 00:45:35,499
执行，其中

960
00:45:35,499 --> 00:45:38,470
顺序是时间戳顺序事务 1

961
00:45:38,470 --> 00:45:41,349
和事务 - 抱歉然后是事务

962
00:45:41,349 --> 00:45:46,569
3 然后事务 2

963
00:45:46,569 --> 00:45:48,460
是等同

964
00:45:48,460 --> 00:45:50,619
于实际产生的串行订单，是时间戳

965
00:45:50,619 --> 00:45:54,210
顺序 10 15 20

966
00:45:55,780 --> 00:46:01,520
 

967
00:46:01,520 --> 00:46:05,510
 

968
00:46:05,510 --> 00:46:09,980
e 更复杂

969
00:46:09,980 --> 00:46:11,589
，我将在一分钟内解决

970
00:46:11,589 --> 00:46:15,109
一个问题，您可能有一个

971
00:46:15,109 --> 00:46:17,839
问题是为什么事务 3 可以读取

972
00:46:17,839 --> 00:46:20,450
y 的旧值，它

973
00:46:20,450 --> 00:46:23,720
在这个时间点发布了对 Y 的

974
00:46:23,720 --> 00:46:27,230
最新数据，为什么 这个值是 12，

975
00:46:27,230 --> 00:46:29,150
但实际得到的值是

976
00:46:29,150 --> 00:46:32,329
故意的陈旧值，不是

977
00:46:32,329 --> 00:46:34,700
最新值，而是不久前的值，

978
00:46:34,700 --> 00:46:37,190
这个值 11 那么

979
00:46:37,190 --> 00:46:39,770
为什么可以，为什么不使用

980
00:46:39,770 --> 00:46:45,290
最新版本的数据可以？

981
00:46:45,290 --> 00:46:47,450
一种技术上的理由

982
00:46:47,450 --> 00:46:50,930
是事务 2 和事务 3

983
00:46:50,930 --> 00:46:53,150
是并发的，即时间重叠，

984
00:46:53,150 --> 00:46:55,970
所以

985
00:46:55,970 --> 00:46:58,369
事务 2 的时间

986
00:46:58,369 --> 00:47:00,349
范围在这里，事务 3 的时间范围在这里，它们是

987
00:47:00,349 --> 00:47:03,290
并发的，并且线性化的规则

988
00:47:03,290 --> 00:47:05,630
能力和外部一致性，或者

989
00:47:05,630 --> 00:47:09,890
如果两个事务是并发的，

990
00:47:09,890 --> 00:47:12,890
那么数据库允许使用的串行顺序

991
00:47:12,890 --> 00:47:15,349
可以是可以将两个

992
00:47:15,349 --> 00:47:17,599
事务按任意顺序放置，

993
00:47:17,599 --> 00:47:20,180
这里数据库生成器选择放置

994
00:47:20,180 --> 00:47:22,790
trans 操作 3 在事务 2 之前

995
00:47:22,790 --> 00:47:28,280
按顺序执行 好的 Robert 我们有

996
00:47:28,280 --> 00:47:30,440
一个学生问题 像时间戳这样的外部

997
00:47:30,440 --> 00:47:32,359
一致性是否总是

998
00:47:32,359 --> 00:47:39,770
意味着强一致性 我是的

999
00:47:39,770 --> 00:47:43,250
 

1000
00:47:43,250 --> 00:47:46,640
 

1001
00:47:46,640 --> 00:47:48,290
 

1002
00:47:48,290 --> 00:47:51,080
而且我相信

1003
00:47:51,080 --> 00:47:53,590
线性化能力和

1004
00:47:53,590 --> 00:47:57,650
外部一致性的定义是相同的，所以我

1005
00:47:57,650 --> 00:48:01,070
会说是的，另一个问题

1006
00:48:01,070 --> 00:48:03,320
是这如何不绝对炸毁存储

1007
00:48:03,320 --> 00:48:05,930
，这是一个很好的问题，答案

1008
00:48:05,930 --> 00:48:09,380
是它肯定会炸毁存储

1009
00:48:09,380 --> 00:48:12,050
，原因是现在 存储

1010
00:48:12,050 --> 00:48:16,040
系统必须保留

1011
00:48:16,040 --> 00:48:17,840
最近多次修改的数据记录的多个副本

1012
00:48:17,840 --> 00:48:20,480
，这肯定会

1013
00:48:20,480 --> 00:48:23,660
花费这笔成本以及

1014
00:48:23,660 --> 00:48:26,360
内存中磁盘上的存储空间和空间，

1015
00:48:26,360 --> 00:48:28,370
而且它就像

1016
00:48:28,370 --> 00:48:30,890
您现在知道的一个额外的簿记层

1017
00:48:30,890 --> 00:48:34,540
考虑时间戳和

1018
00:48:34,630 --> 00:48:39,590
密钥，我认为存储费用并不

1019
00:48:39,590 --> 00:48:41,990
像它可能的那样大，因为系统

1020
00:48:41,990 --> 00:48:44,270
di  scards old records that paper没有

1021
00:48:44,270 --> 00:48:49,000
说明策略是什么，但

1022
00:48:49,000 --> 00:48:51,800
 

1023
00:48:51,800 --> 00:48:53,480
如果

1024
00:48:53,480 --> 00:48:54,650
多条记录的唯一原因是实现

1025
00:48:54,650 --> 00:48:57,680
这类事务的快照隔离，

1026
00:48:57,680 --> 00:48:59,570
那么它肯定会丢弃旧记录，那么你真的

1027
00:48:59,570 --> 00:49:02,980
不需要记住值 过去太远了，

1028
00:49:02,980 --> 00:49:06,920
因为您只

1029
00:49:06,920 --> 00:49:08,920
需要记住最早的时间值，

1030
00:49:08,920 --> 00:49:11,900
即事务可能开始的最早时间

1031
00:49:11,900 --> 00:49:13,760
现在仍在运行，并且如果您的

1032
00:49:13,760 --> 00:49:15,860
事务大部分您总是完成

1033
00:49:15,860 --> 00:49:18,080
或通过杀死它们来强制完成或

1034
00:49:18,080 --> 00:49:21,170
如果没有

1035
00:49:21,170 --> 00:49:22,400
事务可以花费超过一

1036
00:49:22,400 --> 00:49:23,690
分钟，那么你只需要

1037
00:49:23,690 --> 00:49:26,930
记住数据库中最后一分钟的版本

1038
00:49:26,930 --> 00:49:29,120
，实际上该文件

1039
00:49:29,120 --> 00:49:30,810
 

1040
00:49:30,810 --> 00:49:32,520
暗示他们比那更早两天，因为

1041
00:49:32,520 --> 00:49:36,570
看起来他们支持有意

1042
00:49:36,570 --> 00:49:39,930
支持这些 快照读取允许

1043
00:49:39,930 --> 00:49:42,870
他们支持看到你

1044
00:49:42,870 --> 00:49:44,520
知道不久前的数据的概念，你

1045
00:49:44,520 --> 00:49:46,590
知道昨天的数据，但他们没有

1046
00:49:46,590 --> 00:49:49,740
说 但是垃圾收集

1047
00:49:49,740 --> 00:49:52,380
策略是针对旧值的，所以我不知道

1048
00:49:52,380 --> 00:49:58,730
这对他们来说会有多贵，好吧

1049
00:49:58,730 --> 00:50:02,400
好吧，所以 ice 合法的理由

1050
00:50:02,400 --> 00:50:03,840
是，在外部一致性

1051
00:50:03,840 --> 00:50:06,900
中，外部一致性强加的唯一规则

1052
00:50:06,900 --> 00:50:09,000
是，如果一个

1053
00:50:09,000 --> 00:50:11,220
事务 已经完成然后一个

1054
00:50:11,220 --> 00:50:13,470
事务在它必须

1055
00:50:13,470 --> 00:50:16,740
看到它的权限之后开始，所以 t1 可能是

1056
00:50:16,740 --> 00:50:18,810
t1 完成假设 t1 在这个时候完成

1057
00:50:18,810 --> 00:50:23,040
并且 t3 在它可能是外部一致性之后开始，

1058
00:50:23,040 --> 00:50:25,350
但是要求 t3

1059
00:50:25,350 --> 00:50:28,170
看到关键的权限，但是因为 c2

1060
00:50:28,170 --> 00:50:30,060
肯定没有 '在 t3 开始之前完成，

1061
00:50:30,060 --> 00:50:32,400
我们没有义务根据

1062
00:50:32,400 --> 00:50:34,950
外部一致性 43 查看

1063
00:50:34,950 --> 00:50:38,190
教师的权利，实际上在这个

1064
00:50:38,190 --> 00:50:40,230
例子中它没有，所以它实际上是

1065
00:50:40,230 --> 00:50:46,050
合法的，好吧，另一个问题

1066
00:50:46,050 --> 00:50:51,540
是事务 T 3

1067
00:50:51,540 --> 00:50:52,860
需要读取数据 作为一个特定的

1068
00:50:52,860 --> 00:50:56,310
时间戳，但你知道

1069
00:50:56,310 --> 00:50:58,110
这是可取的原因是它允许

1070
00:50:58,110 --> 00:51:00,900
我们从同一个数据中心的本地副本中读取，

1071
00:51:00,900 --> 00:51:02,760
但也许是

1072
00:51:02,760 --> 00:51:05,610
本地的 副本是少数

1073
00:51:05,610 --> 00:51:08,970
没有看到

1074
00:51:08,970 --> 00:51:11,640
最新日志记录领导者的paxos追随者，所以

1075
00:51:11,640 --> 00:51:13,710
也许我们的本地副本可能从未

1076
00:51:13,710 --> 00:51:16,920
见过你知道根本没有见过这些

1077
00:51:16,920 --> 00:51:19,950
X＆Y权利它仍然回到

1078
00:51:19,950 --> 00:51:22,460
松树的版本你知道五 或六个或七个

1079
00:51:22,460 --> 00:51:25,710
，因此，如果

1080
00:51:25,710 --> 00:51:28,350
我们在要求

1081
00:51:28,350 --> 00:51:31,820
您知道小于

1082
00:51:31,820 --> 00:51:34,590
时间戳 15 的最高版本记录时不做一些聪明的事情，我们可能会得到一些更旧的

1083
00:51:34,590 --> 00:51:36,990
版本，这实际上不是您

1084
00:51:36,990 --> 00:51:38,820
由事务一生成的，它们

1085
00:51:38,820 --> 00:51:41,540
需要 看到

1086
00:51:41,950 --> 00:51:44,600
所以他的扳手处理这个的方式

1087
00:51:44,600 --> 00:51:52,070
是我们的安全时间的概念，而且

1088
00:51:52,070 --> 00:51:55,580
独家新闻是每个副本都记得你

1089
00:51:55,580 --> 00:51:58,310
知道它正在从它的税务领导那里获取日志记录，

1090
00:51:58,310 --> 00:52:02,060
并且日志记录

1091
00:52:02,060 --> 00:52:03,980
结果是纸张安排

1092
00:52:03,980 --> 00:52:05,360
以便领导发送 输出日志记录

1093
00:52:05,360 --> 00:52:07,340
并严格增加时间戳顺序，

1094
00:52:07,340 --> 00:52:11,000
以便副本可以查看

1095
00:52:11,000 --> 00:52:12,770
它从其领导者那里获得的最后一条日志记录，

1096
00:52:12,770 --> 00:52:17,150
以了解它的最新情况，所以如果我

1097
00:52:17,150 --> 00:52:20,650
要求时间戳 15 的值，但

1098
00:52:20,650 --> 00:52:23,960
代表 lica 只从我的 pax 获得了日志条目，

1099
00:52:23,960 --> 00:52:26,000
是领导者几次，戳

1100
00:52:26,000 --> 00:52:28,370
13 副本会让我们延迟它

1101
00:52:28,370 --> 00:52:31,190
不会回答，直到它从领导者那里

1102
00:52:31,190 --> 00:52:33,380
获得时间戳为 15 的日志记录

1103
00:52:33,380 --> 00:52:36,980
，这确保了副本

1104
00:52:36,980 --> 00:52:39,440
不回答请求 对于给定的

1105
00:52:39,440 --> 00:52:41,000
时间戳，直到他们保证

1106
00:52:41,000 --> 00:52:43,670
知道从领导者

1107
00:52:43,670 --> 00:52:45,440
到该时间戳的所有内容，所以这可能会

1108
00:52:45,440 --> 00:52:55,000
延迟这可能会延迟读取，

1109
00:52:58,410 --> 00:53:01,260
所以下一个问题我一直

1110
00:53:01,260 --> 00:53:03,450
假设我在本次讨论中假设

1111
00:53:03,450 --> 00:53:05,220
时钟和所有 不同的服务器是

1112
00:53:05,220 --> 00:53:07,470
完美同步的，所以每个人的

1113
00:53:07,470 --> 00:53:11,010
时钟都说你同时知道 1001 秒和 30 秒

1114
00:53:11,010 --> 00:53:15,150
，但事实

1115
00:53:15,150 --> 00:53:19,640
证明你不能同步时钟

1116
00:53:19,640 --> 00:53:27,750
，而你基本上

1117
00:53:27,750 --> 00:53:29,369
不可能得到完美同步的

1118
00:53:29,369 --> 00:53:35,099
时钟，原因是相当

1119
00:53:35,099 --> 00:53:39,450
基本的，所以 主题是时间

1120
00:53:39,450 --> 00:53:41,700
同步，这有点

1121
00:53:41,700 --> 00:53:44,059
确保时钟说相同的实时值

1122
00:53:44,059 --> 00:53:50,150
不同的时钟读取相同的值，

1123
00:53:53,990 --> 00:53:57,030
我会告诉那种 f 根本

1124
00:53:57,030 --> 00:53:59,160
问题是时间基本上被定义为

1125
00:53:59,160 --> 00:54:01,950
它

1126
00:54:01,950 --> 00:54:04,589
 

1127
00:54:04,589 --> 00:54:05,910
在一组政府实验室中的一组高度准确的昂贵时钟上显示的时间，

1128
00:54:05,910 --> 00:54:07,859
因此我们无法直接读取

1129
00:54:07,859 --> 00:54:10,920
它们，尽管我们可以知道这些

1130
00:54:10,920 --> 00:54:12,420
政府实验室可以

1131
00:54:12,420 --> 00:54:18,960
以各种方式广播时间 方式和

1132
00:54:18,960 --> 00:54:20,369
广播需要时间，所以

1133
00:54:20,369 --> 00:54:22,349
一段时间后，可能未知的时间

1134
00:54:22,349 --> 00:54:24,809
之后，我们会听到这些关于

1135
00:54:24,809 --> 00:54:26,099
它自己的时间的公告，你知道，

1136
00:54:26,099 --> 00:54:27,329
 

1137
00:54:27,329 --> 00:54:32,450
由于不同的延迟，它可能都会在不同的时间听到这些公告，所以

1138
00:54:32,450 --> 00:54:34,950
我实际上首先不想要

1139
00:54:34,950 --> 00:54:37,910
考虑一个问题，

1140
00:54:37,910 --> 00:54:43,190
如果时钟不

1141
00:54:43,190 --> 00:54:49,130
同步，对快照隔离有什么影响，那它们就

1142
00:54:52,960 --> 00:54:56,290
不行了，那么如果时钟

1143
00:54:56,290 --> 00:54:58,280
没有问题，那么对于 spanners 读写事务来说实际上根本没有问题，

1144
00:54:58,280 --> 00:55:00,560
 

1145
00:55:00,560 --> 00:55:02,180
因为读写事务使用了

1146
00:55:02,180 --> 00:55:04,430
锁和 两阶段提交他们

1147
00:55:04,430 --> 00:55:05,990
实际上并没有使用解决方案中的快照，

1148
00:55:05,990 --> 00:55:07,460
因此他们不在乎，因此读写

1149
00:55:07,460 --> 00:55:09,290
事务仍将被序列化 b

1150
00:55:09,290 --> 00:55:11,740
y 锁定两阶段锁定机制，

1151
00:55:11,740 --> 00:55:14,030
因此我们只对 RF 或只读事务发生的情况感兴趣，

1152
00:55:14,030 --> 00:55:18,110
因此

1153
00:55:18,110 --> 00:55:22,180
假设只读事务

1154
00:55:22,690 --> 00:55:27,800
选择的时间戳太大，

1155
00:55:27,800 --> 00:55:29,480
以至于您知道的未来很远

1156
00:55:29,480 --> 00:55:31,640
现在是下午 12:01。 它选择

1157
00:55:31,640 --> 00:55:39,560
在 C 点 1 点钟的时间戳。 因此，如果

1158
00:55:39,560 --> 00:55:42,640
事务选择的时间戳太大

1159
00:55:42,640 --> 00:55:46,340
，实际上并没有那么糟糕，这

1160
00:55:46,340 --> 00:55:48,170
意味着它将执行读取请求，

1161
00:55:48,170 --> 00:55:50,440
它将向某些副本发送读取请求，

1162
00:55:50,440 --> 00:55:52,340
副本会说等一下，

1163
00:55:52,340 --> 00:55:53,930
您知道您的时钟是

1164
00:55:53,930 --> 00:55:56,420
Farrer，您的提示音似乎

1165
00:55:56,420 --> 00:55:58,850
比我为我的 pax is leader 看到的最后一个日志条目要大得多，

1166
00:55:58,850 --> 00:56:00,230
所以我

1167
00:56:00,230 --> 00:56:03,050
会让您等到 PAX 在

1168
00:56:03,050 --> 00:56:04,760
当时并且日志条目和 Paxos

1169
00:56:04,760 --> 00:56:05,990
领导者赶上您的时间 '已经

1170
00:56:05,990 --> 00:56:08,720
要求我只会回复，所以

1171
00:56:08,720 --> 00:56:11,810
这是正确的，但速度很慢，读者

1172
00:56:11,810 --> 00:56:16,849
将被迫离开，这不是

1173
00:56:16,849 --> 00:56:19,039
世界上最糟糕的，但如果我们有

1174
00:56:19,039 --> 00:56:21,829
一个只读事务并且它的

1175
00:56:21,829 --> 00:56:27,109
时间戳太小会发生什么，这将

1176
00:56:27,109 --> 00:56:30,140
对应 它的时钟

1177
00:56:30,140 --> 00:56:31,849
要么设置错误，所以它

1178
00:56:31,849 --> 00:56:34,309
在过去被说过，或者它最初设置

1179
00:56:34,309 --> 00:56:36,140
正确，但时钟它的时钟滴答声

1180
00:56:36,140 --> 00:56:39,259
太慢了这个问题，这

1181
00:56:39,259 --> 00:56:41,359
显然会导致正确性问题，

1182
00:56:41,359 --> 00:56:42,950
这将导致违反外部

1183
00:56:42,950 --> 00:56:46,130
c 持续性，因为多版本

1184
00:56:46,130 --> 00:56:47,930
数据库你会给它一个

1185
00:56:47,930 --> 00:56:50,089
远在过去的时间戳，比如一个小时前

1186
00:56:50,089 --> 00:56:53,119
，数据库会读取一个

1187
00:56:53,119 --> 00:56:55,400
与它相关的值，一个

1188
00:56:55,400 --> 00:56:58,279
小时前的时间戳可能会忽略最近的

1189
00:56:58,279 --> 00:57:01,460
写入，所以使用分配一个

1190
00:57:01,460 --> 00:57:03,470
太小的事务的时间戳会

1191
00:57:03,470 --> 00:57:05,989
导致您错过最近提交的

1192
00:57:05,989 --> 00:57:11,869
写入，这违反了

1193
00:57:11,869 --> 00:57:21,029
外部一致性，所以不是外部的

1194
00:57:21,029 --> 00:57:24,059
，所以我们实际上有一个问题

1195
00:57:24,059 --> 00:57:26,249
，时钟

1196
00:57:26,249 --> 00:57:29,579
同步的假设实际上是一个非常严重的

1197
00:57:29,579 --> 00:57:31,439
假设，事实 你不能

1198
00:57:31,439 --> 00:57:33,059
指望它意味着除非我们做某事，否则

1199
00:57:33,059 --> 00:57:35,339
系统将是

1200
00:57:35,339 --> 00:57:43,799
不正确的，所以我们可以

1201
00:57:43,799 --> 00:57:46,529
完美地同步时钟

1202
00:57:46,529 --> 00:57:48,509
，这将是理想的事情，如果不是，

1203
00:57:48,509 --> 00:57:51,869
为什么不那么时钟

1204
00:57:51,869 --> 00:57:59,669
同步呢？ 提到我们已经

1205
00:57:59,669 --> 00:58:01,409
完成了，它实际上

1206
00:58:01,409 --> 00:58:03,869
 

1207
00:58:03,869 --> 00:58:06,859
是时钟和政府实验室集合中位数的集合，

1208
00:58:06,859 --> 00:58:09,719
就像我们听到关于 ti 的方式一样 我

1209
00:58:09,719 --> 00:58:11,880
是它是通过各种协议广播的，

1210
00:58:11,880 --> 00:58:13,679
有时是通过无线电协议广播的，比如

1211
00:58:13,679 --> 00:58:16,469
基本上 GPS 为扳手所做的事情

1212
00:58:16,469 --> 00:58:19,739
是 GPS 充当无线电

1213
00:58:19,739 --> 00:58:22,259
广播系统，通过 GPS 卫星将当前时间

1214
00:58:22,259 --> 00:58:24,539
从某个政府实验室广播

1215
00:58:24,539 --> 00:58:27,689
到谷歌机器中的 GPS 接收器

1216
00:58:27,689 --> 00:58:31,979
房间，还有

1217
00:58:31,979 --> 00:58:34,140
许多其他无线电协议，例如 WWB

1218
00:58:34,140 --> 00:58:37,259
是另一种较旧的无线电协议，用于

1219
00:58:37,259 --> 00:58:39,409
广播当前时间，

1220
00:58:39,409 --> 00:58:41,429
还有更新的协议，例如

1221
00:58:41,429 --> 00:58:45,559
在 Internet 上运行的 NTP 协议，

1222
00:58:46,130 --> 00:58:48,589
它也负责

1223
00:58:48,589 --> 00:58:51,299
基本的广播时间，所以

1224
00:58:51,299 --> 00:58:54,959
这种系统图 是有一些

1225
00:58:54,959 --> 00:58:57,329
政府实验室，而政府实验室

1226
00:58:57,329 --> 00:58:59,459
的精确时钟定义了一个

1227
00:58:59,459 --> 00:59:02,099
通用的时间概念，称为

1228
00:59:02,099 --> 00:59:07,079
UTC，所以我们有来自某些实验室的一些时钟的 UTC，

1229
00:59:07,079 --> 00:59:09,329
然后我们有一些你知道的

1230
00:59:09,329 --> 00:59:11,729
无线电互联网广播或

1231
00:59:11,729 --> 00:59:19,949
案例 扳手是我们可以

1232
00:59:19,949 --> 00:59:20,819
想到的，政府允许

1233
00:59:20,819 --> 00:59:25,650
向 GPS 卫星广播

1234
00:59:25,650 --> 00:59:28,799
卫星 反过来广播和

1235
00:59:28,799 --> 00:59:31,469
广播公司，您知道那里有数百万个 GPS

1236
00:59:31,469 --> 00:59:33,380
接收器，

1237
00:59:33,380 --> 00:59:37,220
您可以花几百美元购买 GPS 接收器，这些接收

1238
00:59:37,220 --> 00:59:38,690
器将解码

1239
00:59:38,690 --> 00:59:44,240
GPS 信号中的时间戳，并

1240
00:59:44,240 --> 00:59:46,700
让您及时了解最新信息

1241
00:59:46,700 --> 00:59:49,510
时间已针对

1242
00:59:49,510 --> 00:59:51,680
政府实验室和 GPS 卫星之间的传播延迟进行了

1243
00:59:51,680 --> 00:59:53,570
 

1244
00:59:53,570 --> 00:59:55,910
校正，并且还针对您当前位置的 GPS 卫星之间的延迟进行了校正

1245
00:59:55,910 --> 00:59:59,020
，

1246
00:59:59,020 --> 01:00:04,490
然后在每个数据中心都有

1247
01:00:04,490 --> 01:00:10,960
一个 GPS 接收器连接到

1248
01:00:10,960 --> 01:00:14,240
论文所说的时间 master

1249
01:00:14,240 --> 01:00:16,880
是一些服务器

1250
01:00:16,880 --> 01:00:18,080
，

1251
01:00:18,080 --> 01:00:21,440
如果其中一个发生故障，数据中心将有不止一个服务器，然后

1252
01:00:21,440 --> 01:00:22,880
数据中心中的所有数百台服务器都在

1253
01:00:22,880 --> 01:00:24,350
运行 spanner 作为

1254
01:00:24,350 --> 01:00:27,970
服务器或客户端，每个服务器

1255
01:00:27,970 --> 01:00:33,080
都将运行 定期向本地发送一个请求

1256
01:00:33,080 --> 01:00:34,880
说现在几点了

1257
01:00:34,880 --> 01:00:37,850
一个或多个通常不止一件

1258
01:00:37,850 --> 01:00:41,120
一个人对时间主人的感觉，

1259
01:00:41,120 --> 01:00:43,100
时间主人会回复 哦，你知道，

1260
01:00:43,100 --> 01:00:44,780
我认为 GPS 接收到的当前时间

1261
01:00:44,780 --> 01:00:51,080
是这样那样的，现在内置于其中，

1262
01:00:51,080 --> 01:00:52,850
不幸的是，存在一定量

1263
01:00:52,850 --> 01:00:59,270
的不确定性和不确定性的主要

1264
01:00:59,270 --> 01:01:01,610
来源，我认为

1265
01:01:01,610 --> 01:01:03,410
存在根本上的不确定性，

1266
01:01:03,410 --> 01:01:05,030
因为我们实际上并没有

1267
01:01:05,030 --> 01:01:08,930
确切地知道我们离 GPS 卫星有多远，

1268
01:01:08,930 --> 01:01:10,280
所以你知道无线电信号需要一些

1269
01:01:10,280 --> 01:01:12,560
时间，即使 GPS

1270
01:01:12,560 --> 01:01:14,000
卫星确切地知道

1271
01:01:14,000 --> 01:01:15,620
这些信号需要一些时间才能到达

1272
01:01:15,620 --> 01:01:17,630
我们的 GPS 接收器，我们不确定那

1273
01:01:17,630 --> 01:01:19,730
是什么 这是否意味着当吉普车

1274
01:01:19,730 --> 01:01:22,460
从 GPS 卫星的无线电信息中收到一条消息时，

1275
01:01:22,460 --> 01:01:25,250
准确地说是 12

1276
01:01:25,250 --> 01:01:25,580
点钟，

1277
01:01:25,580 --> 01:01:28,190
你知道传播延迟是否

1278
01:01:28,190 --> 01:01:30,200
可能是几

1279
01:01:30,200 --> 01:01:32,710
纳秒，这意味着

1280
01:01:32,710 --> 01:01:34,580
实际上传播延迟很大

1281
01:01:34,580 --> 01:01:35,960
不仅如此，传播延迟的真正不

1282
01:01:35,960 --> 01:01:38,690
确定性意味着

1283
01:01:38,690 --> 01:01:40,370
我们并不确定

1284
01:01:40,370 --> 01:01:41,690
到底是 12 点钟还是

1285
01:01:41,690 --> 01:01:44,810
稍早一点

1286
01:01:44,810 --> 01:01:46,820
在传达时间时，确实

1287
01:01:46,820 --> 01:01:49,400
存在您必须考虑的不确定性

1288
01:01:49,400 --> 01:01:52,430
，最大​​的来源是，

1289
01:01:52,430 --> 01:01:54,380
当服务器在一段时间后发送请求

1290
01:01:54,380 --> 01:01:56,600
时，如果响应说正好是 12 点，它会得到响应，

1291
01:01:56,600 --> 01:02:01,850
但是

1292
01:02:01,850 --> 01:02:04,820
数量但是嗯说第二遍 你知道

1293
01:02:04,820 --> 01:02:06,470
在服务器发送请求

1294
01:02:06,470 --> 01:02:08,900
和我得到响应之间，

1295
01:02:08,900 --> 01:02:11,120
服务器所知道的是，即使主

1296
01:02:11,120 --> 01:02:13,310
服务器有正确的时间，服务器所

1297
01:02:13,310 --> 01:02:18,140
知道的只是时间在

1298
01:02:18,140 --> 01:02:22,280
12 点钟的一秒内，因为也许那

1299
01:02:22,280 --> 01:02:24,500
可能 是请求是即时的，但

1300
01:02:24,500 --> 01:02:27,290
回复被延迟了，或者请求

1301
01:02:27,290 --> 01:02:30,170
被延迟了一秒钟，而响应

1302
01:02:30,170 --> 01:02:31,700
是事件，所以你真正知道

1303
01:02:31,700 --> 01:02:34,400
的是它在你知道的 12 点

1304
01:02:34,400 --> 01:02:38,500
和零秒和十二点和

1305
01:02:38,500 --> 01:02:45,590
1 之间 第二个好的，所以总是有这种

1306
01:02:45,590 --> 01:02:49,400
不确定性，但我们

1307
01:02:49,400 --> 01:02:50,960
真的不能忽视，因为

1308
01:02:50,960 --> 01:02:52,160
我们在这里谈论的不确定性是

1309
01:02:52,160 --> 01:02:55,400
毫秒，我们会

1310
01:02:55,400 --> 01:02:57,320
发现这些不确定性

1311
01:02:57,320 --> 01:03:00,170
和时间过去了 直接针对

1312
01:03:00,170 --> 01:03:02,240
这些安全等待必须多长时间以及

1313
01:03:02,240 --> 01:03:03,590
其他一些暂停必须等待多长时间，

1314
01:03:03,590 --> 01:03:08,660
正如我们将看到的那样，您知道

1315
01:03:08,660 --> 01:03:10,010
毫秒级别的不确定性

1316
01:03:10,010 --> 01:03:11,360
是一个严重的问题，另一个很大的

1317
01:03:11,360 --> 01:03:13,130
不确定性是每个 这些

1318
01:03:13,130 --> 01:03:15,050
服务器中的一些仅

1319
01:03:15,050 --> 01:03:16,640
每隔一段时间就向主服务器请求当前时间，

1320
01:03:16,640 --> 01:03:20,480
例如每分钟或每隔一段时间，并且

1321
01:03:20,480 --> 01:03:22,730
在这之间，每个服务器运行

1322
01:03:22,730 --> 01:03:25,190
自己的本地时钟，这使得

1323
01:03:25,190 --> 01:03:26,990
时间从主服务器的最后一次开始

1324
01:03:26,990 --> 01:03:28,640
那些本地时钟

1325
01:03:28,640 --> 01:03:32,150
实际上非常糟糕，并且

1326
01:03:32,150 --> 01:03:34,430
 

1327
01:03:34,430 --> 01:03:36,220
在服务器与主服务器对话的时间之间可能会发生几毫秒的漂移，

1328
01:03:36,220 --> 01:03:40,000
因此系统必须

1329
01:03:40,000 --> 01:03:44,120
将本地时钟的未知但估计的漂移添加

1330
01:03:44,120 --> 01:03:48,290
到时间的不确定性中，所以

1331
01:03:48,290 --> 01:03:50,810
我按顺序 为了捕捉这种不确定性

1332
01:03:50,810 --> 01:03:54,760
并解释它，

1333
01:03:55,719 --> 01:04:00,079
扳手使用这个真实的时间方案

1334
01:04:00,079 --> 01:04:01,849
，当你问它什么时候是

1335
01:04:01,849 --> 01:04:03,890
你实际得到的时间，作为这些 TT

1336
01:04:03,890 --> 01:04:12,440
间隔事物之一，这是一对

1337
01:04:12,440 --> 01:04:18,380
早 t 时间和最迟最早时间

1338
01:04:18,380 --> 01:04:21,589
是他们最早的时间

1339
01:04:21,589 --> 01:04:25,099
可能是最早的时间，第二个是最晚

1340
01:04:25,099 --> 01:04:27,710
的时间可能是所以当

1341
01:04:27,710 --> 01:04:31,670
你知道的应用程序发出这个库

1342
01:04:31,670 --> 01:04:32,599
调用时，它询问它

1343
01:04:32,599 --> 01:04:34,489
收回这个付款人的时间 知道

1344
01:04:34,489 --> 01:04:35,719
当前时间介于

1345
01:04:35,719 --> 01:04:38,029
最早和最晚之间

1346
01:04:38,029 --> 01:04:39,920
最早可能是在这种情况下 最早

1347
01:04:39,920 --> 01:04:41,359
可能是十二点 可能这

1348
01:04:41,359 --> 01:04:42,950
可能是一秒钟内的十二点

1349
01:04:42,950 --> 01:04:46,729
只是我们

1350
01:04:46,729 --> 01:04:48,859
保证正确 时间不小于

1351
01:04:48,859 --> 01:04:51,519
最早也不大于最新

1352
01:04:51,519 --> 01:04:53,210
什么我们不知道在什么之间

1353
01:04:53,210 --> 01:04:57,529
否则没关系

1354
01:04:57,529 --> 01:05:01,160
所以这就是呃当交易

1355
01:05:01,160 --> 01:05:03,349
询问系统现在是什么时间这是这

1356
01:05:03,349 --> 01:05:05,150
就是交易

1357
01:05:05,150 --> 01:05:11,049
实际返回的时间 时间系统，现在

1358
01:05:11,440 --> 01:05:14,029
让我们回到我们最初的问题是

1359
01:05:14,029 --> 01:05:17,859
，如果时钟太慢，

1360
01:05:17,859 --> 01:05:20,599
只读事务可能会读取

1361
01:05:20,599 --> 01:05:23,210
过去的数据，并且不会

1362
01:05:23,210 --> 01:05:25,039
从最近提交的

1363
01:05:25,039 --> 01:05:27,529
事务中读取数据 n 所以我们需要知道

1364
01:05:27,529 --> 01:05:29,900
我们正在寻找的是 spanner 如何

1365
01:05:29,900 --> 01:05:32,089
在其真实时间的概念中使用这些 TT 间隔，

1366
01:05:32,089 --> 01:05:34,039
以确保尽管

1367
01:05:34,039 --> 01:05:36,650
不确定它是什么时间的事务，但它

1368
01:05:36,650 --> 01:05:40,400
 

1369
01:05:40,400 --> 01:05:42,200
是一个只读事务的外部一致性

1370
01:05:42,200 --> 01:05:45,259
得到保证 查看由在我们之前完成的

1371
01:05:45,259 --> 01:05:47,479
交易率交易

1372
01:05:47,479 --> 01:05:52,369
完成的写入

1373
01:05:52,369 --> 01:05:55,130
，并且本文讨论

1374
01:05:55,130 --> 01:06:01,219
了两条规则来执行此

1375
01:06:01,219 --> 01:06:04,249
规则以及第 4-1 节中的两条规则 - 其中一个

1376
01:06:04,249 --> 01:06:07,059
是开始规则

1377
01:06:07,380 --> 01:06:14,100
，另一个是 是提交等待

1378
01:06:16,940 --> 01:06:20,840
这个注释规则告诉我们什么时间戳

1379
01:06:20,840 --> 01:06:23,060
训练实际上什么时间戳

1380
01:06:23,060 --> 01:06:26,990
事务选择并且基本上

1381
01:06:26,990 --> 01:06:29,780
说事务时间戳必须

1382
01:06:29,780 --> 01:06:35,870
等于真实

1383
01:06:35,870 --> 01:06:38,870
时间当前时间的最新一半所以这是 T T 现在

1384
01:06:38,870 --> 01:06:40,670
调用它返回其中一个 最早的

1385
01:06:40,670 --> 01:06:43,460
最新对是当前时间，

1386
01:06:43,460 --> 01:06:45,560
并且交易时间戳必须

1387
01:06:45,560 --> 01:06:48,410
是最新的，这将是一个

1388
01:06:48,410 --> 01:06:50,570
保证尚未发生的时间，

1389
01:06:50,570 --> 01:06:52,190
因为真实时间

1390
01:06:52,190 --> 01:06:54,800
介于最早和最晚之间，对于

1391
01:06:54,800 --> 01:06:59,840
只读事务

1392
01:06:59,840 --> 01:07:03,910
，它是它开始时的最晚时间的标志

1393
01:07:03,910 --> 01:07:06,560
，对于读取或写入事务，

1394
01:07:06,560 --> 01:07:09,950
是分配一个时间戳，这

1395
01:07:09,950 --> 01:07:14,020
是它开始提交时的最新值，

1396
01:07:16,180 --> 01:07:18,710
所以 开始规则说这是

1397
01:07:18,710 --> 01:07:21,109
扳手选择时间戳的方式

1398
01:07:21,109 --> 01:07:24,560
仅用于读写事务的提交权重规则

1399
01:07:24,560 --> 01:07:31,780
说，当

1400
01:07:31,780 --> 01:07:35,030
您知道事务协调员时会

1401
01:07:35,030 --> 01:07:36,410
收集选票并看到它

1402
01:07:36,410 --> 01:07:39,140
能够提交，并

1403
01:07:39,140 --> 01:07:41,420
在选择此时间戳后选择时间戳

1404
01:07:41,420 --> 01:07:44,240
需要延迟等待一段

1405
01:07:44,240 --> 01:07:45,980
时间，直到我必须

1406
01:07:45,980 --> 01:07:47,660
实际提交并写入值并

1407
01:07:47,660 --> 01:07:52,060
释放锁，因此读写事务

1408
01:07:52,060 --> 01:07:58,099
必须延迟，直到

1409
01:07:58,099 --> 01:08:00,560
它开始

1410
01:08:00,560 --> 01:08:02,990
考虑提交时选择的时间戳小于 当前

1411
01:08:02,990 --> 01:08:11,430
时间最早

1412
01:08:11,430 --> 01:08:13,530
对不起

1413
01:08:13,530 --> 01:08:14,960
所以这里发生的事情是

1414
01:08:14,960 --> 01:08:17,870
现在调用 TS 的循环中，它

1415
01:08:17,870 --> 01:08:20,000
一直在该循环中，直到

1416
01:08:20,000 --> 01:08:21,319
它在开始时选择的时间戳

1417
01:08:21,319 --> 01:08:23,240
提交过程小于

1418
01:08:23,240 --> 01:08:25,430
当前时间最早的一半，

1419
01:08:25,430 --> 01:08:30,770
这保证了从现在起

1420
01:08:30,770 --> 01:08:34,310
最早可能的正确时间

1421
01:08:34,310 --> 01:08:36,290
大于事务时间戳

1422
01:08:36,290 --> 01:08:38,810
，这意味着当这个循环

1423
01:08:38,810 --> 01:08:39,859
完成时，提交等待

1424
01:08:39,859 --> 01:08:41,510
完成时

1425
01:08:41,510 --> 01:08:43,580
事务的这个时间戳 绝对

1426
01:08:43,580 --> 01:08:49,460
保证过去没问题，那么

1427
01:08:49,460 --> 01:08:52,220
系统实际上如何利用这两个

1428
01:08:52,220 --> 01:09:00,620
规则来强制

1429
01:09:00,620 --> 01:09:02,510
只读事务的外部一致性我

1430
01:09:02,510 --> 01:09:09,410
想回到我们的或者我想

1431
01:09:09,410 --> 01:09:14,210
制作一个简化的场景

1432
01:09:14,210 --> 01:09:17,300
为了说明这一点所以我会

1433
01:09:17,300 --> 01:09:18,740
想象写事务

1434
01:09:18,740 --> 01:09:21,290
每个只写一次只是降低

1435
01:09:21,290 --> 01:09:24,340
复杂性假设有两个

1436
01:09:24,340 --> 01:09:27,290
读/写事务所以我们有 t0

1437
01:09:27,290 --> 01:09:32,240
和 t1 是读/写事务并且

1438
01:09:32,240 --> 01:09:35,569
它们都写 X 而我们 有一个

1439
01:09:35,569 --> 01:09:37,609
t2 将读取 X，我们要

1440
01:09:37,609 --> 01:09:40,609
确保 t2 看到你知道它将

1441
01:09:40,609 --> 01:09:42,380
在时间戳上使用快照隔离，我们

1442
01:09:42,380 --> 01:09:43,939
要确保看到 l 测试

1443
01:09:43,939 --> 01:09:48,800
写入值，因此我们将

1444
01:09:48,800 --> 01:09:51,800
假设 t2 写入 X 并向 X 写入 1

1445
01:09:51,800 --> 01:09:56,150
然后提交 我们将

1446
01:09:56,150 --> 01:09:58,150
假设

1447
01:09:58,150 --> 01:10:00,830
抱歉 t1 写入 sex 并在 t2 也

1448
01:10:00,830 --> 01:10:05,960
写入 X 向 X 写入值 2 并且 我们

1449
01:10:05,960 --> 01:10:07,550
需要区分 can prepare

1450
01:10:07,550 --> 01:10:09,080
和 commit 所以我们要说它

1451
01:10:09,080 --> 01:10:11,330
实际上是一个事务

1452
01:10:11,330 --> 01:10:14,840
选择它的时间戳的准备所以这

1453
01:10:14,840 --> 01:10:16,310
是它选择时间戳并且

1454
01:10:16,310 --> 01:10:19,550
它在一段时间后提交然后

1455
01:10:19,550 --> 01:10:21,620
我们想象的点 假设 t2

1456
01:10:21,620 --> 01:10:24,620
在 t1 完成后开始，因此它将在

1457
01:10:24,620 --> 01:10:27,700
之后读取 X

1458
01:10:27,770 --> 01:10:29,610
并且我们要确保它

1459
01:10:29,610 --> 01:10:34,760
看到 - 好吧，让我们假设

1460
01:10:34,760 --> 01:10:40,740
t0 选择一个提交的时间戳

1461
01:10:40,740 --> 01:10:46,280
写入数据库假设 t1

1462
01:10:46,280 --> 01:10:49,170
在它选择的时间开始 时间戳 它

1463
01:10:49,170 --> 01:10:51,120
会得到一些 它不会

1464
01:10:51,120 --> 01:10:53,070
从真实时间中

1465
01:10:53,070 --> 01:10:57,900
得到一个数字 系统真的会得到一系列你最早知道的数字

1466
01:10:57,900 --> 01:11:02,220
和一个最新的值，比如说在

1467
01:11:02,220 --> 01:11:04,700
它选择时间戳

1468
01:11:04,700 --> 01:11:09,210
的时候它是它最早得到的值的范围

1469
01:11:09,210 --> 01:11:12,270
是 1 个 d 当前时间的最新字段

1470
01:11:12,270 --> 01:11:17,970
是 10，因此规则

1471
01:11:17,970 --> 01:11:20,340
说它必须选择 10 最新值作为

1472
01:11:20,340 --> 01:11:22,260
其时间戳，因此 t1 将

1473
01:11:22,260 --> 01:11:24,920
以其时间步长 10 提交，

1474
01:11:24,920 --> 01:11:27,720
现在您还不能提交，因为

1475
01:11:27,720 --> 01:11:29,520
提交权重规则说明了它 必须

1476
01:11:29,520 --> 01:11:32,640
等到它的时间戳

1477
01:11:32,640 --> 01:11:35,610
保证在过去，所以事务 1

1478
01:11:35,610 --> 01:11:37,350
会坐在那里不断询问

1479
01:11:37,350 --> 01:11:37,980
现在几点了，

1480
01:11:37,980 --> 01:11:41,990
直到它得到一个

1481
01:11:41,990 --> 01:11:45,590
不包括时间 10 的间隔，所以在某个时候

1482
01:11:45,590 --> 01:11:48,090
它是 会问

1483
01:11:48,090 --> 01:11:49,710
现在几点了，我们是最早的

1484
01:11:49,710 --> 01:11:51,990
值 11 和精英是我不知道，

1485
01:11:51,990 --> 01:11:54,240
让我们说 20 现在我要说 AHA

1486
01:11:54,240 --> 01:11:56,280
现在我知道我的时间山姆它

1487
01:11:56,280 --> 01:11:57,750
保证在 过去，我可以

1488
01:11:57,750 --> 01:12:00,810
提交，所以 t1 实际上这是它的

1489
01:12:00,810 --> 01:12:03,930
提交等待期，坐在那里

1490
01:12:03,930 --> 01:12:07,620
等待一段时间，然后再提交，现在

1491
01:12:07,620 --> 01:12:10,560
在它提交事务 2 之后

1492
01:12:10,560 --> 01:12:13,290
出现一个怪物 B Dex，它

1493
01:12:13,290 --> 01:12:16,710
也会选择一个时间戳，我们假设 它

1494
01:12:16,710 --> 01:12:19,890
在 t1 完成后开始，因为这

1495
01:12:19,890 --> 01:12:21,390
很有趣 外部

1496
01:12:21,390 --> 01:12:23,670
一致性的场景所以让我们说当

1497
01:12:23,670 --> 01:12:28,500
它要求它在时间 11 之后的某个时间要求的时间

1498
01:12:28,500 --> 01:12:30,480
所以它会返回一个

1499
01:12:30,480 --> 01:12:34,000
包含时间 11 的间隔

1500
01:12:34,000 --> 01:12:35,320
所以让我们假设它

1501
01:12:35,320 --> 01:12:39,490
从时间 10 开始一点点返回这

1502
01:12:39,490 --> 01:12:43,930
是 最早和时间 12 最晚

1503
01:12:43,930 --> 01:12:45,160
，当然时间 12 必须是

1504
01:12:45,160 --> 01:12:47,740
因为我们知道必须至少是时间

1505
01:12:47,740 --> 01:12:50,680
11，因为事务 2 在

1506
01:12:50,680 --> 01:12:53,560
事务 1 完成之后开始，这

1507
01:12:53,560 --> 01:12:55,900
意味着 11 必须小于

1508
01:12:55,900 --> 01:12:59,470
事务 2 将要进行的最新值 选择

1509
01:12:59,470 --> 01:13:02,950
这个最新的 1/2 作为它的时间戳，所以它

1510
01:13:02,950 --> 01:13:09,870
实际上会选择时间戳 12，

1511
01:13:09,870 --> 01:13:12,670
在这个例子中，当它读取时，

1512
01:13:12,670 --> 01:13:15,220
它会询问存储系统哦，我

1513
01:13:15,220 --> 01:13:18,430
想从时间戳 12 开始读取，因为

1514
01:13:18,430 --> 01:13:20,380
事务 1 使用时间戳 10 写入，

1515
01:13:20,380 --> 01:13:22,090
这意味着 你知道假设

1516
01:13:22,090 --> 01:13:25,120
安全等待安全时间机器工作，

1517
01:13:25,120 --> 01:13:27,160
我们实际上会读取正确的

1518
01:13:27,160 --> 01:13:32,730
值，而这里发生的事情是

1519
01:13:33,060 --> 01:13:37,270
，所以这碰巧成功了，但

1520
01:13:37,270 --> 01:13:39,580
确实可以保证你的工作 t 如果

1521
01:13:39,580 --> 01:13:41,590
事务 2 只要事务 2

1522
01:13:41,590 --> 01:13:43,720
在事务 1 提交之后开始

1523
01:13:43,720 --> 01:13:47,190
，原因是提交权重会导致

1524
01:13:47,190 --> 01:13:49,810
事务 1

1525
01:13:49,810 --> 01:13:52,180
直到其时间戳被保证

1526
01:13:52,180 --> 01:13:53,050
在

1527
01:13:53,050 --> 01:13:55,750
过去时才完成提交，所以事务 1 选择

1528
01:13:55,750 --> 01:13:59,640
它保证提交的时间戳

1529
01:13:59,640 --> 01:14:05,370
在该时间戳之后，事务 2

1530
01:14:05,370 --> 01:14:10,840
在提交之后开始，因此我们

1531
01:14:10,840 --> 01:14:11,830
不知道它的

1532
01:14:11,830 --> 01:14:14,170
最早值是多少，但它的最新

1533
01:14:14,170 --> 01:14:16,090
值保证在

1534
01:14:16,090 --> 01:14:17,710
当前时间之后，但我们知道

1535
01:14:17,710 --> 01:14:19,510
当前时间在提交时间之后

1536
01:14:19,510 --> 01:14:23,080
T 1 并因此教导最新

1537
01:14:23,080 --> 01:14:26,140
值，它选择的时间戳

1538
01:14:26,140 --> 01:14:29,680
保证在 C 提交

1539
01:14:29,680 --> 01:14:34,240
之后，因此在 C 使用的时间戳之后，

1540
01:14:34,240 --> 01:14:37,870
并且因为事务 2 如果

1541
01:14:37,870 --> 01:14:40,590
事务 2 在 T 1 完成事务 2 之后开始，

1542
01:14:40,590 --> 01:14:42,430
则保证获得

1543
01:14:42,430 --> 01:14:45,000
更高的时间戳，

1544
01:14:45,000 --> 01:14:46,950
并且 多个版本的快照隔离机制

1545
01:14:46,950 --> 01:14:49,970
将导致它读取

1546
01:14:49,970 --> 01:14:53,430
到它的读取以查看

1547
01:14:53,430 --> 01:14:55,110
所有较低时间的所有较低值写入- 标记

1548
01:14:55,110 --> 01:14:56,970
交易，这意味着教你

1549
01:14:56,970 --> 01:14:59,100
将看到 t1 nom，这基本上

1550
01:14:59,100 --> 01:15:01,020
意味着我们就是这样，这就是

1551
01:15:01,020 --> 01:15:04,800
扳手如何为其交易强制执行外部一致性

1552
01:15:04,800 --> 01:15:09,300
，所以

1553
01:15:09,300 --> 01:15:18,660
关于这个机器的任何问题，好吧，我

1554
01:15:18,660 --> 01:15:22,140
会退后一点，

1555
01:15:22,140 --> 01:15:25,740
真的 从我的角度来看

1556
01:15:25,740 --> 01:15:27,840
，这里发生了两件大事，一个是

1557
01:15:27,840 --> 01:15:30,630
 

1558
01:15:30,630 --> 01:15:32,910
 

1559
01:15:32,910 --> 01:15:35,100
 

1560
01:15:35,100 --> 01:15:36,860
 

1561
01:15:36,860 --> 01:15:38,970
 

1562
01:15:38,970 --> 01:15:41,190
快照隔离本身 只有事务，

1563
01:15:41,190 --> 01:15:43,470
因为基本上快照

1564
01:15:43,470 --> 01:15:45,390
隔离的意思是我们将

1565
01:15:45,390 --> 01:15:47,580
使用这些时间戳作为等效的

1566
01:15:47,580 --> 01:15:50,160
串行顺序，并且诸如安全

1567
01:15:50,160 --> 01:15:54,690
等待安全时间之类的

1568
01:15:54,690 --> 01:15:57,270
事情确保只读事务在它们的

1569
01:15:57,270 --> 01:15:59,580
时间戳中真正读取看到每个读写

1570
01:15:59,580 --> 01:16:01,290
事务 在此之前和之后都没有

1571
01:16:01,290 --> 01:16:04,520
，所以实际上有两个

1572
01:16:04,520 --> 01:16:08,370
快照隔离快照隔离

1573
01:16:08,370 --> 01:16:11,370
本身虽然是 实际上不仅经常

1574
01:16:11,370 --> 01:16:14,160
被扳手使用，而且通常

1575
01:16:14,160 --> 01:16:16,490
不会自我保证外部一致性，

1576
01:16:16,490 --> 01:16:18,780
因为在分布式系统中，选择时间戳的是

1577
01:16:18,780 --> 01:16:20,430
不同的计算机，

1578
01:16:20,430 --> 01:16:22,380
所以我们不确定

1579
01:16:22,380 --> 01:16:24,630
时间戳是否会遵守外部

1580
01:16:24,630 --> 01:16:26,450
一致性，即使它们会提供

1581
01:16:26,450 --> 01:16:29,460
序列化能力所以 除了

1582
01:16:29,460 --> 01:16:32,850
快照隔离，spanner 还具有

1583
01:16:32,850 --> 01:16:34,530
同步时间戳，正是

1584
01:16:34,530 --> 01:16:37,230
同步时间戳加上提交

1585
01:16:37,230 --> 01:16:40,920
权重规则允许 spanner

1586
01:16:40,920 --> 01:16:43,860
保证外部一致性和

1587
01:16:43,860 --> 01:16:48,150
可序列化性，

1588
01:16:48,150 --> 01:16:49,470
这一切有趣的原因是

1589
01:16:49,470 --> 01:16:52,170
程序员真的很喜欢事务，

1590
01:16:52,170 --> 01:16:53,550
我真的很喜欢 外部一致性，

1591
01:16:53,550 --> 01:16:55,170
因为这使得应用程序更

1592
01:16:55,170 --> 01:16:57,170
容易编写

1593
01:16:57,170 --> 01:16:59,540
它们传统上没有在

1594
01:16:59,540 --> 01:17:01,130
分布式设置中提供，因为它们

1595
01:17:01,130 --> 01:17:03,500
太慢了，所以 spanner

1596
01:17:03,500 --> 01:17:04,780
设法释放的事实使只读

1597
01:17:04,780 --> 01:17:08,120
事务非常快，这是非常

1598
01:17:08,120 --> 01:17:10,160
有吸引力的，没有锁定没有两个 - 阶段

1599
01:17:10,160 --> 01:17:12,530
提交，甚至没有任何远程

1600
01:17:12,530 --> 01:17:14,270
读取 一个只读事务，它们

1601
01:17:14,270 --> 01:17:16,610
从本地副本中非常有效地运行

1602
01:17:16,610 --> 01:17:19,100
，这

1603
01:17:19,100 --> 01:17:22,090
对于表 3 和表 6 中测量的 10 延迟改进的基本参与因素是有好处的，

1604
01:17:22,090 --> 01:17:25,790
 

1605
01:17:25,790 --> 01:17:29,420
但只是提醒您

1606
01:17:29,420 --> 01:17:34,300
这不是全部，也不是全部都很棒

1607
01:17:34,300 --> 01:17:36,200
这台很棒的机器它真的

1608
01:17:36,200 --> 01:17:38,240
只适用于只读事务

1609
01:17:38,240 --> 01:17:40,760
读写事务仍然使用

1610
01:17:40,760 --> 01:17:43,610
两阶段提交和锁，在

1611
01:17:43,610 --> 01:17:45,290
很多情况下，

1612
01:17:45,290 --> 01:17:47,180
由于安全

1613
01:17:47,180 --> 01:17:50,630
时间和提交等待，即使扳手也会有块，但只要

1614
01:17:50,630 --> 01:17:53,150
他们的时间足够准确，

1615
01:17:53,150 --> 01:17:55,700
这些提交权重可能

1616
01:17:55,700 --> 01:17:59,390
相对较小，可以总结

1617
01:17:59,390 --> 01:18:03,260
一下当时的扳手是一种

1618
01:18:03,260 --> 01:18:05,000
突破，因为很少

1619
01:18:05,000 --> 01:18:07,210
看到部署的系统运行

1620
01:18:07,210 --> 01:18:10,280
分布式事务，其中数据

1621
01:18:10,280 --> 01:18:14,630
在地理上非常不同的

1622
01:18:14,630 --> 01:18:17,150
数据 我很惊讶你知道

1623
01:18:17,150 --> 01:18:19,120
扳手人们很惊讶

1624
01:18:19,120 --> 01:18:21,200
有人使用的数据库

1625
01:18:21,200 --> 01:18:23,300
实际上做得很好

1626
01:18:23,300 --> 01:18:26,120
t 性能是可以忍受的，

1627
01:18:26,120 --> 01:18:28,190
快照隔离和

1628
01:18:28,190 --> 01:18:30,830
时间戳可能是论文中最

1629
01:18:30,830 --> 01:18:35,110
有趣的方面的一部分，

1630
01:18:35,110 --> 01:18:40,810
这就是我今天要说的所有

1631
01:18:40,810 --> 01:18:49,430
最后的问题，好吧，

1632
01:18:49,430 --> 01:18:51,720
我想

1633
01:18:51,720 --> 01:18:53,640
我们会去的 看看农场

1634
01:18:53,640 --> 01:18:57,300
，这是一个非常不同的部分，

1635
01:18:57,300 --> 01:19:00,330
通过提供非常高性能的交易的愿望，

1636
01:19:00,330 --> 01:19:05,370
所以我们周四见

1637
01:19:05,370 --> 01:19:07,520
 

