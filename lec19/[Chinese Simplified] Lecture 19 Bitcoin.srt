1
00:00:00,860 --> 00:00:05,120
好的，所以我们正在

2
00:00:05,629 --> 00:00:08,790
解释比特币的设计，我

3
00:00:08,790 --> 00:00:11,639
已经到了

4
00:00:11,639 --> 00:00:16,710
想要有一个所有交易的全球公开记录的地步，

5
00:00:16,710 --> 00:00:24,060
好吧，

6
00:00:24,060 --> 00:00:27,990
这个要求非常类似于

7
00:00:27,990 --> 00:00:29,550
 

8
00:00:29,550 --> 00:00:31,430
上周的证书透明度和

9
00:00:31,430 --> 00:00:34,170
解决方案有点让人联想到，

10
00:00:34,170 --> 00:00:37,770
虽然比

11
00:00:37,770 --> 00:00:40,230
证书透明度解决方案更复杂，而且

12
00:00:40,230 --> 00:00:42,480
我们想要一个公共日志的名称这通常

13
00:00:42,480 --> 00:00:46,020
也称为公共分类账，那么

14
00:00:46,020 --> 00:00:47,190
我们将如何建立自己的公共

15
00:00:47,190 --> 00:00:49,980
分类账，以便每个人都同意 在所有

16
00:00:49,980 --> 00:00:51,120
已经发生的交易上

17
00:00:51,120 --> 00:00:53,190
以及当他们就交易顺序达成一致时进一步，

18
00:00:53,190 --> 00:00:55,680
因为如果

19
00:00:55,680 --> 00:00:59,940
Y 试图同时将这个硬币发送给 Z 和

20
00:00:59,940 --> 00:01:01,559
Q，你知道我们希望

21
00:01:01,559 --> 00:01:02,850
第一个赢，第二个赢

22
00:01:02,850 --> 00:01:03,359
 

23
00:01:03,359 --> 00:01:06,060
不管 Yellin 哪一个想要哪个

24
00:01:06,060 --> 00:01:08,760
交易先来，哪个交易

25
00:01:08,760 --> 00:01:10,860
第二，都应该被忽略，好吧，

26
00:01:10,860 --> 00:01:15,570
所以如何制作分类帐，所以这是一个坏

27
00:01:15,570 --> 00:01:17,960
 

28
00:01:19,100 --> 00:01:21,780
主意 好主意实际上有最

29
00:01:21,780 --> 00:01:23,670
简单的想法是只选择

30
00:01:23,670 --> 00:01:25,290
每个人都信任的人，并让

31
00:01:25,290 --> 00:01:27,810
某人为您维护分类帐，

32
00:01:27,810 --> 00:01:29,280
每次您要进行交易时，

33
00:01:29,280 --> 00:01:31,320
您都告诉受信任的实体是什么

34
00:01:31,320 --> 00:01:33,090
交易，它只是积累了一个日志

35
00:01:33,090 --> 00:01:35,130
并且愿意 将该日志的副本提供

36
00:01:35,130 --> 00:01:37,049
给任何人，以便任何人都可以检查它

37
00:01:37,049 --> 00:01:38,930
并查看硬币是否已经被花费，

38
00:01:38,930 --> 00:01:41,759
这实际上是一个好主意，如果你

39
00:01:41,759 --> 00:01:44,369
可以这样做，你应该出于

40
00:01:44,369 --> 00:01:46,350
各种原因比特币设计师

41
00:01:46,350 --> 00:01:47,820
拒绝这个非常明显的

42
00:01:47,820 --> 00:01:51,420
直接想法，并且 根本

43
00:01:51,420 --> 00:01:54,060
原因是，在全球系统中的大系统中，

44
00:01:54,060 --> 00:01:57,090
不可能有

45
00:01:57,090 --> 00:02:00,090
任何一个实体是每个人都信任

46
00:02:00,090 --> 00:02:01,890
的，并且确实值得信赖，并且

47
00:02:01,890 --> 00:02:05,729
没有腐败的员工，例如，在

48
00:02:05,729 --> 00:02:07,110
一个全球系统中，你知道这意味着

49
00:02:07,110 --> 00:02:09,209
我们不能拥有 美国你知道

50
00:02:09,209 --> 00:02:10,470
政府

51
00:02:10,470 --> 00:02:12,390
我是值得信赖的实体，因为

52
00:02:12,390 --> 00:02:13,650
世界上有很多政府

53
00:02:13,650 --> 00:02:15,240
不一定信任

54
00:02:15,240 --> 00:02:18,120
美国类似 对于任何其他

55
00:02:18,120 --> 00:02:20,070
单个政府来说，对于一个

56
00:02:20,070 --> 00:02:23,040
全球系统来说真的是

57
00:02:23,040 --> 00:02:24,990
 

58
00:02:24,990 --> 00:02:27,840
 

59
00:02:27,840 --> 00:02:29,430
 

60
00:02:29,430 --> 00:02:31,340
 

61
00:02:31,340 --> 00:02:36,360
这样 不信任的参与者，

62
00:02:36,360 --> 00:02:41,190
我们可以通过他们的参与者知道的恶意幸存下来，

63
00:02:41,190 --> 00:02:43,740
好吧，所以这是

64
00:02:43,740 --> 00:02:48,120
一个很糟糕的可能性，让我们让

65
00:02:48,120 --> 00:02:50,610
任何人都让我们建立一个

66
00:02:50,610 --> 00:02:52,650
任何人都可以加入的系统，所以

67
00:02:52,650 --> 00:02:54,570
如果计算机会称

68
00:02:54,570 --> 00:02:55,950
他们为同行，可能会有数千个他们分散 在

69
00:02:55,950 --> 00:02:56,880
整个互联网上

70
00:02:56,880 --> 00:02:58,530
，他们每个人都

71
00:02:58,530 --> 00:03:03,210
将为我们的新加密货币系统运行该软件，

72
00:03:03,210 --> 00:03:07,770
任何时候有人

73
00:03:07,770 --> 00:03:10,590
想要进行新的交易，比如 Y

74
00:03:10,590 --> 00:03:19,950
想向 Z 发送硬币 Y 洪水他们的

75
00:03:19,950 --> 00:03:21,510
新交易将他们的新交易发送

76
00:03:21,510 --> 00:03:23,970
给所有 节点直接发送

77
00:03:23,970 --> 00:03:26,670
它们，或者

78
00:03:26,670 --> 00:03:28,200
实际上比特币使用的另一种设计是 Y

79
00:03:28,200 --> 00:03:30,030
将新交易发送给几个

80
00:03:30,030 --> 00:03:33,060
节点，然后节点 有点像

81
00:03:33,060 --> 00:03:38,280
通过单独的 TCP 链接到

82
00:03:38,280 --> 00:03:39,780
整个系统的其余部分，因此在每个

83
00:03:39,780 --> 00:03:41,459
事务中最终都被发送到所有

84
00:03:41,459 --> 00:03:43,440
对等点和对等点，他们

85
00:03:43,440 --> 00:03:46,350
试图做的是他们每个人都维护

86
00:03:46,350 --> 00:03:48,209
所有日志的完整副本

87
00:03:48,209 --> 00:03:50,730
交易，我们真正想要的是

88
00:03:50,730 --> 00:03:54,060
所有对等点都使用所有诚实的

89
00:03:54,060 --> 00:03:56,850
对等点，因为他们的交易日志是

90
00:03:56,850 --> 00:03:58,739
相同的，他们会就存在哪些交易达成一致，并且

91
00:03:58,739 --> 00:04:01,140
 

92
00:04:01,140 --> 00:04:03,269
对这些交易的顺序同样重要，

93
00:04:03,269 --> 00:04:05,580
所以我们如何安排所有这些对等点

94
00:04:05,580 --> 00:04:09,990
最终处理

95
00:04:09,990 --> 00:04:11,400
它们以相同顺序记录的标题事务

96
00:04:11,400 --> 00:04:13,890
当然记住为什么可能已经

97
00:04:13,890 --> 00:04:16,680
将事务发送到 Z 你知道

98
00:04:16,680 --> 00:04:19,290
这些对等方，同时将

99
00:04:19,290 --> 00:04:22,320
其事务发送到 Q 到其他一组

100
00:04:22,320 --> 00:04:25,650
对等方，我们想要 为了确保即使 Y 试图很好地对待，

101
00:04:25,650 --> 00:04:30,630
尽管对等点最终会

102
00:04:30,630 --> 00:04:32,400
得到相同的日志，但

103
00:04:32,400 --> 00:04:36,450
我实际上不

104
00:04:36,450 --> 00:04:39,930
知道如何设计

105
00:04:39,930 --> 00:04:43,920
这个你可以想象的一种可能性是对等点

106
00:04:43,920 --> 00:04:45,690
会以某种方式 就每个新事务互相讨论，

107
00:04:45,690 --> 00:04:48,030
并且对于

108
00:04:48,030 --> 00:04:50,910
日志中的每个新插槽，将投票决定哪个

109
00:04:50,910 --> 00:04:54,440
事务应该填充该插槽并

110
00:04:54,440 --> 00:04:56,700
拥有您知道的多数，因为

111
00:04:56,700 --> 00:04:58,110
如果他们收到不同的事务，他们可能会合法地不同意

112
00:04:58,110 --> 00:05:00,060
我们有

113
00:05:00,060 --> 00:05:02,040
一个多数规则，这说明我们 '

114
00:05:02,040 --> 00:05:03,300
所有同行都会看待

115
00:05:03,300 --> 00:05:05,970
所有的选票，而

116
00:05:05,970 --> 00:05:07,950
获得最多选票的交易是

117
00:05:07,950 --> 00:05:09,630
将在日志中的下一个插槽中进行的投票，然后

118
00:05:09,630 --> 00:05:15,020
他们将在下一张幻灯片上再次投票，

119
00:05:15,620 --> 00:05:17,550
您知道也许您也许您 可以

120
00:05:17,550 --> 00:05:19,440
 

121
00:05:19,440 --> 00:05:21,000
 

122
00:05:21,000 --> 00:05:22,530
 

123
00:05:22,530 --> 00:05:25,230
 

124
00:05:25,230 --> 00:05:27,000
使它起作用您必须知道所有其他对等方是谁才能知道多数是多少您不必知道有多少对等方并且您确实想确保从不计算任何

125
00:05:27,000 --> 00:05:30,150
对等方 不止一次，但在

126
00:05:30,150 --> 00:05:33,240
像比特币这样的完全开放的系统中，实际上我们

127
00:05:33,240 --> 00:05:34,920
不能做任何一件我们不

128
00:05:34,920 --> 00:05:36,480
知道比特币有多少参与者的事情

129
00:05:36,480 --> 00:05:38,670
，而且

130
00:05:38,670 --> 00:05:41,010
随着人们

131
00:05:41,010 --> 00:05:43,410
加入和离开系统，这个数字一直在变化，所以 w 我们不

132
00:05:43,410 --> 00:05:44,790
知道有多少同行，所以我们不

133
00:05:44,790 --> 00:05:47,700
知道多数会是多少此外，我们

134
00:05:47,700 --> 00:05:50,370
没有办法可靠地计算选票，

135
00:05:50,370 --> 00:05:52,980
这样即使假设这是可取的，每个参与者也只能得到一

136
00:05:52,980 --> 00:05:56,060
票，

137
00:05:56,060 --> 00:05:59,900
所以我们可以 '不要使用IP

138
00:05:59,900 --> 00:06:03,090
地址来决定它是不同的投票

139
00:06:03,090 --> 00:06:04,980
我们不能说好每个IP地址获得

140
00:06:04,980 --> 00:06:07,380
一票或最多一票因为

141
00:06:07,380 --> 00:06:09,870
事实证明

142
00:06:09,870 --> 00:06:12,900
伪造IP地址或闯入

143
00:06:12,900 --> 00:06:15,930
人们的计算机来积累非常容易

144
00:06:15,930 --> 00:06:18,479
数以万计的真实计算机，你可以

145
00:06:18,479 --> 00:06:21,090
控制，你当然可以

146
00:06:21,090 --> 00:06:24,890
让他们都投票给你

147
00:06:25,840 --> 00:06:28,130
，你可以让他们都在系统中投票，

148
00:06:28,130 --> 00:06:29,630
这样攻击者就可以

149
00:06:29,630 --> 00:06:31,460
 

150
00:06:31,460 --> 00:06:34,250
相对容易地以某种方式积累大多数选票

151
00:06:34,250 --> 00:06:36,320
像这样简单的设计，

152
00:06:36,320 --> 00:06:38,750
如果攻击者可以获得多数票，

153
00:06:38,750 --> 00:06:44,000
那么它可以使用这个多数

154
00:06:44,000 --> 00:06:47,600
来坐下来说不同的

155
00:06:47,600 --> 00:06:49,760
事情，但每次都是多数，

156
00:06:49,760 --> 00:06:53,720
所以如果 Z 询问系统哦 y 你

157
00:06:53,720 --> 00:06:57,280
知道这两个

158
00:06:57,280 --> 00:06:59,510
交易中的哪一个先发生因为你

159
00:06:59,510 --> 00:07:02,180
知道记住问题是担心的

160
00:07:02,180 --> 00:07:03,889
是你会双花

161
00:07:03,889 --> 00:07:06,470
一些硬币所以它会花同一个

162
00:07:06,470 --> 00:07:09,590
硬币-Q希望你相信

163
00:07:09,590 --> 00:07:13,130
它会发送相同的 Q 的硬币给 Z

164
00:07:13,130 --> 00:07:15,290
和 1c 相信所以也许当 Q

165
00:07:15,290 --> 00:07:17,270
询问下一个交易是什么来记录

166
00:07:17,270 --> 00:07:19,310
由攻击者控制的多数人

167
00:07:19,310 --> 00:07:21,560
可以说哦，你知道明智的转移到 Q

168
00:07:21,560 --> 00:07:22,970
是日志中的下一个，

169
00:07:22,970 --> 00:07:26,570
并且在此交易之前发生并且 当 Z

170
00:07:26,570 --> 00:07:28,520
询问时，大多数攻击者可能会

171
00:07:28,520 --> 00:07:30,169
说，你知道转移 Z 是

172
00:07:30,169 --> 00:07:33,140
第一位的，而另一个到 Q 的交易

173
00:07:33,140 --> 00:07:36,979
是第二位的，这意味着

174
00:07:36,979 --> 00:07:40,570
攻击者可以欺骗 q + Z 到 X

175
00:07:40,570 --> 00:07:43,669
接受同一个硬币，这是一个双

176
00:07:43,669 --> 00:07:48,110
花，这是一个 灾难，所以如果没有

177
00:07:48,110 --> 00:07:50,990
一些非常聪明的想法，很难

178
00:07:50,990 --> 00:07:52,580
建立一个

179
00:07:52,580 --> 00:07:54,580
你知道没有受控

180
00:07:54,580 --> 00:07:56,479
成员的开放系统很难建立

181
00:07:56,479 --> 00:08:01,270
一个你有可靠投票的开放系统，

182
00:08:01,270 --> 00:08:06,289
但事实上比特币d 没有完全

183
00:08:06,289 --> 00:08:09,139
使用投票，但它仍然

184
00:08:09,139 --> 00:08:13,190
设法解决这个问题，即尽管存在恶意，如何

185
00:08:13,190 --> 00:08:14,930
在单个分类账上达成一致，

186
00:08:14,930 --> 00:08:18,260
所以这是比特币

187
00:08:18,260 --> 00:08:20,530
区块链

188
00:08:26,379 --> 00:08:29,350
，此时有很多差异

189
00:08:29,350 --> 00:08:31,900
链系统，所以实际上我

190
00:08:31,900 --> 00:08:33,970
不是 甚至确定区块链作为一个术语

191
00:08:33,970 --> 00:08:36,940
指的是什么，但我现在只在谈论

192
00:08:36,940 --> 00:08:41,320
比特币，所以我们的目标是我们

193
00:08:41,320 --> 00:08:43,570
希望再次就单个交易日志达成一致，

194
00:08:43,570 --> 00:08:46,450
因为我们想要防止

195
00:08:46,450 --> 00:08:50,980
双重支出，我们

196
00:08:50,980 --> 00:08:52,300
将构建比特币 构建这个

197
00:08:52,300 --> 00:08:55,840
叫做区块链的东西，它包含

198
00:08:55,840 --> 00:08:57,490
所有硬币上的所有交易，所以

199
00:08:57,490 --> 00:09:00,820
它是一个单一的区块链，

200
00:09:00,820 --> 00:09:02,980
 

201
00:09:02,980 --> 00:09:06,630
再次描述系统中的所有交易，就像以前的系统一样

202
00:09:06,630 --> 00:09:08,860
，会有很多对等点，所以我们

203
00:09:08,860 --> 00:09:10,920
仍然有这种覆盖 网络

204
00:09:10,920 --> 00:09:15,610
似乎每个对等点都在自己的内存中构建

205
00:09:15,610 --> 00:09:18,280
日志副本和事务日志的完整副本，

206
00:09:18,280 --> 00:09:21,120
 

207
00:09:21,120 --> 00:09:25,450
我们不知道他们有多少对等

208
00:09:25,450 --> 00:09:27,930
点或有多少谁 它们是，

209
00:09:27,930 --> 00:09:30,220
但它们形成了一种在这些

210
00:09:30,220 --> 00:09:32,950
覆盖网络中发现的 TCP

211
00:09:32,950 --> 00:09:35,230
连接，并且任何时候对等点

212
00:09:35,230 --> 00:09:37,270
听到新交易，例如当 Y

213
00:09:37,270 --> 00:09:39,640
想要向 Z 或 Q 提交支付交易时，

214
00:09:39,640 --> 00:09:41,920
它会将其发送给一个或多个

215
00:09:41,920 --> 00:09:43,780
对等点，并且 对等点会将事务淹没

216
00:09:43,780 --> 00:09:47,800
在整个系统

217
00:09:47,800 --> 00:09:50,170
中建立日志的

218
00:09:50,170 --> 00:09:52,270
方式建立区块链的方式是每个

219
00:09:52,270 --> 00:09:54,550
对等点累积交易并将

220
00:09:54,550 --> 00:09:57,280
数千个交易PACs放入一个

221
00:09:57,280 --> 00:10:01,240
块中，然后是全新的

222
00:10:01,240 --> 00:10:03,190
交易块 真正通过在整个系统

223
00:10:03,190 --> 00:10:06,670
中泛滥新块来再次附加到分类帐，

224
00:10:06,670 --> 00:10:08,680
因此至少

225
00:10:08,680 --> 00:10:10,540
在理论上每个对等点都可以看到每个新

226
00:10:10,540 --> 00:10:17,050
块，因此区块链模型

227
00:10:17,050 --> 00:10:19,150
区块链由块组成，每个

228
00:10:19,150 --> 00:10:26,500
块看起来都是

229
00:10:26,500 --> 00:10:31,260
前一个块的哈希，有点像 我

230
00:10:32,829 --> 00:10:35,449
之前的交易破坏了交易

231
00:10:35,449 --> 00:10:36,559
系统，所以我们有前一个区块的哈希值，

232
00:10:36,559 --> 00:10:42,379
就像前一个区块的加密哈希值一样

233
00:10:42,379 --> 00:10:44,179
，有一组

234
00:10:44,179 --> 00:10:46,639
交易 o 这些是单独的

235
00:10:46,639 --> 00:10:51,259
跨度，你知道为什么要尝试支付

236
00:10:51,259 --> 00:10:54,519
队列或任何它恰好是

237
00:10:54,519 --> 00:10:56,420
几十个整千个

238
00:10:56,420 --> 00:10:57,920
单独的交易，每笔

239
00:10:57,920 --> 00:11:00,050
交易实际上就像我

240
00:11:00,050 --> 00:11:04,040
之前描述的那样，它具有

241
00:11:04,040 --> 00:11:06,110
该硬币的前一笔交易的哈希值

242
00:11:06,110 --> 00:11:07,429
将存在于前一个区块中，

243
00:11:07,429 --> 00:11:10,490
通常它已经剥夺了该硬币

244
00:11:10,490 --> 00:11:13,160
前所有者的私钥的签名，

245
00:11:13,160 --> 00:11:14,990
并且它

246
00:11:14,990 --> 00:11:16,939
是新所有者的公钥，因此该交易将

247
00:11:16,939 --> 00:11:20,059
具有转移资金的原因

248
00:11:20,059 --> 00:11:24,110
队列将包含休的 公钥

249
00:11:24,110 --> 00:11:27,619
和签名由明智的私钥

250
00:11:27,619 --> 00:11:30,649
加上前一个块中的前一个交易的哈希

251
00:11:30,649 --> 00:11:34,160
以及这些

252
00:11:34,160 --> 00:11:38,000
交易有一个随机数

253
00:11:38,000 --> 00:11:39,889
，我稍后会谈到它

254
00:11:39,889 --> 00:11:43,100
只是一个 32 位数字，然后是

255
00:11:43,100 --> 00:11:49,459
当前时间 系统的大致

256
00:11:49,459 --> 00:11:52,490
工作方式是对等节点累积新

257
00:11:52,490 --> 00:11:53,959
交易，并且大约每 10

258
00:11:53,959 --> 00:11:56,300
分钟其中一个会产生一个新块

259
00:11:56,300 --> 00:11:58,100
，该块应该是包含以下内容的后续块

260
00:11:58,100 --> 00:12:00,350
 

261
00:12:00,350 --> 00:12:01,730
 

262
00:12:01,730 --> 00:12:03,699
自上一个区块创建以来，大约在十分钟内发送到系统的所有交易

263
00:12:03,699 --> 00:12:08,800
，

264
00:12:08,800 --> 00:12:11,120
如果有人告诉你他们正在向你支付

265
00:12:11,120 --> 00:12:14,089
比特币，那么在你接受

266
00:12:14,089 --> 00:12:16,160
他们真的完成之前，你 需要

267
00:12:16,160 --> 00:12:18,410
观察区块链的发展，并且您

268
00:12:18,410 --> 00:12:19,670
知道区块 新区块是无处不在的标志

269
00:12:19,670 --> 00:12:21,139
，因此

270
00:12:21,139 --> 00:12:24,019
如果您认为有人声称

271
00:12:24,019 --> 00:12:26,089
已向您付款，则区块链是相当公开的，您需要观察

272
00:12:26,089 --> 00:12:28,490
区块链，直到您看到一个包含您的交易的新区块

273
00:12:28,490 --> 00:12:32,110
 

274
00:12:32,110 --> 00:12:35,269
'期待

275
00:12:35,269 --> 00:12:37,819
声称向您汇款的人以及您的

276
00:12:37,819 --> 00:12:39,889
公钥看起来是有效的

277
00:12:39,889 --> 00:12:42,579
您知道正确签名好的所以

278
00:12:42,579 --> 00:12:45,559
每个人都必须注意

279
00:12:45,559 --> 00:12:52,009
区块链以向他们付款

280
00:12:52,009 --> 00:12:55,660
所以谁创建每个块这个

281
00:12:55,660 --> 00:12:57,620
动作 创建一个新块称为

282
00:12:57,620 --> 00:13:00,949
挖掘，用于

283
00:13:00,949 --> 00:13:02,540
生成新块的技术通常也称为

284
00:13:02,540 --> 00:13:05,180
工作量证明，因为它

285
00:13:05,180 --> 00:13:08,059
需要大量 CPU 时间来生成一个

286
00:13:08,059 --> 00:13:09,559
新块，因此新

287
00:13:09,559 --> 00:13:12,050
块的产生基本上证明了您

288
00:13:12,050 --> 00:13:14,720
控制了一个真实的实时 CPU，而您

289
00:13:14,720 --> 00:13:18,170
不仅仅是在假计算机上挖掘新块。

290
00:13:18,170 --> 00:13:25,269
 

291
00:13:25,960 --> 00:13:29,500
 

292
00:13:29,500 --> 00:13:32,650
 

293
00:13:32,650 --> 00:13:35,830
 

294
00:13:35,830 --> 00:13:39,070
当然，如果你只是采取

295
00:13:39,070 --> 00:13:41,020
一堆任意交易

296
00:13:41,020 --> 00:13:43,270
并对它进行加密散列，那么现在块的散列开头有一定数量的零，那么

297
00:13:43,270 --> 00:13:45,760
一些数据的散列不太可能

298
00:13:45,760 --> 00:13:48,580
 

299
00:13:48,580 --> 00:13:52,480
超过 在加密哈希的开头有一个或两个或三个零，

300
00:13:52,480 --> 00:13:54,880
 

301
00:13:54,880 --> 00:14:00,370
但是正在挖掘块的计算机

302
00:14:00,370 --> 00:14:02,320
可以将它喜欢的任何值放在这里

303
00:14:02,320 --> 00:14:04,960
作为节点，所以挖掘

304
00:14:04,960 --> 00:14:07,240
计算机所做的是他们尝试

305
00:14:07,240 --> 00:14:09,180
通过不同的随机值来尝试不同的随机数

306
00:14:09,180 --> 00:14:11,080
选择一个带有随机数生成器的随机数

307
00:14:11,080 --> 00:14:13,450
生成器，将其粘贴在

308
00:14:13,450 --> 00:14:14,890
他们试图挖掘的块的副本中，

309
00:14:14,890 --> 00:14:16,000
然后他们将计算块上的哈希值

310
00:14:16,000 --> 00:14:16,480
 

311
00:14:16,480 --> 00:14:18,430
，他们将检查有多少个零有

312
00:14:18,430 --> 00:14:20,740
多少个前导零

313
00:14:20,740 --> 00:14:22,900
如果有足够的前导零，则带有这个特定结的哈希

314
00:14:22,900 --> 00:14:24,550
我不知道它有多少，

315
00:14:24,550 --> 00:14:26,080
但是

316
00:14:26,080 --> 00:14:28,839
如果有足够的

317
00:14:28,839 --> 00:14:30,610
前导零并且它是一个有效的矿井一个

318
00:14:30,610 --> 00:14:34,600
有效的块以及它是什么对等点，它是你知道的大约几十个

319
00:14:34,600 --> 00:14:36,670
发现这个导致

320
00:14:36,670 --> 00:14:38,709
块散列有很多前导零的随机数

321
00:14:38,709 --> 00:14:40,660
可以在网络上泛滥这个块

322
00:14:40,660 --> 00:14:43,330
，你知道所有相等的

323
00:14:43,330 --> 00:14:45,400
都是新的下一个块和

324
00:14:45,400 --> 00:14:51,070
链，但通常是块的散列

325
00:14:51,070 --> 00:14:52,660
与任何 给定随机数，你

326
00:14:52,660 --> 00:14:55,270
知道没有足够的前导零，并且

327
00:14:55,270 --> 00:14:57,310
挖掘对等方将不得不尝试另一个

328
00:14:57,310 --> 00:14:59,350
随机数，另一个随机随机数继续这样做

329
00:14:59,350 --> 00:15:01,510
，直到它得到

330
00:15:01,510 --> 00:15:03,850
一个哈希到具有足够前导零的哈希的块

331
00:15:03,850 --> 00:15:05,589
，所以这需要很多 需要的 CPU

332
00:15:05,589 --> 00:15:07,630
时间哦，你知道这是一个随机

333
00:15:07,630 --> 00:15:11,890
过程，但是系统经过了某种调整，

334
00:15:11,890 --> 00:15:13,930
并且

335
00:15:13,930 --> 00:15:16,089
 

336
00:15:16,089 --> 00:15:19,720
设置了在块的哈希开始处需要存在的零的数量，因此

337
00:15:19,720 --> 00:15:22,029
你知道大约需要十分钟

338
00:15:22,029 --> 00:15:23,800
迪 数十万不同的同行

339
00:15:23,800 --> 00:15:25,150
出现在那里，他们正在

340
00:15:25,150 --> 00:15:28,000
做比特币挖掘，

341
00:15:28,000 --> 00:15:29,650
在他们中的第一个

342
00:15:29,650 --> 00:15:33,459
找到一个有足够喂零的区块的随机数之前的平均时间

343
00:15:33,459 --> 00:15:36,490
量设置为十分

344
00:15:36,490 --> 00:15:38,640
钟

345
00:15:38,640 --> 00:15:44,620
好吧，所以问同行或新的如何

346
00:15:44,620 --> 00:15:46,120
对等点发现其他对等点进行

347
00:15:46,120 --> 00:15:48,399
通信是的，这是一个

348
00:15:48,399 --> 00:15:50,320
很好的问题，所以

349
00:15:50,320 --> 00:15:54,970
如果

350
00:15:54,970 --> 00:15:57,399
我是一个新的对等点，你知道我已经安装了一台

351
00:15:57,399 --> 00:15:58,930
新计算机，我的比特币软件

352
00:15:58,930 --> 00:16:00,790
安装了我的 计算机，我

353
00:16:00,790 --> 00:16:03,519
想加入比特币网络 我

354
00:16:03,519 --> 00:16:06,880
怎么知道与谁交谈以及我怎么知道，

355
00:16:06,880 --> 00:16:09,100
所以直接的答案

356
00:16:09,100 --> 00:16:11,350
是比特币软件已经

357
00:16:11,350 --> 00:16:15,070
内置在一大堆当前对等点的 IP 地址上，

358
00:16:15,070 --> 00:16:17,769
并且 因此，

359
00:16:17,769 --> 00:16:19,990
当您第一次将软件启动

360
00:16:19,990 --> 00:16:21,760
到二进制文件中时，无论

361
00:16:21,760 --> 00:16:24,040
您知道什么比特币软件都有

362
00:16:24,040 --> 00:16:25,480
大量 IP 地址，并且您尝试

363
00:16:25,480 --> 00:16:30,670
与这些现有

364
00:16:30,670 --> 00:16:32,170
对等点建立 TCP 连接，如果一切顺利，您将 b

365
00:16:32,170 --> 00:16:33,279
能够连接到他们，你会

366
00:16:33,279 --> 00:16:34,899
说我是新人，请给我一份区块链的副本，

367
00:16:34,899 --> 00:16:37,480
因为它现在存在，

368
00:16:37,480 --> 00:16:40,110
他们会向你发送当前

369
00:16:40,110 --> 00:16:42,550
大约几百

370
00:16:42,550 --> 00:16:46,180
GB 的区块团队，如果 一切

371
00:16:46,180 --> 00:16:50,199
顺利如果一切不顺利，那么

372
00:16:50,199 --> 00:16:52,240
您可能会遇到问题，

373
00:16:52,240 --> 00:16:54,519
例如，如果您的软件副本已

374
00:16:54,519 --> 00:16:56,529
被恶意修改为

375
00:16:56,529 --> 00:16:59,440
拥有全部由攻击者控制的 IP 地址列表，

376
00:16:59,440 --> 00:17:02,829
或者

377
00:17:02,829 --> 00:17:05,049
攻击者控制您的 计算机网络，

378
00:17:05,049 --> 00:17:07,240
因此无论您尝试与

379
00:17:07,240 --> 00:17:09,520
谁连接，您最终

380
00:17:09,520 --> 00:17:11,679
都会与攻击者的机器

381
00:17:11,679 --> 00:17:13,599
 

382
00:17:13,599 --> 00:17:17,799
 

383
00:17:17,799 --> 00:17:19,630
 

384
00:17:19,630 --> 00:17:21,069
对话

385
00:17:21,069 --> 00:17:23,589
比特币知道的连接数，但是哎呀，他们都是

386
00:17:23,589 --> 00:17:25,780
攻击者节点，在这种情况下，

387
00:17:25,780 --> 00:17:28,000
你将获得的区块链将

388
00:17:28,000 --> 00:17:29,020
被攻击者控制

389
00:17:29,020 --> 00:17:31,980
，你很可能会遇到麻烦

390
00:17:31,980 --> 00:17:36,429
，你知道有一个选择 对此的一些

391
00:17:36,429 --> 00:17:41,799
防御措施可能是

392
00:17:41,799 --> 00:17:44,540
他

393
00:17:44,540 --> 00:17:48,500
加载正确的比特币软件的主要井正确的比特

394
00:17:48,500 --> 00:17:50,680
币软件具有

395
00:17:50,680 --> 00:17:52,850
区块链中最近区块的内置

396
00:17:52,850 --> 00:17:54,800
哈希，这意味着如果

397
00:17:54,800 --> 00:17:56,270
您在

398
00:17:56,270 --> 00:17:59,540
运行正确的比特币软件时连接到一些攻击者，

399
00:17:59,540 --> 00:18:05,150
至少 Bakhtin 必须从第一个开始，

400
00:18:05,150 --> 00:18:07,100
但是

401
00:18:07,100 --> 00:18:09,470
如果你下载

402
00:18:09,470 --> 00:18:11,210
了被攻击者修改的绝对错误的软件，

403
00:18:11,210 --> 00:18:13,490
那么箱梁中的数千个块必须是正确的，那么

404
00:18:13,490 --> 00:18:16,970
比特币无能为力，那么这是

405
00:18:16,970 --> 00:18:19,820
我所拥有的系统中的一个潜在

406
00:18:19,820 --> 00:18:20,990
弱点 '不一定听说过有人

407
00:18:20,990 --> 00:18:26,000
利用它，但这绝对

408
00:18:26,000 --> 00:18:28,150
是值得考虑的事情

409
00:18:28,150 --> 00:18:33,110
ok 回到挖矿 ok 所以如果你

410
00:18:33,110 --> 00:18:34,370
想创建一个新块，你必须找到一个

411
00:18:34,370 --> 00:18:38,000
随机数，它会导致你试图产生的新块

412
00:18:38,000 --> 00:18:40,280
导致哈希有

413
00:18:40,280 --> 00:18:43,460
一台机器的很多前导零

414
00:18:43,460 --> 00:18:47,030
你知道

415
00:18:47,030 --> 00:18:48,680
一台普通计算机

416
00:18:48,680 --> 00:18:50,930
找到满足这个要求的随机数的时间

417
00:18:50,930 --> 00:18:54,010
就像一个 至少需要几个月的 CPU 时间，

418
00:18:54,010 --> 00:18:57,620
但是那里有大量的

419
00:18:57,620 --> 00:19:00,200
比特币矿工，所以

420
00:19:00,200 --> 00:19:01,340
即使他们中的任何一个都需要很

421
00:19:01,340 --> 00:19:04,490
长时间才能找到一个新区块，或者我们

422
00:19:04,490 --> 00:19:05,960
真正关心的是第一个区块的

423
00:19:05,960 --> 00:19:07,490
时间 他们中的一个找到一个块

424
00:19:07,490 --> 00:19:09,200
，因为他们都

425
00:19:09,200 --> 00:19:12,530
在随机选择随机数，所以他们

426
00:19:12,530 --> 00:19:17,330
中的一个会找到一个相对较快满足要求的随机数，

427
00:19:17,330 --> 00:19:20,390
并且

428
00:19:20,390 --> 00:19:22,520
比特币的数量会调整

429
00:19:22,520 --> 00:19:24,590
前导所需前导零的数量

430
00:19:24,590 --> 00:19:29,720
散列以响应新块出现的速度

431
00:19:29,720 --> 00:19:32,150
，因此如果新

432
00:19:32,150 --> 00:19:33,910
块出现的速度远快于

433
00:19:33,910 --> 00:19:36,530
每 10 分钟一次，比特币将

434
00:19:36,530 --> 00:19:38,300
自动增加所需的

435
00:19:38,300 --> 00:19:39,890
前导零的数量，

436
00:19:39,890 --> 00:19:41,900
这将使其相应地变得更难

437
00:19:41,900 --> 00:19:44,840
并花费更长的时间 矿工找到

438
00:19:44,840 --> 00:19:47,270
一个新块 Nana 块在持续的一段时间内当然

439
00:19:47,270 --> 00:19:48,800
比每 10 分钟慢

440
00:19:48,800 --> 00:19:50,570
一次，然后

441
00:19:50,570 --> 00:19:52,790
比特币将调整所需数量

442
00:19:52,790 --> 00:19:54,230
的前导零 h

443
00:19:54,230 --> 00:19:56,540
更小，这意味着它会更容易

444
00:19:56,540 --> 00:19:57,580
更快

445
00:19:57,580 --> 00:19:59,080
地找到你的块

446
00:19:59,080 --> 00:20:04,360
到我们那里的自适应方案的块到

447
00:20:04,360 --> 00:20:05,980
新的盒子显示每十分钟运行一次

448
00:20:05,980 --> 00:20:09,539
大致可以，所以这

449
00:20:09,539 --> 00:20:14,610
是工作量证明方案 这

450
00:20:14,610 --> 00:20:17,619
本质上是一个解决方案，并且以一种

451
00:20:17,619 --> 00:20:21,220
有趣的方式解决了我几分钟前提到的那个投票问题

452
00:20:21,220 --> 00:20:23,019
，你

453
00:20:23,019 --> 00:20:25,029
不能真正进行一些练习我有

454
00:20:25,029 --> 00:20:28,389
多数票因为我们不确定

455
00:20:28,389 --> 00:20:30,159
参与者是谁或有多少参与者

456
00:20:30,159 --> 00:20:32,590
是因为人们可能会在某种程度上

457
00:20:32,590 --> 00:20:35,590
创建伪造的计算机伪造 IP 地址，

458
00:20:35,590 --> 00:20:39,249
无论它在这里你必须使用

459
00:20:39,249 --> 00:20:41,049
CPU 时间，这是一种真实的

460
00:20:41,049 --> 00:20:44,919
资源，不能

461
00:20:44,919 --> 00:20:47,320
为了贡献一个新块而伪造，这

462
00:20:47,320 --> 00:20:50,169
意味着你知道，虽然它不是 真的是一个

463
00:20:50,169 --> 00:20:53,019
投票方案，它本质上

464
00:20:53,019 --> 00:20:57,190
做的是新块来自

465
00:20:57,190 --> 00:21:01,149
对参与采矿的不同计算机的反应性随机选择，

466
00:21:01,149 --> 00:21:03,279
 

467
00:21:03,279 --> 00:21:08,470
所以这个方案是

468
00:21:08,470 --> 00:21:10,840
一种随机的加密

469
00:21:10,840 --> 00:21:12,850
方式 非常强大的随机选择

470
00:21:12,850 --> 00:21:15,489
过程来决定谁可以选择下一个

471
00:21:15,489 --> 00:21:17,289
区块，因此如果有

472
00:21:17,289 --> 00:21:19,869
少数攻击者，他们极不可能

473
00:21:19,869 --> 00:21:23,019
被这个过程选中以

474
00:21:23,019 --> 00:21:25,090
贡献下一个区块，这

475
00:21:25,090 --> 00:21:26,379
意味着如果大多数攻击者

476
00:21:26,379 --> 00:21:28,899
参与者或系统中的大部分 CPU 能力

477
00:21:28,899 --> 00:21:31,539
由非

478
00:21:31,539 --> 00:21:34,119
恶意人员控制，那么大多数新

479
00:21:34,119 --> 00:21:35,980
块将由非恶意

480
00:21:35,980 --> 00:21:37,929
人员发现，这不是

481
00:21:37,929 --> 00:21:39,970
双重支出的直接解决方案，但我们会

482
00:21:39,970 --> 00:21:44,529
看到它是关键

483
00:21:44,529 --> 00:21:52,049
双重支出防御

484
00:21:52,630 --> 00:21:54,910
好吧，让我们回到我们的

485
00:21:54,910 --> 00:21:59,800
示例，我们有一个区块链，可能

486
00:21:59,800 --> 00:22:02,940
看起来我们目前阻止了 5

487
00:22:02,940 --> 00:22:06,310
点钟罚款已经发布给

488
00:22:06,310 --> 00:22:11,980
每个人，嗯，他们所有的同行都

489
00:22:11,980 --> 00:22:14,710
在努力挖掘潜在的区块 6，

490
00:22:14,710 --> 00:22:15,940
并且 我们还不知道会发生什么

491
00:22:15,940 --> 00:22:21,430
，因为矿工仍在

492
00:22:21,430 --> 00:22:23,260
努力寻找有关结的信息，但您

493
00:22:23,260 --> 00:22:24,850
知道我们知道它有很多

494
00:22:24,850 --> 00:22:26,530
交易，如果此时

495
00:22:26,530 --> 00:22:30,640
为什么要广泛 投你知道说这是

496
00:22:30,640 --> 00:22:33,370
对 Z 的付款，矿工已经

497
00:22:33,370 --> 00:22:35,650
在这个区块上工作了，所以明智的新

498
00:22:35,650 --> 00:22:37,150
交易，即使它发送出去，

499
00:22:37,150 --> 00:22:38,110
所以现在可能不会

500
00:22:38,110 --> 00:22:40,000
被合并到区块中，

501
00:22:40,000 --> 00:22:42,160
但所有矿工都会

502
00:22:42,160 --> 00:22:44,740
善良 保留这个新交易和一个

503
00:22:44,740 --> 00:22:46,690
缓冲区，当他们

504
00:22:46,690 --> 00:22:51,730
中的一个确实为第 6 块找到一个新块时，一旦有人介意第 7 框，这个 Y 箭头 Z

505
00:22:51,730 --> 00:22:53,650
就会将明智的交易纳入

506
00:22:53,650 --> 00:22:59,410
到挖掘第 7 块的尝试中

507
00:22:59,410 --> 00:23:01,140
 

508
00:23:01,140 --> 00:23:04,930
实际上真的

509
00:23:04,930 --> 00:23:14,470
在区块链中好吧，所以一个

510
00:23:14,470 --> 00:23:17,110
问题是，是否有两个不同的

511
00:23:17,110 --> 00:23:20,140
继任者走六位，是否存在

512
00:23:20,140 --> 00:23:23,590
第七区块和第七区块的

513
00:23:23,590 --> 00:23:31,600
质数，是什么阻止了这种结构

514
00:23:31,600 --> 00:23:33,250
的出现，当然还有

515
00:23:33,250 --> 00:23:35,140
我们为什么 对此感兴趣的是，

516
00:23:35,140 --> 00:23:38,910
如果结构可能出现，

517
00:23:39,240 --> 00:23:43,950
那么这两个可能是七个素数 B 七个

518
00:23:43,950 --> 00:23:46,920
双素数 那么这两个不同的 b7

519
00:23:46,920 --> 00:23:48,840
s b6 的两个不同的连续后继

520
00:23:48,840 --> 00:23:51,690
可能有不同的 tr 来自 Y 的回答

521
00:23:51,690 --> 00:23:54,570
，所以如果你只知道 b7

522
00:23:54,570 --> 00:23:57,540
质数，你会想为什么要支付比特币

523
00:23:57,540 --> 00:23:59,940
来看看你是否只是 b7

524
00:23:59,940 --> 00:24:01,920
质数，你这会点击

525
00:24:01,920 --> 00:24:05,100
来自广泛急性的完全合法的付款我的

526
00:24:05,100 --> 00:24:07,440
问题是可以在那里 是

527
00:24:07,440 --> 00:24:11,940
一个区块的两个不同的继任者事实证明

528
00:24:11,940 --> 00:24:14,370
答案是肯定的，而且它确实

529
00:24:14,370 --> 00:24:17,220
经常发生，

530
00:24:17,220 --> 00:24:18,780
原因是你知道那里有

531
00:24:18,780 --> 00:24:22,140
成千上万的同行正在挖掘

532
00:24:22,140 --> 00:24:24,330
试图找到阻止六个的继任者

533
00:24:24,330 --> 00:24:27,900
，他们很可能正在挖掘 你

534
00:24:27,900 --> 00:24:29,100
知道试图产生一些

535
00:24:29,100 --> 00:24:30,420
不同的块，其中包含不同的

536
00:24:30,420 --> 00:24:32,040
交易集，所以很容易

537
00:24:32,040 --> 00:24:34,140
想象这样一种情况，

538
00:24:34,140 --> 00:24:37,110
你知道他们碰巧看到的一些对等点只是

539
00:24:37,110 --> 00:24:38,520
因为交易

540
00:24:38,520 --> 00:24:40,200
在他们碰巧看到的网络中移动的方式

541
00:24:40,200 --> 00:24:42,390
为什么它首先转移到 Z 并

542
00:24:42,390 --> 00:24:44,040
合并到阻止他们

543
00:24:44,040 --> 00:24:46,380
的挖矿和其他你知道的

544
00:24:46,380 --> 00:24:49,650
相同继任者的对等方，但他们

545
00:24:49,650 --> 00:24:51,210
的区块版本是他们作为继任者的挖矿

546
00:24:51,210 --> 00:24:53,340
六个碰巧首先看到了这笔

547
00:24:53,340 --> 00:24:54,809
交易并将其包含

548
00:24:54,809 --> 00:24:57,150
在区块中，因此我们可以很容易地让不同的

549
00:24:57,150 --> 00:24:59,460
矿工尝试以一种尝试

550
00:24:59,460 --> 00:25:01,200
产生不同继任者的方式工作，

551
00:25:01,200 --> 00:25:03,900
如果他们中的两个碰巧找到了一个

552
00:25:03,900 --> 00:25:06,809
满足前导零的随机数 同时在

553
00:25:06,809 --> 00:25:10,260
哈希规则中，这意味着我们

554
00:25:10,260 --> 00:25:11,700
有两个不同的块来肿瘤

555
00:25:11,700 --> 00:25:13,980
同时产生的完全有效的块

556
00:25:13,980 --> 00:25:17,309
，它们都会将

557
00:25:17,309 --> 00:25:18,920
这些块发送到网络中，

558
00:25:18,920 --> 00:25:20,970
他们会看到你

559
00:25:20,970 --> 00:25:22,530
大致知道 所有其他

560
00:25:22,530 --> 00:25:25,080
对等方同时进行，因此很容易

561
00:25:25,080 --> 00:25:29,600
出现两个不同的两个完全不同的

562
00:25:29,600 --> 00:25:34,470
继任者来阻止六个，

563
00:25:34,470 --> 00:25:37,160
这被称为分叉

564
00:25:40,940 --> 00:25:43,440
，所以我们

565
00:25:43,440 --> 00:25:46,110
对分叉发生的事情非常感兴趣，因为这可能而且

566
00:25:46,110 --> 00:25:49,200
确实会出现 好吧，最直接的规则

567
00:25:49,200 --> 00:25:53,430
是，一旦任何对等方看到

568
00:25:53,430 --> 00:25:56,250
后继者，哦，您知道所有对等方都在

569
00:25:56,250 --> 00:25:59,010
尝试挖掘后继者以阻止六个

570
00:25:59,010 --> 00:26:02,220
，只要他们中的任何

571
00:26:02,220 --> 00:26:05,040
一个看到新的继任者集团 k 被

572
00:26:05,040 --> 00:26:06,570
一些成功开采的对等方淹没，

573
00:26:06,570 --> 00:26:08,280
 

574
00:26:08,280 --> 00:26:10,950
它将停止在 6 上工作并

575
00:26:10,950 --> 00:26:12,810
立即切换到尝试

576
00:26:12,810 --> 00:26:16,470
从 b737 开始工作，因此最初每个

577
00:26:16,470 --> 00:26:19,590
对等方一旦看到后继

578
00:26:19,590 --> 00:26:22,080
区块就会切换到挖掘

579
00:26:22,080 --> 00:26:24,120
该后继区块的后继区块 所以在这种

580
00:26:24,120 --> 00:26:26,340
情况下，一些同行将首先看到 b7

581
00:26:26,340 --> 00:26:28,290
Prime 并开始研究其

582
00:26:28,290 --> 00:26:30,720
后继者，然后其他同行将

583
00:26:30,720 --> 00:26:33,120
开始我的将看到 b7 Prime Prime 因为

584
00:26:33,120 --> 00:26:35,100
这取决于你知道

585
00:26:35,100 --> 00:26:37,110
如果这两个如果他们首先看到的是什么

586
00:26:37,110 --> 00:26:39,420
同时开采，

587
00:26:39,420 --> 00:26:40,710
他们将开始研究 b7 prime prime 的继任者，

588
00:26:40,710 --> 00:26:43,200
所以现在我们让

589
00:26:43,200 --> 00:26:45,840
一些同行致力于在

590
00:26:45,840 --> 00:26:48,690
区块链中扩展这个分叉，而其他

591
00:26:48,690 --> 00:26:51,360
同行则致力于在

592
00:26:51,360 --> 00:26:59,730
区块链中扩展这个分叉 另一个关键

593
00:26:59,730 --> 00:27:08,550
规则是，如果

594
00:27:08,550 --> 00:27:11,190
有人在尝试制作这些

595
00:27:11,190 --> 00:27:14,760
区块中的一个，并且它看到一个更长的不同分叉的新区块，

596
00:27:14,760 --> 00:27:18,930
那么

597
00:27:18,930 --> 00:27:21,540
任何致力于扩展这个分叉的人都会

598
00:27:21,540 --> 00:27:23,730
我切换到延长这个更长的

599
00:27:23,730 --> 00:27:27,150
叉子，所以这是软件中的一条规则

600
00:27:27,150 --> 00:27:30,390
，每个人都应该支持

601
00:27:30,390 --> 00:27:33,000
最长的链，所以至少在最初，如果

602
00:27:33,000 --> 00:27:35,130
我们有一些同行

603
00:27:35,130 --> 00:27:38,220
在一个叉子和另一个上挖掘一条路，并且

604
00:27:38,220 --> 00:27:40,140
长度相同，其他的 在

605
00:27:40,140 --> 00:27:42,780
另一个分叉上挖掘事实证明

606
00:27:42,780 --> 00:27:45,150
，产生有效节点所需的时间差异

607
00:27:45,150 --> 00:27:47,420
非常大，

608
00:27:47,420 --> 00:27:50,750
所以即使有相同数量的

609
00:27:50,750 --> 00:27:53,180
对等节点同时挖掘两个分叉，

610
00:27:53,180 --> 00:27:56,510
其中一个很可能会在

611
00:27:56,510 --> 00:27:58,340
另一个分叉之前找到一个明显的后继者

612
00:27:58,340 --> 00:28:00,980
所以这个继任者将被淹没到

613
00:28:00,980 --> 00:28:02,660
一堆似乎正在

614
00:28:02,660 --> 00:28:04,100
处理这个继任者的节点上，他们

615
00:28:04,100 --> 00:28:07,190
都会切换到更长的分叉，

616
00:28:07,190 --> 00:28:09,560
这意味着这里有一种

617
00:28:09,560 --> 00:28:16,070
不对称性，这会让我们有点

618
00:28:16,070 --> 00:28:19,580
你知道如果这个 分叉

619
00:28:19,580 --> 00:28:21,170
itza 在这个分叉之前被次要扩展，

620
00:28:21,170 --> 00:28:24,080
然后将矿工承包

621
00:28:24,080 --> 00:28:26,240
到这个分叉上，越来越

622
00:28:26,240 --> 00:28:29,110
多的矿工在这个分叉上挖矿，

623
00:28:29,110 --> 00:28:32,120
所以新的区块会被发现更多，

624
00:28:32,120 --> 00:28:34,310
在获胜的分叉上更快，所以

625
00:28:34,310 --> 00:28:36,110
有一种加强成功的趋势

626
00:28:36,110 --> 00:28:39,080
，即更长的分叉变得

627
00:28:39,080 --> 00:28:42,020
更长，很快一旦所有

628
00:28:42,020 --> 00:28:43,490
矿工都听说过这个更长的分叉，

629
00:28:43,490 --> 00:28:44,930
没有人会离开这个分叉上的采矿，

630
00:28:44,930 --> 00:28:46,820
每个人都会忽略它，

631
00:28:46,820 --> 00:28:49,580
每个人只会 把这个最长的

632
00:28:49,580 --> 00:28:55,970
分叉当作真正的链来对待，好吧，

633
00:28:55,970 --> 00:29:00,620
所以很可能其中

634
00:29:00,620 --> 00:29:02,270
一个有一个分叉，两个分叉中的一个

635
00:29:02,270 --> 00:29:06,800
会首先看到一个 x 块，

636
00:29:06,800 --> 00:29:08,390
每个人都将

637
00:29:08,390 --> 00:29:10,220
转向挖矿 它并且

638
00:29:10,220 --> 00:29:12,050
每个人都会很快同意

639
00:29:12,050 --> 00:29:15,530
另一个是最长的分叉当然

640
00:29:15,530 --> 00:29:19,750
是废弃分叉上的交易

641
00:29:19,750 --> 00:29:21,890
你通常知道大部分趋势

642
00:29:21,890 --> 00:29:24,920
通常这两个竞争博客让

643
00:29:24,920 --> 00:29:26,960
你知道非常相似

644
00:29:26,960 --> 00:29:28,490
的交易集，但很可能 在

645
00:29:28,490 --> 00:29:30,470
这里进行

646
00:29:30,470 --> 00:29:31,430
一些不存在的交易，当然，如果

647
00:29:31,430 --> 00:29:34,130
有人尝试将花费，或者但是

648
00:29:34,130 --> 00:29:35,270
如果

649
00:29:35,270 --> 00:29:37,280
废弃的分叉中有交易没有发生 en

650
00:29:37,280 --> 00:29:39,770
也是在获胜的分叉中，然后这些

651
00:29:39,770 --> 00:29:42,350
交易就消失了

652
00:29:42,350 --> 00:29:44,420
没有尝试在区块链

653
00:29:44,420 --> 00:29:47,200
系统本身中尝试将这些交易转移到

654
00:29:47,200 --> 00:29:50,810
现在，或者实际上现在没有

655
00:29:50,810 --> 00:29:52,460
尝试直接合并

656
00:29:52,460 --> 00:29:54,860
两个分叉 你知道，如果你

657
00:29:54,860 --> 00:29:56,360
没有看到你的交易出现，你

658
00:29:56,360 --> 00:29:58,710
可能会发出它，

659
00:29:58,710 --> 00:30:00,880
而且你知道因为区块链是

660
00:30:00,880 --> 00:30:02,830
公开的，很明显你的

661
00:30:02,830 --> 00:30:04,210
交易需要得到保证，

662
00:30:04,210 --> 00:30:05,800
因为它没有更多地合并

663
00:30:05,800 --> 00:30:10,870
到获胜的分叉中，但是它是 还有一种

664
00:30:10,870 --> 00:30:13,860
情况是，在短时间内，

665
00:30:13,860 --> 00:30:17,320
这两项交易都在

666
00:30:17,320 --> 00:30:21,040
区块链中，所以在

667
00:30:21,040 --> 00:30:23,050
短时间内，

668
00:30:23,050 --> 00:30:28,180
智能币在区块链中出现双花，你

669
00:30:28,180 --> 00:30:29,530
知道这有点

670
00:30:29,530 --> 00:30:30,910
危险 事实上，你知道

671
00:30:30,910 --> 00:30:32,020
这是一个极其危险的情况，

672
00:30:32,020 --> 00:30:34,090
因为关键是要避免使用

673
00:30:34,090 --> 00:30:35,710
区块链，直到这

674
00:30:35,710 --> 00:30:38,620
两条链中的一条变得更长，现在完全

675
00:30:38,620 --> 00:30:40,870
不清楚这两条中的哪一条 链去

676
00:30:40,870 --> 00:30:42,790
相信，然后这些同行

677
00:30:42,790 --> 00:30:44,290
可能只知道其中一个或

678
00:30:44,290 --> 00:30:47,740
另一个，所以这引发了一个

679
00:30:47,740 --> 00:30:51,250
不愉快的问题，即 Q 或 Z 你如何

680
00:30:51,250 --> 00:30:53,260
知道他们应该使用什么程序

681
00:30:53,260 --> 00:30:54,940
来确保他们实际上已经 显然已经支付了

682
00:30:54,940 --> 00:30:58,030
正确的款项，Z 还

683
00:30:58,030 --> 00:31:01,030
不足以在交易

684
00:31:01,030 --> 00:31:02,800
出现在区块链中时说好，然后我确定

685
00:31:02,800 --> 00:31:04,600
我没有画，因为那不是

686
00:31:04,600 --> 00:31:07,720
真的，也许这条酒吧链

687
00:31:07,720 --> 00:31:09,250
最终会变得更短，并且

688
00:31:09,250 --> 00:31:12,700
wipies Q 区块链将赢得类似 P

689
00:31:12,700 --> 00:31:14,800
你不能只看哦，你知道我的

690
00:31:14,800 --> 00:31:18,250
交易出现在这个区块和区块

691
00:31:18,250 --> 00:31:19,630
链中，因此它是一个有效的

692
00:31:19,630 --> 00:31:21,130
交易，因为它可能最终被

693
00:31:21,130 --> 00:31:22,840
放弃，因为它在一个较短的分叉上

694
00:31:22,840 --> 00:31:24,730
，所以这个 规则的原因

695
00:31:24,730 --> 00:31:28,720
在于，关心交易的人不会真正

696
00:31:28,720 --> 00:31:30,970
相信交易，

697
00:31:30,970 --> 00:31:33,100
直到在区块链中出现几个区块，

698
00:31:33,100 --> 00:31:37,210
并且随着更长的链

699
00:31:37,210 --> 00:31:39,640
变得越来越长或者你

700
00:31:39,640 --> 00:31:41,170
认为更长的链 g  ets 越来越

701
00:31:41,170 --> 00:31:43,750
长，可能

702
00:31:43,750 --> 00:31:46,180
有一些其他链

703
00:31:46,180 --> 00:31:48,250
在其中变得更长的机会比它可能

704
00:31:48,250 --> 00:31:50,770
消失的小，因为如果你在一条

705
00:31:50,770 --> 00:31:52,750
稍长的链上，这将

706
00:31:52,750 --> 00:31:55,510
吸引矿工在它上面挖矿，所以没有

707
00:31:55,510 --> 00:31:58,240
其他链可以增长 非常迅速，

708
00:31:58,240 --> 00:31:59,680
当然你知道

709
00:31:59,680 --> 00:32:03,040
一个特定分叉可以增长的链的速率与在该链上挖掘的对

710
00:32:03,040 --> 00:32:06,280
等点的数量成正比，

711
00:32:06,280 --> 00:32:09,660
 

712
00:32:10,060 --> 00:32:14,870
所以这

713
00:32:14,870 --> 00:32:18,740
就是防止它的机制，

714
00:32:18,740 --> 00:32:21,080
所以如果 Y同时发出两个冲突

715
00:32:21,080 --> 00:32:24,170
的交易，

716
00:32:24,170 --> 00:32:25,790
即使如果有一个分叉可能会有短暂的双重花费

717
00:32:25,790 --> 00:32:28,270
，但很快就会

718
00:32:28,270 --> 00:32:30,680
只有两个

719
00:32:30,680 --> 00:32:32,330
交易中的一个或另一个将在最长的

720
00:32:32,330 --> 00:32:34,760
链中，因此其中一个将获胜

721
00:32:34,760 --> 00:32:39,110
现在在那种官方链中，你

722
00:32:39,110 --> 00:32:41,840
确实知道如果第二个交易

723
00:32:41,840 --> 00:32:44,990
出现是在链中的 Y 转移疾病之后发送给对等点，

724
00:32:44,990 --> 00:32:47,990
那么

725
00:32:47,990 --> 00:32:52,580
所有对等点将忽略新

726
00:32:52,580 --> 00:32:55,070
到达的趋势

727
00:32:55,070 --> 00:32:57,410
对于已经在他们正在挖掘

728
00:32:57,410 --> 00:32:59,300
的分叉上的链上的交易中花费的硬币的操作，

729
00:32:59,300 --> 00:33:02,510
那么为什么你不

730
00:33:02,510 --> 00:33:04,730
知道

731
00:33:04,730 --> 00:33:07,670
在第一笔交易出现

732
00:33:07,670 --> 00:33:15,260
在区块链中的链中之后再次发送该交易好吧好吧 所以

733
00:33:15,260 --> 00:33:17,210
你知道还有一些其他的攻击你

734
00:33:17,210 --> 00:33:20,060
可能想知道一个问题是

735
00:33:20,060 --> 00:33:25,310
你是否知道让我们假设

736
00:33:25,310 --> 00:33:30,620
这就是链如果 Y

737
00:33:30,620 --> 00:33:33,320
与一些同行勾结这

738
00:33:33,320 --> 00:33:36,350
是官方的 b7 我们有 b8 等你

739
00:33:36,350 --> 00:33:36,620
知道

740
00:33:36,620 --> 00:33:38,720
假设为什么 不是与

741
00:33:38,720 --> 00:33:41,360
一些同行联盟可能会出现这个块

742
00:33:41,360 --> 00:33:43,490
7 现在你知道在

743
00:33:43,490 --> 00:33:47,960
链的中间并改变它以产生

744
00:33:47,960 --> 00:33:50,240
一个不同的块，其中没有这个

745
00:33:50,240 --> 00:33:52,070
交易，只是

746
00:33:52,070 --> 00:33:56,660
替代这个新的块 旧

747
00:33:56,660 --> 00:33:58,280
块 7 的块，并假装

748
00:33:58,280 --> 00:34:00,860
块 e 引用它，现在块这个

749
00:34:00,860 --> 00:34:03,410
新块 7 没有

750
00:34:03,410 --> 00:34:05,840
事务，因此对单个块进行非常

751
00:34:05,840 --> 00:34:07,700
简单的更改

752
00:34:07,700 --> 00:34:10,730
不起作用，原因是 on 是

753
00:34:10,730 --> 00:34:13,969
这里的这些箭头真的

754
00:34:13,969 --> 00:34:15,560
意味着有一个密码散列

755
00:34:15,560 --> 00:34:17,690
和博客 ate 它

756
00:34:17,690 --> 00:34:19,969
是它所指的块 7 的散列

757
00:34:19,969 --> 00:34:23,270
，所以

758
00:34:23,270 --> 00:34:25,250
对于已经存在的块 7，这个散列封锁你知道

759
00:34:25,250 --> 00:34:26,989
这个 hashman 块 8 是

760
00:34:26,989 --> 00:34:29,299
原始区块 7 的哈希 如果

761
00:34:29,299 --> 00:34:31,039
有人更改此内容，它将

762
00:34:31,039 --> 00:34:33,799
具有不同的哈希，因此

763
00:34:33,799 --> 00:34:37,010
如果您尝试将

764
00:34:37,010 --> 00:34:38,569
这个修改的区块抵押给

765
00:34:38,569 --> 00:34:39,589
知道区块 8 的人，他们会

766
00:34:39,589 --> 00:34:41,418
说我们没有密钥 你知道

767
00:34:41,418 --> 00:34:43,969
哈希不会散列到同一个块

768
00:34:43,969 --> 00:34:45,559
这个块七素数不会散列到

769
00:34:45,559 --> 00:34:47,239
嵌入在块 E 中的相同值

770
00:34:47,239 --> 00:34:50,449
所以你不能欺骗任何

771
00:34:50,449 --> 00:34:52,219
知道后续块的人接受

772
00:34:52,219 --> 00:34:55,069
修改后的中间块好吧

773
00:34:55,069 --> 00:34:55,668
问题

774
00:34:55,668 --> 00:35:00,109
我 看看为什么他的咖啡旁边有一个 Q 商店它

775
00:35:00,109 --> 00:35:03,640
出现在一个街区

776
00:35:03,860 --> 00:35:08,030
哦我明白了所以这是让我

777
00:35:08,030 --> 00:35:10,610
稍微备份一下所以我认为

778
00:35:10,610 --> 00:35:12,440
我们的情况是你知道

779
00:35:12,440 --> 00:35:16,000
有一个区块链然后 兄弟 ief 分叉

780
00:35:16,000 --> 00:35:20,360
，在那个简短的分叉中，为什么

781
00:35:20,360 --> 00:35:28,790
要向两个不同的两个不同

782
00:35:28,790 --> 00:35:33,080
方支付相同的硬币，假设这是第 7 块

783
00:35:33,080 --> 00:35:37,700
素数，第 7 块获胜

784
00:35:37,700 --> 00:35:40,640
并且在主链上，第 7 块

785
00:35:40,640 --> 00:35:43,880
素数是它只是被遗忘和

786
00:35:43,880 --> 00:35:45,530
忽略了 问题是天哪，你

787
00:35:45,530 --> 00:35:48,410
至少知道 Q 看到这个

788
00:35:48,410 --> 00:35:49,820
交易出现在连锁店里，然后

789
00:35:49,820 --> 00:35:51,770
把咖啡给了为什么，然后

790
00:35:51,770 --> 00:35:53,660
为什么我离开了商店，但是你知道

791
00:35:53,660 --> 00:35:55,550
这部分连锁店被丢弃了，

792
00:35:55,550 --> 00:35:57,500
Q 被留下了 在没有钱的情况下，他们赠送

793
00:35:57,500 --> 00:35:59,390
了一些咖啡，但他们没有得到

794
00:35:59,390 --> 00:36:01,970
 

795
00:36:01,970 --> 00:36:05,650
 

796
00:36:05,650 --> 00:36:07,880
 

797
00:36:07,880 --> 00:36:10,040
 

798
00:36:10,040 --> 00:36:12,110
报酬 然后他们会冒

799
00:36:12,110 --> 00:36:13,910
这种情况的风险，他们对此

800
00:36:13,910 --> 00:36:15,890
无能为力，他们无法

801
00:36:15,890 --> 00:36:17,420
拿回钱我的意思是除非你

802
00:36:17,420 --> 00:36:20,270
跑到街上追上那个人，

803
00:36:20,270 --> 00:36:23,330
把那杯咖啡拿走，这

804
00:36:23,330 --> 00:36:25,330
就是为什么 用于高价值

805
00:36:25,330 --> 00:36:27,740
交易 离子您的星巴克手推车

806
00:36:27,740 --> 00:36:29,810
并不在乎，那杯

807
00:36:29,810 --> 00:36:32,030
咖啡真的只花费您知道的 50

808
00:36:32,030 --> 00:36:33,800
美分，就像如果他们

809
00:36:33,800 --> 00:36:35,780
偶尔知道这些叉子不会经常发生，

810
00:36:35,780 --> 00:36:37,370
他们偶尔会失去一杯

811
00:36:37,370 --> 00:36:40,910
咖啡，他们可能会 愿意

812
00:36:40,910 --> 00:36:44,090
处理这个问题，但如果你为什么

813
00:36:44,090 --> 00:36:47,330
要从 Q 买车知道 20,000 美元的

814
00:36:47,330 --> 00:36:49,490
比特币，谢谢你可能宁愿

815
00:36:49,490 --> 00:36:53,810
不让 Y 带着这种水平的保证离开，这

816
00:36:53,810 --> 00:36:56,480
 

817
00:36:56,480 --> 00:36:59,330
就是为什么如果你在乎你会等待的原因 直到

818
00:36:59,330 --> 00:37:02,630
 

819
00:37:02,630 --> 00:37:05,360
在你的交易所

820
00:37:05,360 --> 00:37:08,930
在的区块之后出现多个区块，所以如果这是一笔

821
00:37:08,930 --> 00:37:10,430
高价值交易，Z实际上不会

822
00:37:10,430 --> 00:37:12,590
交出货物，直到之后至少有

823
00:37:12,590 --> 00:37:15,530
一些数字 5 6 区块出现

824
00:37:15,530 --> 00:37:17,090
块

825
00:37:17,090 --> 00:37:22,160
动作射击打开并且

826
00:37:22,160 --> 00:37:26,870
叉子不太可能

827
00:37:26,870 --> 00:37:28,760
像在一个小时内那样延长五六次

828
00:37:28,760 --> 00:37:30,470
现在肯块

829
00:37:30,470 --> 00:37:32,510
每十分钟出现一次，然后结果

830
00:37:32,510 --> 00:37:35,030
是最短的而不是最长的 链，

831
00:37:35,030 --> 00:37:36,770
因为这意味着有一些

832
00:37:36,770 --> 00:37:43,370
其他的叉子扩展得更快，

833
00:37:43,370 --> 00:37:44,390
而其他一些之前可以

834
00:37:44,390 --> 00:37:46,130
扩展得更快的唯一方法是，如果

835
00:37:46,130 --> 00:37:47,840
大多数 cpu 功率都在它上面工作，

836
00:37:47,840 --> 00:37:49,610
我们假设 cpu 功率的大多数

837
00:37:49,610 --> 00:37:52,640
是伊斯兰教 恶意的，

838
00:37:52,640 --> 00:37:55,820
因此可以切换到当前

839
00:37:55,820 --> 00:38:01,700
最长的链，所以

840
00:38:01,700 --> 00:38:03,200
如果你进行大额

841
00:38:03,200 --> 00:38:05,390
交易，你必须要小心，

842
00:38:05,390 --> 00:38:07,220
等到链变长并且在

843
00:38:07,220 --> 00:38:15,890
你的交易出现之后，还可以，

844
00:38:15,890 --> 00:38:17,810
所以我 解释了为什么你不能简单地

845
00:38:17,810 --> 00:38:19,820
修改链中间的一个块

846
00:38:19,820 --> 00:38:22,280
有一个相关的问题

847
00:38:22,280 --> 00:38:24,920
是假设有一个现有的

848
00:38:24,920 --> 00:38:29,000
区块链你

849
00:38:29,000 --> 00:38:35,560
知道它很长而且你的交易 Y 箭头

850
00:38:35,560 --> 00:38:37,850
交易为什么他出现

851
00:38:37,850 --> 00:38:41,000
在区块链中而你 想摆脱

852
00:38:41,000 --> 00:38:42,740
你想隐藏该交易现在

853
00:38:42,740 --> 00:38:45,380
以某种方式使它不存在，

854
00:38:45,380 --> 00:38:47,870
天哪，你为什么不生产一种新的

855
00:38:47,870 --> 00:38:52,040
替代链，你知道它

856
00:38:52,040 --> 00:38:55,430
与 t 基本相同 他主要是真正的链，但

857
00:38:55,430 --> 00:39:00,350
它更长，恰好省略了 Y

858
00:39:00,350 --> 00:39:03,320
被转移到 Z 而是包括

859
00:39:03,320 --> 00:39:05,360
Y 被转移到 Q 如果你

860
00:39:05,360 --> 00:39:07,070
为此正确地进行挖掘并且哈希计算

861
00:39:07,070 --> 00:39:09,140
出你的链更长，它

862
00:39:09,140 --> 00:39:10,700
只会被接受

863
00:39:10,700 --> 00:39:13,010
比特币的规则，每个人都

864
00:39:13,010 --> 00:39:15,920
应该切换到最长的链，所以为什么

865
00:39:15,920 --> 00:39:18,700
你不能这样做

866
00:39:20,350 --> 00:39:22,390
，你知道这也会让

867
00:39:22,390 --> 00:39:24,060
你通过

868
00:39:24,060 --> 00:39:26,860
以前花费的数量和

869
00:39:26,860 --> 00:39:28,750
我之前关于哦你的评论中基本上未花费来双花 '

870
00:39:28,750 --> 00:39:30,700
应该等你知道 zis 是

871
00:39:30,700 --> 00:39:32,860
等到区块链被扩展

872
00:39:32,860 --> 00:39:36,730
你知道这现在是打败 Z

873
00:39:36,730 --> 00:39:38,500
等待区块链扩展它的一种方法

874
00:39:38,500 --> 00:39:41,560
所以我们真的是因为

875
00:39:41,560 --> 00:39:46,780
如果你能把这项工作做得好所以我们真的很麻烦所以和

876
00:39:46,780 --> 00:39:48,340
有点好，答案是肯定的，这

877
00:39:48,340 --> 00:39:52,480
可以工作，这是如何做到的，

878
00:39:52,480 --> 00:39:54,850
你知道主区块链正在

879
00:39:54,850 --> 00:39:56,620
被非恶意

880
00:39:56,620 --> 00:39:59,020
参与者以某种速度扩展，他们

881
00:39:59,020 --> 00:40:00,550
有足够的 CPU 能力，你知道

882
00:40:00,550 --> 00:40:02,500
亲 每 10 分钟产生一个新块，如果

883
00:40:02,500 --> 00:40:04,570
你是攻击者并且你的

884
00:40:04,570 --> 00:40:07,870
CPU 能力比整个非恶意

885
00:40:07,870 --> 00:40:10,390
集合出现的更多，那么你将能够

886
00:40:10,390 --> 00:40:13,120
比真正的链更快地生成步行，

887
00:40:13,120 --> 00:40:15,790
所以你的块让你知道

888
00:40:15,790 --> 00:40:17,530
链开始时可能会更短，我可能会

889
00:40:17,530 --> 00:40:19,060
花一些时间来生成每个块，

890
00:40:19,060 --> 00:40:20,890
但你知道也许你可以

891
00:40:20,890 --> 00:40:22,600
每十分钟生成两个块，而

892
00:40:22,600 --> 00:40:25,120
主链

893
00:40:25,120 --> 00:40:26,710
每十分钟只能生成一个块，这

894
00:40:26,710 --> 00:40:28,540
意味着有一段时间你 '将

895
00:40:28,540 --> 00:40:30,460
赶上并超过

896
00:40:30,460 --> 00:40:34,300
主链的长度，主分叉，根据

897
00:40:34,300 --> 00:40:36,550
比特币的规则，每个

898
00:40:36,550 --> 00:40:39,700
非恶意的完全正确的比特币

899
00:40:39,700 --> 00:40:41,170
同行，他们都会切换到你的更长的

900
00:40:41,170 --> 00:40:42,670
链，这意味着他们都会

901
00:40:42,670 --> 00:40:45,130
有效地忘记这一点 交易，

902
00:40:45,130 --> 00:40:47,650
除了这个其他交易，

903
00:40:47,650 --> 00:40:49,510
第二次花费同一个硬币，所以如果

904
00:40:49,510 --> 00:40:51,460
你是一个攻击者，你的 CPU

905
00:40:51,460 --> 00:40:53,500
能力比整个网络的其余部分都多，

906
00:40:53,500 --> 00:40:53,830
 

907
00:40:53,830 --> 00:40:56,590
你可以生成这个链，这意味着

908
00:40:56,590 --> 00:41:02,980
你可以双花 你知道那

909
00:41:02,980 --> 00:41:05,830
当然是你知道要考虑的事情，

910
00:41:05,830 --> 00:41:11,910
但是你可能希望

911
00:41:11,910 --> 00:41:14,350
更多地相信

912
00:41:14,350 --> 00:41:16,090
它不会出现的原因是，在一个

913
00:41:16,090 --> 00:41:18,880
有很多参与者的大系统中，

914
00:41:18,880 --> 00:41:21,460
可能很难组装更多的 CPU

915
00:41:21,460 --> 00:41:24,040
能力 比整个系统的其余部分，

916
00:41:24,040 --> 00:41:28,630
所以一旦 buns 比特币变大，你就会

917
00:41:28,630 --> 00:41:31,610
知道人们有点

918
00:41:31,610 --> 00:41:33,830
相信主要类型的非恶意系统

919
00:41:33,830 --> 00:41:35,150
有足够的 cpu 能力，

920
00:41:35,150 --> 00:41:38,180
攻击者组装

921
00:41:38,180 --> 00:41:40,610
更多的 CPU 能力会比其他系统更昂贵 该

922
00:41:40,610 --> 00:41:43,190
系统当然适用于

923
00:41:43,190 --> 00:41:45,700
尚未

924
00:41:45,700 --> 00:41:48,520
进行大规模采矿作业的新加密货币

925
00:41:48,520 --> 00:41:51,140
他们实际上很容易被

926
00:41:51,140 --> 00:41:52,820
击落 对于像

927
00:41:52,820 --> 00:41:54,590
比特币这样的新加密货币来说很容易 对于你知道的攻击者来说很容易

928
00:41:54,590 --> 00:41:56,540
因为任何原因让它

929
00:41:56,540 --> 00:41:59,930
停业 通过获得更多的 CPU 能力，

930
00:41:59,930 --> 00:42:01,550
但对于像比特币这样的大型系统

931
00:42:01,550 --> 00:42:05,140
来说，现在有点困难，

932
00:42:05,140 --> 00:42:07,610
因为研究过的人试图

933
00:42:07,610 --> 00:42:13,160
弄清楚谁控制着挖矿 CPU 能力

934
00:42:13,160 --> 00:42:17,120
和比特币 su 预计最大的

935
00:42:17,120 --> 00:42:22,400
参与者在总数中的一小部分

936
00:42:22,400 --> 00:42:25,220
与 50% 相差不远，

937
00:42:25,220 --> 00:42:27,170
当然，如果你知道两个或

938
00:42:27,170 --> 00:42:30,830
三个最大的采矿作业联合

939
00:42:30,830 --> 00:42:33,500
力量，他们将拥有

940
00:42:33,500 --> 00:42:36,140
比特币的大部分采矿能力，并且可以

941
00:42:36,140 --> 00:42:38,560
产生替代 像这样的分叉，所以

942
00:42:38,560 --> 00:42:45,400
这有点

943
00:42:45,400 --> 00:42:47,660
 

944
00:42:47,660 --> 00:42:49,730
 

945
00:42:49,730 --> 00:42:51,230
 

946
00:42:51,230 --> 00:42:53,630
 

947
00:42:53,630 --> 00:42:55,660
 

948
00:42:55,660 --> 00:42:58,490
令人不安 对于一个

949
00:42:58,490 --> 00:43:00,800
从很久以前开始的连锁店，人们会

950
00:43:00,800 --> 00:43:04,250
不会注意到这一点，你会知道这会

951
00:43:04,250 --> 00:43:06,350
破坏对比特币的信心，并可能

952
00:43:06,350 --> 00:43:08,330
破坏恶意

953
00:43:08,330 --> 00:43:10,310
方希望实现的任何目标

954
00:43:10,310 --> 00:43:11,930
，因为你知道它非常昂贵，

955
00:43:11,930 --> 00:43:13,670
实际上你知道比特币的大玩家

956
00:43:13,670 --> 00:43:15,590
用比特币挖矿我花了

957
00:43:15,590 --> 00:43:19,340
一大笔钱购买他们拥有的挖矿硬件

958
00:43:19,340 --> 00:43:21,350
，所以他们可能

959
00:43:21,350 --> 00:43:22,970
不想破坏人们 le 对比特币的信任，

960
00:43:22,970 --> 00:43:25,010
因为这会破坏

961
00:43:25,010 --> 00:43:29,040
他们庞大的收藏合作伙伴的价值，

962
00:43:29,040 --> 00:43:31,690
好吧，任何关于

963
00:43:31,690 --> 00:43:40,470
机器的问题都可以，所以我

964
00:43:40,470 --> 00:43:45,930
提出问题，我可以回答一个

965
00:43:45,930 --> 00:43:48,570
问题，区块之间的十分钟

966
00:43:48,570 --> 00:43:50,400
实际上是一个严重的烦恼，

967
00:43:50,400 --> 00:43:52,760
这意味着 如果我想买东西

968
00:43:52,760 --> 00:43:55,560
，即使在第一个区块中，交易也需要 10 分钟才能

969
00:43:55,560 --> 00:43:57,000
出现在区块链

970
00:43:57,000 --> 00:43:57,780
中

971
00:43:57,780 --> 00:44:02,520
，你

972
00:44:02,520 --> 00:44:04,020
知道我必须等待 10

973
00:44:04,020 --> 00:44:06,180
分钟才能拿到我的咖啡或

974
00:44:06,180 --> 00:44:07,530
商店 所有者必须在区块链交易之前给我一杯

975
00:44:07,530 --> 00:44:10,020
咖啡，

976
00:44:10,020 --> 00:44:11,460
 

977
00:44:11,460 --> 00:44:14,670
因此必须信任我，所以为什么我们

978
00:44:14,670 --> 00:44:21,450
不能缩短 10 分钟，你

979
00:44:21,450 --> 00:44:23,010
知道实际上可能可以缩短 10 分钟

980
00:44:23,010 --> 00:44:24,960
 

981
00:44:24,960 --> 00:44:28,470
它不短的实际原因是，

982
00:44:28,470 --> 00:44:30,840
 

983
00:44:30,840 --> 00:44:33,150
在矿工找到下一个区块后，新盒子实际上需要一段时间才能淹没系统，

984
00:44:33,150 --> 00:44:35,790
它必须

985
00:44:35,790 --> 00:44:38,730
发送数千个对等点 Bitcoi  n

986
00:44:38,730 --> 00:44:41,640
网络连接速度可能很慢，并且

987
00:44:41,640 --> 00:44:43,380
可能需要很长时间

988
00:44:43,380 --> 00:44:45,330
才能让所有其他对等方知道该块，这

989
00:44:45,330 --> 00:44:47,810
意味着在一段

990
00:44:47,810 --> 00:44:50,250
时间内其他对等方正在挖掘

991
00:44:50,250 --> 00:44:54,720
块或浪费时间挖掘

992
00:44:54,720 --> 00:44:58,710
属于我的块 已经被

993
00:44:58,710 --> 00:45:02,869
一个尚未搁浅的区块所取代，

994
00:45:02,869 --> 00:45:07,369
基本上你花费在挖矿上的时间

995
00:45:07,369 --> 00:45:09,810
浪费在尝试开采

996
00:45:09,810 --> 00:45:11,990
已被取代的区块上

997
00:45:11,990 --> 00:45:15,109
的时间与开采每个区块

998
00:45:15,109 --> 00:45:17,700
所需的时间与洪水所需的时间有关

999
00:45:17,700 --> 00:45:19,950
块，所以如果你让

1000
00:45:19,950 --> 00:45:23,190
块间的间隔越来越短，那么

1001
00:45:23,190 --> 00:45:25,470
它开始变得足够小，以至于

1002
00:45:25,470 --> 00:45:26,790
它接近

1003
00:45:26,790 --> 00:45:29,310
洪水新块所需的时间，这

1004
00:45:29,310 --> 00:45:32,190
将导致大多数码头浪费

1005
00:45:32,190 --> 00:45:34,560
他们大部分的采矿工作，因为

1006
00:45:34,560 --> 00:45:36,119
矿工实际上是通过挖矿来赚钱赚取比特币

1007
00:45:36,119 --> 00:45:37,260
，因为

1008
00:45:37,260 --> 00:45:39,990
每个区块的成功矿工都会获得一点奖励

1009
00:45:39,990 --> 00:45:42,900
矿工对浪费资源挖矿非常不感兴趣

1010
00:45:42,900 --> 00:45:47,099
 

1011
00:45:47,099 --> 00:45:51,150
已被取代的锁，因此

1012
00:45:51,150 --> 00:45:53,110
他们

1013
00:45:53,110 --> 00:45:55,210
对这 10 分钟非常不感兴趣 比现在短得多，

1014
00:45:55,210 --> 00:45:57,570
而且你知道这是一个

1015
00:45:57,570 --> 00:46:02,800
重要的限制，所以有一个

1016
00:46:02,800 --> 00:46:04,660
问题是什么阻止了为什么

1017
00:46:04,660 --> 00:46:07,450
在更晚的区块当码头时双花很多

1018
00:46:07,450 --> 00:46:09,070
可能已经忘记了

1019
00:46:09,070 --> 00:46:11,350
第一笔交易，所以

1020
00:46:11,350 --> 00:46:14,290
你知道问题是哦，你在很早的

1021
00:46:14,290 --> 00:46:17,410
区块中就知道为什么根据 Z 转移，

1022
00:46:17,410 --> 00:46:20,620
然后有数千个区块 Y

1023
00:46:20,620 --> 00:46:24,280
试图将同一个硬币转移到 Q 你

1024
00:46:24,280 --> 00:46:26,790
知道一年后或 事情的结果

1025
00:46:26,790 --> 00:46:29,910
，答案是

1026
00:46:29,910 --> 00:46:32,820
所有的同行都永远记住这一点，

1027
00:46:32,820 --> 00:46:36,720
他们绝对永远记住每笔未使用的

1028
00:46:36,720 --> 00:46:41,640
交易，这意味着

1029
00:46:45,710 --> 00:46:47,920
实际上这不可能是

1030
00:46:47,920 --> 00:46:51,370
我名义上认为告诉你真相的第一个

1031
00:46:51,370 --> 00:46:52,690
我不明白的一切 这个问题的

1032
00:46:52,690 --> 00:46:54,430
来龙去脉，但

1033
00:46:54,430 --> 00:46:55,420
解决这个问题最直接的方法

1034
00:46:55,420 --> 00:46:57,250
是让所有对等方永远记住

1035
00:46:57,250 --> 00:46:59,530
每笔交易以及

1036
00:46:59,530 --> 00:47:02,500
他们检查到的每笔传入交易

1037
00:47:02,500 --> 00:47:05,380
确保硬币还没有被花掉，

1038
00:47:05,380 --> 00:47:08,050
他们只是在课程中创建了一个数据库

1039
00:47:08,050 --> 00:47:11,050
或索引或其他东西，但允许他们

1040
00:47:11,050 --> 00:47:13,810
基本上检查每条记录，看看

1041
00:47:13,810 --> 00:47:17,080
这个硬币是否已经被花掉了，我

1042
00:47:17,080 --> 00:47:19,240
认为你可以，虽然我不完全

1043
00:47:19,240 --> 00:47:21,670
了解这一点，我认为同行可以

1044
00:47:21,670 --> 00:47:25,000
 

1045
00:47:25,000 --> 00:47:27,160
通过仅记住

1046
00:47:27,160 --> 00:47:30,760
有关未使用交易的信息来丢弃大量此类信息，

1047
00:47:30,760 --> 00:47:32,140
因此他们保留未使用交易的数据库，

1048
00:47:32,140 --> 00:47:35,100
但它不包括已使用的

1049
00:47:35,100 --> 00:47:38,080
硬币，并且如果新交易

1050
00:47:38,080 --> 00:47:40,150
硬币不在 未使用

1051
00:47:40,150 --> 00:47:43,990
事务的数据库，那么它就被忽略了，但是

1052
00:47:43,990 --> 00:47:45,490
你知道这个数据库必须是

1053
00:47:45,490 --> 00:47:47,640
每一对都必须永远保留这个数据库

1054
00:47:47,640 --> 00:47:52,240
所以你当然知道这

1055
00:47:52,240 --> 00:47:54,400
是一个非常昂贵的系统，

1056
00:47:54,400 --> 00:47:56,740
因为我们正在谈论的是你

1057
00:47:56,740 --> 00:47:58,090
知道基本上永远维护每笔交易的记录，

1058
00:47:58,090 --> 00:48:01,090
 

1059
00:48:01,090 --> 00:48:01,960
如果您考虑一下地球

1060
00:48:01,960 --> 00:48:04,090
上每秒或每年有多少笔交易，

1061
00:48:04,090 --> 00:48:05,950
 

1062
00:48:05,950 --> 00:48:09,580
这是一个巨大的数字，所以人们

1063
00:48:09,580 --> 00:48:11,200
真的 e 认真使用比特币，他们将比特币

1064
00:48:11,200 --> 00:48:12,820
用于一切，就像他们

1065
00:48:12,820 --> 00:48:16,120
使用现金一样

1066
00:48:16,120 --> 00:48:18,220
 

1067
00:48:18,220 --> 00:48:20,380
 

1068
00:48:20,380 --> 00:48:22,750
 

1069
00:48:22,750 --> 00:48:27,220
 

1070
00:48:27,220 --> 00:48:30,490
 

1071
00:48:30,490 --> 00:48:32,410
不要像今天那样在比特币上运行整个世界的金融系统，而且

1072
00:48:32,410 --> 00:48:34,980
 

1073
00:48:34,980 --> 00:48:38,440
有一堆限制，你知道一个

1074
00:48:38,440 --> 00:48:40,630
限制是完整的比特币数据库

1075
00:48:40,630 --> 00:48:41,860
已经消耗了几百

1076
00:48:41,860 --> 00:48:43,690
GB 是的，这实际上并没有那么

1077
00:48:43,690 --> 00:48:46,480
糟糕，因为你 可以将其安装在磁盘上，但

1078
00:48:46,480 --> 00:48:48,040
如果它大一千倍

1079
00:48:48,040 --> 00:48:49,570
，甚至存储它都将成为一个严重的问题，

1080
00:48:49,570 --> 00:48:51,580
更不用说

1081
00:48:51,580 --> 00:48:56,059
在其中搜索内容了，这是最直接的问题

1082
00:48:56,059 --> 00:48:57,769
，我们发现处理这些

1083
00:48:57,769 --> 00:48:59,509
事务并不是非常昂贵

1084
00:48:59,509 --> 00:49:01,789
因为对于同行来说，它主要是关于

1085
00:49:01,789 --> 00:49:03,319
散列，这些加密散列

1086
00:49:03,319 --> 00:49:07,699
非常快，但是

1087
00:49:07,699 --> 00:49:11,509
你知道的最丑陋的限制是

1088
00:49:11,509 --> 00:49:14,269
这些块 k 因为

1089
00:49:14,269 --> 00:49:16,009
这些块的大小是有限制的，这些块的

1090
00:49:16,009 --> 00:49:18,229
大小只能是几兆字节

1091
00:49:18,229 --> 00:49:22,430
，新块每十分钟才出现一次

1092
00:49:22,430 --> 00:49:25,640
，这意味着你每分钟只

1093
00:49:25,640 --> 00:49:27,619
知道不到一兆字节的新

1094
00:49:27,619 --> 00:49:30,140
交易

1095
00:49:30,140 --> 00:49:35,150
你知道的那种 Val 是

1096
00:49:35,150 --> 00:49:37,640
各种缩写方式，但

1097
00:49:37,640 --> 00:49:39,170
你知道每笔交易至少有

1098
00:49:39,170 --> 00:49:42,319
几十个或一百个字节，这

1099
00:49:42,319 --> 00:49:45,079
意味着系统真的只能

1100
00:49:45,079 --> 00:49:46,939
因为这个块大小限制和

1101
00:49:46,939 --> 00:49:49,539
系统可以的十分钟限制 只能处理

1102
00:49:49,539 --> 00:49:52,400
好几千或

1103
00:49:52,400 --> 00:49:57,109
几万笔

1104
00:49:57,109 --> 00:49:58,579
 

1105
00:49:58,579 --> 00:50:03,670
 

1106
00:50:03,670 --> 00:50:05,869
 

1107
00:50:05,869 --> 00:50:07,699
 

1108
00:50:07,699 --> 00:50:09,439
交易 交易

1109
00:50:09,439 --> 00:50:12,920
是，所以你知道人们会改变它，它会

1110
00:50:12,920 --> 00:50:18,229
进化，但

1111
00:50:18,229 --> 00:50:20,059
它对所有事情都不够快，当然没有人真正

1112
00:50:20,059 --> 00:50:22,880
将它用于商业它主要

1113
00:50:22,880 --> 00:50:24,380
用于投机 任何人都可以

1114
00:50:24,380 --> 00:50:27,170
说这还不是问题，

1115
00:50:27,170 --> 00:50:29,059
但从设计的角度来看，需要

1116
00:50:29,059 --> 00:50:35,299
修复一些问题，所以我

1117
00:50:35,299 --> 00:50:38,390
之前提到过比特币软件会

1118
00:50:38,390 --> 00:50:40,609
调整寻找随机数的难度，即

1119
00:50:40,609 --> 00:50:42,529
 

1120
00:50:42,529 --> 00:50:45,849
块哈希调整中所需的前导零的数量 动态

1121
00:50:45,849 --> 00:50:49,339
地导致有 10 分钟的时间来

1122
00:50:49,339 --> 00:50:54,469
阻止一件事，

1123
00:50:54,469 --> 00:50:56,239
但必须是所有参与者都

1124
00:50:56,239 --> 00:50:58,999
必须就所需的前导零数量达成一致，

1125
00:50:58,999 --> 00:51:00,739
他们实际上都必须

1126
00:51:00,739 --> 00:51:02,689
就找到结的难度达成一致

1127
00:51:02,689 --> 00:51:06,319
，因此 如果一个对等点查看

1128
00:51:06,319 --> 00:51:07,939
区块的生成

1129
00:51:07,939 --> 00:51:09,550
 

1130
00:51:09,550 --> 00:51:12,830
速度，而且它太慢了，它

1131
00:51:12,830 --> 00:51:15,710
应该需要更少的前导零，但

1132
00:51:15,710 --> 00:51:17,480
其他对等点没有做出相同的

1133
00:51:17,480 --> 00:51:20,660
决定，那么第一个码头将

1134
00:51:20,660 --> 00:51:22,640
生成块

1135
00:51:22,640 --> 00:51:24,140
被其他对等点拒绝，因为所有对等点都

1136
00:51:24,140 --> 00:51:26,660
要求他们认为

1137
00:51:26,660 --> 00:51:31,640
散列中前导零的正确数量，

1138
00:51:31,640 --> 00:51:35,390
因此必须就

1139
00:51:35,390 --> 00:51:36,980
找到一个 并不是

1140
00:51:36,980 --> 00:51:39,260
说同行必须完全同意

1141
00:51:39,260 --> 00:51:40,970
以及当前的硬度是多少，

1142
00:51:40,970 --> 00:51:42,230
否则他们将拒绝彼此的

1143
00:51:42,230 --> 00:51:44,119
块，所以他们如何达成该

1144
00:51:44,119 --> 00:51:48,880
协议实际上是

1145
00:51:48,880 --> 00:51:52,160
完全简单的，毕竟他们都在

1146
00:51:52,160 --> 00:51:54,589
看同一个区块链

1147
00:51:54,589 --> 00:51:56,720
关键是你

1148
00:51:56,720 --> 00:51:58,580
知道，除了临时分叉之外，

1149
00:51:58,580 --> 00:51:59,990
只有一个区块链，每个人都没有区块链

1150
00:51:59,990 --> 00:52:02,750
中完全相同的位的

1151
00:52:02,750 --> 00:52:05,720
副本，因此比特币只是

1152
00:52:05,720 --> 00:52:09,670
定义了一个确定性函数，

1153
00:52:09,670 --> 00:52:12,260
它将当前区块链作为其

1154
00:52:12,260 --> 00:52:13,970
参数并使用它来

1155
00:52:13,970 --> 00:52:16,750
确定性地产生当前

1156
00:52:16,750 --> 00:52:19,760
寻找随机数的难度，

1157
00:52:19,760 --> 00:52:21,140
它的方式基本上是查看

1158
00:52:21,140 --> 00:52:25,099
块中的时间戳来决定

1159
00:52:25,099 --> 00:52:27,349
最近的块产生的速度，

1160
00:52:27,349 --> 00:52:28,790
但是由于每个人都

1161
00:52:28,790 --> 00:52:30,109
在相同的时间戳中查看相同的块

1162
00:52:30,109 --> 00:52:32,650
并且是 运行相同的函数

1163
00:52:32,650 --> 00:52:35,660
来调整硬度他们都得出了

1164
00:52:35,660 --> 00:52:38,030
完全相同的结论，

1165
00:52:38,030 --> 00:52:40,430
即每个硬度应该是多少 h

1166
00:52:40,430 --> 00:52:42,890
区块链中的连续区块，因此

1167
00:52:42,890 --> 00:52:45,020
有一种有趣的

1168
00:52:45,020 --> 00:52:46,910
协议正在那里执行，因为他们

1169
00:52:46,910 --> 00:52:51,200
都看到相同的法律，好吧

1170
00:52:51,200 --> 00:52:52,359
 

1171
00:52:52,359 --> 00:52:54,950
另一个有趣的问题是

1172
00:52:54,950 --> 00:52:56,900
，一些人

1173
00:52:56,900 --> 00:52:58,099
对新

1174
00:52:58,099 --> 00:53:00,650
加密货币感兴趣的动机之一是他们可能

1175
00:53:00,650 --> 00:53:02,450
比信用卡更匿名，

1176
00:53:02,450 --> 00:53:03,650
实际上信用卡是

1177
00:53:03,650 --> 00:53:06,260
非常匿名的，因为信用卡

1178
00:53:06,260 --> 00:53:08,030
公司确切地知道你在做什么

1179
00:53:08,030 --> 00:53:11,660
我会记录下来，而比特币

1180
00:53:11,660 --> 00:53:13,310
至少从表面上看你知道

1181
00:53:13,310 --> 00:53:14,780
比特币没有 一个

1182
00:53:14,780 --> 00:53:17,150
比特币交易，上面写着我的

1183
00:53:17,150 --> 00:53:18,099
名字，

1184
00:53:18,099 --> 00:53:20,450
现在你可能会认为每笔比特币

1185
00:53:20,450 --> 00:53:22,850
交易都有我的公钥

1186
00:53:22,850 --> 00:53:24,410
 

1187
00:53:24,410 --> 00:53:26,390
 

1188
00:53:26,390 --> 00:53:29,840
 

1189
00:53:29,840 --> 00:53:31,310
公钥相对

1190
00:53:31,310 --> 00:53:34,190
容易，因为每当我向某人付款时，

1191
00:53:34,190 --> 00:53:36,350
他们就会知道我的公钥，然后

1192
00:53:36,350 --> 00:53:38,270
人们可以通过查找我的公钥来跟踪我的活动

1193
00:53:38,270 --> 00:53:39,830
r 我

1194
00:53:39,830 --> 00:53:43,130
在比特币锁上的签名，它是一个

1195
00:53:43,130 --> 00:53:45,910
公共日志，所以现在任何

1196
00:53:45,910 --> 00:53:49,310
人都可以查看每个关心的人，我认为

1197
00:53:49,310 --> 00:53:51,110
大多数比特币钱包提供

1198
00:53:51,110 --> 00:53:53,840
的每笔交易实际上都会为每笔交易生成新的公钥

1199
00:53:53,840 --> 00:53:56,390
如果有人

1200
00:53:56,390 --> 00:53:58,490
想付钱给我我的钱包 将

1201
00:53:58,490 --> 00:54:00,500
生成一个以前从未使用过的新公钥

1202
00:54:00,500 --> 00:54:01,370
私钥对

1203
00:54:01,370 --> 00:54:03,470
记住私钥，然后将公钥提供

1204
00:54:03,470 --> 00:54:05,360
给想要

1205
00:54:05,360 --> 00:54:07,610
给我汇款的人，这会使

1206
00:54:07,610 --> 00:54:14,180
跟踪变得更加困难，但事实证明，如果

1207
00:54:14,180 --> 00:54:17,980
你遇到了坚定的侦探，

1208
00:54:17,980 --> 00:54:20,870
那就是你 知道如果

1209
00:54:20,870 --> 00:54:25,130
您经常进行交易就会有足够的线索，

1210
00:54:25,130 --> 00:54:26,870
因为交易通常与您的

1211
00:54:26,870 --> 00:54:28,340
真实身份相关联，例如如果您

1212
00:54:28,340 --> 00:54:31,550
使用比特币从亚马逊购买

1213
00:54:31,550 --> 00:54:33,170
 

1214
00:54:33,170 --> 00:54:34,910
 

1215
00:54:34,910 --> 00:54:36,860
东西 到您的家庭住址，

1216
00:54:36,860 --> 00:54:38,660
那是那里的一小部分识别

1217
00:54:38,660 --> 00:54:41,180
信息，这将使

1218
00:54:41,180 --> 00:54:42,950
某人弄清楚是您

1219
00:54:42,950 --> 00:54:44,390
花了那笔钱，然后 他们将能够

1220
00:54:44,390 --> 00:54:46,040
直接向后追溯，以查看

1221
00:54:46,040 --> 00:54:48,620
这笔钱来自哪里，从而获得

1222
00:54:48,620 --> 00:54:50,300
有关您是谁以及您在做什么的另一个线索，

1223
00:54:50,300 --> 00:54:57,380
因此实际上针对业余爱好者，比特币

1224
00:54:57,380 --> 00:54:59,900
对于严重的对手来说是相当匿名的，而

1225
00:54:59,900 --> 00:55:02,630
比特币却不

1226
00:55:02,630 --> 00:55:10,340
是这样 特别匿名 好吧

1227
00:55:10,340 --> 00:55:12,260
 

1228
00:55:12,260 --> 00:55:14,540
有点失望 对那些

1229
00:55:14,540 --> 00:55:16,910
对隐私感兴趣、从事毒品

1230
00:55:16,910 --> 00:55:21,850
交易或资助非法活动的人有点失望

1231
00:55:23,020 --> 00:55:24,880
 

1232
00:55:24,880 --> 00:55:28,520
 

1233
00:55:28,520 --> 00:55:31,670
 

1234
00:55:31,670 --> 00:55:34,250
上面有每笔

1235
00:55:34,250 --> 00:55:36,230
交易，如果你能让它发挥作用，那么它有

1236
00:55:36,230 --> 00:55:39,260
很多问题，比如可扩展

1237
00:55:39,260 --> 00:55:41,470
 

1238
00:55:41,470 --> 00:55:43,970
 

1239
00:55:43,970 --> 00:55:45,670
 

1240
00:55:45,670 --> 00:55:48,050
 

1241
00:55:48,050 --> 00:55:50,330
 

1242
00:55:50,330 --> 00:55:52,700
性 有点不是

1243
00:55:52,700 --> 00:55:55,220
一个真正的技术问题，但如果你重视它，

1244
00:55:55,220 --> 00:55:57,560
那么它真的很酷很神奇，

1245
00:55:57,560 --> 00:56:00,860
但有可能达成一致 一个

1246
00:56:00,860 --> 00:56:05,030
没有中央信任的单一日志，我正在

1247
00:56:05,030 --> 00:56:06,830
使用参与者，其中许多人都是

1248
00:56:06,830 --> 00:56:09,590
恶意的，最后的关键

1249
00:56:09,590 --> 00:56:13,070
想法是挖掘

1250
00:56:13,070 --> 00:56:14,930
工作量证明的想法，它也有问题，

1251
00:56:14,930 --> 00:56:17,780
但令人惊讶的是存在一种

1252
00:56:17,780 --> 00:56:21,170
技术 所有这一切都允许

1253
00:56:21,170 --> 00:56:24,620
以一种不会被这些虚假 IP 地址攻击所愚弄的方式达成一致，

1254
00:56:24,620 --> 00:56:27,380
这种攻击

1255
00:56:27,380 --> 00:56:29,420
不会遭受与投票相同的问题

1256
00:56:29,420 --> 00:56:31,910
，这是一个非常

1257
00:56:31,910 --> 00:56:33,850
令人惊讶和有趣的发展

1258
00:56:33,850 --> 00:56:37,370
，这就是我要说的全部

1259
00:56:37,370 --> 00:56:40,850
实际上发送了一些继续

1260
00:56:40,850 --> 00:56:41,990
这种思路和下一个

1261
00:56:41,990 --> 00:56:44,660
讲座，这是一种不同

1262
00:56:44,660 --> 00:56:49,310
类型的分散系统，部分

1263
00:56:49,310 --> 00:56:52,780
建立在比特币之上

